
proc redirect_and_catch { args } { 
    
    redirect -var redirect_return_var { if { [catch {eval [join $args " "]} res] } { puts "$res \n-E- Error running $args"}} 
    
    if { [regexp -all "\\\-E\\\- Error running $args" $redirect_return_var res] } { 
        set err_msg [join [lrange [split $redirect_return_var "\n"] 0 end-2] "\n"] 
        puts $err_msg 
        
        set redirect_return_var [join [lrange [split $redirect_return_var "\n"] end-1 end] "\n"]
    } else { set err_msg "" }
    
    return $res
    
}
proc be_get_report_header { {report_name ""} } {
    global PROJECT
    global DESIGN_NAME
    global STAGE

    set pawad   [exec pwd]
    set run     [lindex [split $pawad "/"] end]
    set version [lindex [split $pawad "/"] end-1] 
    set ds "" 

    set file_header "
============================================================
  Report:                 $report_name
  Generated by:           $::synopsys_program_name [get_app_var sh_product_version]
  Generated on:           [clock format [clock seconds] -format "%b %d %Y   %r"]
  Module:                 [get_attribute [get_designs] name]
  Operating conditions:   [get_attribute [get_scenarios -filter {setup}] name]
  Operating conditions:   [get_attribute [get_scenarios -filter {hold}] name] 
  User:                   $::env(USER)
  Folder:                 [exec pwd]
  Run:                    $run  
  Version:                $version  
  Project:                $PROJECT  
  Block:                  $DESIGN_NAME
  Stage:                  $STAGE
============================================================
    "
    
    return $file_header
}
proc nice_header { text_here } {
    set upper  [string toupper $text_here]
    set length [string length $text_here]
    set line   [string repeat "=" [expr $length + 8]]
    
    set nh "
    $line
    ==  $upper  ==
    $line"

  return $nh
}
proc be_short_report_timing_summary {} {
    global STAGE
    global RUNNING_DIR
    #reg2reg in2reg reg2out in2out
    if {[file exists ${RUNNING_DIR}/reports/${STAGE}/timing_summary.csv.gz]} {
	set fi [open "|gunzip -c ${RUNNING_DIR}/reports/${STAGE}/timing_summary.csv.gz" r]
    } elseif {[file exists ${RUNNING_DIR}/reports/${STAGE}/timing_summary.csv]} {
	set fi [open ${RUNNING_DIR}/reports/${STAGE}/timing_summary.csv r]
    }
    ### TODO supporting reg2cgate
    #set fi [open ${RUNNING_DIR}/reports/${STAGE}/timing_summary_without_reg2cgate.csv r]
    set con [read $fi]
    close $fi
    set lines [split $con "\n"]
    set setup_timing_table {}
    set hold_timing_table {}
    set i 4
    foreach group {reg2reg in2reg reg2out in2out} {
	set line [linsert [lrange [split [lindex $lines [lsearch $lines "max*"]] ","] $i [expr $i + 2]] 0 $group]
	set line_h [linsert [lrange [split [lindex $lines [lsearch $lines "min*"]] ","] $i [expr $i + 2]] 0 $group]
	lappend setup_timing_table $line
	lappend hold_timing_table $line_h
	incr i 3
    }
    #reg2cgate
    #set fi [open ${RUNNING_DIR}/reports/${STAGE}/timing_summary_reg2cgate.csv r]
    #set con [read $fi]
    #close $fi
    #set lines1 [split $con "\n"]
    #set group reg2cgate
    #set i 1
    #set line [linsert [lrange [split [lindex $lines1 1] ","] $i [expr $i + 2]] 0 $group]
    #set line_h [linsert [lrange [split [lindex $lines1 2] ","] $i [expr $i + 2]] 0 $group]
    #lappend setup_timing_table $line
    #lappend hold_timing_table $line_h
    #all
    if {[file exists ${RUNNING_DIR}/reports/${STAGE}/timing_summary.csv.gz]} {
	set fi [open "|gunzip -c ${RUNNING_DIR}/reports/${STAGE}/timing_summary.csv.gz" r]
    } elseif {[file exists ${RUNNING_DIR}/reports/${STAGE}/timing_summary.csv]} {
	set fi [open ${RUNNING_DIR}/reports/${STAGE}/timing_summary.csv r]
    }
    
    set con [read $fi]
    close $fi
    set lines2 [split $con "\n"]
    set group all
    set i 1
    set line [linsert [lrange [split [lindex $lines2 [lsearch $lines "max*"]] ","] $i [expr $i + 2]] 0 $group]
    set line_h [linsert [lrange [split [lindex $lines2 [lsearch $lines "min*"]] ","] $i [expr $i + 2]] 0 $group]
    lappend setup_timing_table $line
    lappend hold_timing_table $line_h


    set setup_timing_table [lsort -real -index 2 -decreasing [lsort -ascii -index 0 -decreasing $setup_timing_table]]
    set hold_timing_table [lsort -real -index 2 -decreasing [lsort -ascii -index 0 -decreasing $hold_timing_table]]
    set timing_format [list "%s" "%10s" "%12s" "%10s"]
    set timing_header [list "Group" "WNS(ps)" "TNS(ps)" "FEP"]
    if [lindex [split [lindex $lines2 [lsearch $lines "max*"]] ","] 3] {redirect -var s_output_res {rls_table -format $timing_format -header $timing_header -table $setup_timing_table -spacious -breaks}} { set s_output_res "-W- No negative setup paths found"}
    if [lindex [split [lindex $lines2 [lsearch $lines "min*"]] ","] 3] {redirect -var h_output_res {rls_table -format $timing_format -header $timing_header -table $hold_timing_table -spacious -breaks}} { set h_output_res "-W- No negative hold paths found"}
    ###
    set t [join [list "SETUP TIMING:" $s_output_res "HOLD TIMING:" $h_output_res] "\n"]
    return $t
}
proc be_short_report_clocks {} {
    global STAGE
    global RUNNING_DIR
    if {[file exists ${RUNNING_DIR}/reports/${STAGE}/report_clocks.rpt.gz]} {
	set fi [open "|gunzip -c ${RUNNING_DIR}/reports/${STAGE}/report_clocks.rpt.gz" r]
    } elseif {[file exists ${RUNNING_DIR}/reports/${STAGE}/report_clocks.rpt]} {
	set fi [open ${RUNNING_DIR}/reports/${STAGE}/report_clocks.rpt r]
    }
  
    set con [read $fi]
    close $fi
    set lines [split $con "\n"]
    set st [lsearch $lines "Clock*"]
    set t [join [lrange $lines $st end-3] "\n"]
    return $t
}
proc be_count_cells {} {
    global STAGE
    global RUNNING_DIR
    if {[file exists ${RUNNING_DIR}/reports/${STAGE}/report_qor.rpt.gz]} {
	set fi [open "|gunzip -c ${RUNNING_DIR}/reports/${STAGE}/report_qor.rpt.gz" r]
    } elseif {[file exists ${RUNNING_DIR}/reports/${STAGE}/report_qor.rpt]} {
	set fi [open ${RUNNING_DIR}/reports/${STAGE}/report_qor.rpt r]
    }
 
    set con [read $fi]
    close $fi
    set lines [split $con "\n"]
    ###
    set new_lines [list]
    lappend new_lines [lindex $lines [lsearch $lines "Leaf Cell Count*"]]
    lappend new_lines [format "%-34s%5s" "Physical Cell Count:" [sizeof [get_cells -filter {is_physical_only}]]]
    lappend new_lines [lindex $lines [lsearch $lines "Sequential Cell Count*"]]
    set SB [lindex [string trim [string trimleft [lsearch -inline $lines "*Single-bit Sequential Cell Count*"]] :] end]
    set MB [lindex [string trim [string trimleft [lsearch -inline $lines "*Multi-bit Sequential Cell Count*"]] :] end]
    set BPF [lindex [string trim [string trimleft [lsearch -inline $lines "*BitsPerflop*"]] :] end]
    lappend new_lines [format "%-34s%5.0f" "FF Bit Count" [expr $BPF * [expr $SB + $MB]]]
    ### gating status
    if {$STAGE=="compile"} {
    if {[file exists ${RUNNING_DIR}/reports/${STAGE}/report_ungated_registers.rpt.gz]} {
	set fi [open "|gunzip -c ${RUNNING_DIR}/reports/${STAGE}/report_ungated_registers.rpt.gz" r]
    } elseif {[file exists ${RUNNING_DIR}/reports/${STAGE}/report_ungated_registers.rpt]} {
	set fi [open ${RUNNING_DIR}/reports/${STAGE}/report_ungated_registers.rpt r]
    }
 
    set con [read $fi]
    close $fi
    set lines1 [split $con "\n"]
    lappend new_lines [format "%-34s%5s" "Gated registers:" [lindex [string trim [string trimleft [lsearch -inline $lines1 "*Number of Gated registers*"]] "|"] end-1]]
    lappend new_lines [format "%-34s%5s" "Ungated registers:" [lindex [string trim [string trimleft [lsearch -inline $lines1 "*Number of Ungated registers*"]] "|"] end-1]]
    }
    ###
    lappend new_lines [format "%-34s%5s" "Latch Cell Count:" 0]
    lappend new_lines [lindex $lines [lsearch $lines "Combinational Cell Count*"]]
    lappend new_lines [format "%-34s%5s" "Buffer Cell Count:" [lindex [string trim [string trimleft [lsearch -inline $lines "*Buf Cell Count*"]] :] end]]
    lappend new_lines [format "%-34s%5s" "Inverter Cell Count:" [lindex [string trim [string trimleft [lsearch -inline $lines "*Inv Cell Count*"]] :] end]]
    lappend new_lines [format "%-34s%5s" "ICG Count:" [lindex [string trim [string trimleft [lsearch -inline $lines "*Integrated Clock-Gating Cell Count*"]] :] end]]
    lappend new_lines [format "%-34s%5s" "Clock Inverters:" [sizeof [get_cells -filter {lib_cell.is_inverter && is_clock_network_cell}]]]
    lappend new_lines [format "%-34s%5s" "Clock Buffers:" [sizeof [get_cells -filter {lib_cell.is_buffer && is_clock_network_cell}]]]
    lappend new_lines [format "%-34s%5s" "Clock Logic:" [sizeof [get_cells -filter {!lib_cell.is_buffer && !lib_cell.is_inverter && is_clock_network_cell}]]]
    lappend new_lines [lindex $lines [lsearch $lines "Hierarchical Cell Count*"]]
    lappend new_lines [format "%-34s%5s" "Port Count:" [sizeof [get_ports]]]
    ###
    set t [join $new_lines "\n"]
    return $t
}
proc be_count_interface {} {
    global STAGE
    global RUNNING_DIR
    if {[file exists ${RUNNING_DIR}/reports/${STAGE}/report_design.rpt.gz]} {
	set fi [open "|gunzip -c ${RUNNING_DIR}/reports/${STAGE}/report_design.rpt.gz" r]
    } elseif {[file exists ${RUNNING_DIR}/reports/${STAGE}/report_design.rpt]} {
	set fi [open ${RUNNING_DIR}/reports/${STAGE}/report_design.rpt r]
    }
 
    set con [read $fi]
    close $fi
    set lines [split $con "\n"]
    set st [lsearch $lines "PORT AND PIN*"] 
    set t [join [lrange $lines $st [expr $st + 8]] "\n"]
    return $t
}
proc be_report_mbit {} {
    global STAGE
    global RUNNING_DIR
    if {[file exists ${RUNNING_DIR}/reports/${STAGE}/report_multibit.rpt.gz]} {
	set fi [open "|gunzip -c ${RUNNING_DIR}/reports/${STAGE}/report_multibit.rpt.gz" r]
    } elseif {[file exists ${RUNNING_DIR}/reports/${STAGE}/report_multibit.rpt]} {
	set fi [open ${RUNNING_DIR}/reports/${STAGE}/report_multibit.rpt r]
    }
 

    set con [read $fi]
    close $fi
    set lines [split $con "\n"]
    set st [lsearch $lines "Total number of sequential cells*"]
    set t [join [lrange $lines $st end-2] "\n"]
    return $t

}
proc be_new_report_util {} {
    global STAGE
    global RUNNING_DIR
    if {[file exists ${RUNNING_DIR}/reports/${STAGE}/report_qor.rpt.gz]} {
	set fi [open "|gunzip -c ${RUNNING_DIR}/reports/${STAGE}/report_qor.rpt.gz" r]
    } elseif {[file exists ${RUNNING_DIR}/reports/${STAGE}/report_qor.rpt]} {
	set fi [open ${RUNNING_DIR}/reports/${STAGE}/report_qor.rpt r]
    }
    set con [read $fi]
    close $fi
    set lines [split $con "\n"]
    # util
    # RoyL: get_core_area does not exists for initial_map
    #set core_area [get_attribute  [get_core_area ] area]
    set core_area [get_attribute -quiet [get_designs] core_area_area]
    
    set x [get_attribute -quiet [current_design] core_area_bounding_box.width]
    set y [get_attribute -quiet [current_design] core_area_bounding_box.height]
     # Macro Instance area
    set st [lsearch -inline $lines "Macro/Black Box Area:  *"]
    set pure_macro_cell_area [string trim [lindex [split $st :] 1]]
    # RE calculating the macros area this way includes also the halos area around them
    # this area is taken into account as part of the macro cells area in the utilization calculation equation
    set macro_rects [get_attribute [get_cells -hierarchical -filter {design_type==macro} -quiet] bbox -quiet]
    set bbox [get_attribute [get_cells -hierarchical -filter {design_type==black_box}] bbox -quiet]
    if {$bbox == ""} {
    	set macro_cell_rects 0
    } else { 
    	set macro_cell_rects [compute_polygons -objects2 $macro_rects -objects1 $bbox -operation OR]
    }
    #set macro_cell_area  [compute_area [compute_polygons -objects2 $macro_rects -objects1 [get_attribute [get_cells -hierarchical -filter {design_type==black_box}] bbox -quiet] -operation OR]]

    # since macros are allowed on the die area, subtract only the portion overlapping the core, as only that blocks STD cell placement.
#    set core_rect  [get_attribute  [get_core_area ] boundary]
    set core_rect [get_attribute [get_designs] core_area_boundary -quiet]
    if {$macro_cell_rects != 0 && $core_rect != ""} {
    	set macro_cell_area [compute_area [compute_polygons -objects1 $macro_cell_rects -objects2 $core_rect -operation AND]]
    } else {
    	set macro_cell_area [compute_area -objects [get_cells -hierarchical -filter {design_type==macro} -quiet]]
    }

    # Leaf Instance area
    set st [lsearch -inline $lines "Cell Area (netlist)*"]
    set leaf_cell_area [expr [string trim [lindex [split $st :] 1]] - $pure_macro_cell_area]
    # Physical Instance area   
    set st [lsearch -inline $lines "Cell Area (netlist and physical*"]
    set cell_includes_pyhs_area [expr [string trim [lindex [split $st :] 1]] - $pure_macro_cell_area]
    set phys_cell_area [expr $cell_includes_pyhs_area - $leaf_cell_area]
    set total_std_area [expr $leaf_cell_area + $phys_cell_area]
    

    # Blockages    
    set pb_soft  [get_attribute [get_placement_blockages -filter {blockage_type == soft} -quiet] bbox]
    set pb_hard  [get_attribute [get_placement_blockages -filter {blockage_type == hard} -quiet] bbox]
    set pb_net [get_attribute [get_placement_blockages -quiet] bbox]
	
    if { ![llength $pb_net]||[catch { set pb_net_area [compute_area [compute_polygons -objects1 [compute_polygons -objects1 $pb_net -objects2 $macro_rects -operation NOT] -objects2 $core_rect -operation AND ]] } res] }  {set pb_net_area 0}
    if { ![llength $pb_hard]||[catch { set pb_hard_area [compute_area [compute_polygons -objects1 [compute_polygons -objects1 $pb_hard -objects2 $macro_rects -operation NOT] -objects2 $core_rect -operation AND ]] } res] }  {set pb_hard_area 0}
    set pb_soft_area [expr $pb_net_area - $pb_hard_area] 
        

    # area
    # Sequential Instance area  
    set all_edge   [all_registers -edge]
    set all_level  [all_registers -level]  
    if { [catch {if { [sizeof $all_edge]  > 0 } { set flop_cell_area   [lsum [get_attribute [filter_collection $all_edge  "design_type!=macro"]  area ]] } { set flop_cell_area 0 }}  res] } { set flop_cell_area  0 }
    if { [catch {if { [sizeof $all_level] > 0 } { set latch_cell_area  [lsum [get_attribute [filter_collection $all_level "!is_integrated_clock_gating_cell"]  area ]] } { set latch_cell_area 0 }} res] } { set latch_cell_area 0 }   
    # Combinational Instance area 
    if { [catch { set comb_cell_area [lsum [get_attribute [get_cells -quiet -hier -filter "!is_hierarchical && is_combinational==true && !lib_cell.is_buffer && !lib_cell.is_inverter"] area ]] } res] } { set comb_cell_area 0 }
    # Buffer Instance area 
    if { [catch { set buff_cell_area [lsum [get_attribute [get_cells -quiet -hier -filter "!is_hierarchical && lib_cell.is_buffer"] area ]] } res] } { set buff_cell_area 0 }
    # Inverter Instance area 
    if { [catch { set inv_cell_area  [lsum [get_attribute [get_cells -quiet -hier -filter "!is_hierarchical && lib_cell.is_inverter"] area ]] } res] } { set inv_cell_area 0 }
    # ICG Instance area 
    if { [catch { set icg_cell_area  [lsum [get_attribute  [get_cells -quiet -hier -filter  "!is_hierarchical && is_integrated_clock_gating_cell"] area ]] } res] } { set icg_cell_area 0 }
    


    #% Pure Gate Density #1 (Subtracting BLOCKAGES):
    set pure_gate_density_1 [format "%.2f" [expr 100*$total_std_area/($core_area - $pb_net_area)]]  
    #% Pure Gate Density #2 (Subtracting BLOCKAGES and Physical Cells):  
    set pure_gate_density_2 [format "%.2f" [expr 100*$leaf_cell_area/($core_area - $pb_net_area)]]          
    #% Pure Gate Density #3 (Subtracting MACROS):
    set pure_gate_density_3 [format "%.2f" [expr 100*$total_std_area/($core_area - $macro_cell_area)]]                  
    #% Pure Gate Density #4 (Subtracting MACROS and Physical Cells):
    set pure_gate_density_4 [format "%.2f" [expr 100*$leaf_cell_area/($core_area - $macro_cell_area)]]  
                  
    #% Pure Gate Density #5 (Subtracting MACROS and BLOCKAGES):  
    set pure_gate_density_5 [format "%.2f" [expr 100*$total_std_area/($core_area - $macro_cell_area - $pb_net_area)]]   
    #% Pure Gate Density #6 ((Unpreplaced Standard Inst + Unpreplaced Block Inst + Unpreplaced Black Blob Inst + Fixed Clock Inst Area) / (Free Site Area + Fixed Clock Inst Area) for insts are placed):       
    set pure_gate_density_6 [format "%.2f" [expr 100*$leaf_cell_area/($core_area - $macro_cell_area - $pb_net_area)]]                          
    #% Core Density (Counting Std Cells and MACROs):
   echo "100*($total_std_area+$macro_cell_area)/($core_area)"
    if {$core_area == ""} {
    	set core_dens_1 ""
	set core_dens_2 ""
    } else {
    	set core_dens_1 [format "%.2f" [expr 100*($total_std_area+$macro_cell_area)/($core_area)]]                  
    	#% Core Density #2(Subtracting Physical Cells):  
    	set core_dens_2 [format "%.2f" [expr 100*($leaf_cell_area+$macro_cell_area)/($core_area)]]    
    }                    
    #% Chip Density (Counting Std Cells and MACROs and IOs):
    #% Chip Density #2(Subtracting Physical Cells):  
    set t1 "
Leaf Cell Area:          [format "%.2f" $leaf_cell_area] ; # Leaf (no physical cells area)
Physical Cell Area:      [format "%.2f" $phys_cell_area] ; # Without FILLER cells (FILL_*)
Flop Cell Area:          [format "%.2f" $flop_cell_area] 
Latch Cell Area:         [format "%.2f" $latch_cell_area] 
Combinational Cell Area: [format "%.2f" $comb_cell_area] 
Buffer Cell Area:        [format "%.2f" $buff_cell_area] 
Inverter Cell Area:      [format "%.2f" $inv_cell_area] 
Clock Gate Cell Area:    [format "%.2f" $icg_cell_area] 
Macro Cell Area:         [format "%.2f" $macro_cell_area]
Hard Blockage Area:      [format "%.2f" $pb_hard_area] 
Soft Blockage Area:      [format "%.2f" $pb_soft_area] 
Effective Blockage Area: [format "%.2f" $pb_net_area] ; # Soft and Hard blockages area w.o. overlap
Core Area:               $core_area
X:                       $x
Y:                       $y

Pure STD Cell Density:        [format "%-8s"  $pure_gate_density_4%] ; # Leaf_cell_area / (Core_area - Macro_area) AKA BRCM STYLE
Effective Density:            [format "%-8s"  $pure_gate_density_6%] ; # Leaf_cell_area / (Core_area - Macro_area - Effective_blockages_area)
Effective include Phys cells: [format "%-8s"  $pure_gate_density_5%] ; # (Leaf_cell_area + Phys_cell_area) / (Core_area - Macro_area)
"
    return $t1

}
proc be_short_report_power {} {
    global STAGE
    global RUNNING_DIR
    global LVT_PERCENTAGE
    if {[file exists ${RUNNING_DIR}/reports/${STAGE}/report_power.rpt.gz]} {
	set fi [open "|gunzip -c ${RUNNING_DIR}/reports/${STAGE}/report_power.rpt.gz" r]
    } elseif {[file exists ${RUNNING_DIR}/reports/${STAGE}/report_power.rpt]} {
	set fi [open ${RUNNING_DIR}/reports/${STAGE}/report_power.rpt r]
    }
 
    set con [read $fi]
    close $fi
    set lines [split $con "\n"]

    set ip [lindex [split [lindex [split [lsearch -inline $lines "*Internal Power*"] "="] 1] "mW"] 0]
    set sp [lindex [split [lindex [split [lsearch -inline $lines "*Switching Power*"] "="] 1] "mW"] 0]
    #set dp [lindex [split [lindex [split [lsearch -inline $lines "*Dynamic Power*"] "="] 1] "mW"] 0]
    set lp [lindex [split [lindex [split [lsearch -inline $lines "*Cell Leakage Power*"] "="] 1] "mW"] 0]
    set l [lsearch -inline $lines "*Total   *"]
    set tp [string trim [string range $l [expr [string last "mW" [string range $l 0 end-3]] + 2]  end-3]]

    set t1 "
Total Internal Power:      $ip 	   [format %0.2f [expr $ip / $tp * 100]]%
Total Switching Power:     $sp 	   [format %0.2f [expr $sp / $tp * 100]]%
Total Leakage Power:       $lp 	   [format %0.2f [expr $lp / $tp * 100]]%
Total Power:                $tp
"

    # vt_groups
    
    if {[file exists ${RUNNING_DIR}/reports/${STAGE}/report_vt_summary.rpt.gz]} {
	set fi [open "|gunzip -c ${RUNNING_DIR}/reports/${STAGE}/report_vt_summary.rpt.gz" r]
    } elseif {[file exists ${RUNNING_DIR}/reports/${STAGE}/report_vt_summary.rpt]} {
	set fi [open ${RUNNING_DIR}/reports/${STAGE}/report_vt_summary.rpt r]
    }
    set con [read $fi]
    close $fi
    set lines [split $con "\n"]
    set i [lsearch $lines "Vth Group*"]
    set i1 [expr [lsearch [lrange $lines [expr $i+1] end] "Vth Group*"] + $i + 1]
    set diff [expr $i1 - $i]
    set t [lsearch $lines "Total*"]
    set new_con [list]
    foreach line [lrange $lines [expr $i + 3] $t] {lappend new_con "[lrange $line  0 2 ] [lrange [lindex $lines [expr $i + 3 + $diff]] 1 2]"; incr i}
    set new_con [lreplace $new_con [expr [lsearch $new_con Total*] - 1] [expr [lsearch $new_con Total*] - 1]] 
    set timing_format [list "%s" "%10s" "%12s" "%10s"]
    set timing_header [list "Vth Name" "Group cells" "All cells" "Group area" "All area" ]
    redirect -var s_output_res {rls_table -format $timing_format -header $timing_header -table $new_con -spacious -breaks}
    set tbl [split $s_output_res "\n"]
    set tbl [linsert $tbl end-2 [lindex $tbl 1]]
    set t2 [join $tbl "\n"]
    
    # add note if Low vt area percentage is more than LVT_PERCENTAGE 
    set i [lsearch $lines "Low vth groups*"]
    set i1 [expr [lsearch [lrange $lines [expr $i+1] end] "Low vth groups*"] + $i + 1]
    set line [lindex $lines $i1]
    set area [string range $line [string first "(" $line ] [string first ")" $line]]
    set area [string range $area 1 end-1]; # removing ( )
    if { [string range $area 0 end-1] > $LVT_PERCENTAGE } {set msg "NOTE: Low-Vt is $area (>${LVT_PERCENTAGE}%) due to inclusion of CG cells (not subject to the limit)"} {set msg ""}

    return [string cat "$t1\n\n" "$t2\n"]
}
proc be_short_cong_report {} {
    global STAGE
    global RUNNING_DIR
    if {[file exists ${RUNNING_DIR}/reports/${STAGE}/report_congestion_summary.rpt.gz]} {
	set fi [open "|gunzip -c ${RUNNING_DIR}/reports/${STAGE}/report_congestion_summary.rpt.gz" r]
    } elseif {[file exists ${RUNNING_DIR}/reports/${STAGE}/report_congestion_summary.rpt]} {
	set fi [open ${RUNNING_DIR}/reports/${STAGE}/report_congestion_summary.rpt r]
    } 
 
    set con [read $fi]
    close $fi
    set lines [split $con "\n"]
    set hov [lindex [split [lindex [split [lsearch -inline $lines "H routing*"] "("] 1] ")"] 0]
    set vov [lindex [split [lindex [split [lsearch -inline $lines "V routing*"] "("] 1] ")"] 0]
    set t "
    H overflow            : $hov
    V overflow            : $vov
       "
    return $t
}
proc be_short_check_drc {} {
    global STAGE 
    global RUNNING_DIR
    if {[file exists ${RUNNING_DIR}/reports/${STAGE}/report_drc_matrix.rpt.gz]} {
	set fi [open "|gunzip -c ${RUNNING_DIR}/reports/${STAGE}/report_drc_matrix.rpt.gz" r]
    } elseif {[file exists ${RUNNING_DIR}/reports/${STAGE}/report_drc_matrix.rpt]} {
	set fi [open ${RUNNING_DIR}/reports/${STAGE}/report_drc_matrix.rpt r]
    }

    set con [read $fi]
    close $fi
    set lines [split $con "\n"]
    set t [lrange $lines [expr [lsearch $lines "*TOTALS BY TYPE"] + 2] end-3]
    set u [lmap l $t { string cat [string range $l 0 [expr [string first "|" $l] + 1]] [string range $l [expr [string last "|" $l] + 1] end] }]
    set u [lreplace $u end-1 end-1 [string range [lindex $u end-1] 0 [expr [string length [lindex $u end]] - 1]]]
    set v [join $u "\n"]
    return $v

}
proc be_report_shorts_per_layer {} {
    global STAGE 
    global RUNNING_DIR
    if {[file exists ${RUNNING_DIR}/reports/${STAGE}/report_shorts_per_layer_matrix.rpt.gz]} {
	set fi [open "|gunzip -c ${RUNNING_DIR}/reports/${STAGE}/report_shorts_per_layer_matrix.rpt.gz" r]
    } elseif {[file exists ${RUNNING_DIR}/reports/${STAGE}/report_shorts_per_layer_matrix.rpt]} {
	set fi [open ${RUNNING_DIR}/reports/${STAGE}/report_shorts_per_layer_matrix.rpt r]
    }

    set con [read $fi]
    close $fi
    set lines [split $con "\n"]
    set t [lrange $lines [lsearch $lines "*TOTALS BY TYPE"] end-4]
    set t [join $t "\n"]
    return $t

}
proc be_rt_mem_cpu {} {
    set cpu_sec [get_cputime]
    global STAGE
    global RUNNING_DIR
    exec tail -50 ${RUNNING_DIR}/log/do_${STAGE}.log.full > last_50.log
    set fi [open last_50.log r]
    set con [read $fi]
    close $fi
    exec rm last_50.log
    set lines [split $con "\n"]
    set st [expr [lsearch $lines "script_runtime_proc -end"] + 2]
    set trimmedLines [lmap line [lrange $lines $st [expr $st + 2]]  {string map {"#     " ""} $line}]    
    set t [join $trimmedLines "\n"]
    return $t
   
}
#proc be_report_ungated {} {
#    global STAGE 
#    global RUNNING_DIR
#    set fi [open ${RUNNING_DIR}/reports/${STAGE}/report_ungated_registers.rpt r]
#    set con [read $fi]
#    close $fi
#    set lines [split $con "\n"]
#    set st [lsearch $lines "Clock Gating Summary*"]
#    set t [join [lrange $lines $st end-3] "\n"]
#    return $t
#}

proc _be_convert_reports_to_bash_mail { subject headline err_sum recipient {attachments {}} } {

    set file_name "./[pid]_send_mail.bs"
    set err_sum_html ${err_sum}.html


    ############################
    # Construct bash mail sender
    ############################    
    set fp [open $file_name w]
    
    puts $fp "#!/bin/bash"
    
    set attach_string ""
#    if { $attachments != {} } {
#        set attach_string "-a [regsub " " [join $attachments " "] " -a "]"
#    }
    
    set cmd_line "cat \"${err_sum}.html\" | mailx -r BE_Run_Summary@nextsilicon.com -s \"$subject \$(echo -e \\\\\\nContent-Type: text/html)\" $recipient"    
    
    puts $fp $cmd_line 
    
    close $fp
    
    
    #########################
    # Convert err_sum to html
    #########################
    if { ![file exists $err_sum] } { puts "-E- No <STAGE>_err.sum exists" ; file delete $file_name ; return -1 }
    set fp [open $err_sum r]
    set fd [read $fp]
    close $fp
    
    set is_error false    
    set error_lines ""
    set warng_lines ""
    set other_lines ""
    set style_start    ""
    set style_end      " "                
    
    set   fp [open ${err_sum}.html w]
    puts $fp  "<html><body>"
    
    foreach line [split $headline "\n"] {
        if { [regexp "^\\\-W\\\- " $line res] } { 
            puts $fp  "<h2 style=\"color:DarkRed;\">$line</h2>"        
        } else {
            puts $fp  "<h2 style=\"color:DarkBlue;\">$line</h2>"
        }
    }
    puts $fp  "<pre>"
    foreach line [split $fd "\n"] {      
#      set new_line "$line "

            
      if { [regexp "ERROR" $line] || [regexp "Error" $line] } {
#        set new_line "<b style=\"color:DarkRed;\">$line</b>" 
#        append error_lines "$new_line"
         set style_start "<b style=\"color:DarkRed;\">"
         set style_end   "</b>"
      } elseif { [regexp "WARNING" $line] || [regexp "Warning" $line] } {
#        set new_line "<b style=\"color:DarkRed;\">$line</b>" 
#        append error_lines "$new_line"
         set style_start "<b style=\"color:Orange;\">"
         set style_end   "</b>"
      } elseif { [regexp "INFO" $line] || [regexp "Info" $line] } {
#        set new_line "<b style=\"color:DarkRed;\">$line</b>" 
#        append error_lines "$new_line"
         set style_start "<b style=\"color:DarkGreen;\">"
         set style_end   "</b>"
      } else {

      }
      
      puts $fp "$style_start$line$style_end"
    }

    puts  $fp  "<html></body></pre>"    
    close $fp
    
    exec chmod 755 $file_name
    exec $file_name    
    file delete $file_name
}


::parseOpt::cmdSpec be_reports {
    -help "Generate BE reports in Fusion Compiler"
    -opt    {
            {-optname all         -type boolean   -default false     -required 0 -help "Generate all reports regardless of other flags"}
            {-optname timing      -type boolean   -default false     -required 0 -help "Generate timing reports"}
            {-optname multibit    -type boolean   -default false     -required 0 -help "Generate multibit report"}                                       
            {-optname power       -type boolean   -default false     -required 0 -help "Generate power reports"} 
            {-optname congestion  -type boolean   -default false     -required 0 -help "Generate congestion reports"}   
	    {-optname mail	  -type string    -default "true"    -required 0 -help "Mail qor to user"}                                                                    
    }
}

proc be_reports { args } {

     	global STAGE
        global RUNNING_DIR
	global DESIGN_NAME
	
   	if { ! [::parseOpt::parseOpt be_reports $args] } { return 0 }
   
        set all         $opt(-all)
        set timing      $opt(-timing)
        set mbit        $opt(-multibit)        
        set power       $opt(-power)
	set congestion  $opt(-congestion)
	set mail 	$opt(-mail)
	
	
	### file ###
	set file_name "${RUNNING_DIR}/reports/$STAGE/${STAGE}.be.qor" 
	set file_header [redirect_and_catch {be_get_report_header be_reports}]

	### timing ###
	set table_res [expr {$all || $timing ? "[redirect_and_catch {be_short_report_timing_summary}]" : "NA"}]
	set timing_status "[nice_header "Timing QOR"]\n\n$table_res"
	
	### clocks ###
	redirect -var report_clocks { redirect_and_catch { be_short_report_clocks} }
	set clock_status "[nice_header "Clocks"]\n\n$report_clocks"

	### cell count ###
	set cell_count [redirect_and_catch {be_count_cells}]
	set cell_count_status "[nice_header "Cell Count"]\n\n$cell_count\n"

	### multibit ###
	set mbit_report [expr {$all || $mbit ? "[redirect_and_catch {be_report_mbit}]" : "NA"}]	     
        set mbit_status "[nice_header "mbit count"]\n\n$mbit_report"
	
	### area & util ###
	set area_report [redirect_and_catch {be_new_report_util}]
    	set area_status "[nice_header Area]\n\n$area_report"

	### power ###
	set power_report [expr {$all || $power ? "[redirect_and_catch {be_short_report_power}]" : "NA"}]	     	   
    	set power_status "[nice_header "power"]\n$power_report"

	### congestion ###
	set congestion [expr {($all || $congestion)&&![regexp $STAGE route] ? "[redirect_and_catch {be_short_cong_report}]" : "NA"}]	     	   	
	
	### drc ###
	if {[regexp $STAGE route]} {
		set drc_status [redirect_and_catch be_short_check_drc  ]
        	set shorts     [redirect_and_catch be_report_shorts_per_layer ]
        } else {
	set drc_status "NA"
        set shorts     "NA"
	}

	set routing_status "
	[nice_header "routing"]\n\n$congestion
	[nice_header "drc"]\n\n$drc_status
    	[nice_header "short_per_layer"]\n\n$shorts"

	### runitime ###
	script_runtime_proc -end
	set rt_mem_cpu "[nice_header "runtime"]\n\n[redirect_and_catch {be_rt_mem_cpu}]"
		
	### printing results to file
	set fo [open $file_name w]
	puts $fo $file_header 
	puts $fo $timing_status     
	puts $fo $clock_status      
	puts $fo $cell_count_status 
	puts $fo $mbit_status          
	puts $fo $area_status      
	puts $fo $power_status       
	puts $fo $routing_status
	puts $fo $rt_mem_cpu
	close $fo     
 	
	### mailing ###
	set address [expr {$mail ? "[redirect_and_catch {be_get_user_email}]" : ""}]	   
        if { $address != "" } {
            set suser [be_get_supper_user_email]
            foreach sss $suser {
	        set address "$address [be_get_user_email $sss]"
	    }
	    regsub {\s} [lsort -unique $address] "," address
	    set pawad   [exec pwd]
	    set run     [lindex [split $pawad "/"] end]
    	    set version [lindex [split $pawad "/"] end-1] 
	   
	    set snapshots_list [exec ls ${RUNNING_DIR}/reports/${STAGE}/snapshots/]
   	    set att_ss "" 
            foreach file $snapshots_list {
                if { [file exists ${RUNNING_DIR}/reports/${STAGE}/snapshots/$file] } {append att_ss "-a ${RUNNING_DIR}/reports/${STAGE}/snapshots/$file " }
            }
	    
	    set echo_txt "-I- Report QOR summary: \n"	
        
	    # Report errors/warnings
            redirect ${RUNNING_DIR}/reports/${STAGE}_err.sum { report_msg -summary }
     
	    set subject "BE_FLOW - $DESIGN_NAME - $version - $run"	
            set cmd  "exec echo \"-I- Report QOR summary - $STAGE - [::ory_time::now] : \n $pawad \" | mail -r BE_Run_Summary@nextsilicon.com -a $file_name $att_ss -s \$subject $address "
            set bsh_mail_cmd  "_be_convert_reports_to_bash_mail \$subject \"$echo_txt\" ${RUNNING_DIR}/reports/\${STAGE}_err.sum \$address \[list \$file_name\]"	   
	    eval $cmd
	    eval $bsh_mail_cmd 

        }
            
	puts "${STAGE}.be.qor file was saved to ${RUNNING_DIR}/reports/${STAGE}" 
}
