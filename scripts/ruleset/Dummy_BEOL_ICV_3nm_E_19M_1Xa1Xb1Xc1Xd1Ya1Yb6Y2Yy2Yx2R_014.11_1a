#include <icv.rh>
///*****************************************************************************
/// TSMC 3 NM BEOL DUMMY GENERATION UTILITY (IC Validator) - Dummy_BEOL_ICV_3nm_E_19M_1Xa1Xb1Xc1Xd1Ya1Yb6Y2Yy2Yx2R_014.11_1a (01/19/2024)
/// 1P19M PROCESS WITH 1Xa1Xb1Xc1Xd1Ya1Yb6Y2Yy2Yx2R METAL OPTION
/// UTILITY DOCUMENT:     T-N03-CL-DR-014-J3 VER 1.1_1a
/// DESIGN RULE DOCUMENT: T-N03-CL-DR-014    VER 1.1_1
/// DUMMY SPEC DOCUMENT:  T-N03-CL-US-012    VER 1.1_1a
///
/// Tech File Ver: v1.1_1a
///*****************************************************************************

#ifdef VERSION_LT

#if VERSION_LT(2022, 12, 4, 2)
#error This PXL runset was generated to run with ICV version U-2022.12-SP4-2 code and newer.
#endif
#endif



///*****************************************************************************
///     USAGE
///*****************************************************************************
///
/// (1) #define OUTPUT_GDS
///     Turn on to output GDS; Turn off to output OASIS
///
/// (2) #define FULL_CHIP
///     Turn on for chip level design; Turn off for IP/macro/cell level design
///
/// (3) #define WITH_SEALRING
///     Turn on if sealring is assembed in chip 
///
/// (4) #define UseprBoundary
///     #define ChipWindowUsed
///     In default, utility will use the bounding box of defined (tape-out) layers as the window of chip.
///
///     If user wants to specify the window of chip by prBoundary(108;0) layer,
///     please un-comment the line as below:
///
///         #define UseprBoundary
///
///     If user wants to specify the window of chip exactly, please un-comment
///     the line as below:
///
///         #define ChipWindowUsed
///
///     , and then modify the variables ( xLB, yLB ) for the coordinate of left-bottom corner
///     and ( xRT, yRT ) for the coordinate of right-top corner of the user-defined chip window.

/// (5) #define MERGE_ORIGINAL_DESIGN
///     By default, the output data will not include the original design. To have post DRC/LVS
///     checking after the dummy insertion, please enable this option to include the design.
///     User could un-comment the line as below to enable this function.
///
///         #define MERGE_ORIGINAL_DESIGN
///
///
///
/// (6) #define HIGHMETALDN
///     Turn on this switch will increase metal density with M0/1/xa, but it will cost extra run time
///
/// (7) #define HighMzDensityMn
///     Turn on to increase Mz Density
///
/// (8) #define FILL_DMn
///     Turn on to fill dummy Metal and OPC dummy Metal.
///
/// (9) #define FILL_Mn_BTCD
///     Turn on to fill Mn dummy TCD (Mn_BTCD).
///     Only M0/M1/Mxa/Mxb/Mxc/Mxd/Mya/Myb/My supports Mn dummy TCD.
///
/// (10) #define FILL_DmyVIAn
///     Turn on to fill dummy VIAn.
///     DmyVIAn will be outputed with datatype 200(DVIAxa_O), 250(DVIAxb_O), 301/302(DVIAxc_O), 351/352(DVIAxd_O), 955(DVIAya), 805(DVIAyb), 975(DVIAy), 95(DVIAyy), 800(DVIAyb_O), 970(DVIAy_O), 90(DVIAyy_O)
///
/// (11) #define FILL_VIAn_BTCD
///     Turn on to fill VIAn dummy TCD (VIAn_BTCD).
///     Only VIAxa/VIAxb/VIAxc/VIAxd/VIAya/VIAyb/VIAy supports VIAn dummy TCD.
///     Note that only when FILL_Mn_BTCD and FILL_Mn+1_BTCD are both turned on, too, VIAn dummy TCD can be filled.
///     Only DVIAxa_O/DVIAxb_O/DVIAxc_O/DVIAxd_O/DVIAya/DVIAyb/DVIAy are supported.
///
///
/// (12) #define VERTICAL_Mn
///     For metal type Mxa, to control preferred (right way) dircetion:
///     If this switch is turned on, preferred (right way) dircetion is vertical.
///     If this switch is turned off, preferred (right way) dircetion is horizontal.
///     User may adjust DMxa direction according to real rounting preferred (right way) direction.
///
///     For other metal types, to control DMn direction:
///     If this switch is turned on, DMn will be filled in vertical.
///     If this switch is turned off, DMn will be filled in horizontal.
///     User may adjust DMxa direction according to real rounting direction.
///
///     Note that same direction of DMn and DMn+1 may cause low DVIAn insertion.
///
/// (13) #define ANTPrevention
///     Turn on to prevent ANT rule violation
///
/// (14) #define DMY_Boundary_Control
///     Turn on to control dummy utility behavior to blockage layers
///
/// (15) #define CONTROL_MAX_METAL_LENGTH
///     Turn on to prevent ANT rule violation by limit maximum metal length
///
/// 
/// (16) #define SHDMIM
///     Turn on to fill SHDMIM, can not open when FHDMIM turning on
/// 
/// (17) #define SHDMIM_KOZ_AP_SPACE_5um
///     Turn on to change SHDMIM KOZ region, please don't open when FHDMIM/FHDMIM_KOZ_AP_SPACE_5um turn on
/// 
/// (18) #define FHDMIM
///     Turn on to fill FHDMIM, can not open when SHDMIM turning on
/// 
/// (19) #define FHDMIM_KOZ_AP_SPACE_5um
///     Turn on to change FHDMIM KOZ region, please don't open when SHDMIM/SHDMIM_KOZ_AP_SPACE_5um turn on
/// 
/// (20) #define KOZ_High_subst_layer 
///     Turn on to check KOZ for package substrate layer >14
///
/// (21) #define Lid
///     Turn on to change KOZ region to comply with CoWos_S Lid process, please open CoWoS_S at the same time, and don't open Ring at the same time
///
/// (22) #define Ring 
///     Turn on to change KOZ region to comply with CoWos_S Ring process, please open CoWoS_S at the same time, and don't open Lid at the same time
///
/// (23) #define CoWoS_S 
///     Turn on to use CoWos_S process, it needs to choose either Lid or Ring
///


///*****************************************************************************


///*****************************************************************************
///      NOTE
///*****************************************************************************
///
/// If this utility was used for cell level design, please set the options or variables below.
///
/// (1) chip boundary: turn on option "UseprBoundary" or "ChipWindowUsed" to define chip boundary,
///     or use whole layout extent.
///
/// (2) Dummy to chip boundary: variable "DMx1O_Chip" (M0/M1/Mxa), "DMx2O_Chip" (Mxb/Mxc),"DMx3O_Chip" (Mxd), "DMy1_Chip" (Mya/Myb/My), "DMz_Chip" defines
///     min. space between dummy and chip boundary.
///     Users can revise this variable to change the space between dummy and chip boundary.
///     Please at least leave a buffer from dummy to chip boundary to avoid dummy abutted when IP merged.
///
///*****************************************************************************
//************************************************************************************
//* TSMC developed this deck using Synopsys proprietary ICV format.
//* The deck is to be used only in ICV tools.
//************************************************************************************

/* SWITCH DEFINITION START */


#ifndef COMBINE

//******************************************************************************
//      CONFIGURATION
//******************************************************************************

//***** Output database ********************************************************
// #define OUTPUT_GDS                      // Turn on to output GDS; turn off to output OASIS
//#define MERGE_ORIGINAL_DESIGN         // Output data will contain the original design

//***** Fill cell name setting ********************************************************
//DECK_VERSION : string = "B11u1a";    // Attach deck version to cell name
// UNIQUE_ID : string = ""; // Attach the unique ID to fill cell to avoid cell name collision in cell-level run


// CELL_PREFIX: string = DECK_VERSION + UNIQUE_ID;

output_cell_prefix : string = CELL_PREFIX;
#ifdef OUTPUT_GDS
output_file_name   : string = "BEOL.gds";
out_file = gds_library(output_file_name);
#else
// output_file_name   : string = "BEOL.oas";
out_file = oasis_library(output_file_name);
#endif

//***** Design level ***********************************************************
// #define FULL_CHIP                       // Turn on for chip level design; Turn off for IP/macro/cell level design
// #define WITH_SEALRING                   // Turn on if sealring is assembed in chip 

//***** User defined chip area *************************************************
//#define UseprBoundary         // Use layer prBoundary(108;0) to define the chip window
//#define ChipWindowUsed        // Specify chip boundary directly by following variables
xLB : const double = 0.0;       // x-coordinate of left-bottom corner for user defined chip window
yLB : const double = 0.0;       // y-coordinate of left-bottom corner for user defined chip window
xRT : const double = 1000.0;    // x-coordinate of right-top corner for user defined chip window
yRT : const double = 1000.0;    // y-coordinate of right-top corner for user defined chip window

//***** Synopsys in-design flow *************************************************




#endif

//#define HIGHMETALDN   //Turn on this switch will increase metal density with M0/1/xa, but it will cost extra run time
#define ANTPrevention     // Turn on to prevent ANT rule violation
#define CONTROL_MAX_METAL_LENGTH     // Turn on to prevent ANT rule violation by limit maximum metal length
//#define DMY_Boundary_Control
#pragma PXL encrypted begin
.PK/"=3GN@<[MIRXEM2PN^2V()"'R .<9@\@ #,+@I$9 BD J>F9SGS=ZARIB51GBM-PP<F)
G_6(\X7%\&Z? #,+@I$9 BD \(%5\8=4*0WPL/-,IPRQ&R"P #,+@I$9 BD W.X89M"[A^W<
X?F:R1\]*AOA\HJP"U("C__RT,\'\+SA8);0$?LX@#,.T6X1%7]EQ[<A\(P51[4C5%SE+%Q'
<Z;OK+\:#D-S=.%%FD(M;5QTX70M+Z.J%[WAZF-"9I*:O?#J\*$V^\A)JH7P5Z.V,_JZ42A7
[>CA8PE/#'7M$A6]? 961D$2U!+.:MXIU2K4GK%FO[RYPA.>6[*0>2;*D@];;_D4MXICP]1O
SL)>[QECA.#.
#pragma PXL encrypted end





//***** Select layers to be filled  

#define FILL_DM0                         // turn on to fill dummy M0
#define FILL_M0_BTCD                     // turn on to fill M0 dummy TCD
  //#define VERTICAL_M0                 // control DM0 direction or perferred (right way) dircetion

#define FILL_DmyVIA0                    // turn on to fill dummy VIA0
#define FILL_VIA0_BTCD                  // turn on to fill VIA0 dummy TCD
#define FILL_DM1                         // turn on to fill dummy M1
#define FILL_M1_BTCD                     // turn on to fill M1 dummy TCD
  #define VERTICAL_M1                    // control DM1 direction or perferred (right way) dircetion

#define FILL_DmyVIA1                    // turn on to fill dummy VIA1
#define FILL_VIA1_BTCD                  // turn on to fill VIA1 dummy TCD
#define FILL_DM2                         // turn on to fill dummy M2
#define FILL_M2_BTCD                     // turn on to fill M2 dummy TCD
  //#define VERTICAL_M2                 // control DM2 direction or perferred (right way) dircetion

#define FILL_DmyVIA2                    // turn on to fill dummy VIA2
#define FILL_VIA2_BTCD                  // turn on to fill VIA2 dummy TCD
#define FILL_DM3                         // turn on to fill dummy M3
#define FILL_M3_BTCD                     // turn on to fill M3 dummy TCD
  #define VERTICAL_M3                    // control DM3 direction or perferred (right way) dircetion

#define FILL_DmyVIA3                    // turn on to fill dummy VIA3
#define FILL_VIA3_BTCD                  // turn on to fill VIA3 dummy TCD
#define FILL_DM4                         // turn on to fill dummy M4
#define FILL_M4_BTCD                     // turn on to fill M4 dummy TCD
  //#define VERTICAL_M4                 // control DM4 direction or perferred (right way) dircetion

#define FILL_DmyVIA4                    // turn on to fill dummy VIA4
#define FILL_VIA4_BTCD                  // turn on to fill VIA4 dummy TCD
#define FILL_DM5                         // turn on to fill dummy M5
#define FILL_M5_BTCD                     // turn on to fill M5 dummy TCD
  #define VERTICAL_M5                    // control DM5 direction or perferred (right way) dircetion

#define FILL_DmyVIA5                    // turn on to fill dummy VIA5
#define FILL_VIA5_BTCD                  // turn on to fill VIA5 dummy TCD
#define FILL_DM6                         // turn on to fill dummy M6
#define FILL_M6_BTCD                     // turn on to fill M6 dummy TCD
  //#define VERTICAL_M6                 // control DM6 direction or perferred (right way) dircetion

#define FILL_DmyVIA6                    // turn on to fill dummy VIA6
#define FILL_VIA6_BTCD                  // turn on to fill VIA6 dummy TCD
#define FILL_DM7                         // turn on to fill dummy M7
#define FILL_M7_BTCD                     // turn on to fill M7 dummy TCD
  #define VERTICAL_M7                    // control DM7 direction or perferred (right way) dircetion

#define FILL_DmyVIA7                    // turn on to fill dummy VIA7
#define FILL_VIA7_BTCD                  // turn on to fill VIA7 dummy TCD
#define FILL_DM8                         // turn on to fill dummy M8
#define FILL_M8_BTCD                     // turn on to fill M8 dummy TCD
  //#define VERTICAL_M8                 // control DM8 direction or perferred (right way) dircetion

#define FILL_DmyVIA8                    // turn on to fill dummy VIA8
#define FILL_VIA8_BTCD                  // turn on to fill VIA8 dummy TCD
#define FILL_DM9                         // turn on to fill dummy M9
#define FILL_M9_BTCD                     // turn on to fill M9 dummy TCD
  #define VERTICAL_M9                    // control DM9 direction or perferred (right way) dircetion

#define FILL_DmyVIA9                    // turn on to fill dummy VIA9
#define FILL_VIA9_BTCD                  // turn on to fill VIA9 dummy TCD
#define FILL_DM10                         // turn on to fill dummy M10
#define FILL_M10_BTCD                     // turn on to fill M10 dummy TCD
  //#define VERTICAL_M10                 // control DM10 direction or perferred (right way) dircetion

#define FILL_DmyVIA10                    // turn on to fill dummy VIA10
#define FILL_VIA10_BTCD                  // turn on to fill VIA10 dummy TCD
#define FILL_DM11                         // turn on to fill dummy M11
#define FILL_M11_BTCD                     // turn on to fill M11 dummy TCD
  #define VERTICAL_M11                    // control DM11 direction or perferred (right way) dircetion

#define FILL_DmyVIA11                    // turn on to fill dummy VIA11
#define FILL_VIA11_BTCD                  // turn on to fill VIA11 dummy TCD
#define FILL_DM12                         // turn on to fill dummy M12
#define FILL_M12_BTCD                     // turn on to fill M12 dummy TCD
  //#define VERTICAL_M12                 // control DM12 direction or perferred (right way) dircetion

#define FILL_DmyVIA12                    // turn on to fill dummy VIA12
#define FILL_VIA12_BTCD                  // turn on to fill VIA12 dummy TCD
#define FILL_DM13                         // turn on to fill dummy M13
#define FILL_M13_BTCD                     // turn on to fill M13 dummy TCD
  #define VERTICAL_M13                    // control DM13 direction or perferred (right way) dircetion

#define FILL_DmyVIA13                    // turn on to fill dummy VIA13
#define FILL_DM14                         // turn on to fill dummy M14
  //#define VERTICAL_M14                 // control DM14 direction or perferred (right way) dircetion

#define FILL_DmyVIA14                    // turn on to fill dummy VIA14
#define FILL_DM15                         // turn on to fill dummy M15
  #define VERTICAL_M15                    // control DM15 direction or perferred (right way) dircetion

#define FILL_DmyVIA15                    // turn on to fill dummy VIA15
#define FILL_DM16                         // turn on to fill dummy M16
  //#define VERTICAL_M16                 // control DM16 direction or perferred (right way) dircetion

#define FILL_DmyVIA16                    // turn on to fill dummy VIA16
#define FILL_DM17                         // turn on to fill dummy M17
  #define VERTICAL_M17                    // control DM17 direction or perferred (right way) dircetion

//#define FILL_DmyVIA17                    // turn on to fill dummy VIA17
//#define FILL_DM18                         // turn on to fill dummy M18
  //#define VERTICAL_M18                 // control DM18 direction or perferred (right way) dircetion

//#define FILL_DmyVIA18                    // turn on to fill dummy VIA18
//#define FILL_DM19                         // turn on to fill dummy M19
  #define VERTICAL_M19                    // control DM19 direction or perferred (right way) dircetion





















//#define SHDMIM                  // turn on to fill SHDMIM dummy cell, can not open when FHDMIM turning on 
//#define SHDMIM_KOZ_AP_SPACE_5um   // Turn on to change SHDMIM KOZ region, please don't open when FHDMIM/FHDMIM_KOZ_AP_SPACE_5um turn on
//#define FHDMIM                  // turn on to fill FHDMIM dummy cell, can not open when SHDMIM turning on 
//#define FHDMIM_KOZ_AP_SPACE_5um   // Turn on to change FHDMIM KOZ region, please don't open when SHDMIM/SHDMIM_KOZ_AP_SPACE_5um turn on
//#define KOZ_High_subst_layer      // Turn on to check KOZ for package substrate layer >14
//#define Lid                       // Turn on to change KOZ region to comply with CoWos_S Lid process, please open CoWoS_S at the same time, and don't open Ring at the same time
//#define Ring                      // Turn on to change KOZ region to comply with CoWos_S Ring process, please open CoWoS_S at the same time, and don't open Lid at the same time
//#define CoWoS_S          // Turn on to use CoWos_S process, it needs to choose either Lid or Ring



/* SWITCH DEFINITION END */
#ifdef SHDMIM 
    #undef FHDMIM                       /* forbid FHDMIM & SHDMIM turn on at the same time */ 
    #undef FHDMIM_KOZ_AP_SPACE_5um 
    #define MIM_DMY_FILL 
#endif
#ifdef FHDMIM 
    #undef SHDMIM_KOZ_AP_SPACE_5um 
    #define MIM_DMY_FILL 
#endif
#ifdef SHDMIM_KOZ_AP_SPACE_5um 
    #define MIM_KOZ_AP_SPACE_5um 
#endif
#ifdef FHDMIM_KOZ_AP_SPACE_5um 
    #define MIM_KOZ_AP_SPACE_5um 
#endif


/* SWITCH DEFINITION END */

#ifndef COMBINE

#ifdef OVERRIDE_FILE
#include "override_file.rs"
#endif

//***** Input database ********************************************************
library( 
    library_name = "GDSFILENAME",
    cell         = "TOPCELLNAME",
#ifdef OUTPUT_GDS
    format       = GDSII
#else
    format       = OASIS	
#endif
);
error_options( 
    output_violation_shapes 	= { NET_POLYGON },
    error_limit_per_check = ERROR_LIMIT_MAX /*Specify ERROR_LIMIT_MAX to report all errors*/ 
);
gds_options( 
    box            		= CONVERT_TO_RECT,
    duplicate_cell 		= DROP
);
resolution_options( 
    spacing_tolerance = 0.0,
    drc_length_precision = 0.0,
    internal_resolution 	= 0.0005

);
prototype_options(symmetry = DUAL);
layout_drawn_options( 
    self_intersect        	= true,
    self_intersect_action 	= FILL
);
layout_grid_options( 
    check_45 = {},
    check_90 = {}
);
text_options( 
    colon_text     		= REGULAR_TEXT,
    semicolon_text 		= REGULAR_TEXT,
    allow_all_numeric 		= true,
    replace_text_characters_regex = { { { { search_string = "[\\s\\*\"={},]", replace_string = "_" } } } }    
);




































#ifndef COMBINE
#endif












// DRAWN LAYER DEFINITIONS
//========================
APBLK          = assign({ { 150, 74 } }); 
/* TSMC internal used */
INDDMY_APCHECK = assign({ { 144, 42 } }); 
/* TSMC internal used */

// DRAWN LAYER DEFINITIONS
//========================
CHIP_BOUNDARY             = assign({ { 108, 250 } }); // for Chip area definition
PRBOUNDARY                = assign({ { 108, 0 } }); // P&R cell boundary layer for auto P&R purpose
/* Top die Chip_Boundary without SEALRING_ALL for DRC recognition purpose. */
TD_CHIP_BOUNDARY = assign({ { 108, 16 } }); 
TDSBOUNDARY               = assign({ { 108, 100 } }); //3D SoIC define top die chip area without SEALRING_ALL (162;2) for DRC recognition purpose

/* Assembly Recognition Layer for SoIC_F2F */
ARL_S_F2F           = assign({ { 108, 500 } }); 
/* Assembly recognition layer(ARL) for SoIC face-to-face tier 1 pseudo layer */
ARL_S_F2F_T1        = assign({ { 108, 501 } }); 
/* Assembly recognition layer(ARL) for SoIC face-to-face tier 2 pseudo layer */
ARL_S_F2F_T2        = assign({ { 108, 502 } }); 
/* Assembly recognition layer(ARL) for SoIC face-to-face tier 3 pseudo layer */
ARL_S_F2F_T3        = assign({ { 108, 503 } }); 
/* Assembly recognition layer(ARL) for SoIC face-to-face tier 4 pseudo layer */
ARL_S_F2F_T4        = assign({ { 108, 504 } }); 
/* Assembly recognition layer(ARL) for SoIC face-to-face tier 5 pseudo layer */
ARL_S_F2F_T5        = assign({ { 108, 505 } }); 
/* Assembly Recognition Layer for SoIC_F2F */
ARL_S_F2B           = assign({ { 108, 510 } }); 
/* Assembly recognition layer(ARL) for SoIC face-to-back tier 1 pseudo layer */
ARL_S_F2B_T1        = assign({ { 108, 511 } }); 
/* Assembly recognition layer(ARL) for SoIC face-to-back tier 2 pseudo layer */
ARL_S_F2B_T2        = assign({ { 108, 512 } }); 
/* Assembly recognition layer(ARL) for SoIC face-to-back tier 3 pseudo layer */
ARL_S_F2B_T3        = assign({ { 108, 513 } }); 
/* Assembly recognition layer(ARL) for SoIC face-to-back tier 4 pseudo layer */
ARL_S_F2B_T4        = assign({ { 108, 514 } }); 
/* Assembly recognition layer(ARL) for SoIC face-to-back tier 5 pseudo layer */
ARL_S_F2B_T5        = assign({ { 108, 515 } }); 
/* Assembly recognition layer(ARL) at SoC chip boundary at  jointed top die of CoWoS-S product */
ARL_C_TDUB          = assign({ { 108, 520 } }); 
/* Assembly recognition layer(ARL) at SoC chip boundary for top die at CoW_3D */
ARL_I_TDBP          = assign({ { 108, 540 } }); 
/* Assembly recognition layer(ARL) at SoC chip boundary for bottom die at CoW_3D */
ARL_I_BDBP          = assign({ { 108, 541 } }); 
/* Assembly recognition layer at SoC chip boundary for top die at InFO */
ARL_I_TDPM0         = assign({ { 108, 542 } }); 
/* Assembly recognition layer for InFO_3DP */
ARL_I_INFO3D        = assign({ { 108, 543 } }); 
/* Assembly recognition layer(ARL) in top die for following FC C4 bump product identification */
ARL_F_TD            = assign({ { 108, 551 } }); 
/* Assembly recognition layer(ARL) in top die for following DoW micro bump product identification */
ARL_DOW_TDUB        = assign({ { 108, 552 } }); 
/* Assembly recognition layer(ARL) for Wafer-on-Wafer (WoW) EBO recognition */
ARL_WOW             = assign({ { 108, 580 } }); 
/* Assembly recognition layer(ARL) for Wafer-on-Wafer T1 (WoW) product */
ARL_WOW_T1          = assign({ { 108, 581 } }); 
/* Assembly recognition layer(ARL) for Wafer-on-Wafer T2 (WoW) product */
ARL_WOW_T2          = assign({ { 108, 582 } }); 
/* Assembly recognition layer(ARL) for Wafer-on-Wafer T3 (WoW) product */
ARL_WOW_T3          = assign({ { 108, 583 } }); 
/* Assembly recognition layer(ARL) for Wafer-on-Wafer T4 (WoW) product */
ARL_WOW_T4          = assign({ { 108, 584 } }); 
/* Assembly recognition layer(ARL) for Wafer-on-Wafer T5 (WoW) product */
ARL_WOW_T5          = assign({ { 108, 585 } }); 
/* Assembly recognition layer(ARL) for SoIC face-to-face and stands for final tier identification */
ARL_S_F2F_TF        = assign({ { 108, 700 } }); 
/* Assembly recognition layer(ARL) for SoIC face-to-face and stands for tier1 with FC product identification */
ARL_S_F2F_T1_FC     = assign({ { 108, 701 } }); 
/* Assembly recognition layer(ARL) for SoIC face-to-face and stands for tier1 with InFO product identification */
ARL_S_F2F_T1_INFO   = assign({ { 108, 702 } }); 
/* Assembly recognition layer(ARL) for SoIC face-to-face and stands for tier1 with DoW product identification */
ARL_S_F2F_T1_DOW    = assign({ { 108, 703 } }); 
/* Assembly recognition layer(ARL) for SoIC face-to-face and stands for tier1 with CoWoS product identification */
ARL_S_F2F_T1_COWOS  = assign({ { 108, 704 } }); 
/* Assembly recognition layer(ARL) for SoIC face-to-face and stands for tier1 with InFO3D product identification */
ARL_S_F2F_T1_INFO3D = assign({ { 108, 705 } }); 
/* Assembly recognition layer(ARL) for SoIC face-to-back and stands for final tier identification */
ARL_S_F2B_TF        = assign({ { 108, 710 } }); 
/* Assembly recognition layer(ARL) for SoIC face-to-back and stands for tier1 with FC product identification */
ARL_S_F2B_T1_FC     = assign({ { 108, 711 } }); 
/* Assembly recognition layer(ARL) for SoIC face-to-back and stands for tier1 with InFO product identification */
ARL_S_F2B_T1_INFO   = assign({ { 108, 712 } }); 
/* Assembly recognition layer(ARL) for SoIC face-to-back and stands for tier1 with DoW product identification */
ARL_S_F2B_T1_DOW    = assign({ { 108, 713 } }); 
/* Assembly recognition layer(ARL) for SoIC face-to-back and stands for tier1 with CoWoS product identification */
ARL_S_F2B_T1_COWOS  = assign({ { 108, 714 } }); 
/* Assembly recognition layer(ARL) for SoIC face-to-back and stands for tier1 with InFO3D product identification */
ARL_S_F2B_T1_INFO3D = assign({ { 108, 715 } }); 
/* Assembly recognition layer(ARL) for Wafer-on-Wafer (WoW) and stands for bottom die identification */
ARL_WOW_BD          = assign({ { 108, 780 } }); 
/* Assembly recognition layer(ARL) for Wafer-on-Wafer (WoW) and stands for top die with FC product identification */
ARL_WOW_TD_FC       = assign({ { 108, 781 } }); 
/* Assembly recognition layer(ARL) for Wafer-on-Wafer (WoW) and stands for top die with InFO product identification */
ARL_WOW_TD_INFO     = assign({ { 108, 782 } }); 
/* Assembly recognition layer(ARL) for Wafer-on-Wafer (WoW) and stands for top die with DoW product identification */
ARL_WOW_TD_DOW      = assign({ { 108, 783 } }); 
/* Assembly recognition layer(ARL) for Wafer-on-Wafer (WoW) and stands for top die with CoWoS product identification */
ARL_WOW_TD_COWOS    = assign({ { 108, 784 } }); 
/* Assembly recognition layer(ARL) for Wafer-on-Wafer (WoW) and stands for top die with InFO3D product identification */
ARL_WOW_TD_INFO3D   = assign({ { 108, 785 } }); 

FB_1                      = assign({ { 250, 1 } }); // FINFET device
FB_2                      = assign({ { 250, 2 } }); // FINFET I/O device
FB_3                      = assign({ { 250, 3 } }); // H195 STD Cell
FB_4                      = assign({ { 250, 4 } }); // H494 STD Cell
FB_5                      = assign({ { 250, 5 } }); // H338 STD Cell
FB_6                      = assign({ { 250, 6 } }); // H156 1-Fin STD Cell
FB_7                      = assign({ { 250, 7 } }); // H286 STD Cell
FB_8                      = assign({ { 250, 8 } }); // H390 STD Cell
FB_9                      = assign({ { 250, 9 } }); // H286 STD Cell
FB_10                     = assign({ { 250, 10 } }); // H156 STD Cell
/* H143 on grid STD Cell */
FB_11    = assign({ { 250, 11 } }); 
/* H143 off grid STD Cell */
FB_12    = assign({ { 250, 12 } }); 
/* H130 on grid STD Cell */
FB_13    = assign({ { 250, 13 } }); 
/* H130 off grid STD Cell */
FB_14    = assign({ { 250, 14 } }); 
/* H182 STD Cell */
FB_15    = assign({ { 250, 15 } }); 
/* H208 STD Cell */
FB_16    = assign({ { 250, 16 } }); 
/* H364 STD Cell */
FB_17    = assign({ { 250, 17 } }); 
/* STD Cell */
FB_18    = assign({ { 250, 18 } }); 
/* H247 STD Cell */
FB_19    = assign({ { 250, 19 } }); 
/* STD Cell */
FB_26       = assign({ { 250, 26 } }); 
/* STD Cell */
FB_28       = assign({ { 250, 28 } }); 
/* STD Cell */
FB_29       = assign({ { 250, 29 } }); 
/* STD Cell */
FB_31       = assign({ { 250, 31 } }); 
/* STD Cell */
FB_36       = assign({ { 250, 36 } }); 
/* STD Cell */
FB_38       = assign({ { 250, 38 } }); 
/* to distinguish STD cell FB_1 */
FB1_STD     = assign({ { 250, 30 } }); 
/* H117 STD Cell, 1-fin   */
FB_A     = assign({ { 250, 50 } }); 
/* H169 STD Cell, 2-fin */
FB_B     = assign({ { 250, 51 } }); 
/* H221 STD Cell, 3-fin */
FB_C     = assign({ { 250, 52 } }); 
/* STD cell A in FB_31 */
FB_31_A     = assign({ { 250, 53 } }); 
/* STD cell B in FB_31 */
FB_31_B     = assign({ { 250, 54 } }); 
/* STD cell C in FB_31 */
FB_31_C     = assign({ { 250, 55 } });
/* Define the FinFET area with high-speed performance */
FB_HS       = assign({ { 250, 58 } }); 
/* Marker layer for customized stdcell like 1R1W SRAM Bit cell */
SRM_1R1W      = assign({ { 250, 61 } }); 
/* Marker layer for customized stdcell like 2R1W SRAM Bit cell */
SRM_2R1W      = assign({ { 250, 62 } }); 
/* Marker layer for customized stdcell like 2R2W SRAM Bit cell */
SRM_2R2W      = assign({ { 250, 63 } }); 
/* Marker layer for customized stdcell like SRM_1R1W_2ROW SRAM Bit cell */
SRM_1R1W_2ROW = assign({ { 250, 64 } }); 
/* Marker layer for customized stdcell like SRM_ROM SRAM Bit cell */
SRM_ROM       = assign({ { 250, 65 } }); 
/* Marker layer for customized stdcell like 12R6W SRAM Bit cell */
SRM_12R6W     = assign({ { 250, 66 } }); 
/* Marker layer for customized stdcell like 4R1W and 4R2W SRAM Bit cell */
SRM_4R1W_2W  = assign({ { 250, 67 } }); 
/* Marker layer for customized stdcell like 2R2W type2 SRAM Bit cell */
SRM_2R2W_T2  = assign({ { 250, 68 } }); 
/* Marker layer for customized stdcell like 1RST2R1W SRAM Bit cell */
SRM_1RST2R1W = assign({ { 250, 69 } }); 
/* Marker layer for FB_10 full height boundary block */
FB_10_H     = assign({ { 250, 110 } }); 
/* Marker layer for FB_10 half height boundary block */
FB_10_F     = assign({ { 250, 160 } });
/* Marker layer for all analog cell */
FB_AN        = assign({ { 252, 1 } }); 
/* Marker layer for waive low OD density area in analog cell */
FB_AN_OD        = assign({ { 252, 2 } });
/* Marker layer for T16 cell */
T16_STD        = assign({ { 252, 3 } });
/* Marker layer for T18 cell */
T18_STD        = assign({ { 252, 4 } });
/* Analog HD cell special CAD layer */
AN_HD        = assign({ { 252, 10 } });
/* FB_1 Analog unit Cell special CAD layer */
AN_U1        = assign({ { 252, 11 } }); 
/* FB1AN exception layer */
AN_C1        = assign({ { 252, 12 } }); 
/* FB_1 Analog CMOS Cell special CAD layer */
ANA_EXP        = assign({ { 252, 21 } }); 
/* Marker layer for BEOL rule push of Analog unit cell */
AN_HDU1M0_3T = assign({ { 252, 101 } }); 
/* Marker layer for BEOL rule push of Analog unit cell */
AN_HDU1M0_4T = assign({ { 252, 102 } }); 
/* Marker layer for BEOL rule push of Analog CMOS */
AN_HDC1M0    = assign({ { 252, 103 } }); 
/* Marker layer for BEOL rule push of Analog HD208 */
AN_HDU3M0    = assign({ { 252, 105 } }); 
/* Marker layer for BEOL rule push of Analog C520 cell */
AN_HDC2M0    = assign({ { 252, 106 } }); 
/* Marker layer for BEOL rule push of Analog HD312 cell */
AN_HDU4M0    = assign({ { 252, 107 } }); 
/* FB_1 Analog unit Cell special CAD layer for 3T BEOL	 */
BE_3T        = assign({ { 252, 111 } }); 
/* FB_1 Analog unit Cell special CAD layer for 4T BEOL */
BE_4T    = assign({ { 252, 112 } }); 
/* VIA2 Marker layer for BEOL rule push of Analog Cell HD218 */
AN_HD_V2_18 = assign({ { 252, 120 } }); 
/* VIA1 Marker layer for BEOL rule push of Analog Cell HD218 */
AN_HD_V1_18 = assign({ { 252, 121 } }); 
/* VIA0 Marker layer for BEOL rule push of Analog Cell C560 */
AN_HD_V0_16 = assign({ { 252, 125 } }); 
/* VIA1 Marker layer for BEOL rule push of Analog Cell C560 */
AN_HD_V1_16 = assign({ { 252, 126 } }); 
/* VIA2 Marker layer for BEOL rule push of Analog Cell C560 */
AN_HD_V2_16 = assign({ { 252, 127 } }); 
/* Maker layer of Analog cell of ECO region */
ECO_REGION  = assign({ { 252, 41 } }); 
/* Maker layer of Analog cell of ECO Decap */
ECO_DECAP   = assign({ { 252, 42 } }); 
/* Waive LUP.WARN.5 rules only for eco_anaGR_cell, eco_anaTap_cell */
ECO_TAP_DMY   = assign({ { 252, 43 } }); 
/* Marker layer for ECO cells swap to active MOS */
ECO_ACT     = assign({ { 252, 44 } }); 
/* Analog ECO CELL */
D130_P45_2FN    = assign({ { 252, 51 } }); 
/* Analog ECO CELL */
D130_P45_2FP    = assign({ { 252, 52 } }); 
/* Analog ECO CELL */
D208_P45_4FN    = assign({ { 252, 57 } }); 
/* Analog ECO CELL */
D208_P45_4FP    = assign({ { 252, 58 } }); 
/* Analog ECO CELL */
D260_P45_2_2FN  = assign({ { 252, 61 } }); 
/* Analog ECO CELL */
D260_P45_2_2FP  = assign({ { 252, 62 } }); 
/* Analog ECO CELL */
D260_P45_6FN    = assign({ { 252, 63 } }); 
/* Analog ECO CELL */
D260_P45_6FP    = assign({ { 252, 64 } }); 
/* Analog ECO CELL */
D260_P45_8FN    = assign({ { 252, 65 } }); 
/* Analog ECO CELL */
D260_P45_8FP    = assign({ { 252, 66 } }); 
/* Analog ECO CELL */
D260_P135_2_2FN = assign({ { 252, 171 } }); 
/* Analog ECO CELL */
D260_P135_2_2FP = assign({ { 252, 172 } }); 
/* Analog ECO CELL */
D260_P135_6FN   = assign({ { 252, 173 } }); 
/* Analog ECO CELL */
D260_P135_6FP   = assign({ { 252, 174 } }); 
/* Analog ECO CELL */
D260_P135_8FN   = assign({ { 252, 175 } }); 
/* Analog ECO CELL */
D260_P135_8FP   = assign({ { 252, 176 } }); 
/* Analog ECO CELL for HD280, 6fin, Lg55, CPP135, N-type */
D280_P135_6FN   = assign({ { 252, 301 } }); 
/* Analog ECO CELL for HD280, 6fin, Lg55, CPP135, P-type */
D280_P135_6FP   = assign({ { 252, 302 } }); 
/* Analog ECO CELL for HD336, 6fin CPP135, N-type */
D336_P135_6FN = assign({ { 252, 303 } }); 
/* Analog ECO CELL for HD336, 6fin CPP135, P-type */
D336_P135_6FP = assign({ { 252, 304 } }); 
/* Analog ECO cell for HD280, 6fin, Lg86, CPP166, N-type */
D280_P166_6FN = assign({ { 252, 311 } }); 
/* Analog ECO cell for HD280, 6fin, Lg86, CPP166, P-type */
D280_P166_6FP = assign({ { 252, 312 } }); 
/* Analog ECO cell for HD336, 8fin, Lg86, CPP166, N-type */
D336_P166_8FN = assign({ { 252, 313 } }); 
/* Analog ECO cell for HD336, 8fin, Lg86, CPP166, P-type */
D336_P166_8FP = assign({ { 252, 314 } }); 
/* tsmc internal usage */
D130_PL_2FN      = assign({ { 252, 351 } }); 
/* tsmc internal usage */
D130_PL_2FP      = assign({ { 252, 352 } }); 
/* tsmc internal usage */
D208_PL_4FN      = assign({ { 252, 357 } }); 
/* tsmc internal usage */
D208_PL_4FP      = assign({ { 252, 358 } }); 
/* tsmc internal usage */
D260_PL_2_2FN    = assign({ { 252, 361 } }); 
/* tsmc internal usage */
D260_PL_2_2FP    = assign({ { 252, 362 } }); 
/* tsmc internal usage */
D260_PL_6FN      = assign({ { 252, 363 } }); 
/* tsmc internal usage */
D260_PL_6FP      = assign({ { 252, 364 } }); 
/* tsmc internal usage */
C260_PL_2FN2FP   = assign({ { 252, 801 } }); 
/* tsmc internal usage */
C260_PL_2FN2FP_G = assign({ { 252, 802 } }); 
/* tsmc internal usage */
C520_PL_2FN2FP   = assign({ { 252, 803 } }); 
/* tsmc internal usage */
C520_PL_2X2FN2FP = assign({ { 252, 804 } }); 
/* tsmc internal usage */
C520_PL_6FN6FP   = assign({ { 252, 805 } }); 
/* Analog ECO CELL */
S208_P45_4FN    = assign({ { 252, 257 } }); 
/* Analog ECO CELL */
S208_P45_4FP    = assign({ { 252, 258 } }); 
/* Analog ECO CELL for C260, 2fin, Lg3, CPP135, CMOS */
C260_P45_2FN2FP = assign({ { 252, 501 } }); 
/* Analog ECO CELL for C260, CPP45, 2 fin N-type, 2 fin P-type (general) */
C260_P45_2FN2FP_G = assign({ { 252, 502 } }); 
/* Analog ECO CELL for C520, CPP45, 2 fin N-type, 2 fin P-type */
C520_P45_2FN2FP   = assign({ { 252, 503 } }); 
/* Analog ECO CELL for C520, 2finx2, Lg3, CPP45, CMOS */
C520_P45_2X2FN2FP = assign({ { 252, 504 } }); 
/* Analog ECO CELL for C520, CPP45, 6 fin N-type, 6 fin P-type */
C520_P45_6FN6FP   = assign({ { 252, 505 } }); 
/* Analog ECO CELL for C560, CPP166, 6 fin N-type, 6 fin P-type */
C560_P166_6FN6FP = assign({ { 252, 546 } }); 
/* Analog ECO CELL for C672, CPP166, 6 fin N-type, 6 fin P-type */
C672_P166_6FN6FP = assign({ { 252, 547 } }); 
/* Analog ECO CELL for C812, CPP166, 8 fin N-type, 8 fin P-type */
C672_P166_8FN8FP = assign({ { 252, 548 } }); 
/* Confined Compact Pattern for FB_3 */
CCP_3    = assign({ { 98, 3 } }); 
/* Confined Compact Pattern for FB_4 */
CCP_4    = assign({ { 98, 4 } }); 
/* Confined Compact Pattern for FB_5 */
CCP_5    = assign({ { 98, 5 } }); 
/* Confined Compact Pattern for FB_6 */
CCP_6    = assign({ { 98, 6 } }); 
/* Confined Compact Pattern for FB_7 */
CCP_7    = assign({ { 98, 7 } }); 
/* Confined Compact Pattern for FB_8 */
CCP_8    = assign({ { 98, 8 } }); 
/* Confined Compact Pattern for FB_9 */
CCP_9    = assign({ { 98, 9 } }); 
/* Confined Compact Pattern for FB_10 */
CCP_10   = assign({ { 98, 10 } }); 
/* Confined Compact Pattern for FB_11 */
CCP_11   = assign({ { 98, 11 } }); 
/* Confined Compact Pattern for FB_12 */
CCP_12   = assign({ { 98, 12 } }); 
/* Confined Compact Pattern for FB_13 */
CCP_13   = assign({ { 98, 13 } }); 
/* Confined Compact Pattern for FB_14 */
CCP_14   = assign({ { 98, 14 } }); 
/* Confined Compact Pattern for FB_15 */
CCP_15   = assign({ { 98, 15 } }); 
/* Confined Compact Pattern for FB_16 */
CCP_16   = assign({ { 98, 16 } }); 
/* Confined Compact Pattern for FB_17 */
CCP_17   = assign({ { 98, 17 } }); 
/* Confined Compact Pattern for FB_18 */
CCP_18      = assign({ { 98, 18 } }); 
/* Confined Compact Pattern for FB_19 */
CCP_19   = assign({ { 98, 19 } }); 
/* define Confined Compact Pattern for FB_26 */
CCP_26      = assign({ { 98, 26 } }); 
/* define Confined Compact Pattern for FB_28 */
CCP_28      = assign({ { 98, 28 } }); 
/* define Confined Compact Pattern for FB_29 */
CCP_29      = assign({ { 98, 29 } }); 
/* define Confined Compact Pattern for FB_31 */
CCP_31      = assign({ { 98, 31 } }); 
/* define Confined Compact Pattern for FB_36 */
CCP_36      = assign({ { 98, 36 } }); 
/* define Confined Compact Pattern for FB_38 */
CCP_38      = assign({ { 98, 38 } }); 

/* Filler cell marker (1fin height) for periphery cell and std cell abutment */
STD_FILLER_1 = assign({ { 6, 201 } }); 
/* Filler cell marker (4fin height) for periphery cell and std cell abutment */
STD_FILLER_4 = assign({ { 6, 202 } }); 
/* Filler cell marker for periphery cell and std cell abutment */
STD_FILLER   = assign({ { 6, 210 } }); 
/* Marker layer COD_V smoothing at STD_FILLER boundary region */
STD_FILLER_H_BOUND = assign({ { 6, 211 } }); 
/* Padded dummy poly boundary recognized in APR */
PADDED_DPO = assign({ { 6, 220 } });

/* Deep N-well */
DNW             = assign({ { 1, 0 } }); 
/* N-well */
NW              = assign({ { 3, 0 } }); 
/* OD */
OD              = assign({ { 6, 0 } }, layer_intent = { LAYER_INTENT_BASE }); 
/* Dummy OD */
SR_DOD          = assign({ { 6, 7 } }); 
/* SRAM OD (TSMC internal use) */
OD_SRAM1          = assign({ { 6, 11 } }); 
/* Planar OD special usage for COD utility */
OD_20           = assign({ { 6, 20 } }); 
/* OD mandrel */
OD_DA           = assign({ { 6, 30 } }); 
/* OD density waive layer for H338 only */
OD_DN_BLK       = assign({ { 6, 31 } }); 
/* Marker layer for STD Cell direct abutment of diff conditions */
FB_BOUNDARY_BLK_H = assign({ { 6, 33 } }); 
/* Block layer from mandrel generation */
FB_BOUNDARY_BLK = assign({ { 6, 34 } }); 
/* Block layer from mandrel generation */
FB_CORNER_BLK   = assign({ { 6, 35 } }); 
/* FB6 1X height boundary cell marker laye */
FB6_1X_BLK  = assign({ { 6, 36 } }); 
/* FB26 1X height boundary cell marker layer */
FB_26_1X_BLK = assign({ { 6, 37 } });
/* Horizontal Cut OD  */
COD_H           = assign({ { 6, 60 } }); 
/* Vertical Cut OD */
COD_V           = assign({ { 6, 61 } }); 
/* 2nd Vertical Cut OD */
COD_V2          = assign({ { 6, 65 } }); 
/* Cut OD block */
COD_BLOCK       = assign({ { 6, 70 } }); 
/* OD mandrel block */
ODMMB           = assign({ { 6, 80 } }); 
/* Dummy Horizontal Cut OD  */
DCOD_H          = assign({ { 6, 160 } }); 
/* Dummy Vertical Cut OD */
DCOD_V          = assign({ { 6, 161 } }); 
/* Dummy 2nd Vertical Cut OD */
DCOD_V2         = assign({ { 6, 165 } }); 
/* Dummy Cut OD block */
DCOD_BLOCK      = assign({ { 6, 170 } }); 
/* Horizontal Cut OD (COD utility) */
GCOD_H          = assign({ { 6, 260 } }); 
/* Vertical Cut OD (COD utility) */
GCOD_V          = assign({ { 6, 261 } }); 
/* OD mandrel (utility generation) */
ODMUO           = assign({ { 6, 230 } }); 
/* Poly */
PO              = assign({ { 17, 0 } }, layer_intent = { LAYER_INTENT_BASE }); 
/* Dummy Poly */
SR_DPO          = assign({ { 17, 7 } }); 
/* Cut Poly for SRAM */
CPO_SRAM        = assign({ { 17, 12 } }); 
/* Trim PO for Lg=5nm */
TPO         = assign({ { 17, 20 } }); 
/* Cut Poly */
CPO             = assign({ { 17, 30 } }); 
/* Dummy CPO */
SR_DCPO         = assign({ { 17, 50 } }); 
/* SRAM butted FB_1 PO layer          */
BPO             = assign({ { 17, 80 } }); 
/* SRAM butted FB_1 PO layer          */
BPO_2           = assign({ { 17, 81 } }); 
/* PO pitch 42 block layer */
PO_P42          = assign({ { 17, 90 } }); 
/* PO pitch 48 block layer */
PO_P48          = assign({ { 17, 91 } }); 
/* PO pitch 51 block layer */
PO_P51          = assign({ { 17, 92 } }); 
/* PO pitch 81 block layer */
PO_P81          = assign({ { 17, 93 } }); 
/* PO pitch 81 block layer */
PO_P81_WPO      = assign({ { 17, 94 } });
/* PO pitch 57 block layer */
PO_P57          = assign({ { 17, 95 } }); 
/* PO pitch 54 block layer */
PO_P54          = assign({ { 17, 96 } }); 
/* Marker layer for chip that only allow Lg3 poly gate */
PA_CORE_MIN          = assign({ { 17, 100 } }); 
/* EPI blocking layer */
EPI_BLK         = assign({ { 206, 1 } });
/* GATE abut OD vertical edge   */
PODE_GATE       = assign({ { 206, 28 } }); 

/* Marker layer for P/G net, for M2 */
M2_PG_MARKER  = assign({ { 207, 32 } }); 
/* Marker layer for P/G net, for M3 */
M3_PG_MARKER  = assign({ { 207, 33 } }); 
/* Marker layer for P/G net, for M4 */
M4_PG_MARKER  = assign({ { 207, 34 } }); 
/* Marker layer for P/G net, for M5 */
M5_PG_MARKER  = assign({ { 207, 35 } }); 
/* Marker layer for P/G net, for M6 */
M6_PG_MARKER  = assign({ { 207, 36 } }); 
/* Marker layer for P/G net, for M7 */
M7_PG_MARKER  = assign({ { 207, 37 } }); 
/* Marker layer for P/G net, for M8 */
M8_PG_MARKER  = assign({ { 207, 38 } }); 
/* Marker layer for P/G net, for M9 */
M9_PG_MARKER  = assign({ { 207, 39 } }); 
/* Marker layer for P/G net, for M10 */
M10_PG_MARKER = assign({ { 207, 40 } }); 
/* Marker layer for P/G net, for M11 */
M11_PG_MARKER = assign({ { 207, 41 } }); 
/* Marker layer for P/G net, for M12 */
M12_PG_MARKER = assign({ { 207, 42 } }); 
/* Marker layer for P/G net, for M13 */
M13_PG_MARKER = assign({ { 207, 43 } }); 
/* Marker layer for P/G net, for M14 */
M14_PG_MARKER = assign({ { 207, 44 } }); 
/* Marker layer for P/G net, for M15 */
M15_PG_MARKER = assign({ { 207, 45 } }); 
/* Marker layer for P/G net, for M16 */
M16_PG_MARKER = assign({ { 207, 46 } }); 
/* Marker layer for P/G net, for M17 */
M17_PG_MARKER = assign({ { 207, 47 } }); 
/* Marker layer for P/G net, for M18 */
M18_PG_MARKER = assign({ { 207, 48 } }); 
/* Marker layer for P/G net, for M19 */
M19_PG_MARKER = assign({ { 207, 49 } }); 
/* Marker layer for P/G net, for M20 */
M20_PG_MARKER = assign({ { 207, 550 } }); 
/* Marker layer for P/G net, for M21 */
M21_PG_MARKER = assign({ { 207, 551 } });
MPG_MARKER_M2  = assign({ { 207, 332 } }); 
/* Marker layer for customer P/G net, for M3 */
MPG_MARKER_M3  = assign({ { 207, 333 } }); 
/* Marker layer for customer P/G net, for M4 */
MPG_MARKER_M4  = assign({ { 207, 334 } }); 
/* Marker layer for customer P/G net, for M5 */
MPG_MARKER_M5  = assign({ { 207, 335 } }); 
/* Marker layer for customer P/G net, for M6 */
MPG_MARKER_M6  = assign({ { 207, 336 } }); 
/* Marker layer for customer P/G net, for M7 */
MPG_MARKER_M7  = assign({ { 207, 337 } }); 
/* Marker layer for customer P/G net, for M8 */
MPG_MARKER_M8  = assign({ { 207, 338 } }); 
/* Marker layer for customer P/G net, for M9 */
MPG_MARKER_M9  = assign({ { 207, 339 } }); 
/* Marker layer for customer P/G net, for M10 */
MPG_MARKER_M10 = assign({ { 207, 340 } }); 
/* Marker layer for customer P/G net, for M11 */
MPG_MARKER_M11 = assign({ { 207, 341 } }); 
/* Marker layer for customer P/G net, for M12 */
MPG_MARKER_M12 = assign({ { 207, 342 } }); 
/* Marker layer for customer P/G net, for M13 */
MPG_MARKER_M13 = assign({ { 207, 343 } }); 
/* Marker layer for customer P/G net, for M14 */
MPG_MARKER_M14 = assign({ { 207, 344 } }); 
/* Marker layer for customer P/G net, for M15 */
MPG_MARKER_M15 = assign({ { 207, 345 } }); 
/* Marker layer for customer P/G net, for M16 */
MPG_MARKER_M16 = assign({ { 207, 346 } }); 
/* Marker layer for customer P/G net, for M17 */
MPG_MARKER_M17 = assign({ { 207, 347 } }); 
/* Marker layer for customer P/G net, for M18 */
MPG_MARKER_M18 = assign({ { 207, 348 } }); 
/* Marker layer for customer P/G net, for M19 */
MPG_MARKER_M19 = assign({ { 207, 349 } }); 
/* Marker layer for customer P/G net, for M20 */
MPG_MARKER_M20 = assign({ { 207, 350 } }); 
/* Marker layer for customer  P/G net, for M21 */
MPG_MARKER_M21 = assign({ { 207, 351 } }); 

/* Recognize dummy mos cell in PDK/LVS flows   */
MOSDMY       = assign({ { 208, 5 } }); 
/* Connect two PODE cells together for Continuous OD       */
CPODE           = assign({ { 206, 150 } }); 
/* Dummy CPODE */
DCPODE          = assign({ { 206, 170 } }); 
/* MD interconnection between OD and VD */
MD              = assign({ { 82, 150 } }, layer_intent = { LAYER_INTENT_BASE }); 
/* dummy MD */
SR_DMD          = assign({ { 82, 170 } }, layer_intent = { LAYER_INTENT_FILL }); 
/* Cut MD */
CMD             = assign({ { 82, 250 } }); 
/* dummy CMD */
SR_DCMD         = assign({ { 82, 270 } }); 
/* Butted CMD at Std Cell */
BCMD            = assign({ { 87, 0 } }); 
/* MD interconnection between OD and VD  */
MP             = assign({ { 83, 150 } }, layer_intent = { LAYER_INTENT_BASE }); 
/* Via on MG  */
VDR             = assign({ { 177, 150 } }, layer_intent = { LAYER_INTENT_BASE }); 
/* Via on MG  */
VG              = assign({ { 178, 150 } }, layer_intent = { LAYER_INTENT_BASE }); 
/* Butted Via on MG at Std Cell */
BVG             = assign({ { 178, 180 } }); 
/* Via on MD */
VD              = assign({ { 179, 150 } }, layer_intent = { LAYER_INTENT_BASE }); 
/* Via (inside power rail) on MD */
VD2             = assign({ { 179, 151 } }, layer_intent = { LAYER_INTENT_BASE }); 
/* Butted via (inside power rail) on MD */
BVD2            = assign({ { 179, 152 } }, layer_intent = { LAYER_INTENT_BASE });

/* 1.2V thick gate oxide */
OD_12   = assign({ { 14, 0 } }); 
/* 1.2V thick gate oxide underdrive 1.0v */
OD12_10 = assign({ { 14, 1 } }); 
/* 1.2V thick gate oxide overdrive 1.5v */
OD12_15 = assign({ { 14, 2 } }); 
/* 1.5V thick gate oxide */
OD_15   = assign({ { 15, 0 } }); 
/* 1.5V thick gate oxide underdrive 1.2v */
OD15_12 = assign({ { 15, 1 } }); 
/* 1.8V thick gate oxide */
OD_18   = assign({ { 16, 0 } }); 
/* 1.8V thick gate oxide underdrive 1.2v */
OD18_12 = assign({ { 16, 1 } }); 
/* 1.8V thick gate oxide underdrive 1.5v */
OD18_15 = assign({ { 16, 4 } }); 
/* 1.8V thick gate oxide underdrive 1.0v */
OD18_10 = assign({ { 16, 5 } }); 
/* P+ S/D implant */
PP      = assign({ { 25, 0 } }); 
/* N+ S/D implant */
gNP      = assign({ { 26, 0 } });
/* Marker layer for NP boundary effect relaxation for specific layout */
NP_BOUNDARY_BLK      = assign({ { 26, 1 } });
/* Standard Vt N+ implant */
VTS_N   = assign({ { 23, 0 } }); 
/* Low leakage Standard Vt N+ implant */
VTSN_LL     = assign({ { 23, 4 } }); 
/* Standard Vt P+ implant */
VTS_P       = assign({ { 24, 0 } }); 
/* Low leakage Standard Vt P+ implant */
VTSP_LL     = assign({ { 24, 4 } }); 
/* Low Vt N+ implant */
VTL_N       = assign({ { 12, 0 } }); 
/* Low leakage low Vt N+ implant */
VTLN_LL     = assign({ { 12, 4 } }); 
/* Low Vt P+ implant */
VTL_P       = assign({ { 13, 0 } }); 
/* Low leakage low Vt P+ implant */
VTLP_LL     = assign({ { 13, 4 } }); 
/* Extreme low Vt N+ implant */
VTXL_N      = assign({ { 12, 2 } }); 
/* Extreme low Vt P+ implant */
VTXL_P      = assign({ { 13, 2 } }); 
/* High Vt N+ implant */
VTH_N       = assign({ { 23, 1 } }); 
/* High Vt P+ implant */
VTH_P       = assign({ { 24, 1 } }); 
/* Ultra Low Vt N+ implant */
VTUL_N      = assign({ { 151, 0 } }); 
/* Low leakage ultra Low Vt N+ implant */
VTULN_LL    = assign({ { 151, 4 } }); 
/* Ultra Low Vt P+ implant */
VTUL_P      = assign({ { 152, 0 } }); 
/* Low leakage ultra Low Vt P+ implant */
VTULP_LL    = assign({ { 152, 4 } }); 
/* Medium Low Vt N+ implant */
VTML_N      = assign({ { 151, 5 } }); 
/* Medium Low Vt P+ implant */
VTML_P      = assign({ { 152, 5 } }); 
/* Low Vt N+ implant */
VTEL_N      = assign({ { 12, 6 } }); 
/* Low Vt P+ implant */
VTEL_P      = assign({ { 13, 6 } });
/* Well implant blocking */
NT_N = assign({ { 11, 0 } }); 
/* MOS varactor device */
VAR  = assign({ { 143, 0 } }); 

/* Passivation opening for Wire-Bond */
CB     = assign({ { 76, 0 } }); 
/* Passivation opening for flip-chip */
CBD    = assign({ { 169, 0 } }); 
/* Passivation opening as VIA between AP and Top Metal */
RV     = assign({ { 85, 0 } }); 
/* AlCu bonding Pad & AlCu Redistributional layer (Al RDL). */
AP     = assign({ { 74, 0 } });
/* SoIC backside AlCu Redistributional layer */
APS         = assign({ { 74, 180 } }); 
/* AlCu bonding Pad & AlCu Redistributional layer (Al RDL). */
BPMT   = assign({ { 74, 200 } }); 
/* Dummy hybrid bond metal on top chip (Tier 2) */
D_BPMT        = assign({ { 74, 201 } }); 
/* Passivation opening as VIA between AP and Top Metal */
CU_RV         = assign({ { 85, 300 } }); 
/* AlCu bonding Pad & AlCu Redistributional layer (Al RDL). */
CU_RDL        = assign({ { 73, 0 } }); 
/* AlCu bonding Pad & AlCu Redistributional layer (Al RDL). */
DCU_RDL       = assign({ { 373, 0 } }); 
/* Backside Through Si Via */
BTSV        = assign({ { 121, 182 } });
/* Frontside HB contact */
HBC         = assign({ { 121, 233 } }); 
/* Frontside HB link */
HBL         = assign({ { 121, 234 } }); 
/* Backside HB contact */
BSHBC       = assign({ { 121, 237 } }); 

/* AlCu bonding Pad & AlCu Redistributional layer (Al RDL).InFO layer for DRC/LVS checking about CB2/PM and PM0 overlap */
IFO_VIA = assign({ { 74, 11 } }); 
CPS         = assign({ { 74, 21 } }); 
CPS2        = assign({ { 74, 24 } }); 
/* Micro Cu bump alignment mark (micro Cu bump for flip chip) */
MCBAM = assign({ { 74, 120 } });
/* marker layer for AP pad (THK14.5KA) */
AP_14P5_MARKER = assign({ { 74, 155 } }); 
/* marker layer for Cu pad (THK 28KA) */
CU_28_MARKER  = assign({ { 73, 160 } }); 
/* Cu pad marker */
CU_PAD_MARKER = assign({ { 73, 250 } }); 
/* Cu micro Pad marker */
CU_UPAD_MARKER = assign({ { 73, 260 } });
/* Cu micro Pad marker for pitch 36 um */
CU_UPAD_MARKER_P36 = assign({ { 73, 270 } });
/* Cu micro Pad marker for pitch 25 um */
CU_UPAD_MARKER_P25 = assign({ { 73, 280 } }); 
/* Cu micro Pad marker for pitch 90 um */
CU_UPAD_MARKER_P90 = assign({ { 73, 290 } }); 
/* 3D SoIC define AP marker location for DRC recognition purpose */
COWAP_MARKER = assign({ { 74, 250 } });
/* Marker for AP bird peak treatment to avoid peak crack */
AP_UPAD_MARKER = assign({ { 74, 260 } }); 
/* Passivation-2 opening for Wire-Bond */
CB2_WB = assign({ { 86, 20 } }); 
/* Passivation-2 opening for flip-chip */
CB2_FC = assign({ { 86, 0 } }); 
/* Pseudo layer in PASS 2 for LVS purpose  */
DR_CB2      = assign({ { 86, 1 } }); 
/* Passivation-2 open in SAC Pad */
CB2_SAC     = assign({ { 86, 10 } });
/* // Pseudo layer for CB2_SAC without PM0_SAC_Pad */
CB2_SAC_ISO     = assign({ { 86, 2 } });
/* Back-Side passivation-2 opening, second bonding pad opening */
CB2B        = assign({ { 86, 160 } }); 
/* SoIC backside passivation-2 opening */
CB2S        = assign({ { 86, 180 } }); 
/* SoIC frontside passivation-2 open */
CB2_F2B     = assign({ { 86, 200 } }); 
/* Passivation-2 opening for flip-chip */
CU_CB2_FC   = assign({ { 86, 300 } }); 
/* Passivation-2 opening for micro-bump */
CU_CB2_FCU  = assign({ { 86, 325 } }); 
/* Passivation-2 opening micro bump (Cu_RDL) for pitch 36 um */
CU_CB2_FCU_P36 = assign({ { 86, 335 } }); 
/* Passivation-2 opening micro bump (Cu_RDL) for pitch 25 um */
CU_CB2_FCU_P25 = assign({ { 86, 345 } }); 
/* Passivation-2 opening micro bump (Cu_RDL) for pitch 90 um */
CU_CB2_FCU_P90 = assign({ { 86, 355 } }); 
/* Polyimide opening */
PM     = assign({ { 5, 0 } }); 
/* PM opening pattern under PM0 to separate different PKG application under the same SOC design */
PM_IN       = assign({ { 5, 60 } }); 
/* PM opening pattern under micro PM0 (PM0_u) to separate different PKG application under the same SOC design */
PM_INU      = assign({ { 5, 65 } });
/* Cu via between AP and Cu_PPI */
PM0    = assign({ { 5, 10 } }); 
/* Layer for sacrificial pad (SAC Pad) */
PM0_SAC     = assign({ { 5, 14 } }); 
/* PM0 pattern for InFO package */
PM0_IN      = assign({ { 5, 12 } }); 
/* micro-bump pattern under for InFO package */
PM0_INU     = assign({ { 5, 17 } });
/* micro-bump pattern under for InFO package */
PM0_PAD     = assign({ { 5, 19 } }); 
/* Under bump metal for flip-chip */
UBM    = assign({ { 170, 0 } }); 
/* under bump metallurgy */
UBM_FC      = assign({ { 170, 10 } }); 
/* under bump metallurgy */
UBM_FCU     = assign({ { 170, 5 } }); 
/* SoIC under bump metallurgy */
UBM_F2B     = assign({ { 170, 200 } }); 
/* Micro under bump metallurgy for flip chip */
UUBM     = assign({ { 170, 100 } }); 
/* Vision dummy micro bump for alignment usage (Small CD bump) */
V_UUBM      = assign({ { 170, 230 } }); 
/* polyimide window */
PM_FC       = assign({ { 5, 55 } }); 
/* polyimide window */
PM_FCU      = assign({ { 5, 25 } }); 
/* 3D SoIC define backside BPM (Bonding Pad Metal) alignment mark for DRC recognition purpose */
BSAM        = assign({ { 5, 230 } }); 
/* passivation2 window for bump pad */
CB2_FCU     = assign({ { 86, 25 } }); 
/* CB2 pattern under PM0 for InFO package */
CB2_IN      = assign({ { 86, 30 } }); 
/* CB2 pattern under PM0_U for InFO package  */
CB2_INU     = assign({ { 86, 35 } });
/* TSV pattern  */
TSV         = assign({ { 251, 0 } });
/* Dummy resistor cover TSV region for LVS */
DRTSV       = assign({ { 251, 1 } }); 
/* Backside TSV pseudo metal */
BTPM        = assign({ { 251, 76 } }); 
/* NWEL 2-T resistor */
NWDMY_0   = assign({ { 114, 0 } }, layer_intent = { LAYER_INTENT_FILL }); 
/* NWEL 3-T resistor */
NWDMY_1   = assign({ { 114, 1 } }, layer_intent = { LAYER_INTENT_FILL }); 
/* High-R Resistor */
RH_TN     = assign({ { 117, 6 } }); 
/* Dummy High-R Resistor */
SR_DTN    = assign({ { 117, 7 } }); 
/* High-R Resistor block layer */
RH_TNB    = assign({ { 117, 8 } }); 
/* 2 terminal HiR resistor device */
RHDMY_ALL = assign({ { 117, 9 } }); 
/* high-EM blocking layer */
RH_TNE    = assign({ { 117, 10 } }); 
/* To define the different matching requirement. */
RH_MATCHING_2 = assign({ { 117, 11 } }); 

RHDMY0    = assign({ { 117, 30 } }); // Dummy layer for M0 Resistor region
RHDMY1    = assign({ { 117, 31 } }); // Dummy layer for M1 Resistor region
RHDMY2    = assign({ { 117, 32 } }); // Dummy layer for M2 Resistor region
RHDMY3    = assign({ { 117, 33 } }); // Dummy layer for M3 Resistor region
RHDMY4    = assign({ { 117, 34 } }); // Dummy layer for M4 Resistor region
RHDMY5    = assign({ { 117, 35 } }); // Dummy layer for M5 Resistor region
RHDMY6    = assign({ { 117, 36 } }); // Dummy layer for M6 Resistor region
RHDMY7    = assign({ { 117, 37 } }); // Dummy layer for M7 Resistor region
RHDMY8    = assign({ { 117, 38 } }); // Dummy layer for M8 Resistor region
RHDMY9    = assign({ { 117, 39 } }); // Dummy layer for M9 Resistor region
RHDMY10    = assign({ { 117, 40 } }); // Dummy layer for M10 Resistor region
RHDMY11    = assign({ { 117, 41 } }); // Dummy layer for M11 Resistor region
RHDMY12    = assign({ { 117, 42 } }); // Dummy layer for M12 Resistor region
RHDMY13    = assign({ { 117, 43 } }); // Dummy layer for M13 Resistor region
RHDMY14    = assign({ { 117, 44 } }); // Dummy layer for M14 Resistor region
RHDMY15    = assign({ { 117, 45 } }); // Dummy layer for M15 Resistor region
RHDMY16    = assign({ { 117, 46 } }); // Dummy layer for M16 Resistor region
RHDMY17    = assign({ { 117, 47 } }); // Dummy layer for M17 Resistor region
RHDMY18    = assign({ { 117, 48 } }); // Dummy layer for M18 Resistor region
RHDMY19    = assign({ { 117, 49 } }); // Dummy layer for M19 Resistor region
RMDMY0    = assign({ { 116, 30 } }, layer_intent = { LAYER_INTENT_FILL }); // M0 metal Resistor 
RMDMY1    = assign({ { 116, 31 } }, layer_intent = { LAYER_INTENT_FILL }); // M1 metal Resistor 
RMDMY2    = assign({ { 116, 32 } }, layer_intent = { LAYER_INTENT_FILL }); // M2 metal Resistor 
RMDMY3    = assign({ { 116, 33 } }, layer_intent = { LAYER_INTENT_FILL }); // M3 metal Resistor 
RMDMY4    = assign({ { 116, 34 } }, layer_intent = { LAYER_INTENT_FILL }); // M4 metal Resistor 
RMDMY5    = assign({ { 116, 35 } }, layer_intent = { LAYER_INTENT_FILL }); // M5 metal Resistor 
RMDMY6    = assign({ { 116, 36 } }, layer_intent = { LAYER_INTENT_FILL }); // M6 metal Resistor 
RMDMY7    = assign({ { 116, 37 } }, layer_intent = { LAYER_INTENT_FILL }); // M7 metal Resistor 
RMDMY8    = assign({ { 116, 38 } }, layer_intent = { LAYER_INTENT_FILL }); // M8 metal Resistor 
RMDMY9    = assign({ { 116, 39 } }, layer_intent = { LAYER_INTENT_FILL }); // M9 metal Resistor 
RMDMY10    = assign({ { 116, 40 } }, layer_intent = { LAYER_INTENT_FILL }); // M10 metal Resistor 
RMDMY11    = assign({ { 116, 41 } }, layer_intent = { LAYER_INTENT_FILL }); // M11 metal Resistor 
RMDMY12    = assign({ { 116, 42 } }, layer_intent = { LAYER_INTENT_FILL }); // M12 metal Resistor 
RMDMY13    = assign({ { 116, 43 } }, layer_intent = { LAYER_INTENT_FILL }); // M13 metal Resistor 
RMDMY14    = assign({ { 116, 44 } }, layer_intent = { LAYER_INTENT_FILL }); // M14 metal Resistor 
RMDMY15    = assign({ { 116, 45 } }, layer_intent = { LAYER_INTENT_FILL }); // M15 metal Resistor 
RMDMY16    = assign({ { 116, 46 } }, layer_intent = { LAYER_INTENT_FILL }); // M16 metal Resistor 
RMDMY17    = assign({ { 116, 47 } }, layer_intent = { LAYER_INTENT_FILL }); // M17 metal Resistor 
RMDMY18    = assign({ { 116, 48 } }, layer_intent = { LAYER_INTENT_FILL }); // M18 metal Resistor 
RMDMY19    = assign({ { 116, 49 } }, layer_intent = { LAYER_INTENT_FILL }); // M19 metal Resistor 
/* Cu metal Resistor */
RMDMYCU     = assign({ { 116, 73 } }); 
/* AP metal Resistor */
RMDMYAP    = assign({ { 116, 74 } }, layer_intent = { LAYER_INTENT_FILL }); 

/* TSV_GR layer for OD_DA */
GR_TSV_OD_DA             = assign({ { 251, 83 } }); 
/* TSV_GR layer for PO */
GR_TSV_PO                = assign({ { 251, 84 } }); 
/* TSV_GR layer for MD */
GR_TSV_MD                = assign({ { 251, 85 } }); 
/* TSV_GR layer for VDR */
GR_TSV_VDR               = assign({ { 251, 86 } }); 






















/* TSV_GR layer for VDR */
TSV_BLK                  = assign({ { 251, 181 } }); 

/* Diode device */
DIODMY     = assign({ { 119, 0 } }, layer_intent = { LAYER_INTENT_FILL }); 
/* Serdes device marker layer */
AN_SD      = assign({ { 120, 0 } });
/* Marker layer for H234 srdes cell */
AN_SD_4      = assign({ { 120, 1 } });
/* High Current Diode device */
HIA_DUMMY  = assign({ { 168, 0 } }); 
/* Dummy layer to recognized HIA_diode with optimized layout rule */
IHIADMY = assign({ { 168, 2 } }); 
BJTDMY    = assign({ { 110, 0 } }); 
/* BJT Emitter area */
BJTEDMY    = assign({ { 110, 2 } }); 
/* iBJT device */
IBJTDMY    = assign({ { 110, 3 } });
/* PBJT corner blocking layer */
PBJT_COR    = assign({ { 110, 5 } });
/* IBJT corner blocking layer */
IBJT_COR    = assign({ { 110, 6 } });
/* Dummy layer to cover customized BJT device for analog layout rules   */
BJTDMY_C2   = assign({ { 110, 12 } }); 
/* Dummy layer to cover customized BJT device for analog layout rules */
BJTEDMY_C2  = assign({ { 110, 13 } }); 
/* Dummy layer to cover customized BJT device for analog layout rules   */
BJTDMY_CD1  = assign({ { 110, 14 } }); 
/* Dummy layer to cover customized BJT device for analog layout rules   */
BJTEDMY_CD1 = assign({ { 110, 15 } });
/* Decoupling Capacitor dummy layer to cover DECAP */
DECAPDMY   = assign({ { 129, 0 } }); 

MATCHING    = assign({ { 205, 8 } }); 
/* Marker layer for customized CRAM cell */
CRAM_LP     = assign({ { 255, 8 } });
/* IP marker layer */
BUMP_BLOCKAGE   = assign({ { 255, 17 } }); 
/* sensitive analog N/P MOS array with high matching requirement */
ANARRAY_H   = assign({ { 255, 20 } }); 
/* sensitive analog N/P MOS array with medium matching requirement */
ANARRAY_M   = assign({ { 255, 21 } }); 
/* sensitive analog N/P MOS array with high matching requirement */
ANARRAY_HS  = assign({ { 255, 23 } }); 
/* special CAD layer for small MOS array to check the DGE  */
ANARRAY_S   = assign({ { 255, 24 } }); 
RH_MATCHING = assign({ { 117, 20 } }); 

/* Metal Fuse IP  */
METALFUSE     = assign({ { 156, 2 } }); 
/* Metal Fuse Link */
METALFUSELINK = assign({ { 156, 3 } }); 
/* Metal Fuse Block  */
METALFUSE_B1  = assign({ { 156, 8 } }); 
/* Inductor  */
INDDMY        = assign({ { 144, 0 } }, layer_intent = { LAYER_INTENT_FILL }); 
/* Product labels and LOGO  */
LOGO          = assign({ { 158, 0 } }); 
/* dummy TCD FEOL pattern */
TCDDMY        = assign({ { 165, 1 } }, layer_intent = { LAYER_INTENT_FILL }); 
/* dummy TCD full stack (FEOL+BEOL) */
TCDDMY_ALL    = assign({ { 165, 20 } }, layer_intent = { LAYER_INTENT_FILL }); 
/* voltage range 1.8V<=x<1.98V net marker layer, for decap */
CAP_18V     = assign({ { 255, 130 } }); 
/* Marker layer for DRC check */
RDR_ANALOG    = assign({ { 255, 151 } }); 
/* Marker layer for restriced design rule */
RDR           = assign({ { 255, 152 } }); 
/* Define Non-OPC region in DTCD */
TCDDMY_NON_OPC          = assign({ { 165, 100 } }); 
/* Define Non-OPC region for stacking DTCD */
TCDDMY_NON_OPC_STACK    = assign({ { 165, 101 } }); 
/* Define Non-OPC region for DTCD M0 */
TCDDMY_NON_OPC_BEOL0    = assign({ { 165, 110 } }); 

/* Define Non-OPC region for DTCD M1/V0  */
TCDDMY_NON_OPC_BEOL1 =  assign({ { 165, 111 } });
/* Define Non-OPC region for DTCD M2/V1  */
TCDDMY_NON_OPC_BEOL2 =  assign({ { 165, 112 } });
/* Define Non-OPC region for DTCD M3/V2  */
TCDDMY_NON_OPC_BEOL3 =  assign({ { 165, 113 } });
/* Define Non-OPC region for DTCD M4/V3  */
TCDDMY_NON_OPC_BEOL4 =  assign({ { 165, 114 } });
/* Define Non-OPC region for DTCD M5/V4  */
TCDDMY_NON_OPC_BEOL5 =  assign({ { 165, 115 } });
/* Define Non-OPC region for DTCD M6/V5  */
TCDDMY_NON_OPC_BEOL6 =  assign({ { 165, 116 } });
/* Define Non-OPC region for DTCD M7/V6  */
TCDDMY_NON_OPC_BEOL7 =  assign({ { 165, 117 } });
/* Define Non-OPC region for DTCD M8/V7  */
TCDDMY_NON_OPC_BEOL8 =  assign({ { 165, 118 } });


TCDDMY_M0     = assign({ { 165, 30 } }, layer_intent = { LAYER_INTENT_FILL }); // dummy TCD M0 pattern 


TCDDMY_M1     = assign({ { 165, 31 } }, layer_intent = { LAYER_INTENT_FILL }); // dummy TCD M1 pattern 


TCDDMY_M2     = assign({ { 165, 32 } }, layer_intent = { LAYER_INTENT_FILL }); // dummy TCD M2 pattern 


TCDDMY_M3     = assign({ { 165, 33 } }, layer_intent = { LAYER_INTENT_FILL }); // dummy TCD M3 pattern 


TCDDMY_M4     = assign({ { 165, 34 } }, layer_intent = { LAYER_INTENT_FILL }); // dummy TCD M4 pattern 


TCDDMY_M5     = assign({ { 165, 35 } }, layer_intent = { LAYER_INTENT_FILL }); // dummy TCD M5 pattern 


TCDDMY_M6     = assign({ { 165, 36 } }, layer_intent = { LAYER_INTENT_FILL }); // dummy TCD M6 pattern 


TCDDMY_M7     = assign({ { 165, 37 } }, layer_intent = { LAYER_INTENT_FILL }); // dummy TCD M7 pattern 


TCDDMY_M8     = assign({ { 165, 38 } }, layer_intent = { LAYER_INTENT_FILL }); // dummy TCD M8 pattern 


TCDDMY_M9     = assign({ { 165, 39 } }, layer_intent = { LAYER_INTENT_FILL }); // dummy TCD M9 pattern 


TCDDMY_M10     = assign({ { 165, 40 } }, layer_intent = { LAYER_INTENT_FILL }); // dummy TCD M10 pattern 


TCDDMY_M11     = assign({ { 165, 41 } }, layer_intent = { LAYER_INTENT_FILL }); // dummy TCD M11 pattern 


TCDDMY_M12     = assign({ { 165, 42 } }, layer_intent = { LAYER_INTENT_FILL }); // dummy TCD M12 pattern 


TCDDMY_M13     = assign({ { 165, 43 } }, layer_intent = { LAYER_INTENT_FILL }); // dummy TCD M13 pattern 


TCDDMY_M14     = assign({ { 165, 44 } }, layer_intent = { LAYER_INTENT_FILL }); // dummy TCD M14 pattern 


TCDDMY_M15     = assign({ { 165, 45 } }, layer_intent = { LAYER_INTENT_FILL }); // dummy TCD M15 pattern 


TCDDMY_M16     = assign({ { 165, 46 } }, layer_intent = { LAYER_INTENT_FILL }); // dummy TCD M16 pattern 


TCDDMY_M17     = assign({ { 165, 47 } }, layer_intent = { LAYER_INTENT_FILL }); // dummy TCD M17 pattern 


TCDDMY_M18     = assign({ { 165, 48 } }, layer_intent = { LAYER_INTENT_FILL }); // dummy TCD M18 pattern 


TCDDMY_M19     = assign({ { 165, 49 } }, layer_intent = { LAYER_INTENT_FILL }); // dummy TCD M19 pattern 

TCDDMY_V0     = assign({ { 165, 50 } }, layer_intent = { LAYER_INTENT_FILL });  // dummy TCD V0 pattern

TCDDMY_V1     = assign({ { 165, 51 } }, layer_intent = { LAYER_INTENT_FILL });  // dummy TCD V1 pattern

TCDDMY_V2     = assign({ { 165, 52 } }, layer_intent = { LAYER_INTENT_FILL });  // dummy TCD V2 pattern

TCDDMY_V3     = assign({ { 165, 53 } }, layer_intent = { LAYER_INTENT_FILL });  // dummy TCD V3 pattern

TCDDMY_V4     = assign({ { 165, 54 } }, layer_intent = { LAYER_INTENT_FILL });  // dummy TCD V4 pattern

TCDDMY_V5     = assign({ { 165, 55 } }, layer_intent = { LAYER_INTENT_FILL });  // dummy TCD V5 pattern

TCDDMY_V6     = assign({ { 165, 56 } }, layer_intent = { LAYER_INTENT_FILL });  // dummy TCD V6 pattern

TCDDMY_V7     = assign({ { 165, 57 } }, layer_intent = { LAYER_INTENT_FILL });  // dummy TCD V7 pattern

TCDDMY_V8     = assign({ { 165, 58 } }, layer_intent = { LAYER_INTENT_FILL });  // dummy TCD V8 pattern

TCDDMY_V9     = assign({ { 165, 59 } }, layer_intent = { LAYER_INTENT_FILL });  // dummy TCD V9 pattern

TCDDMY_V10     = assign({ { 165, 60 } }, layer_intent = { LAYER_INTENT_FILL });  // dummy TCD V10 pattern

TCDDMY_V11     = assign({ { 165, 61 } }, layer_intent = { LAYER_INTENT_FILL });  // dummy TCD V11 pattern

TCDDMY_V12     = assign({ { 165, 62 } }, layer_intent = { LAYER_INTENT_FILL });  // dummy TCD V12 pattern

TCDDMY_V13     = assign({ { 165, 63 } }, layer_intent = { LAYER_INTENT_FILL });  // dummy TCD V13 pattern

TCDDMY_V14     = assign({ { 165, 64 } }, layer_intent = { LAYER_INTENT_FILL });  // dummy TCD V14 pattern

TCDDMY_V15     = assign({ { 165, 65 } }, layer_intent = { LAYER_INTENT_FILL });  // dummy TCD V15 pattern

TCDDMY_V16     = assign({ { 165, 66 } }, layer_intent = { LAYER_INTENT_FILL });  // dummy TCD V16 pattern

TCDDMY_V17     = assign({ { 165, 67 } }, layer_intent = { LAYER_INTENT_FILL });  // dummy TCD V17 pattern

TCDDMY_V18     = assign({ { 165, 68 } }, layer_intent = { LAYER_INTENT_FILL });  // dummy TCD V18 pattern

/* LVS dummy layer to cover interdigitated capacitor (IDMOM) */
RTMOMDMY   = assign({ { 155, 0 } }); 
/* MOM capacitor device */
MOMDMY        = assign({ { 155, 21 } }); // MOM capacitor device
VIAMOMDMY     = assign({ { 155, 25 } }); // Dummy layer to define VIA in MOM region
MOMDMY_0      = assign({ { 155, 30 } }, layer_intent = { LAYER_INTENT_FILL });  // MOM M0 finger region
MOMDMY_1      = assign({ { 155, 31 } }, layer_intent = { LAYER_INTENT_FILL });  // MOM M1 finger region
MOMDMY_2      = assign({ { 155, 32 } }, layer_intent = { LAYER_INTENT_FILL });  // MOM M2 finger region
MOMDMY_3      = assign({ { 155, 33 } }, layer_intent = { LAYER_INTENT_FILL });  // MOM M3 finger region
MOMDMY_4      = assign({ { 155, 34 } }, layer_intent = { LAYER_INTENT_FILL });  // MOM M4 finger region
MOMDMY_5      = assign({ { 155, 35 } }, layer_intent = { LAYER_INTENT_FILL });  // MOM M5 finger region
MOMDMY_6      = assign({ { 155, 36 } }, layer_intent = { LAYER_INTENT_FILL });  // MOM M6 finger region
MOMDMY_7      = assign({ { 155, 37 } }, layer_intent = { LAYER_INTENT_FILL });  // MOM M7 finger region
MOMDMY_8      = assign({ { 155, 38 } }, layer_intent = { LAYER_INTENT_FILL });  // MOM M8 finger region
MOMDMY_9      = assign({ { 155, 39 } }, layer_intent = { LAYER_INTENT_FILL });  // MOM M9 finger region
MOMDMY_10      = assign({ { 155, 40 } }, layer_intent = { LAYER_INTENT_FILL });  // MOM M10 finger region
MOMDMY_11      = assign({ { 155, 41 } }, layer_intent = { LAYER_INTENT_FILL });  // MOM M11 finger region
MOMDMY_12      = assign({ { 155, 42 } }, layer_intent = { LAYER_INTENT_FILL });  // MOM M12 finger region
MOMDMY_13      = assign({ { 155, 43 } }, layer_intent = { LAYER_INTENT_FILL });  // MOM M13 finger region
MOMDMY_14      = assign({ { 155, 44 } }, layer_intent = { LAYER_INTENT_FILL });  // MOM M14 finger region
MOMDMY_15      = assign({ { 155, 45 } }, layer_intent = { LAYER_INTENT_FILL });  // MOM M15 finger region
MOMDMY_16      = assign({ { 155, 46 } }, layer_intent = { LAYER_INTENT_FILL });  // MOM M16 finger region
MOMDMY_17      = assign({ { 155, 47 } }, layer_intent = { LAYER_INTENT_FILL });  // MOM M17 finger region
MOMDMY_18      = assign({ { 155, 48 } }, layer_intent = { LAYER_INTENT_FILL });  // MOM M18 finger region
MOMDMY_19      = assign({ { 155, 49 } }, layer_intent = { LAYER_INTENT_FILL });  // MOM M19 finger region
MOMDMY_20      = assign({ { 155, 50 } }, layer_intent = { LAYER_INTENT_FILL });  // MOM M20 finger region
MOMDMY_21      = assign({ { 155, 51 } }, layer_intent = { LAYER_INTENT_FILL });  // MOM M21 finger region
/* DRC/LVS dummy layer for Cu MOM region, for Cu */
MOMDMY_CU   = assign({ { 155, 73 } }); 
/* MOM AP finger region */
MOMDMY_AP   = assign({ { 155, 74 } }); 
/* waive MOM cell */
MOM_WAIVE_FLOAT_M0   = assign({ { 155, 120 } });
/* waive MOM cell */
MOM_WAIVE_FLOAT_M1   = assign({ { 155, 121 } });
/* Free Style MOMCAP */
MOMCAP_FS   = assign({ { 155, 204 } }); 
/* LVS dummy layer for customized MOM recognition */
MOMDMY_QCM  = assign({ { 155, 220 } }); 
/* LVS dummy layer for customized MOM recognition */
MOMDMY_QFM  = assign({ { 155, 221 } }); 

/* ICOVL pattern */
ICOVL_A     = assign({ { 165, 70 } }); 
/* ICOVL pattern */
ICOVL_B     = assign({ { 165, 71 } }); 
/* ICOVL pattern */
ICOVL_C     = assign({ { 165, 72 } }); 
/* ICOVL pattern */
ICOVL_D     = assign({ { 165, 73 } }); 
/* ICOVL pattern */
ICOVL_E     = assign({ { 165, 74 } }); 
/* ICOVL pattern */
ICOVL_F     = assign({ { 165, 75 } }); 
/* ICOVL pattern */
ICOVL_G     = assign({ { 165, 76 } }); 
/* ICOVL pattern */
ICOVL_H     = assign({ { 165, 77 } }); 
/* ICOVL pattern */
ICOVL_I     = assign({ { 165, 78 } }); 
/* ICOVL pattern */
ICOVL_J     = assign({ { 165, 79 } }); 
/* ICOVL pattern */
ICOVL_SINGLE   = assign({ { 165, 320 } }); 
/* 3D SoIC define backside BPM (Bonding Pad Metal) alignment mark for DRC recognition purpose */
/* MiM capacitor top plate for 3-plates MiM process */
TPC         = assign({ { 260, 0 } }); 
/* open area of TPC */
TPC_O       = assign({ { 260, 1 } }); 
/* TPC RV dummy for 3-plate MiM use */
TPC_RVDMY   = assign({ { 260, 3 } }); 
/* TPC dummy for 3-plate MiM use */
TPCDMY      = assign({ { 260, 4 } }); 
/* TPC dummy for 3-plate MiM use (Customized use) */
TPC2_O      = assign({ { 260, 5 } }); 
/* MiM capacitor Middle plate for 3-plates MiM process  */
MPC         = assign({ { 261, 0 } }); 
/* open area of MPC */
MPC_O       = assign({ { 261, 1 } }); 
/* MPC RV dummy for 3-plate MiM use */
MPC_RVDMY   = assign({ { 261, 3 } }); 
/* MPC dummy for 3-plate MiM use */
MPCDMY      = assign({ { 261, 4 } }); 
/* MiM capacitor bottom plate for 3-plates MiM process */
BPC         = assign({ { 262, 0 } }); 
/* open area of BPC */
BPC_O       = assign({ { 262, 1 } }); 
/* BPC RV dummy for 3-plate MiM use */
BPC_RVDMY   = assign({ { 262, 3 } }); 
/* BPC dummy for 3-plate MiM use */
BPCDMY      = assign({ { 262, 4 } }); 
/* DRC/LVS dummy layer for Cu_RDL 3-plates MiM region */
TPCDMY_CU      = assign({ { 148, 73 } }); 
/* DRC/LVS dummy layer for AP 3-plates MiM region */
TPCDMY_AP   = assign({ { 148, 74 } }); 
/* DRC/LVS dummy layer for AP 2-plates MiM region */
TPCDMY_AP2  = assign({ { 148, 75 } }); 
TPCDMY_AP3  = assign({ { 148, 77 } }); 
/* DRC/LVS dummy layer for SHPMiM client region */
PMIM_1      = assign({ { 148, 81 } }); 
/* DRC/LVS dummy layer for SHPMiM server region */
PMIM_2      = assign({ { 148, 82 } }); 
/* DRC/LVS dummy layer for SHPMiM server type2-1 region */
PMIM2_1     = assign({ { 148, 83 } }); 
DMIMEXCL    = assign({ { 150, 260 } }); 
/* dummy layer to avoid SHPMIM dummy insertion */
DPMIMEXCL   = assign({ { 150, 261 } }); 
MIMEXCL     = assign({ { 255, 260 } }); 
PMIMEXCL    = assign({ { 255, 261 } });
/* Marker layer for Gm sensitive analog design */
AN_GM_SENS  = assign({ { 255, 290 } });
BPVT        = assign({ { 85, 200 } }); 
BPVB        = assign({ { 85, 202 } }); 
/* MIM capacitor for SHPMiM process */
BPC_LV       = assign({ { 263, 0 } }); 
/* opening region for SHPMIM use */
BPC_LV_O     = assign({ { 263, 1 } }); 
/* BPC_LV Dummy for SHPMIM use */
BPC_LVHV_DMY = assign({ { 263, 4 } }); 
/* MIM capacitor for SHPMiM client process */
BPC_HV1      = assign({ { 263, 11 } }); 
/* MIM capacitor for SHPMiM server process */
BPC_HV2      = assign({ { 263, 12 } }); 
/* BPC_HV2 opening region for SHPMIM use */
BPC_HV2_O    = assign({ { 263, 13 } }); 
/* BPC_HV2 opening region for SHPMIM use */
BPC_HV1_O    = assign({ { 263, 14 } }); 
/* MIM capacitor for SHPMiM process */
BPC_GND      = assign({ { 264, 0 } }); 
/* opening region for SHPMIM use */
BPC_GND_O    = assign({ { 264, 1 } }); 
/* BPC_GND_DMY Dummy for SHPMIM use */
BPC_GND_DMY  = assign({ { 264, 4 } }); 
/* MIM capacitor for SHPMiM process */
MPC_LV       = assign({ { 265, 0 } }); 
/* opening region for SHPMIM use */
MPC_LV_O     = assign({ { 265, 1 } }); 
/* MPC_LV Dummy for SHPMIM use */
MPC_LV_DMY   = assign({ { 265, 4 } }); 
/* MIM capacitor for SHPMiM process */
TPC_GND      = assign({ { 266, 0 } }); 
/* opening region for SHPMIM use */
TPC_GND_O    = assign({ { 266, 1 } }); 
/* TPC_GND_DMY Dummy for SHPMIM use */
TPC_GND_DMY  = assign({ { 266, 4 } }); 
/* MIM capacitor for SHPMiM process */
TPC_LV       = assign({ { 267, 0 } }); 
/* opening region for SHPMIM use */
TPC_LV_O     = assign({ { 267, 1 } }); 
/* TPC_LV Dummy for SHPMIM use */
TPC_LV_DMY   = assign({ { 267, 4 } }); 


M0_BREAK_BLK	= assign({ { 255, 46 } }); 
VIRT_M1_TRACK	= assign({ { 255, 123 } }); 
ODBLK        = assign({ { 150, 6 } }); 
POBLK        = assign({ { 150, 17 } }); 
MDBLK        = assign({ { 150, 82 } }); 
SIGE_DRAW    = assign({ { 205, 2 } }); 
SIC_DRAW     = assign({ { 205, 3 } }); 
/* SealRing Region */
SEALRING     = assign({ { 162, 0 } }); 
/* SLDB Region outside SealRing */
SEALRING_DB  = assign({ { 162, 1 } }); 
/* EnhanceZone+SealRing+SLDB */
SEALRING_ALL = assign({ { 162, 2 } }); 
/* SealRing EnhanceZone */
SEALRING_EN  = assign({ { 162, 3 } }); 
/* sealring reinforcement region */
SEALRING_RE  = assign({ { 162, 4 } }); 
/* sealring inner region */
SEALRING_IN  = assign({ { 162, 5 } }); 
/* sealring inner region */
SEALRING_OUT = assign({ { 162, 6 } });
/* DRC recognition layer for the sealring corner region */
SEALRING_CORNER = assign({ { 162, 7 } });
/* DRC recognition layer for the SoIC-M sealring empty zone */
SEALRING_EPT_M = assign({ { 162, 10 } }); 
/* New CAD layer of DRC recognition layer for the SoIC sealring empty zone */
SEALRING_EPT_S = assign({ { 162, 11 } }); 
/* L-shape Alignment Mark in SealRing */
LMARK        = assign({ { 109, 0 } }); 
/* CoW alignment mark */
COWAM       = assign({ { 109, 150 } }); 
/* CoW alignment mark for SoIC within CoWoS */
COWAMS      = assign({ { 109, 200 } }); 
/* Chip Corner Stress Relief pattern in SealRing */
CSRDMY       = assign({ { 166, 0 } }, layer_intent = { LAYER_INTENT_FILL });
/* Dummy CAD layer to define pick & place alignment mark (AM) location in AP layer */
AP_AMDMY       = assign({ { 166, 15 } }, layer_intent = { LAYER_INTENT_FILL }); 
/* drain-ballasted ESD device */
SR_ESD           = assign({ { 121, 0 } }); 
/* cover ESD MOS OD region */
SDI              = assign({ { 122, 0 } }); 
/* cover drain side of drain-ballasted ESD device */
SDI_2            = assign({ { 122, 2 } }); 
SDI_3            = assign({ { 122, 3 } }); 
/* waive LUP rules for verified IP */
LUPWDMY          = assign({ { 255, 1 } }, layer_intent = { LAYER_INTENT_FILL }); 
/* recognize Area IO region */
LUPWDMY_2        = assign({ { 255, 18 } }, layer_intent = { LAYER_INTENT_FILL }); 
/* Marker layer for waiving DRC violation in pad frame region */
PAD_WAV     = assign({ { 255, 19 } }); 
/* To waive push rules, only for TV2 tape-out */
LUP6IEDMY_ENG        = assign({ { 255, 55 } }, layer_intent = { LAYER_INTENT_FILL });
/* waive LUP strap density rules */
LUPDWDMY         = assign({ { 255, 59 } }, layer_intent = { LAYER_INTENT_FILL }); 
/* Recognize 15um checking window of OD injectors in IP level */
LUP_015U         = assign({ { 255, 70 } }); 
/* Recognize 15um checking window for P-type OD injectors in IP level */
LUP_015U_P         = assign({ { 255, 76 } }); 
/* Recognize 15um checking window for N-type OD injectors in IP level */
LUP_015U_N         = assign({ { 255, 77 } }); 
/* Recognize 45um checking window of High-noise OD injectors in IP level */
LUP_045U         = assign({ { 255, 71 } }); 
/* Recognize 75um checking window of IHIA OD injectors and check specific LUP rules. */
LUP_045U_IHIA    = assign({ { 255, 74 } });
/* Recognize 45um checking window of IHIA OD injectors and check specific LUP rules. */
LUP_075U_IHIA    = assign({ { 255, 75 } });
/* Recognize 75um checking window of High-noise OD injectors in IP level */
LUP_075U         = assign({ { 255, 72 } }); 
/* Recognize 45um checking window of IHIA OD injectors in IP level */
LUP_045U_15V     = assign({ { 255, 101 } }); 
/* Recognize 75um checking window of IHIA OD injectors in IP level */
LUP_075U_15V     = assign({ { 255, 102 } }); 
/* Recognize 45um checking window of Med-low-noise OD injectors in IP level */
LUP_045U_15V_IHIA 	= assign({ { 255, 103 } });
/* Recognize 75um checking window of Med-low-noise OD injectors in IP level */
LUP_075U_15V_IHIA 	= assign({ { 255, 104 } });
/* To annotate the waived gates for a particular violation */
CNODWVR      = assign({ { 255, 109 } }); 
/* To annotate the waived gates for a particular violation */
CNODWVR_TEXT_exploded = assign_text({ { 255, 109 } }, use_exploded_text = { { { "*" }, { "*" } } }); 
CNODWVR_TEXT = assign_text({ { 255, 109 } }); 
/* Recognize 45um checking window of Med-noise OD injectors in IP level */
LUP_045U_18V     = assign({ { 255, 111 } }); 
/* Recognize 75um checking window of Med-noise OD injectors in IP level */
LUP_075U_18V     = assign({ { 255, 112 } }); 
/* Recognize 45um checking window of IHIA OD injectors in IP level */
LUP_045U_18V_IHIA     = assign({ { 255, 113 } });
/* To check tighten Latch-up rule for Vtrigger=1.70V */
LUP_VTR170_LOGIC     = assign({ { 255, 218 } });
/* To check tighten Latch-up rule for Vtrigger=1.80V */
LUP_VTR180_LOGIC     = assign({ { 255, 219 } });
/* To check SRAM tighten Latch-up rule for Vtrigger=1.60V */
LUP_VTR160_SRM     = assign({ { 255, 221 } });

/* Recognize 75um checking window of IHIA OD injectors in IP level */
LUP_075U_18V_IHIA     = assign({ { 255, 114 } });
/* To check within OD injector 150um  related ESD/LU rules */
LUP_150U         = assign({ { 255, 115 } });
/* An engineering layer for LUP.6 rule waiver. */
LUPWDMY_ENG      = assign({ { 255, 119 } }, layer_intent = { LAYER_INTENT_FILL }); 
/* draw on M1 to triggle LUP check in IP level without PAD */
IODMYI            = assign({ { 255, 31 } }, layer_intent = { LAYER_INTENT_FILL }); 
/* Identify VDD PAD for LUP rules. */
VDDDMY           = assign({ { 255, 4 } }, layer_intent = { LAYER_INTENT_FILL }); 
/* Identify VSS PAD for LUP rules. */
VSSDMY           = assign({ { 255, 5 } }, layer_intent = { LAYER_INTENT_FILL }); 
/* Recognize resistor over 200ohm for ESD/LUP check */
RES200           = assign({ { 255, 9 } }); 
/* Low capacitance ESD device region */
LC_DMY           = assign({ { 168, 1 } }, layer_intent = { LAYER_INTENT_FILL }); 
/* waive defined LUP rules */
LUPIEDMY         = assign({ { 255, 56 } }, layer_intent = { LAYER_INTENT_FILL }); 
/* draw on M1 to recognize low noise OD injector to waive LUP rules */
LUPVIEDMY        = assign({ { 255, 58 } }, layer_intent = { LAYER_INTENT_FILL }); 
/* draw on Pad to recognize low noise OD injector to waive LUP rules */
LUPVIEDMY_BUMP   = assign({ { 255, 60 } }, layer_intent = { LAYER_INTENT_FILL }); 
/* draw on M1 to recognize medium-low noise OD injector to waive LUP rules */
LUP15VIEDMY      = assign({ { 255, 65 } }, layer_intent = { LAYER_INTENT_FILL }); 
/* draw on Pad to recognize medium-low noise OD injector to waive LUP rules */
LUP15VIEDMY_BUMP = assign({ { 255, 62 } }, layer_intent = { LAYER_INTENT_FILL }); 
/* draw on M1 to recognize medium noise OD injector to waive LUP rules */
LUP18VIEDMY      = assign({ { 255, 66 } }, layer_intent = { LAYER_INTENT_FILL }); 
/* draw on Pad to recognize medium noise OD injector to waive LUP rules */
LUP18VIEDMY_BUMP = assign({ { 255, 63 } }, layer_intent = { LAYER_INTENT_FILL }); 
/* DRC recognition layer for waive PAD frame area */
PADDMY           = assign({ { 255, 16 } }, layer_intent = { LAYER_INTENT_FILL }); 
/* draw on M1 to recognize Ultra noise OD injector to waive LUP rules */
LUPULVIEDMY      = assign({ { 255, 91 } }, layer_intent = { LAYER_INTENT_FILL }); 
/* draw on Pad to recognize Ultra noise OD injector to waive LUP rules */
LUPULVIEDMY_BUMP = assign({ { 255, 92 } }, layer_intent = { LAYER_INTENT_FILL }); 

SRM              = assign({ { 20, 0 } }); // define SRAM FEOL region
SRM_1            = assign({ { 20, 1 } }); // TSMC internal use
SRM_3            = assign({ { 20, 3 } }); // TSMC internal use
SRM_4            = assign({ { 20, 4 } }); // TSMC internal use
SRM_7            = assign({ { 20, 7 } }); // TSMC internal use

SRM_9            = assign({ { 20, 9 } });     // SRAM layer for TSMC internal use
SRM_10            = assign({ { 20, 10 } });     // SRAM layer for TSMC internal use
SRM_11            = assign({ { 20, 11 } });     // SRAM layer for TSMC internal use
SRM_12            = assign({ { 20, 12 } });     // SRAM layer for TSMC internal use
SRM_13            = assign({ { 20, 13 } });     // SRAM layer for TSMC internal use
SRM_14            = assign({ { 20, 14 } });     // SRAM layer for TSMC internal use
SRM_15            = assign({ { 20, 15 } });     // SRAM layer for TSMC internal use
SRM_16            = assign({ { 20, 16 } });     // SRAM layer for TSMC internal use
SRM_17            = assign({ { 20, 17 } });     // SRAM layer for TSMC internal use
SRM_18            = assign({ { 20, 18 } });     // SRAM layer for TSMC internal use
SRM_19            = assign({ { 20, 19 } });     // SRAM layer for TSMC internal use
SRM_20            = assign({ { 20, 20 } });     // SRAM layer for TSMC internal use
SRM_21            = assign({ { 20, 21 } });     // SRAM layer for TSMC internal use
SRM_22            = assign({ { 20, 22 } });     // SRAM layer for TSMC internal use
SRM_23            = assign({ { 20, 23 } });     // SRAM layer for TSMC internal use
SRM_24            = assign({ { 20, 24 } });     // SRAM layer for TSMC internal use
SRM_25            = assign({ { 20, 25 } });     // SRAM layer for TSMC internal use
SRM_26            = assign({ { 20, 26 } });     // SRAM layer for TSMC internal use
SRM_27            = assign({ { 20, 27 } });     // SRAM layer for TSMC internal use
SRM_28            = assign({ { 20, 28 } });     // SRAM layer for TSMC internal use
SRM_29            = assign({ { 20, 29 } });     // SRAM layer for TSMC internal use
SRM_30            = assign({ { 20, 30 } });     // SRAM layer for TSMC internal use
SRM_31            = assign({ { 20, 31 } });     // SRAM layer for TSMC internal use
SRM_32            = assign({ { 20, 32 } });     // SRAM layer for TSMC internal use
SRM_33            = assign({ { 20, 33 } });     // SRAM layer for TSMC internal use
SRM_34            = assign({ { 20, 34 } });     // SRAM layer for TSMC internal use
SRM_35            = assign({ { 20, 35 } });     // SRAM layer for TSMC internal use
SRM_36            = assign({ { 20, 36 } });     // SRAM layer for TSMC internal use
SRM_37            = assign({ { 20, 37 } });     // SRAM layer for TSMC internal use
SRM_38            = assign({ { 20, 38 } });     // SRAM layer for TSMC internal use
SRM_39            = assign({ { 20, 39 } });     // SRAM layer for TSMC internal use
SRM_40            = assign({ { 20, 40 } });     // SRAM layer for TSMC internal use
SRM_41            = assign({ { 20, 41 } });     // SRAM layer for TSMC internal use
SRM_42            = assign({ { 20, 42 } });     // SRAM layer for TSMC internal use
SRM_43            = assign({ { 20, 43 } });     // SRAM layer for TSMC internal use
SRM_44            = assign({ { 20, 44 } });     // SRAM layer for TSMC internal use
SRM_45            = assign({ { 20, 45 } });     // SRAM layer for TSMC internal use
SRM_46            = assign({ { 20, 46 } });     // SRAM layer for TSMC internal use
SRM_47            = assign({ { 20, 47 } });     // SRAM layer for TSMC internal use
SRM_48            = assign({ { 20, 48 } });     // SRAM layer for TSMC internal use
SRM_49            = assign({ { 20, 49 } });     // SRAM layer for TSMC internal use

/* TSMC internal use */
SET0_5 = assign({ { 20, 61 } }); 
/* TSMC internal use */
SET6_M = assign({ { 20, 62 } }); 
/* TSMC internal use */
SET6_E = assign({ { 20, 63 } });
/* LVS dummy layer for SRAM process to exclude OD area and DRC dummy layer exclusion, TSMC internally used layer. Please review with TSMC whenever used */
RODMY = assign({ { 20, 100 } });
/* define SRAM BEOL region */
SRAMDMY   = assign({ { 186, 0 } }, layer_intent = { LAYER_INTENT_FILL }); 
/* SRAMDMY (TSMC internal use) */
SRAMDMY_1 = assign({ { 186, 1 } }); 
/* SRAMDMY (TSMC internal use) */
SRAMDMY_2 = assign({ { 186, 2 } }); 
/* Marker layer for SRAM PERI monitor circuit */
PERI_MONITOR = assign({ { 186, 95 } }); 
/* Maker layer for P-strap D25 spec relax */
ULHD_WLD     = assign({ { 186, 96 } }); 
/* define SRAM BEOL region */
SRAM_PERI_STD = assign({ { 186, 97 } }); 
/* define SRAM BEOL region */
SRAM_PERI = assign({ { 186, 98 } }); 
/* SRAM abut STD Cell marker layer */
SRAM_MACRO = assign({ { 186, 100 } }); 
/* Marker layer for ISO-CPODE effect relaxation for specific layout */
ISO_CPODE_WLD = assign({ { 186, 101 } }); 
/* DaisyC_RES_Myy is proposed on Myy for HV and ESD DRC to identify the net is disconnection */
DAISYC_RES_M12 = assign({ { 188, 42 } }); 
/* DaisyC_RES_Myy is proposed on Myy for HV and ESD DRC to identify the net is disconnection */
DAISYC_RES_M13 = assign({ { 188, 43 } }); 
/* SRAM internal layer */
CO_SRAM   = assign({ { 82, 0 } }); 
CO_SRAM11  = assign({ { 82, 11 } }); // SRAM internal layer
CO_SRAM12  = assign({ { 82, 12 } }); // SRAM internal layer
CO_SRAM13  = assign({ { 82, 13 } }); // SRAM internal layer
CO_SRAM14  = assign({ { 82, 14 } }); // SRAM internal layer
CO_SRAM15  = assign({ { 82, 15 } }); // SRAM internal layer
CO_SRAM16  = assign({ { 82, 16 } }); // SRAM internal layer
CO_SRAM17  = assign({ { 82, 17 } }); // SRAM internal layer
CO_SRAM18  = assign({ { 82, 18 } }); // SRAM internal layer
CO_SRAM19  = assign({ { 82, 19 } }); // SRAM internal layer
CO_SRAM20  = assign({ { 82, 20 } }); // SRAM internal layer
CO_SRAM21  = assign({ { 82, 21 } }); // SRAM internal layer
CO_SRAM22  = assign({ { 82, 22 } }); // SRAM internal layer
CO_SRAM23  = assign({ { 82, 23 } }); // SRAM internal layer
CO_SRAM24  = assign({ { 82, 24 } }); // SRAM internal layer
CO_SRAM25  = assign({ { 82, 25 } }); // SRAM internal layer
CO_SRAM26  = assign({ { 82, 26 } }); // SRAM internal layer
CO_SRAM27  = assign({ { 82, 27 } }); // SRAM internal layer
CO_SRAM28  = assign({ { 82, 28 } }); // SRAM internal layer
CO_SRAM29  = assign({ { 82, 29 } }); // SRAM internal layer
CO_SRAM30  = assign({ { 82, 30 } }); // SRAM internal layer
CO_SRAM31  = assign({ { 82, 31 } }); // SRAM internal layer
CO_SRAM32  = assign({ { 82, 32 } }); // SRAM internal layer
CO_SRAM33  = assign({ { 82, 33 } }); // SRAM internal layer
CO_SRAM34  = assign({ { 82, 34 } }); // SRAM internal layer
CO_SRAM35  = assign({ { 82, 35 } }); // SRAM internal layer
CO_SRAM36  = assign({ { 82, 36 } }); // SRAM internal layer
CO_SRAM37  = assign({ { 82, 37 } }); // SRAM internal layer
CO_SRAM38  = assign({ { 82, 38 } }); // SRAM internal layer
CO_SRAM39  = assign({ { 82, 39 } }); // SRAM internal layer
CO_SRAM40  = assign({ { 82, 40 } }); // SRAM internal layer
CO_SRAM41  = assign({ { 82, 41 } }); // SRAM internal layer
CO_SRAM42  = assign({ { 82, 42 } }); // SRAM internal layer
CO_SRAM43  = assign({ { 82, 43 } }); // SRAM internal layer
CO_SRAM44  = assign({ { 82, 44 } }); // SRAM internal layer
CO_SRAM45  = assign({ { 82, 45 } }); // SRAM internal layer
CO_SRAM46  = assign({ { 82, 46 } }); // SRAM internal layer
CO_SRAM47  = assign({ { 82, 47 } }); // SRAM internal layer
CO_SRAM48  = assign({ { 82, 48 } }); // SRAM internal layer
CO_SRAM49  = assign({ { 82, 49 } }); // SRAM internal layer
CO_SRAM50  = assign({ { 82, 50 } }); // SRAM internal layer
CO_SRAM51  = assign({ { 82, 51 } }); // SRAM internal layer
CO_SRAM52  = assign({ { 82, 52 } }); // SRAM internal layer
CO_SRAM53  = assign({ { 82, 53 } }); // SRAM internal layer
CO_SRAM54  = assign({ { 82, 54 } }); // SRAM internal layer
CO_SRAM55  = assign({ { 82, 55 } }); // SRAM internal layer
CO_SRAM56  = assign({ { 82, 56 } }); // SRAM internal layer
CO_SRAM57  = assign({ { 82, 57 } }); // SRAM internal layer
CO_SRAM58  = assign({ { 82, 58 } }); // SRAM internal layer
CO_SRAM59  = assign({ { 82, 59 } }); // SRAM internal layer
CO_SRAM60  = assign({ { 82, 60 } }); // SRAM internal layer
/* SRAM internal layer */
M0_JUMP = assign({ { 82, 110 } });
/* SRAM internal layer */
M1_JUMP     = assign({ { 82, 111 } });
/* OPC special treatment on SRAM M2 jumper */
M2_JUMP = assign({ { 82, 112 } });
/* OPC special treatment on SRAM M3 jumper */
M3_JUMP     = assign({ { 82, 113 } }); 
/* M3 no opc block layer */
M3_NO_OPC   = assign({ { 82, 123 } }); 
/* CRAM block layer */
CRAM1       = assign({ { 255, 6 } }); 
/* SRAM DRC violations waive layer (FEOL) */
BLK_WF = assign({ { 255, 10 } }); 
/* SRAM DRC violations waive layer (BEOL) */
BLK_WB = assign({ { 255, 11 } }); 
/* SRAM boundary cell blocking layer */
BCWDMY = assign({ { 255, 14 } }, layer_intent = { LAYER_INTENT_FILL }); 
/* SRAM M0 block   */
BLK_M0 = assign({ { 255, 39 } }); 
/* SRAM M1 block   */
BLK_M1 = assign({ { 255, 40 } }); 
/* SRAM M2 block  */
BLK_M2 = assign({ { 255, 32 } }); 
/* SRAM M3 block */
BLK_M3 = assign({ { 255, 33 } }); 
/* SRAM M4 block   */
BLK_M4 = assign({ { 255, 34 } }); 
/*   Marker layer for Customized Daisy chain recognition */
DAISYC_BLK  = assign({ { 255, 155 } }); 

/* block FEOL dummy fill  */
FEOLBLK = assign({ { 150, 27 } }); 
/* block BEOL dummy fill */
BEOLBLK = assign({ { 150, 28 } }); 

DM0EXCL = assign({ {150, 30}, {NDM_SYSTEM_LAYER_ROUTING_BLOCKAGE} }, ndm = {blockage_layers={30}, views = {DESIGN_VIEW, FRAME_VIEW} });

DM1EXCL = assign({ {150, 31}, {NDM_SYSTEM_LAYER_ROUTING_BLOCKAGE} }, ndm = {blockage_layers={31}, views = {DESIGN_VIEW, FRAME_VIEW} });

DM2EXCL = assign({ {150, 32}, {NDM_SYSTEM_LAYER_ROUTING_BLOCKAGE} }, ndm = {blockage_layers={32}, views = {DESIGN_VIEW, FRAME_VIEW} });

DM3EXCL = assign({ {150, 33}, {NDM_SYSTEM_LAYER_ROUTING_BLOCKAGE} }, ndm = {blockage_layers={33}, views = {DESIGN_VIEW, FRAME_VIEW} });

DM4EXCL = assign({ {150, 34}, {NDM_SYSTEM_LAYER_ROUTING_BLOCKAGE} }, ndm = {blockage_layers={34}, views = {DESIGN_VIEW, FRAME_VIEW} });

DM5EXCL = assign({ {150, 35}, {NDM_SYSTEM_LAYER_ROUTING_BLOCKAGE} }, ndm = {blockage_layers={35}, views = {DESIGN_VIEW, FRAME_VIEW} });

DM6EXCL = assign({ {150, 36}, {NDM_SYSTEM_LAYER_ROUTING_BLOCKAGE} }, ndm = {blockage_layers={36}, views = {DESIGN_VIEW, FRAME_VIEW} });

DM7EXCL = assign({ {150, 37}, {NDM_SYSTEM_LAYER_ROUTING_BLOCKAGE} }, ndm = {blockage_layers={37}, views = {DESIGN_VIEW, FRAME_VIEW} });

DM8EXCL = assign({ {150, 38}, {NDM_SYSTEM_LAYER_ROUTING_BLOCKAGE} }, ndm = {blockage_layers={38}, views = {DESIGN_VIEW, FRAME_VIEW} });

DM9EXCL = assign({ {150, 39}, {NDM_SYSTEM_LAYER_ROUTING_BLOCKAGE} }, ndm = {blockage_layers={39}, views = {DESIGN_VIEW, FRAME_VIEW} });

DM10EXCL = assign({ {150, 40}, {NDM_SYSTEM_LAYER_ROUTING_BLOCKAGE} }, ndm = {blockage_layers={40}, views = {DESIGN_VIEW, FRAME_VIEW} });

DM11EXCL = assign({ {150, 41}, {NDM_SYSTEM_LAYER_ROUTING_BLOCKAGE} }, ndm = {blockage_layers={41}, views = {DESIGN_VIEW, FRAME_VIEW} });

DM12EXCL = assign({ {150, 42}, {NDM_SYSTEM_LAYER_ROUTING_BLOCKAGE} }, ndm = {blockage_layers={42}, views = {DESIGN_VIEW, FRAME_VIEW} });

DM13EXCL = assign({ {150, 43}, {NDM_SYSTEM_LAYER_ROUTING_BLOCKAGE} }, ndm = {blockage_layers={43}, views = {DESIGN_VIEW, FRAME_VIEW} });

DM14EXCL = assign({ {150, 44}, {NDM_SYSTEM_LAYER_ROUTING_BLOCKAGE} }, ndm = {blockage_layers={44}, views = {DESIGN_VIEW, FRAME_VIEW} });

DM15EXCL = assign({ {150, 45}, {NDM_SYSTEM_LAYER_ROUTING_BLOCKAGE} }, ndm = {blockage_layers={45}, views = {DESIGN_VIEW, FRAME_VIEW} });

DM16EXCL = assign({ {150, 46}, {NDM_SYSTEM_LAYER_ROUTING_BLOCKAGE} }, ndm = {blockage_layers={46}, views = {DESIGN_VIEW, FRAME_VIEW} });

DM17EXCL = assign({ {150, 47}, {NDM_SYSTEM_LAYER_ROUTING_BLOCKAGE} }, ndm = {blockage_layers={47}, views = {DESIGN_VIEW, FRAME_VIEW} });

DM18EXCL = assign({ {150, 48}, {NDM_SYSTEM_LAYER_ROUTING_BLOCKAGE} }, ndm = {blockage_layers={48}, views = {DESIGN_VIEW, FRAME_VIEW} });

DM19EXCL = assign({ {150, 49}, {NDM_SYSTEM_LAYER_ROUTING_BLOCKAGE} }, ndm = {blockage_layers={49}, views = {DESIGN_VIEW, FRAME_VIEW} });
DV0EXCL = assign({ {150, 50}, {NDM_SYSTEM_LAYER_ROUTING_BLOCKAGE} }, ndm = {blockage_layers={50}, views = {DESIGN_VIEW, FRAME_VIEW} });
DV1EXCL = assign({ {150, 51}, {NDM_SYSTEM_LAYER_ROUTING_BLOCKAGE} }, ndm = {blockage_layers={51}, views = {DESIGN_VIEW, FRAME_VIEW} });
DV2EXCL = assign({ {150, 52}, {NDM_SYSTEM_LAYER_ROUTING_BLOCKAGE} }, ndm = {blockage_layers={52}, views = {DESIGN_VIEW, FRAME_VIEW} });
DV3EXCL = assign({ {150, 53}, {NDM_SYSTEM_LAYER_ROUTING_BLOCKAGE} }, ndm = {blockage_layers={53}, views = {DESIGN_VIEW, FRAME_VIEW} });
DV4EXCL = assign({ {150, 54}, {NDM_SYSTEM_LAYER_ROUTING_BLOCKAGE} }, ndm = {blockage_layers={54}, views = {DESIGN_VIEW, FRAME_VIEW} });
DV5EXCL = assign({ {150, 55}, {NDM_SYSTEM_LAYER_ROUTING_BLOCKAGE} }, ndm = {blockage_layers={55}, views = {DESIGN_VIEW, FRAME_VIEW} });
DV6EXCL = assign({ {150, 56}, {NDM_SYSTEM_LAYER_ROUTING_BLOCKAGE} }, ndm = {blockage_layers={56}, views = {DESIGN_VIEW, FRAME_VIEW} });
DV7EXCL = assign({ {150, 57}, {NDM_SYSTEM_LAYER_ROUTING_BLOCKAGE} }, ndm = {blockage_layers={57}, views = {DESIGN_VIEW, FRAME_VIEW} });
DV8EXCL = assign({ {150, 58}, {NDM_SYSTEM_LAYER_ROUTING_BLOCKAGE} }, ndm = {blockage_layers={58}, views = {DESIGN_VIEW, FRAME_VIEW} });
DV9EXCL = assign({ {150, 59}, {NDM_SYSTEM_LAYER_ROUTING_BLOCKAGE} }, ndm = {blockage_layers={59}, views = {DESIGN_VIEW, FRAME_VIEW} });
DV10EXCL = assign({ {150, 60}, {NDM_SYSTEM_LAYER_ROUTING_BLOCKAGE} }, ndm = {blockage_layers={60}, views = {DESIGN_VIEW, FRAME_VIEW} });
DV11EXCL = assign({ {150, 61}, {NDM_SYSTEM_LAYER_ROUTING_BLOCKAGE} }, ndm = {blockage_layers={61}, views = {DESIGN_VIEW, FRAME_VIEW} });
DV12EXCL = assign({ {150, 62}, {NDM_SYSTEM_LAYER_ROUTING_BLOCKAGE} }, ndm = {blockage_layers={62}, views = {DESIGN_VIEW, FRAME_VIEW} });
DV13EXCL = assign({ {150, 63}, {NDM_SYSTEM_LAYER_ROUTING_BLOCKAGE} }, ndm = {blockage_layers={63}, views = {DESIGN_VIEW, FRAME_VIEW} });
DV14EXCL = assign({ {150, 64}, {NDM_SYSTEM_LAYER_ROUTING_BLOCKAGE} }, ndm = {blockage_layers={64}, views = {DESIGN_VIEW, FRAME_VIEW} });
DV15EXCL = assign({ {150, 65}, {NDM_SYSTEM_LAYER_ROUTING_BLOCKAGE} }, ndm = {blockage_layers={65}, views = {DESIGN_VIEW, FRAME_VIEW} });
DV16EXCL = assign({ {150, 66}, {NDM_SYSTEM_LAYER_ROUTING_BLOCKAGE} }, ndm = {blockage_layers={66}, views = {DESIGN_VIEW, FRAME_VIEW} });
DV17EXCL = assign({ {150, 67}, {NDM_SYSTEM_LAYER_ROUTING_BLOCKAGE} }, ndm = {blockage_layers={67}, views = {DESIGN_VIEW, FRAME_VIEW} });
DV18EXCL = assign({ {150, 68}, {NDM_SYSTEM_LAYER_ROUTING_BLOCKAGE} }, ndm = {blockage_layers={68}, views = {DESIGN_VIEW, FRAME_VIEW} });
/* block dummy Cu_RDL fill */
DCUEXCL        = assign({ { 150, 73 } }); 
/* TSMC internal used */
UNFEOLBLK        = assign({ { 150, 327 } }); 
/* TSMC internal used */
UNBEOLBLK        = assign({ { 150, 328 } }); 
UNDM0EXCL = assign({ { 150, 300 } });  // block dummy VIA0 fill

UNDM1EXCL = assign({ { 150, 301 } });  // block dummy VIA1 fill

UNDM2EXCL = assign({ { 150, 302 } });  // block dummy VIA2 fill

UNDM3EXCL = assign({ { 150, 303 } });  // block dummy VIA3 fill

UNDM4EXCL = assign({ { 150, 304 } });  // block dummy VIA4 fill

UNDM5EXCL = assign({ { 150, 305 } });  // block dummy VIA5 fill

UNDM6EXCL = assign({ { 150, 306 } });  // block dummy VIA6 fill

UNDM7EXCL = assign({ { 150, 307 } });  // block dummy VIA7 fill

UNDM8EXCL = assign({ { 150, 308 } });  // block dummy VIA8 fill

UNDM9EXCL = assign({ { 150, 309 } });  // block dummy VIA9 fill

UNDM10EXCL = assign({ { 150, 310 } });  // block dummy VIA10 fill

UNDM11EXCL = assign({ { 150, 311 } });  // block dummy VIA11 fill

UNDM12EXCL = assign({ { 150, 312 } });  // block dummy VIA12 fill

UNDM13EXCL = assign({ { 150, 313 } });  // block dummy VIA13 fill

UNDM14EXCL = assign({ { 150, 314 } });  // block dummy VIA14 fill

UNDM15EXCL = assign({ { 150, 315 } });  // block dummy VIA15 fill

UNDM16EXCL = assign({ { 150, 316 } });  // block dummy VIA16 fill

UNDM17EXCL = assign({ { 150, 317 } });  // block dummy VIA17 fill

UNDM18EXCL = assign({ { 150, 318 } });  // block dummy VIA18 fill

UNDM19EXCL = assign({ { 150, 319 } });  // block dummy VIA19 fill

DC1            = assign({ { 257, 11 } }); 
/* Dummy Cell marker layer */
DC2_MANDREL    = assign({ { 257, 21 } }); 
/* Dummy Cell marker layer */
DC2_CORE       = assign({ { 257, 22 } }); 
/* Dummy Cell marker layer */
DC2_CORE_TYPE3 = assign({ { 257, 25 } }); 
/* Dummy Cell marker layer */
DC2_IO         = assign({ { 257, 23 } }); 
/* Dummy Cell marker layer */
DC3_FB2        = assign({ { 257, 36 } }); 
/* Dummy Cell marker layer */
DC4_CORE       = assign({ { 257, 42 } }); 
/* Dummy Cell marker layer */
DC4_IO         = assign({ { 257, 43 } }); 
/* Dummy Cell marker layer */
DC4_CORE_TYPE2 = assign({ { 257, 44 } }); 
/* Dummy Cell marker layer */
DC5_1          = assign({ { 257, 51 } }); 
/* Dummy Cell marker layer */
DC5_2          = assign({ { 257, 52 } }); 
/* Dummy Cell marker layer */
DC6_1          = assign({ { 257, 61 } }); 
/* Dummy Cell marker layer  */
DC6_2          = assign({ { 257, 62 } }); 
/* Dummy Cell marker layer */
DC7            = assign({ { 257, 71 } }); 
/* Dummy Cell marker layer */
DC8_1          = assign({ { 257, 81 } }); 
/* Dummy Cell marker layer */
DC8_2          = assign({ { 257, 82 } }); 
/* Dummy Cell marker layer */
DC9         = assign({ { 257, 91 } }); 
/* low metal density */
LOWMEDN        = assign({ { 255, 15 } }); 
DFBC 		= assign({ { 257, 150 } }); 
DFBC_H 		= assign({ { 257, 151 } }); 
DFBC_V 		= assign({ { 257, 152 } }); 
DFBC_ALL 	= assign({ { 257, 153 } }); 
PCH_DC 	    = assign({ { 257, 201 } }); 
DI_WPO 	    = assign({ { 257, 202 } }); 
M0_PIN = assign({ { 202, 30 } }); // M0 pin shape layer 
M0_PIN_TEXT_exploded = assign_text({ { 202, 30 } }, use_exploded_text = { { { "*" }, { "*" } } });  // M0 pin text layer
M0_PIN_TEXT = assign_text({ { 202, 30 } });  // M0 pin text layer
M1_PIN = assign({ { 202, 31 } }); // M1 pin shape layer 
M1_PIN_TEXT_exploded = assign_text({ { 202, 31 } }, use_exploded_text = { { { "*" }, { "*" } } });  // M1 pin text layer
M1_PIN_TEXT = assign_text({ { 202, 31 } });  // M1 pin text layer
M2_PIN = assign({ { 202, 32 } }); // M2 pin shape layer 
M2_PIN_TEXT_exploded = assign_text({ { 202, 32 } }, use_exploded_text = { { { "*" }, { "*" } } });  // M2 pin text layer
M2_PIN_TEXT = assign_text({ { 202, 32 } });  // M2 pin text layer
M3_PIN = assign({ { 202, 33 } }); // M3 pin shape layer 
M3_PIN_TEXT_exploded = assign_text({ { 202, 33 } }, use_exploded_text = { { { "*" }, { "*" } } });  // M3 pin text layer
M3_PIN_TEXT = assign_text({ { 202, 33 } });  // M3 pin text layer
M4_PIN = assign({ { 202, 34 } }); // M4 pin shape layer 
M4_PIN_TEXT_exploded = assign_text({ { 202, 34 } }, use_exploded_text = { { { "*" }, { "*" } } });  // M4 pin text layer
M4_PIN_TEXT = assign_text({ { 202, 34 } });  // M4 pin text layer
M5_PIN = assign({ { 202, 35 } }); // M5 pin shape layer 
M5_PIN_TEXT_exploded = assign_text({ { 202, 35 } }, use_exploded_text = { { { "*" }, { "*" } } });  // M5 pin text layer
M5_PIN_TEXT = assign_text({ { 202, 35 } });  // M5 pin text layer
M6_PIN = assign({ { 202, 36 } }); // M6 pin shape layer 
M6_PIN_TEXT_exploded = assign_text({ { 202, 36 } }, use_exploded_text = { { { "*" }, { "*" } } });  // M6 pin text layer
M6_PIN_TEXT = assign_text({ { 202, 36 } });  // M6 pin text layer
M7_PIN = assign({ { 202, 37 } }); // M7 pin shape layer 
M7_PIN_TEXT_exploded = assign_text({ { 202, 37 } }, use_exploded_text = { { { "*" }, { "*" } } });  // M7 pin text layer
M7_PIN_TEXT = assign_text({ { 202, 37 } });  // M7 pin text layer
M8_PIN = assign({ { 202, 38 } }); // M8 pin shape layer 
M8_PIN_TEXT_exploded = assign_text({ { 202, 38 } }, use_exploded_text = { { { "*" }, { "*" } } });  // M8 pin text layer
M8_PIN_TEXT = assign_text({ { 202, 38 } });  // M8 pin text layer
M9_PIN = assign({ { 202, 39 } }); // M9 pin shape layer 
M9_PIN_TEXT_exploded = assign_text({ { 202, 39 } }, use_exploded_text = { { { "*" }, { "*" } } });  // M9 pin text layer
M9_PIN_TEXT = assign_text({ { 202, 39 } });  // M9 pin text layer
M10_PIN = assign({ { 202, 40 } }); // M10 pin shape layer 
M10_PIN_TEXT_exploded = assign_text({ { 202, 40 } }, use_exploded_text = { { { "*" }, { "*" } } });  // M10 pin text layer
M10_PIN_TEXT = assign_text({ { 202, 40 } });  // M10 pin text layer
M11_PIN = assign({ { 202, 41 } }); // M11 pin shape layer 
M11_PIN_TEXT_exploded = assign_text({ { 202, 41 } }, use_exploded_text = { { { "*" }, { "*" } } });  // M11 pin text layer
M11_PIN_TEXT = assign_text({ { 202, 41 } });  // M11 pin text layer
M12_PIN = assign({ { 202, 42 } }); // M12 pin shape layer 
M12_PIN_TEXT_exploded = assign_text({ { 202, 42 } }, use_exploded_text = { { { "*" }, { "*" } } });  // M12 pin text layer
M12_PIN_TEXT = assign_text({ { 202, 42 } });  // M12 pin text layer
M13_PIN = assign({ { 202, 43 } }); // M13 pin shape layer 
M13_PIN_TEXT_exploded = assign_text({ { 202, 43 } }, use_exploded_text = { { { "*" }, { "*" } } });  // M13 pin text layer
M13_PIN_TEXT = assign_text({ { 202, 43 } });  // M13 pin text layer
M14_PIN = assign({ { 202, 44 } }); // M14 pin shape layer 
M14_PIN_TEXT_exploded = assign_text({ { 202, 44 } }, use_exploded_text = { { { "*" }, { "*" } } });  // M14 pin text layer
M14_PIN_TEXT = assign_text({ { 202, 44 } });  // M14 pin text layer
M15_PIN = assign({ { 202, 45 } }); // M15 pin shape layer 
M15_PIN_TEXT_exploded = assign_text({ { 202, 45 } }, use_exploded_text = { { { "*" }, { "*" } } });  // M15 pin text layer
M15_PIN_TEXT = assign_text({ { 202, 45 } });  // M15 pin text layer
M16_PIN = assign({ { 202, 46 } }); // M16 pin shape layer 
M16_PIN_TEXT_exploded = assign_text({ { 202, 46 } }, use_exploded_text = { { { "*" }, { "*" } } });  // M16 pin text layer
M16_PIN_TEXT = assign_text({ { 202, 46 } });  // M16 pin text layer
M17_PIN = assign({ { 202, 47 } }); // M17 pin shape layer 
M17_PIN_TEXT_exploded = assign_text({ { 202, 47 } }, use_exploded_text = { { { "*" }, { "*" } } });  // M17 pin text layer
M17_PIN_TEXT = assign_text({ { 202, 47 } });  // M17 pin text layer
M18_PIN = assign({ { 202, 48 } }); // M18 pin shape layer 
M18_PIN_TEXT_exploded = assign_text({ { 202, 48 } }, use_exploded_text = { { { "*" }, { "*" } } });  // M18 pin text layer
M18_PIN_TEXT = assign_text({ { 202, 48 } });  // M18 pin text layer
M19_PIN = assign({ { 202, 49 } }); // M19 pin shape layer 
M19_PIN_TEXT_exploded = assign_text({ { 202, 49 } }, use_exploded_text = { { { "*" }, { "*" } } });  // M19 pin text layer
M19_PIN_TEXT = assign_text({ { 202, 49 } });  // M19 pin text layer
AP_PIN = assign({ { 202, 74 } } ); // AP pin shape layer
AP_PIN_TEXT_exploded = assign_text({ { 202, 74 } }, use_exploded_text = { { { "*" }, { "*" } } }); // AP pin text layer
AP_PIN_TEXT = assign_text({ { 202, 74 } }); // AP pin text layer
/* Cu_RDL pin shape layer */
CU_RDL_PIN      = assign({ { 202, 73 } }); 
/* Cu_RDL pin text layer */
CU_RDL_PIN_TEXT_exploded = assign_text({ { 202, 73 } }, use_exploded_text = { { { "*" }, { "*" } } });
CU_RDL_PIN_TEXT = assign_text({ { 202, 73 } });

IPTAG  = assign({ { 63, 63 } }); // IP TAG layer
IPTAG_TEXT = assign_text({ { 63, 63 } }, use_exploded_text = { { { "*" }, { "*" } } }); // IP TAG text layer 
/* marker layer for recommended DFM rule */
RRULERECOMMEND     = assign({ { 182, 2 } }); 
/* marker layer for analog guidelines */
RRULEANALOG        = assign({ { 182, 3 } }); 
/* marker layer for excluding DFM recommendations */
EXCLRRULERECOMMEND = assign({ { 182, 12 } }); 
/* marker layer for excluding analog guidelines  */
EXCLRRULEANALOG    = assign({ { 182, 13 } }); 
/* FEOL Rule tighten blocking layer */
FEOL_BLK_T         = assign({ { 255, 41 } }); 
/* FEOL Rule relax blocking layer */
FEOL_BLK_R         = assign({ { 255, 42 } }); 
/* BEOL Rule tighten blocking layer */
BEOL_BLK_T         = assign({ { 255, 43 } }); 
/* BEOL Rule relax blocking layer */
BEOL_BLK_R         = assign({ { 255, 44 } }); 
/* define highest operation voltage  */
tODV_HIGH = assign_text({ { 6, 8 } }, use_exploded_text = { { { "*" }, { "*" } } });
/* define lowest operation voltage  */
tODV_LOW  = assign_text({ { 6, 9 } }, use_exploded_text = { { { "*" }, { "*" } } });
/* define highest operation voltage  */
tPOV_HIGH = assign_text({ { 17, 8 } }, use_exploded_text = { { { "*" }, { "*" } } });
/* define lowest operation voltage  */
tPOV_LOW  = assign_text({ { 17, 9 } }, use_exploded_text = { { { "*" }, { "*" } } });
/* define highest operation voltage  */
tMDV_HIGH = assign_text({ { 82, 8 } }, use_exploded_text = { { { "*" }, { "*" } } });
/* define lowest operation voltage  */
tMDV_LOW  = assign_text({ { 82, 9 } }, use_exploded_text = { { { "*" }, { "*" } } });
/* define two nets are synchronous (High/Low at same time) , for MD/PO */
MDV_SYNC = assign({ { 82, 3 } }); 
/* define 1.2V */
MD_12V = assign({ { 382, 22 } }); 
/* define 2.5V */
MD_25V = assign({ { 382, 29 } }); 
/* define 3.3V */
MD_33V = assign({ { 382, 30 } });
/* Define a net pair whose delta voltage follows UserDV (for MD)  */
MD_USERDV_M   = assign({ { 382, 111 } }); 
/* Define the delta voltage of a net pair (for MD) */
tMD_USERDV     = assign_text({ { 382, 112 } }, use_exploded_text = { { { "*" }, { "*" } } });
/* Define the delta voltage of a net pair at top level to overwrite UserDV tag with lower priority (for MD) */
tMD_USERDV_TOP = assign_text({ { 382, 113 } }, use_exploded_text = { { { "*" }, { "*" } } });

M0_USERDV_M = assign({ { 300, 111 } }); // Define a net pair whose delta voltage follows UserDV (for M0)
tM0_USERDV = assign_text({ { 300, 112 } }, use_exploded_text = { { { "*" }, { "*" } } }); // Define the delta voltage of a net pair (for M0)
tM0_USERDV_TOP = assign_text({ { 300, 113 } }, use_exploded_text = { { { "*" }, { "*" } } }); // Define the delta voltage of a net pair at top level to overwrite UserDV tag with lower priority (for M0)
tM0V_HIGH = assign_text({ { 300, 8 } }, use_exploded_text = { { { "*" }, { "*" } } }); // define highest operation voltage 
tM0V_LOW = assign_text({ { 300, 9 } }, use_exploded_text = { { { "*" }, { "*" } } });  // define lowest operation voltage
tM0V_HIGH_TOP = assign_text({ { 300, 6 } }, use_exploded_text = { { { "*" }, { "*" } } }); // define highest operation voltage in top level to overwrite IP's voltage information
tM0V_LOW_TOP = assign_text({ { 300, 7 } }, use_exploded_text = { { { "*" }, { "*" } } }); // define lowest operation voltage in top level to overwrite IP's voltage information
M0V_SYNC = assign({ { 300, 3 } });  // define two nets are synchronous (High/Low at same time) 
M0_00V = assign({ { 300, 10 } });  // define 0.0V net
M0_01V = assign({ { 300, 11 } });  // define 0.1V net
M0_02V = assign({ { 300, 12 } });  // define 0.2V net
M0_03V = assign({ { 300, 13 } });  // define 0.3V net
M0_04V = assign({ { 300, 14 } });  // define 0.4V net
M0_05V = assign({ { 300, 15 } });  // define 0.5V net
M0_06V = assign({ { 300, 16 } });  // define 0.6V net
M0_07V = assign({ { 300, 17 } });  // define 0.7V net
M0_08V = assign({ { 300, 18 } });  // define 0.8V net
M0_09V = assign({ { 300, 19 } });  // define 0.9V net
M0_10V = assign({ { 300, 20 } });  // define 1.0V net
M0_11V = assign({ { 300, 21 } });  // define 1.1V net
M0_12V = assign({ { 300, 22 } });  // define 1.2V net
M0_13V = assign({ { 300, 23 } });  // define 1.3V net
M0_14V = assign({ { 300, 24 } });  // define 1.4V net
M0_15V = assign({ { 300, 25 } });  // define 1.5V net
M0_16V = assign({ { 300, 26 } });  // define 1.6V net
M0_17V = assign({ { 300, 27 } });  // define 1.7V net
M0_18V = assign({ { 300, 28 } });  // define 1.8V net
M0_25V = assign({ { 300, 29 } });  // define 2.5V net
M0_33V = assign({ { 300, 30 } });  // define 3.3V net
M0_50V = assign({ { 300, 31 } });  // define 5.0V net
M0_70V = assign({ { 300, 32 } });  // define 7.0V net
M1_USERDV_M = assign({ { 301, 111 } }); // Define a net pair whose delta voltage follows UserDV (for M1)
tM1_USERDV = assign_text({ { 301, 112 } }, use_exploded_text = { { { "*" }, { "*" } } }); // Define the delta voltage of a net pair (for M1)
tM1_USERDV_TOP = assign_text({ { 301, 113 } }, use_exploded_text = { { { "*" }, { "*" } } }); // Define the delta voltage of a net pair at top level to overwrite UserDV tag with lower priority (for M1)
tM1V_HIGH = assign_text({ { 301, 8 } }, use_exploded_text = { { { "*" }, { "*" } } }); // define highest operation voltage 
tM1V_LOW = assign_text({ { 301, 9 } }, use_exploded_text = { { { "*" }, { "*" } } });  // define lowest operation voltage
tM1V_HIGH_TOP = assign_text({ { 301, 6 } }, use_exploded_text = { { { "*" }, { "*" } } }); // define highest operation voltage in top level to overwrite IP's voltage information
tM1V_LOW_TOP = assign_text({ { 301, 7 } }, use_exploded_text = { { { "*" }, { "*" } } }); // define lowest operation voltage in top level to overwrite IP's voltage information
M1V_SYNC = assign({ { 301, 3 } });  // define two nets are synchronous (High/Low at same time) 
M1_00V = assign({ { 301, 10 } });  // define 0.0V net
M1_01V = assign({ { 301, 11 } });  // define 0.1V net
M1_02V = assign({ { 301, 12 } });  // define 0.2V net
M1_03V = assign({ { 301, 13 } });  // define 0.3V net
M1_04V = assign({ { 301, 14 } });  // define 0.4V net
M1_05V = assign({ { 301, 15 } });  // define 0.5V net
M1_06V = assign({ { 301, 16 } });  // define 0.6V net
M1_07V = assign({ { 301, 17 } });  // define 0.7V net
M1_08V = assign({ { 301, 18 } });  // define 0.8V net
M1_09V = assign({ { 301, 19 } });  // define 0.9V net
M1_10V = assign({ { 301, 20 } });  // define 1.0V net
M1_11V = assign({ { 301, 21 } });  // define 1.1V net
M1_12V = assign({ { 301, 22 } });  // define 1.2V net
M1_13V = assign({ { 301, 23 } });  // define 1.3V net
M1_14V = assign({ { 301, 24 } });  // define 1.4V net
M1_15V = assign({ { 301, 25 } });  // define 1.5V net
M1_16V = assign({ { 301, 26 } });  // define 1.6V net
M1_17V = assign({ { 301, 27 } });  // define 1.7V net
M1_18V = assign({ { 301, 28 } });  // define 1.8V net
M1_25V = assign({ { 301, 29 } });  // define 2.5V net
M1_33V = assign({ { 301, 30 } });  // define 3.3V net
M1_50V = assign({ { 301, 31 } });  // define 5.0V net
M1_70V = assign({ { 301, 32 } });  // define 7.0V net
M2_USERDV_M = assign({ { 302, 111 } }); // Define a net pair whose delta voltage follows UserDV (for M2)
tM2_USERDV = assign_text({ { 302, 112 } }, use_exploded_text = { { { "*" }, { "*" } } }); // Define the delta voltage of a net pair (for M2)
tM2_USERDV_TOP = assign_text({ { 302, 113 } }, use_exploded_text = { { { "*" }, { "*" } } }); // Define the delta voltage of a net pair at top level to overwrite UserDV tag with lower priority (for M2)
tM2V_HIGH = assign_text({ { 302, 8 } }, use_exploded_text = { { { "*" }, { "*" } } }); // define highest operation voltage 
tM2V_LOW = assign_text({ { 302, 9 } }, use_exploded_text = { { { "*" }, { "*" } } });  // define lowest operation voltage
tM2V_HIGH_TOP = assign_text({ { 302, 6 } }, use_exploded_text = { { { "*" }, { "*" } } }); // define highest operation voltage in top level to overwrite IP's voltage information
tM2V_LOW_TOP = assign_text({ { 302, 7 } }, use_exploded_text = { { { "*" }, { "*" } } }); // define lowest operation voltage in top level to overwrite IP's voltage information
M2V_SYNC = assign({ { 302, 3 } });  // define two nets are synchronous (High/Low at same time) 
M2_00V = assign({ { 302, 10 } });  // define 0.0V net
M2_01V = assign({ { 302, 11 } });  // define 0.1V net
M2_02V = assign({ { 302, 12 } });  // define 0.2V net
M2_03V = assign({ { 302, 13 } });  // define 0.3V net
M2_04V = assign({ { 302, 14 } });  // define 0.4V net
M2_05V = assign({ { 302, 15 } });  // define 0.5V net
M2_06V = assign({ { 302, 16 } });  // define 0.6V net
M2_07V = assign({ { 302, 17 } });  // define 0.7V net
M2_08V = assign({ { 302, 18 } });  // define 0.8V net
M2_09V = assign({ { 302, 19 } });  // define 0.9V net
M2_10V = assign({ { 302, 20 } });  // define 1.0V net
M2_11V = assign({ { 302, 21 } });  // define 1.1V net
M2_12V = assign({ { 302, 22 } });  // define 1.2V net
M2_13V = assign({ { 302, 23 } });  // define 1.3V net
M2_14V = assign({ { 302, 24 } });  // define 1.4V net
M2_15V = assign({ { 302, 25 } });  // define 1.5V net
M2_16V = assign({ { 302, 26 } });  // define 1.6V net
M2_17V = assign({ { 302, 27 } });  // define 1.7V net
M2_18V = assign({ { 302, 28 } });  // define 1.8V net
M2_25V = assign({ { 302, 29 } });  // define 2.5V net
M2_33V = assign({ { 302, 30 } });  // define 3.3V net
M2_50V = assign({ { 302, 31 } });  // define 5.0V net
M2_70V = assign({ { 302, 32 } });  // define 7.0V net
M3_USERDV_M = assign({ { 303, 111 } }); // Define a net pair whose delta voltage follows UserDV (for M3)
tM3_USERDV = assign_text({ { 303, 112 } }, use_exploded_text = { { { "*" }, { "*" } } }); // Define the delta voltage of a net pair (for M3)
tM3_USERDV_TOP = assign_text({ { 303, 113 } }, use_exploded_text = { { { "*" }, { "*" } } }); // Define the delta voltage of a net pair at top level to overwrite UserDV tag with lower priority (for M3)
tM3V_HIGH = assign_text({ { 303, 8 } }, use_exploded_text = { { { "*" }, { "*" } } }); // define highest operation voltage 
tM3V_LOW = assign_text({ { 303, 9 } }, use_exploded_text = { { { "*" }, { "*" } } });  // define lowest operation voltage
tM3V_HIGH_TOP = assign_text({ { 303, 6 } }, use_exploded_text = { { { "*" }, { "*" } } }); // define highest operation voltage in top level to overwrite IP's voltage information
tM3V_LOW_TOP = assign_text({ { 303, 7 } }, use_exploded_text = { { { "*" }, { "*" } } }); // define lowest operation voltage in top level to overwrite IP's voltage information
M3V_SYNC = assign({ { 303, 3 } });  // define two nets are synchronous (High/Low at same time) 
M3_00V = assign({ { 303, 10 } });  // define 0.0V net
M3_01V = assign({ { 303, 11 } });  // define 0.1V net
M3_02V = assign({ { 303, 12 } });  // define 0.2V net
M3_03V = assign({ { 303, 13 } });  // define 0.3V net
M3_04V = assign({ { 303, 14 } });  // define 0.4V net
M3_05V = assign({ { 303, 15 } });  // define 0.5V net
M3_06V = assign({ { 303, 16 } });  // define 0.6V net
M3_07V = assign({ { 303, 17 } });  // define 0.7V net
M3_08V = assign({ { 303, 18 } });  // define 0.8V net
M3_09V = assign({ { 303, 19 } });  // define 0.9V net
M3_10V = assign({ { 303, 20 } });  // define 1.0V net
M3_11V = assign({ { 303, 21 } });  // define 1.1V net
M3_12V = assign({ { 303, 22 } });  // define 1.2V net
M3_13V = assign({ { 303, 23 } });  // define 1.3V net
M3_14V = assign({ { 303, 24 } });  // define 1.4V net
M3_15V = assign({ { 303, 25 } });  // define 1.5V net
M3_16V = assign({ { 303, 26 } });  // define 1.6V net
M3_17V = assign({ { 303, 27 } });  // define 1.7V net
M3_18V = assign({ { 303, 28 } });  // define 1.8V net
M3_25V = assign({ { 303, 29 } });  // define 2.5V net
M3_33V = assign({ { 303, 30 } });  // define 3.3V net
M3_50V = assign({ { 303, 31 } });  // define 5.0V net
M3_70V = assign({ { 303, 32 } });  // define 7.0V net
M4_USERDV_M = assign({ { 304, 111 } }); // Define a net pair whose delta voltage follows UserDV (for M4)
tM4_USERDV = assign_text({ { 304, 112 } }, use_exploded_text = { { { "*" }, { "*" } } }); // Define the delta voltage of a net pair (for M4)
tM4_USERDV_TOP = assign_text({ { 304, 113 } }, use_exploded_text = { { { "*" }, { "*" } } }); // Define the delta voltage of a net pair at top level to overwrite UserDV tag with lower priority (for M4)
tM4V_HIGH = assign_text({ { 304, 8 } }, use_exploded_text = { { { "*" }, { "*" } } }); // define highest operation voltage 
tM4V_LOW = assign_text({ { 304, 9 } }, use_exploded_text = { { { "*" }, { "*" } } });  // define lowest operation voltage
tM4V_HIGH_TOP = assign_text({ { 304, 6 } }, use_exploded_text = { { { "*" }, { "*" } } }); // define highest operation voltage in top level to overwrite IP's voltage information
tM4V_LOW_TOP = assign_text({ { 304, 7 } }, use_exploded_text = { { { "*" }, { "*" } } }); // define lowest operation voltage in top level to overwrite IP's voltage information
M4V_SYNC = assign({ { 304, 3 } });  // define two nets are synchronous (High/Low at same time) 
M4_00V = assign({ { 304, 10 } });  // define 0.0V net
M4_01V = assign({ { 304, 11 } });  // define 0.1V net
M4_02V = assign({ { 304, 12 } });  // define 0.2V net
M4_03V = assign({ { 304, 13 } });  // define 0.3V net
M4_04V = assign({ { 304, 14 } });  // define 0.4V net
M4_05V = assign({ { 304, 15 } });  // define 0.5V net
M4_06V = assign({ { 304, 16 } });  // define 0.6V net
M4_07V = assign({ { 304, 17 } });  // define 0.7V net
M4_08V = assign({ { 304, 18 } });  // define 0.8V net
M4_09V = assign({ { 304, 19 } });  // define 0.9V net
M4_10V = assign({ { 304, 20 } });  // define 1.0V net
M4_11V = assign({ { 304, 21 } });  // define 1.1V net
M4_12V = assign({ { 304, 22 } });  // define 1.2V net
M4_13V = assign({ { 304, 23 } });  // define 1.3V net
M4_14V = assign({ { 304, 24 } });  // define 1.4V net
M4_15V = assign({ { 304, 25 } });  // define 1.5V net
M4_16V = assign({ { 304, 26 } });  // define 1.6V net
M4_17V = assign({ { 304, 27 } });  // define 1.7V net
M4_18V = assign({ { 304, 28 } });  // define 1.8V net
M4_25V = assign({ { 304, 29 } });  // define 2.5V net
M4_33V = assign({ { 304, 30 } });  // define 3.3V net
M4_50V = assign({ { 304, 31 } });  // define 5.0V net
M4_70V = assign({ { 304, 32 } });  // define 7.0V net
M5_USERDV_M = assign({ { 305, 111 } }); // Define a net pair whose delta voltage follows UserDV (for M5)
tM5_USERDV = assign_text({ { 305, 112 } }, use_exploded_text = { { { "*" }, { "*" } } }); // Define the delta voltage of a net pair (for M5)
tM5_USERDV_TOP = assign_text({ { 305, 113 } }, use_exploded_text = { { { "*" }, { "*" } } }); // Define the delta voltage of a net pair at top level to overwrite UserDV tag with lower priority (for M5)
tM5V_HIGH = assign_text({ { 305, 8 } }, use_exploded_text = { { { "*" }, { "*" } } }); // define highest operation voltage 
tM5V_LOW = assign_text({ { 305, 9 } }, use_exploded_text = { { { "*" }, { "*" } } });  // define lowest operation voltage
tM5V_HIGH_TOP = assign_text({ { 305, 6 } }, use_exploded_text = { { { "*" }, { "*" } } }); // define highest operation voltage in top level to overwrite IP's voltage information
tM5V_LOW_TOP = assign_text({ { 305, 7 } }, use_exploded_text = { { { "*" }, { "*" } } }); // define lowest operation voltage in top level to overwrite IP's voltage information
M5V_SYNC = assign({ { 305, 3 } });  // define two nets are synchronous (High/Low at same time) 
M5_00V = assign({ { 305, 10 } });  // define 0.0V net
M5_01V = assign({ { 305, 11 } });  // define 0.1V net
M5_02V = assign({ { 305, 12 } });  // define 0.2V net
M5_03V = assign({ { 305, 13 } });  // define 0.3V net
M5_04V = assign({ { 305, 14 } });  // define 0.4V net
M5_05V = assign({ { 305, 15 } });  // define 0.5V net
M5_06V = assign({ { 305, 16 } });  // define 0.6V net
M5_07V = assign({ { 305, 17 } });  // define 0.7V net
M5_08V = assign({ { 305, 18 } });  // define 0.8V net
M5_09V = assign({ { 305, 19 } });  // define 0.9V net
M5_10V = assign({ { 305, 20 } });  // define 1.0V net
M5_11V = assign({ { 305, 21 } });  // define 1.1V net
M5_12V = assign({ { 305, 22 } });  // define 1.2V net
M5_13V = assign({ { 305, 23 } });  // define 1.3V net
M5_14V = assign({ { 305, 24 } });  // define 1.4V net
M5_15V = assign({ { 305, 25 } });  // define 1.5V net
M5_16V = assign({ { 305, 26 } });  // define 1.6V net
M5_17V = assign({ { 305, 27 } });  // define 1.7V net
M5_18V = assign({ { 305, 28 } });  // define 1.8V net
M5_25V = assign({ { 305, 29 } });  // define 2.5V net
M5_33V = assign({ { 305, 30 } });  // define 3.3V net
M5_50V = assign({ { 305, 31 } });  // define 5.0V net
M5_70V = assign({ { 305, 32 } });  // define 7.0V net
M6_USERDV_M = assign({ { 306, 111 } }); // Define a net pair whose delta voltage follows UserDV (for M6)
tM6_USERDV = assign_text({ { 306, 112 } }, use_exploded_text = { { { "*" }, { "*" } } }); // Define the delta voltage of a net pair (for M6)
tM6_USERDV_TOP = assign_text({ { 306, 113 } }, use_exploded_text = { { { "*" }, { "*" } } }); // Define the delta voltage of a net pair at top level to overwrite UserDV tag with lower priority (for M6)
tM6V_HIGH = assign_text({ { 306, 8 } }, use_exploded_text = { { { "*" }, { "*" } } }); // define highest operation voltage 
tM6V_LOW = assign_text({ { 306, 9 } }, use_exploded_text = { { { "*" }, { "*" } } });  // define lowest operation voltage
tM6V_HIGH_TOP = assign_text({ { 306, 6 } }, use_exploded_text = { { { "*" }, { "*" } } }); // define highest operation voltage in top level to overwrite IP's voltage information
tM6V_LOW_TOP = assign_text({ { 306, 7 } }, use_exploded_text = { { { "*" }, { "*" } } }); // define lowest operation voltage in top level to overwrite IP's voltage information
M6V_SYNC = assign({ { 306, 3 } });  // define two nets are synchronous (High/Low at same time) 
M6_00V = assign({ { 306, 10 } });  // define 0.0V net
M6_01V = assign({ { 306, 11 } });  // define 0.1V net
M6_02V = assign({ { 306, 12 } });  // define 0.2V net
M6_03V = assign({ { 306, 13 } });  // define 0.3V net
M6_04V = assign({ { 306, 14 } });  // define 0.4V net
M6_05V = assign({ { 306, 15 } });  // define 0.5V net
M6_06V = assign({ { 306, 16 } });  // define 0.6V net
M6_07V = assign({ { 306, 17 } });  // define 0.7V net
M6_08V = assign({ { 306, 18 } });  // define 0.8V net
M6_09V = assign({ { 306, 19 } });  // define 0.9V net
M6_10V = assign({ { 306, 20 } });  // define 1.0V net
M6_11V = assign({ { 306, 21 } });  // define 1.1V net
M6_12V = assign({ { 306, 22 } });  // define 1.2V net
M6_13V = assign({ { 306, 23 } });  // define 1.3V net
M6_14V = assign({ { 306, 24 } });  // define 1.4V net
M6_15V = assign({ { 306, 25 } });  // define 1.5V net
M6_16V = assign({ { 306, 26 } });  // define 1.6V net
M6_17V = assign({ { 306, 27 } });  // define 1.7V net
M6_18V = assign({ { 306, 28 } });  // define 1.8V net
M6_25V = assign({ { 306, 29 } });  // define 2.5V net
M6_33V = assign({ { 306, 30 } });  // define 3.3V net
M6_50V = assign({ { 306, 31 } });  // define 5.0V net
M6_70V = assign({ { 306, 32 } });  // define 7.0V net
M7_USERDV_M = assign({ { 307, 111 } }); // Define a net pair whose delta voltage follows UserDV (for M7)
tM7_USERDV = assign_text({ { 307, 112 } }, use_exploded_text = { { { "*" }, { "*" } } }); // Define the delta voltage of a net pair (for M7)
tM7_USERDV_TOP = assign_text({ { 307, 113 } }, use_exploded_text = { { { "*" }, { "*" } } }); // Define the delta voltage of a net pair at top level to overwrite UserDV tag with lower priority (for M7)
tM7V_HIGH = assign_text({ { 307, 8 } }, use_exploded_text = { { { "*" }, { "*" } } }); // define highest operation voltage 
tM7V_LOW = assign_text({ { 307, 9 } }, use_exploded_text = { { { "*" }, { "*" } } });  // define lowest operation voltage
tM7V_HIGH_TOP = assign_text({ { 307, 6 } }, use_exploded_text = { { { "*" }, { "*" } } }); // define highest operation voltage in top level to overwrite IP's voltage information
tM7V_LOW_TOP = assign_text({ { 307, 7 } }, use_exploded_text = { { { "*" }, { "*" } } }); // define lowest operation voltage in top level to overwrite IP's voltage information
M7V_SYNC = assign({ { 307, 3 } });  // define two nets are synchronous (High/Low at same time) 
M7_00V = assign({ { 307, 10 } });  // define 0.0V net
M7_01V = assign({ { 307, 11 } });  // define 0.1V net
M7_02V = assign({ { 307, 12 } });  // define 0.2V net
M7_03V = assign({ { 307, 13 } });  // define 0.3V net
M7_04V = assign({ { 307, 14 } });  // define 0.4V net
M7_05V = assign({ { 307, 15 } });  // define 0.5V net
M7_06V = assign({ { 307, 16 } });  // define 0.6V net
M7_07V = assign({ { 307, 17 } });  // define 0.7V net
M7_08V = assign({ { 307, 18 } });  // define 0.8V net
M7_09V = assign({ { 307, 19 } });  // define 0.9V net
M7_10V = assign({ { 307, 20 } });  // define 1.0V net
M7_11V = assign({ { 307, 21 } });  // define 1.1V net
M7_12V = assign({ { 307, 22 } });  // define 1.2V net
M7_13V = assign({ { 307, 23 } });  // define 1.3V net
M7_14V = assign({ { 307, 24 } });  // define 1.4V net
M7_15V = assign({ { 307, 25 } });  // define 1.5V net
M7_16V = assign({ { 307, 26 } });  // define 1.6V net
M7_17V = assign({ { 307, 27 } });  // define 1.7V net
M7_18V = assign({ { 307, 28 } });  // define 1.8V net
M7_25V = assign({ { 307, 29 } });  // define 2.5V net
M7_33V = assign({ { 307, 30 } });  // define 3.3V net
M7_50V = assign({ { 307, 31 } });  // define 5.0V net
M7_70V = assign({ { 307, 32 } });  // define 7.0V net
M8_USERDV_M = assign({ { 308, 111 } }); // Define a net pair whose delta voltage follows UserDV (for M8)
tM8_USERDV = assign_text({ { 308, 112 } }, use_exploded_text = { { { "*" }, { "*" } } }); // Define the delta voltage of a net pair (for M8)
tM8_USERDV_TOP = assign_text({ { 308, 113 } }, use_exploded_text = { { { "*" }, { "*" } } }); // Define the delta voltage of a net pair at top level to overwrite UserDV tag with lower priority (for M8)
tM8V_HIGH = assign_text({ { 308, 8 } }, use_exploded_text = { { { "*" }, { "*" } } }); // define highest operation voltage 
tM8V_LOW = assign_text({ { 308, 9 } }, use_exploded_text = { { { "*" }, { "*" } } });  // define lowest operation voltage
tM8V_HIGH_TOP = assign_text({ { 308, 6 } }, use_exploded_text = { { { "*" }, { "*" } } }); // define highest operation voltage in top level to overwrite IP's voltage information
tM8V_LOW_TOP = assign_text({ { 308, 7 } }, use_exploded_text = { { { "*" }, { "*" } } }); // define lowest operation voltage in top level to overwrite IP's voltage information
M8V_SYNC = assign({ { 308, 3 } });  // define two nets are synchronous (High/Low at same time) 
M8_00V = assign({ { 308, 10 } });  // define 0.0V net
M8_01V = assign({ { 308, 11 } });  // define 0.1V net
M8_02V = assign({ { 308, 12 } });  // define 0.2V net
M8_03V = assign({ { 308, 13 } });  // define 0.3V net
M8_04V = assign({ { 308, 14 } });  // define 0.4V net
M8_05V = assign({ { 308, 15 } });  // define 0.5V net
M8_06V = assign({ { 308, 16 } });  // define 0.6V net
M8_07V = assign({ { 308, 17 } });  // define 0.7V net
M8_08V = assign({ { 308, 18 } });  // define 0.8V net
M8_09V = assign({ { 308, 19 } });  // define 0.9V net
M8_10V = assign({ { 308, 20 } });  // define 1.0V net
M8_11V = assign({ { 308, 21 } });  // define 1.1V net
M8_12V = assign({ { 308, 22 } });  // define 1.2V net
M8_13V = assign({ { 308, 23 } });  // define 1.3V net
M8_14V = assign({ { 308, 24 } });  // define 1.4V net
M8_15V = assign({ { 308, 25 } });  // define 1.5V net
M8_16V = assign({ { 308, 26 } });  // define 1.6V net
M8_17V = assign({ { 308, 27 } });  // define 1.7V net
M8_18V = assign({ { 308, 28 } });  // define 1.8V net
M8_25V = assign({ { 308, 29 } });  // define 2.5V net
M8_33V = assign({ { 308, 30 } });  // define 3.3V net
M8_50V = assign({ { 308, 31 } });  // define 5.0V net
M8_70V = assign({ { 308, 32 } });  // define 7.0V net
M9_USERDV_M = assign({ { 309, 111 } }); // Define a net pair whose delta voltage follows UserDV (for M9)
tM9_USERDV = assign_text({ { 309, 112 } }, use_exploded_text = { { { "*" }, { "*" } } }); // Define the delta voltage of a net pair (for M9)
tM9_USERDV_TOP = assign_text({ { 309, 113 } }, use_exploded_text = { { { "*" }, { "*" } } }); // Define the delta voltage of a net pair at top level to overwrite UserDV tag with lower priority (for M9)
tM9V_HIGH = assign_text({ { 309, 8 } }, use_exploded_text = { { { "*" }, { "*" } } }); // define highest operation voltage 
tM9V_LOW = assign_text({ { 309, 9 } }, use_exploded_text = { { { "*" }, { "*" } } });  // define lowest operation voltage
tM9V_HIGH_TOP = assign_text({ { 309, 6 } }, use_exploded_text = { { { "*" }, { "*" } } }); // define highest operation voltage in top level to overwrite IP's voltage information
tM9V_LOW_TOP = assign_text({ { 309, 7 } }, use_exploded_text = { { { "*" }, { "*" } } }); // define lowest operation voltage in top level to overwrite IP's voltage information
M9V_SYNC = assign({ { 309, 3 } });  // define two nets are synchronous (High/Low at same time) 
M9_00V = assign({ { 309, 10 } });  // define 0.0V net
M9_01V = assign({ { 309, 11 } });  // define 0.1V net
M9_02V = assign({ { 309, 12 } });  // define 0.2V net
M9_03V = assign({ { 309, 13 } });  // define 0.3V net
M9_04V = assign({ { 309, 14 } });  // define 0.4V net
M9_05V = assign({ { 309, 15 } });  // define 0.5V net
M9_06V = assign({ { 309, 16 } });  // define 0.6V net
M9_07V = assign({ { 309, 17 } });  // define 0.7V net
M9_08V = assign({ { 309, 18 } });  // define 0.8V net
M9_09V = assign({ { 309, 19 } });  // define 0.9V net
M9_10V = assign({ { 309, 20 } });  // define 1.0V net
M9_11V = assign({ { 309, 21 } });  // define 1.1V net
M9_12V = assign({ { 309, 22 } });  // define 1.2V net
M9_13V = assign({ { 309, 23 } });  // define 1.3V net
M9_14V = assign({ { 309, 24 } });  // define 1.4V net
M9_15V = assign({ { 309, 25 } });  // define 1.5V net
M9_16V = assign({ { 309, 26 } });  // define 1.6V net
M9_17V = assign({ { 309, 27 } });  // define 1.7V net
M9_18V = assign({ { 309, 28 } });  // define 1.8V net
M9_25V = assign({ { 309, 29 } });  // define 2.5V net
M9_33V = assign({ { 309, 30 } });  // define 3.3V net
M9_50V = assign({ { 309, 31 } });  // define 5.0V net
M9_70V = assign({ { 309, 32 } });  // define 7.0V net
M10_USERDV_M = assign({ { 310, 111 } }); // Define a net pair whose delta voltage follows UserDV (for M10)
tM10_USERDV = assign_text({ { 310, 112 } }, use_exploded_text = { { { "*" }, { "*" } } }); // Define the delta voltage of a net pair (for M10)
tM10_USERDV_TOP = assign_text({ { 310, 113 } }, use_exploded_text = { { { "*" }, { "*" } } }); // Define the delta voltage of a net pair at top level to overwrite UserDV tag with lower priority (for M10)
tM10V_HIGH = assign_text({ { 310, 8 } }, use_exploded_text = { { { "*" }, { "*" } } }); // define highest operation voltage 
tM10V_LOW = assign_text({ { 310, 9 } }, use_exploded_text = { { { "*" }, { "*" } } });  // define lowest operation voltage
tM10V_HIGH_TOP = assign_text({ { 310, 6 } }, use_exploded_text = { { { "*" }, { "*" } } }); // define highest operation voltage in top level to overwrite IP's voltage information
tM10V_LOW_TOP = assign_text({ { 310, 7 } }, use_exploded_text = { { { "*" }, { "*" } } }); // define lowest operation voltage in top level to overwrite IP's voltage information
M10V_SYNC = assign({ { 310, 3 } });  // define two nets are synchronous (High/Low at same time) 
M10_00V = assign({ { 310, 10 } });  // define 0.0V net
M10_01V = assign({ { 310, 11 } });  // define 0.1V net
M10_02V = assign({ { 310, 12 } });  // define 0.2V net
M10_03V = assign({ { 310, 13 } });  // define 0.3V net
M10_04V = assign({ { 310, 14 } });  // define 0.4V net
M10_05V = assign({ { 310, 15 } });  // define 0.5V net
M10_06V = assign({ { 310, 16 } });  // define 0.6V net
M10_07V = assign({ { 310, 17 } });  // define 0.7V net
M10_08V = assign({ { 310, 18 } });  // define 0.8V net
M10_09V = assign({ { 310, 19 } });  // define 0.9V net
M10_10V = assign({ { 310, 20 } });  // define 1.0V net
M10_11V = assign({ { 310, 21 } });  // define 1.1V net
M10_12V = assign({ { 310, 22 } });  // define 1.2V net
M10_13V = assign({ { 310, 23 } });  // define 1.3V net
M10_14V = assign({ { 310, 24 } });  // define 1.4V net
M10_15V = assign({ { 310, 25 } });  // define 1.5V net
M10_16V = assign({ { 310, 26 } });  // define 1.6V net
M10_17V = assign({ { 310, 27 } });  // define 1.7V net
M10_18V = assign({ { 310, 28 } });  // define 1.8V net
M10_25V = assign({ { 310, 29 } });  // define 2.5V net
M10_33V = assign({ { 310, 30 } });  // define 3.3V net
M10_50V = assign({ { 310, 31 } });  // define 5.0V net
M10_70V = assign({ { 310, 32 } });  // define 7.0V net
M11_USERDV_M = assign({ { 311, 111 } }); // Define a net pair whose delta voltage follows UserDV (for M11)
tM11_USERDV = assign_text({ { 311, 112 } }, use_exploded_text = { { { "*" }, { "*" } } }); // Define the delta voltage of a net pair (for M11)
tM11_USERDV_TOP = assign_text({ { 311, 113 } }, use_exploded_text = { { { "*" }, { "*" } } }); // Define the delta voltage of a net pair at top level to overwrite UserDV tag with lower priority (for M11)
tM11V_HIGH = assign_text({ { 311, 8 } }, use_exploded_text = { { { "*" }, { "*" } } }); // define highest operation voltage 
tM11V_LOW = assign_text({ { 311, 9 } }, use_exploded_text = { { { "*" }, { "*" } } });  // define lowest operation voltage
tM11V_HIGH_TOP = assign_text({ { 311, 6 } }, use_exploded_text = { { { "*" }, { "*" } } }); // define highest operation voltage in top level to overwrite IP's voltage information
tM11V_LOW_TOP = assign_text({ { 311, 7 } }, use_exploded_text = { { { "*" }, { "*" } } }); // define lowest operation voltage in top level to overwrite IP's voltage information
M11V_SYNC = assign({ { 311, 3 } });  // define two nets are synchronous (High/Low at same time) 
M11_00V = assign({ { 311, 10 } });  // define 0.0V net
M11_01V = assign({ { 311, 11 } });  // define 0.1V net
M11_02V = assign({ { 311, 12 } });  // define 0.2V net
M11_03V = assign({ { 311, 13 } });  // define 0.3V net
M11_04V = assign({ { 311, 14 } });  // define 0.4V net
M11_05V = assign({ { 311, 15 } });  // define 0.5V net
M11_06V = assign({ { 311, 16 } });  // define 0.6V net
M11_07V = assign({ { 311, 17 } });  // define 0.7V net
M11_08V = assign({ { 311, 18 } });  // define 0.8V net
M11_09V = assign({ { 311, 19 } });  // define 0.9V net
M11_10V = assign({ { 311, 20 } });  // define 1.0V net
M11_11V = assign({ { 311, 21 } });  // define 1.1V net
M11_12V = assign({ { 311, 22 } });  // define 1.2V net
M11_13V = assign({ { 311, 23 } });  // define 1.3V net
M11_14V = assign({ { 311, 24 } });  // define 1.4V net
M11_15V = assign({ { 311, 25 } });  // define 1.5V net
M11_16V = assign({ { 311, 26 } });  // define 1.6V net
M11_17V = assign({ { 311, 27 } });  // define 1.7V net
M11_18V = assign({ { 311, 28 } });  // define 1.8V net
M11_25V = assign({ { 311, 29 } });  // define 2.5V net
M11_33V = assign({ { 311, 30 } });  // define 3.3V net
M11_50V = assign({ { 311, 31 } });  // define 5.0V net
M11_70V = assign({ { 311, 32 } });  // define 7.0V net
M12_USERDV_M = assign({ { 312, 111 } }); // Define a net pair whose delta voltage follows UserDV (for M12)
tM12_USERDV = assign_text({ { 312, 112 } }, use_exploded_text = { { { "*" }, { "*" } } }); // Define the delta voltage of a net pair (for M12)
tM12_USERDV_TOP = assign_text({ { 312, 113 } }, use_exploded_text = { { { "*" }, { "*" } } }); // Define the delta voltage of a net pair at top level to overwrite UserDV tag with lower priority (for M12)
tM12V_HIGH = assign_text({ { 312, 8 } }, use_exploded_text = { { { "*" }, { "*" } } }); // define highest operation voltage 
tM12V_LOW = assign_text({ { 312, 9 } }, use_exploded_text = { { { "*" }, { "*" } } });  // define lowest operation voltage
tM12V_HIGH_TOP = assign_text({ { 312, 6 } }, use_exploded_text = { { { "*" }, { "*" } } }); // define highest operation voltage in top level to overwrite IP's voltage information
tM12V_LOW_TOP = assign_text({ { 312, 7 } }, use_exploded_text = { { { "*" }, { "*" } } }); // define lowest operation voltage in top level to overwrite IP's voltage information
M12V_SYNC = assign({ { 312, 3 } });  // define two nets are synchronous (High/Low at same time) 
M12_00V = assign({ { 312, 10 } });  // define 0.0V net
M12_01V = assign({ { 312, 11 } });  // define 0.1V net
M12_02V = assign({ { 312, 12 } });  // define 0.2V net
M12_03V = assign({ { 312, 13 } });  // define 0.3V net
M12_04V = assign({ { 312, 14 } });  // define 0.4V net
M12_05V = assign({ { 312, 15 } });  // define 0.5V net
M12_06V = assign({ { 312, 16 } });  // define 0.6V net
M12_07V = assign({ { 312, 17 } });  // define 0.7V net
M12_08V = assign({ { 312, 18 } });  // define 0.8V net
M12_09V = assign({ { 312, 19 } });  // define 0.9V net
M12_10V = assign({ { 312, 20 } });  // define 1.0V net
M12_11V = assign({ { 312, 21 } });  // define 1.1V net
M12_12V = assign({ { 312, 22 } });  // define 1.2V net
M12_13V = assign({ { 312, 23 } });  // define 1.3V net
M12_14V = assign({ { 312, 24 } });  // define 1.4V net
M12_15V = assign({ { 312, 25 } });  // define 1.5V net
M12_16V = assign({ { 312, 26 } });  // define 1.6V net
M12_17V = assign({ { 312, 27 } });  // define 1.7V net
M12_18V = assign({ { 312, 28 } });  // define 1.8V net
M12_25V = assign({ { 312, 29 } });  // define 2.5V net
M12_33V = assign({ { 312, 30 } });  // define 3.3V net
M12_50V = assign({ { 312, 31 } });  // define 5.0V net
M12_70V = assign({ { 312, 32 } });  // define 7.0V net
M13_USERDV_M = assign({ { 313, 111 } }); // Define a net pair whose delta voltage follows UserDV (for M13)
tM13_USERDV = assign_text({ { 313, 112 } }, use_exploded_text = { { { "*" }, { "*" } } }); // Define the delta voltage of a net pair (for M13)
tM13_USERDV_TOP = assign_text({ { 313, 113 } }, use_exploded_text = { { { "*" }, { "*" } } }); // Define the delta voltage of a net pair at top level to overwrite UserDV tag with lower priority (for M13)
tM13V_HIGH = assign_text({ { 313, 8 } }, use_exploded_text = { { { "*" }, { "*" } } }); // define highest operation voltage 
tM13V_LOW = assign_text({ { 313, 9 } }, use_exploded_text = { { { "*" }, { "*" } } });  // define lowest operation voltage
tM13V_HIGH_TOP = assign_text({ { 313, 6 } }, use_exploded_text = { { { "*" }, { "*" } } }); // define highest operation voltage in top level to overwrite IP's voltage information
tM13V_LOW_TOP = assign_text({ { 313, 7 } }, use_exploded_text = { { { "*" }, { "*" } } }); // define lowest operation voltage in top level to overwrite IP's voltage information
M13V_SYNC = assign({ { 313, 3 } });  // define two nets are synchronous (High/Low at same time) 
M13_00V = assign({ { 313, 10 } });  // define 0.0V net
M13_01V = assign({ { 313, 11 } });  // define 0.1V net
M13_02V = assign({ { 313, 12 } });  // define 0.2V net
M13_03V = assign({ { 313, 13 } });  // define 0.3V net
M13_04V = assign({ { 313, 14 } });  // define 0.4V net
M13_05V = assign({ { 313, 15 } });  // define 0.5V net
M13_06V = assign({ { 313, 16 } });  // define 0.6V net
M13_07V = assign({ { 313, 17 } });  // define 0.7V net
M13_08V = assign({ { 313, 18 } });  // define 0.8V net
M13_09V = assign({ { 313, 19 } });  // define 0.9V net
M13_10V = assign({ { 313, 20 } });  // define 1.0V net
M13_11V = assign({ { 313, 21 } });  // define 1.1V net
M13_12V = assign({ { 313, 22 } });  // define 1.2V net
M13_13V = assign({ { 313, 23 } });  // define 1.3V net
M13_14V = assign({ { 313, 24 } });  // define 1.4V net
M13_15V = assign({ { 313, 25 } });  // define 1.5V net
M13_16V = assign({ { 313, 26 } });  // define 1.6V net
M13_17V = assign({ { 313, 27 } });  // define 1.7V net
M13_18V = assign({ { 313, 28 } });  // define 1.8V net
M13_25V = assign({ { 313, 29 } });  // define 2.5V net
M13_33V = assign({ { 313, 30 } });  // define 3.3V net
M13_50V = assign({ { 313, 31 } });  // define 5.0V net
M13_70V = assign({ { 313, 32 } });  // define 7.0V net
M14_USERDV_M = assign({ { 314, 111 } }); // Define a net pair whose delta voltage follows UserDV (for M14)
tM14_USERDV = assign_text({ { 314, 112 } }, use_exploded_text = { { { "*" }, { "*" } } }); // Define the delta voltage of a net pair (for M14)
tM14_USERDV_TOP = assign_text({ { 314, 113 } }, use_exploded_text = { { { "*" }, { "*" } } }); // Define the delta voltage of a net pair at top level to overwrite UserDV tag with lower priority (for M14)
tM14V_HIGH = assign_text({ { 314, 8 } }, use_exploded_text = { { { "*" }, { "*" } } }); // define highest operation voltage 
tM14V_LOW = assign_text({ { 314, 9 } }, use_exploded_text = { { { "*" }, { "*" } } });  // define lowest operation voltage
tM14V_HIGH_TOP = assign_text({ { 314, 6 } }, use_exploded_text = { { { "*" }, { "*" } } }); // define highest operation voltage in top level to overwrite IP's voltage information
tM14V_LOW_TOP = assign_text({ { 314, 7 } }, use_exploded_text = { { { "*" }, { "*" } } }); // define lowest operation voltage in top level to overwrite IP's voltage information
M14V_SYNC = assign({ { 314, 3 } });  // define two nets are synchronous (High/Low at same time) 
M14_00V = assign({ { 314, 10 } });  // define 0.0V net
M14_01V = assign({ { 314, 11 } });  // define 0.1V net
M14_02V = assign({ { 314, 12 } });  // define 0.2V net
M14_03V = assign({ { 314, 13 } });  // define 0.3V net
M14_04V = assign({ { 314, 14 } });  // define 0.4V net
M14_05V = assign({ { 314, 15 } });  // define 0.5V net
M14_06V = assign({ { 314, 16 } });  // define 0.6V net
M14_07V = assign({ { 314, 17 } });  // define 0.7V net
M14_08V = assign({ { 314, 18 } });  // define 0.8V net
M14_09V = assign({ { 314, 19 } });  // define 0.9V net
M14_10V = assign({ { 314, 20 } });  // define 1.0V net
M14_11V = assign({ { 314, 21 } });  // define 1.1V net
M14_12V = assign({ { 314, 22 } });  // define 1.2V net
M14_13V = assign({ { 314, 23 } });  // define 1.3V net
M14_14V = assign({ { 314, 24 } });  // define 1.4V net
M14_15V = assign({ { 314, 25 } });  // define 1.5V net
M14_16V = assign({ { 314, 26 } });  // define 1.6V net
M14_17V = assign({ { 314, 27 } });  // define 1.7V net
M14_18V = assign({ { 314, 28 } });  // define 1.8V net
M14_25V = assign({ { 314, 29 } });  // define 2.5V net
M14_33V = assign({ { 314, 30 } });  // define 3.3V net
M14_50V = assign({ { 314, 31 } });  // define 5.0V net
M14_70V = assign({ { 314, 32 } });  // define 7.0V net
M15_USERDV_M = assign({ { 315, 111 } }); // Define a net pair whose delta voltage follows UserDV (for M15)
tM15_USERDV = assign_text({ { 315, 112 } }, use_exploded_text = { { { "*" }, { "*" } } }); // Define the delta voltage of a net pair (for M15)
tM15_USERDV_TOP = assign_text({ { 315, 113 } }, use_exploded_text = { { { "*" }, { "*" } } }); // Define the delta voltage of a net pair at top level to overwrite UserDV tag with lower priority (for M15)
tM15V_HIGH = assign_text({ { 315, 8 } }, use_exploded_text = { { { "*" }, { "*" } } }); // define highest operation voltage 
tM15V_LOW = assign_text({ { 315, 9 } }, use_exploded_text = { { { "*" }, { "*" } } });  // define lowest operation voltage
tM15V_HIGH_TOP = assign_text({ { 315, 6 } }, use_exploded_text = { { { "*" }, { "*" } } }); // define highest operation voltage in top level to overwrite IP's voltage information
tM15V_LOW_TOP = assign_text({ { 315, 7 } }, use_exploded_text = { { { "*" }, { "*" } } }); // define lowest operation voltage in top level to overwrite IP's voltage information
M15V_SYNC = assign({ { 315, 3 } });  // define two nets are synchronous (High/Low at same time) 
M15_00V = assign({ { 315, 10 } });  // define 0.0V net
M15_01V = assign({ { 315, 11 } });  // define 0.1V net
M15_02V = assign({ { 315, 12 } });  // define 0.2V net
M15_03V = assign({ { 315, 13 } });  // define 0.3V net
M15_04V = assign({ { 315, 14 } });  // define 0.4V net
M15_05V = assign({ { 315, 15 } });  // define 0.5V net
M15_06V = assign({ { 315, 16 } });  // define 0.6V net
M15_07V = assign({ { 315, 17 } });  // define 0.7V net
M15_08V = assign({ { 315, 18 } });  // define 0.8V net
M15_09V = assign({ { 315, 19 } });  // define 0.9V net
M15_10V = assign({ { 315, 20 } });  // define 1.0V net
M15_11V = assign({ { 315, 21 } });  // define 1.1V net
M15_12V = assign({ { 315, 22 } });  // define 1.2V net
M15_13V = assign({ { 315, 23 } });  // define 1.3V net
M15_14V = assign({ { 315, 24 } });  // define 1.4V net
M15_15V = assign({ { 315, 25 } });  // define 1.5V net
M15_16V = assign({ { 315, 26 } });  // define 1.6V net
M15_17V = assign({ { 315, 27 } });  // define 1.7V net
M15_18V = assign({ { 315, 28 } });  // define 1.8V net
M15_25V = assign({ { 315, 29 } });  // define 2.5V net
M15_33V = assign({ { 315, 30 } });  // define 3.3V net
M15_50V = assign({ { 315, 31 } });  // define 5.0V net
M15_70V = assign({ { 315, 32 } });  // define 7.0V net
M16_USERDV_M = assign({ { 316, 111 } }); // Define a net pair whose delta voltage follows UserDV (for M16)
tM16_USERDV = assign_text({ { 316, 112 } }, use_exploded_text = { { { "*" }, { "*" } } }); // Define the delta voltage of a net pair (for M16)
tM16_USERDV_TOP = assign_text({ { 316, 113 } }, use_exploded_text = { { { "*" }, { "*" } } }); // Define the delta voltage of a net pair at top level to overwrite UserDV tag with lower priority (for M16)
tM16V_HIGH = assign_text({ { 316, 8 } }, use_exploded_text = { { { "*" }, { "*" } } }); // define highest operation voltage 
tM16V_LOW = assign_text({ { 316, 9 } }, use_exploded_text = { { { "*" }, { "*" } } });  // define lowest operation voltage
tM16V_HIGH_TOP = assign_text({ { 316, 6 } }, use_exploded_text = { { { "*" }, { "*" } } }); // define highest operation voltage in top level to overwrite IP's voltage information
tM16V_LOW_TOP = assign_text({ { 316, 7 } }, use_exploded_text = { { { "*" }, { "*" } } }); // define lowest operation voltage in top level to overwrite IP's voltage information
M16V_SYNC = assign({ { 316, 3 } });  // define two nets are synchronous (High/Low at same time) 
M16_00V = assign({ { 316, 10 } });  // define 0.0V net
M16_01V = assign({ { 316, 11 } });  // define 0.1V net
M16_02V = assign({ { 316, 12 } });  // define 0.2V net
M16_03V = assign({ { 316, 13 } });  // define 0.3V net
M16_04V = assign({ { 316, 14 } });  // define 0.4V net
M16_05V = assign({ { 316, 15 } });  // define 0.5V net
M16_06V = assign({ { 316, 16 } });  // define 0.6V net
M16_07V = assign({ { 316, 17 } });  // define 0.7V net
M16_08V = assign({ { 316, 18 } });  // define 0.8V net
M16_09V = assign({ { 316, 19 } });  // define 0.9V net
M16_10V = assign({ { 316, 20 } });  // define 1.0V net
M16_11V = assign({ { 316, 21 } });  // define 1.1V net
M16_12V = assign({ { 316, 22 } });  // define 1.2V net
M16_13V = assign({ { 316, 23 } });  // define 1.3V net
M16_14V = assign({ { 316, 24 } });  // define 1.4V net
M16_15V = assign({ { 316, 25 } });  // define 1.5V net
M16_16V = assign({ { 316, 26 } });  // define 1.6V net
M16_17V = assign({ { 316, 27 } });  // define 1.7V net
M16_18V = assign({ { 316, 28 } });  // define 1.8V net
M16_25V = assign({ { 316, 29 } });  // define 2.5V net
M16_33V = assign({ { 316, 30 } });  // define 3.3V net
M16_50V = assign({ { 316, 31 } });  // define 5.0V net
M16_70V = assign({ { 316, 32 } });  // define 7.0V net
M17_USERDV_M = assign({ { 317, 111 } }); // Define a net pair whose delta voltage follows UserDV (for M17)
tM17_USERDV = assign_text({ { 317, 112 } }, use_exploded_text = { { { "*" }, { "*" } } }); // Define the delta voltage of a net pair (for M17)
tM17_USERDV_TOP = assign_text({ { 317, 113 } }, use_exploded_text = { { { "*" }, { "*" } } }); // Define the delta voltage of a net pair at top level to overwrite UserDV tag with lower priority (for M17)
tM17V_HIGH = assign_text({ { 317, 8 } }, use_exploded_text = { { { "*" }, { "*" } } }); // define highest operation voltage 
tM17V_LOW = assign_text({ { 317, 9 } }, use_exploded_text = { { { "*" }, { "*" } } });  // define lowest operation voltage
tM17V_HIGH_TOP = assign_text({ { 317, 6 } }, use_exploded_text = { { { "*" }, { "*" } } }); // define highest operation voltage in top level to overwrite IP's voltage information
tM17V_LOW_TOP = assign_text({ { 317, 7 } }, use_exploded_text = { { { "*" }, { "*" } } }); // define lowest operation voltage in top level to overwrite IP's voltage information
M17V_SYNC = assign({ { 317, 3 } });  // define two nets are synchronous (High/Low at same time) 
M17_00V = assign({ { 317, 10 } });  // define 0.0V net
M17_01V = assign({ { 317, 11 } });  // define 0.1V net
M17_02V = assign({ { 317, 12 } });  // define 0.2V net
M17_03V = assign({ { 317, 13 } });  // define 0.3V net
M17_04V = assign({ { 317, 14 } });  // define 0.4V net
M17_05V = assign({ { 317, 15 } });  // define 0.5V net
M17_06V = assign({ { 317, 16 } });  // define 0.6V net
M17_07V = assign({ { 317, 17 } });  // define 0.7V net
M17_08V = assign({ { 317, 18 } });  // define 0.8V net
M17_09V = assign({ { 317, 19 } });  // define 0.9V net
M17_10V = assign({ { 317, 20 } });  // define 1.0V net
M17_11V = assign({ { 317, 21 } });  // define 1.1V net
M17_12V = assign({ { 317, 22 } });  // define 1.2V net
M17_13V = assign({ { 317, 23 } });  // define 1.3V net
M17_14V = assign({ { 317, 24 } });  // define 1.4V net
M17_15V = assign({ { 317, 25 } });  // define 1.5V net
M17_16V = assign({ { 317, 26 } });  // define 1.6V net
M17_17V = assign({ { 317, 27 } });  // define 1.7V net
M17_18V = assign({ { 317, 28 } });  // define 1.8V net
M17_25V = assign({ { 317, 29 } });  // define 2.5V net
M17_33V = assign({ { 317, 30 } });  // define 3.3V net
M17_50V = assign({ { 317, 31 } });  // define 5.0V net
M17_70V = assign({ { 317, 32 } });  // define 7.0V net
M18_USERDV_M = assign({ { 318, 111 } }); // Define a net pair whose delta voltage follows UserDV (for M18)
tM18_USERDV = assign_text({ { 318, 112 } }, use_exploded_text = { { { "*" }, { "*" } } }); // Define the delta voltage of a net pair (for M18)
tM18_USERDV_TOP = assign_text({ { 318, 113 } }, use_exploded_text = { { { "*" }, { "*" } } }); // Define the delta voltage of a net pair at top level to overwrite UserDV tag with lower priority (for M18)
tM18V_HIGH = assign_text({ { 318, 8 } }, use_exploded_text = { { { "*" }, { "*" } } }); // define highest operation voltage 
tM18V_LOW = assign_text({ { 318, 9 } }, use_exploded_text = { { { "*" }, { "*" } } });  // define lowest operation voltage
tM18V_HIGH_TOP = assign_text({ { 318, 6 } }, use_exploded_text = { { { "*" }, { "*" } } }); // define highest operation voltage in top level to overwrite IP's voltage information
tM18V_LOW_TOP = assign_text({ { 318, 7 } }, use_exploded_text = { { { "*" }, { "*" } } }); // define lowest operation voltage in top level to overwrite IP's voltage information
M18V_SYNC = assign({ { 318, 3 } });  // define two nets are synchronous (High/Low at same time) 
M18_00V = assign({ { 318, 10 } });  // define 0.0V net
M18_01V = assign({ { 318, 11 } });  // define 0.1V net
M18_02V = assign({ { 318, 12 } });  // define 0.2V net
M18_03V = assign({ { 318, 13 } });  // define 0.3V net
M18_04V = assign({ { 318, 14 } });  // define 0.4V net
M18_05V = assign({ { 318, 15 } });  // define 0.5V net
M18_06V = assign({ { 318, 16 } });  // define 0.6V net
M18_07V = assign({ { 318, 17 } });  // define 0.7V net
M18_08V = assign({ { 318, 18 } });  // define 0.8V net
M18_09V = assign({ { 318, 19 } });  // define 0.9V net
M18_10V = assign({ { 318, 20 } });  // define 1.0V net
M18_11V = assign({ { 318, 21 } });  // define 1.1V net
M18_12V = assign({ { 318, 22 } });  // define 1.2V net
M18_13V = assign({ { 318, 23 } });  // define 1.3V net
M18_14V = assign({ { 318, 24 } });  // define 1.4V net
M18_15V = assign({ { 318, 25 } });  // define 1.5V net
M18_16V = assign({ { 318, 26 } });  // define 1.6V net
M18_17V = assign({ { 318, 27 } });  // define 1.7V net
M18_18V = assign({ { 318, 28 } });  // define 1.8V net
M18_25V = assign({ { 318, 29 } });  // define 2.5V net
M18_33V = assign({ { 318, 30 } });  // define 3.3V net
M18_50V = assign({ { 318, 31 } });  // define 5.0V net
M18_70V = assign({ { 318, 32 } });  // define 7.0V net
M19_USERDV_M = assign({ { 319, 111 } }); // Define a net pair whose delta voltage follows UserDV (for M19)
tM19_USERDV = assign_text({ { 319, 112 } }, use_exploded_text = { { { "*" }, { "*" } } }); // Define the delta voltage of a net pair (for M19)
tM19_USERDV_TOP = assign_text({ { 319, 113 } }, use_exploded_text = { { { "*" }, { "*" } } }); // Define the delta voltage of a net pair at top level to overwrite UserDV tag with lower priority (for M19)
tM19V_HIGH = assign_text({ { 319, 8 } }, use_exploded_text = { { { "*" }, { "*" } } }); // define highest operation voltage 
tM19V_LOW = assign_text({ { 319, 9 } }, use_exploded_text = { { { "*" }, { "*" } } });  // define lowest operation voltage
tM19V_HIGH_TOP = assign_text({ { 319, 6 } }, use_exploded_text = { { { "*" }, { "*" } } }); // define highest operation voltage in top level to overwrite IP's voltage information
tM19V_LOW_TOP = assign_text({ { 319, 7 } }, use_exploded_text = { { { "*" }, { "*" } } }); // define lowest operation voltage in top level to overwrite IP's voltage information
M19V_SYNC = assign({ { 319, 3 } });  // define two nets are synchronous (High/Low at same time) 
M19_00V = assign({ { 319, 10 } });  // define 0.0V net
M19_01V = assign({ { 319, 11 } });  // define 0.1V net
M19_02V = assign({ { 319, 12 } });  // define 0.2V net
M19_03V = assign({ { 319, 13 } });  // define 0.3V net
M19_04V = assign({ { 319, 14 } });  // define 0.4V net
M19_05V = assign({ { 319, 15 } });  // define 0.5V net
M19_06V = assign({ { 319, 16 } });  // define 0.6V net
M19_07V = assign({ { 319, 17 } });  // define 0.7V net
M19_08V = assign({ { 319, 18 } });  // define 0.8V net
M19_09V = assign({ { 319, 19 } });  // define 0.9V net
M19_10V = assign({ { 319, 20 } });  // define 1.0V net
M19_11V = assign({ { 319, 21 } });  // define 1.1V net
M19_12V = assign({ { 319, 22 } });  // define 1.2V net
M19_13V = assign({ { 319, 23 } });  // define 1.3V net
M19_14V = assign({ { 319, 24 } });  // define 1.4V net
M19_15V = assign({ { 319, 25 } });  // define 1.5V net
M19_16V = assign({ { 319, 26 } });  // define 1.6V net
M19_17V = assign({ { 319, 27 } });  // define 1.7V net
M19_18V = assign({ { 319, 28 } });  // define 1.8V net
M19_25V = assign({ { 319, 29 } });  // define 2.5V net
M19_33V = assign({ { 319, 30 } });  // define 3.3V net
M19_50V = assign({ { 319, 31 } });  // define 5.0V net
M19_70V = assign({ { 319, 32 } });  // define 7.0V net
/* define highest operation voltage  */
tCU_RDLV_HIGH = assign_text({ { 73, 8 } }, use_exploded_text = { { { "*" }, { "*" } } });
/* define lowest operation voltage  */
tCU_RDLV_LOW = assign_text({ { 73, 9 } }, use_exploded_text = { { { "*" }, { "*" } } });
/* define highest operation voltage in top level to overwrite IP's voltage information */
tCU_RDLV_HIGH_TOP = assign_text({ { 73, 6 } }, use_exploded_text = { { { "*" }, { "*" } } });
/* define lowest operation voltage in top level to overwrite IP's voltage information */
tCU_RDLV_LOW_TOP = assign_text({ { 73, 7 } }, use_exploded_text = { { { "*" }, { "*" } } });
/* define two nets are synchronous (High/Low at same time) */
CU_RDLV_SYNC = assign({ { 73, 3 } }); 
/* Define a net pair whose delta voltage follows UserDV (for AP) */
CU_RDL_USERDV_M = assign({ { 73, 111 } }); 
/* Define the delta voltage of a net pair (for AP) */
tCU_RDL_USERDV = assign_text({ { 73, 112 } }, use_exploded_text = { { { "*" }, { "*" } } });
/* Define the delta voltage of a net pair at top level to overwrite UserDV tag with lower priority (for AP) */
tCU_RDL_USERDV_TOP = assign_text({ { 73, 113 } }, use_exploded_text = { { { "*" }, { "*" } } });
/* define RDL highest operating voltage on a net by text */ 
/*  Dummy AP metal layer for dummy pattern */
AP_DUMMY    = assign({ { 74, 1 } });
/* define highest operation voltage  */
tAPV_HIGH     = assign_text({ { 74, 8 } }, use_exploded_text = { { { "*" }, { "*" } } });
/* define lowest operation voltage */
tAPV_LOW      = assign_text({ { 74, 9 } }, use_exploded_text = { { { "*" }, { "*" } } });
/* define highest operation voltage in top level to overwrite IP's voltage information */
tAPV_HIGH_TOP = assign_text({ { 74, 6 } }, use_exploded_text = { { { "*" }, { "*" } } });
/* define lowest operation voltage in top level to overwrite IP's voltage information */
tAPV_LOW_TOP  = assign_text({ { 74, 7 } }, use_exploded_text = { { { "*" }, { "*" } } });
/* define two nets are synchronous (High/Low at same time)  */
APV_SYNC     = assign({ { 74, 3 } }); 
/* Define a net pair whose delta voltage follows UserDV (for AP)  */
AP_USERDV_M   = assign({ { 74, 111 } }); 
/* Define the delta voltage of a net pair (for AP) */
tAP_USERDV     = assign_text({ { 74, 112 } }, use_exploded_text = { { { "*" }, { "*" } } });
/* Define the delta voltage of a net pair at top level to overwrite UserDV tag with lower priority (for AP) */
tAP_USERDV_TOP = assign_text({ { 74, 113 } }, use_exploded_text = { { { "*" }, { "*" } } });
/* For CM0 utility used, internal waive RT0EXCL region */
RT0EXCL   = assign({ { 150, 130 } }); 
/* Cut M0_CA */
CM0A_MAIN = assign({ { 430, 150 } }); 
/* Cut M0_CB */
CM0B_MAIN = assign({ { 430, 155 } }); 
/* Dummy Cut M0_CA */
DCM0A     = assign({ { 530, 150 } }); 
/* Dummy Cut M0_CB */
DCM0B     = assign({ { 530, 155 } }); 
/* CM0 horizontal merge Blocking Layer */
BCM0H     = assign({ { 430, 100 } }); 
/* CM0 horizontal merge Blocking Layer */
BCM0V     = assign({ { 430, 110 } }); 



M0_BASE = assign({ { 30, 150 } });             
M0_MAIN_CA = assign({ { 30, 151 } });
M0_MAIN_CB = assign({ { 30, 152 } });
DM0_O_CA = assign({ { 330, 151 } }, layer_intent = { LAYER_INTENT_FILL });
DM0_O_CB = assign({ { 330, 152 } }, layer_intent = { LAYER_INTENT_FILL });
DM0_CA  = assign({ { 330, 161 } }, layer_intent = { LAYER_INTENT_FILL });
DM0_CB = assign({ { 330, 162 } }, layer_intent = { LAYER_INTENT_FILL });


M1_MAIN = assign({ { 31, 420 } });
DM1_O = assign({ { 331, 420 } }, layer_intent = { LAYER_INTENT_FILL });
DM1  = assign({ { 331, 430 } }, layer_intent = { LAYER_INTENT_FILL });


M2_BASE_H = assign({ { 32, 200 } });
M2_MAIN_CA_H = assign({ { 32, 201 } });
M2_MAIN_CB_H = assign({ { 32, 202 } });
DM2_O_CA_H = assign({ { 332, 201 } }, layer_intent = { LAYER_INTENT_FILL });
DM2_O_CB_H = assign({ { 332, 202 } }, layer_intent = { LAYER_INTENT_FILL });
DM2_CA_H = assign({ { 332, 211 } }, layer_intent = { LAYER_INTENT_FILL });
DM2_CB_H = assign({ { 332, 212 } }, layer_intent = { LAYER_INTENT_FILL });
M2_BASE_V = assign({ { 32, 220 } });
M2_MAIN_CA_V = assign({ { 32, 221 } });
M2_MAIN_CB_V = assign({ { 32, 222 } });
DM2_O_CA_V = assign({ { 332, 221 } }, layer_intent = { LAYER_INTENT_FILL });
DM2_O_CB_V = assign({ { 332, 222 } }, layer_intent = { LAYER_INTENT_FILL });
DM2_CA_V = assign({ { 332, 231 } }, layer_intent = { LAYER_INTENT_FILL });
DM2_CB_V = assign({ { 332, 232 } }, layer_intent = { LAYER_INTENT_FILL });


M3_MAIN_H = assign({ { 33, 250 } });
DM3_O_H = assign({ { 333, 250 } }, layer_intent = { LAYER_INTENT_FILL });
DM3_H = assign({ { 333, 260 } }, layer_intent = { LAYER_INTENT_FILL });
M3_MAIN_V = assign({ { 33, 270 } });
DM3_O_V = assign({ { 333, 270 } }, layer_intent = { LAYER_INTENT_FILL });
DM3_V = assign({ { 333, 280 } }, layer_intent = { LAYER_INTENT_FILL });


M4_MAIN_H = assign({ { 34, 300 } });
DM4_O_H = assign({ { 334, 300 } }, layer_intent = { LAYER_INTENT_FILL });
DM4_H = assign({ { 334, 310 } }, layer_intent = { LAYER_INTENT_FILL });
M4_MAIN_V = assign({ { 34, 320 } });
DM4_O_V = assign({ { 334, 320 } }, layer_intent = { LAYER_INTENT_FILL });
DM4_V = assign({ { 334, 330 } }, layer_intent = { LAYER_INTENT_FILL });


M5_BASE_H = assign({ { 35, 350 } });
M5_MAIN_CA_H = assign({ { 35, 351 } });
M5_MAIN_CB_H = assign({ { 35, 352 } });
DM5_O_CA_H = assign({ { 335, 351 } }, layer_intent = { LAYER_INTENT_FILL });
DM5_O_CB_H = assign({ { 335, 352 } }, layer_intent = { LAYER_INTENT_FILL });
DM5_CA_H = assign({ { 335, 361 } }, layer_intent = { LAYER_INTENT_FILL });
DM5_CB_H = assign({ { 335, 362 } }, layer_intent = { LAYER_INTENT_FILL });
M5_BASE_V = assign({ { 35, 370 } });
M5_MAIN_CA_V = assign({ { 35, 371 } });
M5_MAIN_CB_V = assign({ { 35, 372 } });
DM5_O_CA_V = assign({ { 335, 371 } }, layer_intent = { LAYER_INTENT_FILL });
DM5_O_CB_V = assign({ { 335, 372 } }, layer_intent = { LAYER_INTENT_FILL });
DM5_CA_V = assign({ { 335, 381 } }, layer_intent = { LAYER_INTENT_FILL });
DM5_CB_V = assign({ { 335, 382 } }, layer_intent = { LAYER_INTENT_FILL });


M6_MAIN_H = assign({ { 36, 950 } });
DM6_O_H = assign({ { 336, 950 } }, layer_intent = { LAYER_INTENT_FILL });
DM6_H = assign({ { 336, 955 } }, layer_intent = { LAYER_INTENT_FILL });
M6_MAIN_V = assign({ { 36, 960 } });
DM6_O_V = assign({ { 336, 960 } }, layer_intent = { LAYER_INTENT_FILL });
DM6_V = assign({ { 336, 965 } }, layer_intent = { LAYER_INTENT_FILL });


M7_MAIN_H = assign({ { 37, 800 } });
DM7_O_H = assign({ { 337, 800 } }, layer_intent = { LAYER_INTENT_FILL });
DM7_H = assign({ { 337, 805 } }, layer_intent = { LAYER_INTENT_FILL });
M7_MAIN_V = assign({ { 37, 810 } });
DM7_O_V = assign({ { 337, 810 } }, layer_intent = { LAYER_INTENT_FILL });
DM7_V = assign({ { 337, 815 } }, layer_intent = { LAYER_INTENT_FILL });


M8_MAIN_H = assign({ { 38, 970 } });
DM8_O_H = assign({ { 338, 970 } }, layer_intent = { LAYER_INTENT_FILL });
DM8_H = assign({ { 338, 975 } }, layer_intent = { LAYER_INTENT_FILL });
M8_MAIN_V = assign({ { 38, 980 } });
DM8_O_V = assign({ { 338, 980 } }, layer_intent = { LAYER_INTENT_FILL });
DM8_V = assign({ { 338, 985 } }, layer_intent = { LAYER_INTENT_FILL });


M9_MAIN_H = assign({ { 39, 970 } });
DM9_O_H = assign({ { 339, 970 } }, layer_intent = { LAYER_INTENT_FILL });
DM9_H = assign({ { 339, 975 } }, layer_intent = { LAYER_INTENT_FILL });
M9_MAIN_V = assign({ { 39, 980 } });
DM9_O_V = assign({ { 339, 980 } }, layer_intent = { LAYER_INTENT_FILL });
DM9_V = assign({ { 339, 985 } }, layer_intent = { LAYER_INTENT_FILL });


M10_MAIN_H = assign({ { 40, 970 } });
DM10_O_H = assign({ { 340, 970 } }, layer_intent = { LAYER_INTENT_FILL });
DM10_H = assign({ { 340, 975 } }, layer_intent = { LAYER_INTENT_FILL });
M10_MAIN_V = assign({ { 40, 980 } });
DM10_O_V = assign({ { 340, 980 } }, layer_intent = { LAYER_INTENT_FILL });
DM10_V = assign({ { 340, 985 } }, layer_intent = { LAYER_INTENT_FILL });


M11_MAIN_H = assign({ { 41, 970 } });
DM11_O_H = assign({ { 341, 970 } }, layer_intent = { LAYER_INTENT_FILL });
DM11_H = assign({ { 341, 975 } }, layer_intent = { LAYER_INTENT_FILL });
M11_MAIN_V = assign({ { 41, 980 } });
DM11_O_V = assign({ { 341, 980 } }, layer_intent = { LAYER_INTENT_FILL });
DM11_V = assign({ { 341, 985 } }, layer_intent = { LAYER_INTENT_FILL });


M12_MAIN_H = assign({ { 42, 970 } });
DM12_O_H = assign({ { 342, 970 } }, layer_intent = { LAYER_INTENT_FILL });
DM12_H = assign({ { 342, 975 } }, layer_intent = { LAYER_INTENT_FILL });
M12_MAIN_V = assign({ { 42, 980 } });
DM12_O_V = assign({ { 342, 980 } }, layer_intent = { LAYER_INTENT_FILL });
DM12_V = assign({ { 342, 985 } }, layer_intent = { LAYER_INTENT_FILL });


M13_MAIN_H = assign({ { 43, 970 } });
DM13_O_H = assign({ { 343, 970 } }, layer_intent = { LAYER_INTENT_FILL });
DM13_H = assign({ { 343, 975 } }, layer_intent = { LAYER_INTENT_FILL });
M13_MAIN_V = assign({ { 43, 980 } });
DM13_O_V = assign({ { 343, 980 } }, layer_intent = { LAYER_INTENT_FILL });
DM13_V = assign({ { 343, 985 } }, layer_intent = { LAYER_INTENT_FILL });


M14_MAIN = assign({ { 44, 90 } });
DM14_O = assign({ { 344, 90 } }, layer_intent = { LAYER_INTENT_FILL });
DM14 = assign({ { 344, 95 } }, layer_intent = { LAYER_INTENT_FILL });


M15_MAIN = assign({ { 45, 90 } });
DM15_O = assign({ { 345, 90 } }, layer_intent = { LAYER_INTENT_FILL });
DM15 = assign({ { 345, 95 } }, layer_intent = { LAYER_INTENT_FILL });


M16_MAIN = assign({ { 46, 70 } });
DM16 = assign({ { 346, 75 } }, layer_intent = { LAYER_INTENT_FILL });


M17_MAIN = assign({ { 47, 70 } });
DM17 = assign({ { 347, 75 } }, layer_intent = { LAYER_INTENT_FILL });


M18_MAIN = assign({ { 48, 80 } });
DM18 = assign({ { 348, 85 } }, layer_intent = { LAYER_INTENT_FILL });


M19_MAIN = assign({ { 49, 80 } });
DM19 = assign({ { 349, 85 } }, layer_intent = { LAYER_INTENT_FILL });




 NOUSEM2 = assign({              { 32, 150 }, { 32, 151 }, { 32, 152 }, { 32, 170 }, { 32, 171 }, { 32, 172 }, { 332, 151 }, { 332, 152 }, { 332, 171 }, { 332, 172 }, { 332, 161 }, { 332, 162 }, { 332, 181 }, { 332, 182 },   { 32, 250 }, { 32, 270 }, { 332, 250 }, { 332, 260 }, { 332, 270 }, { 332, 280 },  { 32, 300 }, { 32, 320 }, { 332, 300 }, { 332, 310 }, { 332, 320 }, { 332, 330 },  { 32, 500 }, { 32, 501 }, { 32, 502 }, { 32, 520 }, { 32, 521 }, { 32, 522 }, { 332, 501 }, { 332, 502 }, { 332, 521 }, { 332, 522 }, { 332, 511 }, { 332, 512 }, { 332, 531 }, { 332, 532 },  { 32, 550 }, { 32, 551 }, { 32, 552 }, { 32, 570 }, { 32, 571 }, { 32, 572 }, { 332, 551 }, { 332, 552 }, { 332, 571 }, { 332, 572 }, { 332, 561 }, { 332, 562 }, { 332, 581 }, { 332, 582 },  { 32, 350 }, { 32, 351 }, { 32, 352 }, { 32, 370 }, { 32, 371 }, { 32, 372 }, { 332, 351 }, { 332, 352 }, { 332, 371 }, { 332, 372 }, { 332, 361 }, { 332, 362 }, { 332, 381 }, { 332, 382 }, { 332, 353 }, { 332, 354 }, { 332, 373 }, { 332, 374 },  { 32, 400 }, { 32, 401 }, { 32, 402 }, { 32, 420 }, { 32, 421 }, { 32, 422 }, { 332, 401 },  { 332, 402 },  { 332, 421 },  { 332, 422 },  { 332, 411 },  { 332, 412 },  { 332, 431 },  { 332, 432 },  { 32, 950 }, { 32, 960 }, { 332, 950 }, { 332, 960 }, { 332, 955 }, { 332, 965 },  { 32, 800 }, { 32, 810 }, { 332, 800 }, { 332, 810 }, { 332, 805 }, { 332, 815 },  { 32, 920 }, { 32, 930 }, { 332, 920 }, { 332, 930 }, { 332, 925 }, { 332, 935 },  { 32, 970 }, { 32, 980 }, { 332, 970 }, { 332, 980 }, { 332, 975 }, { 332, 985 },  { 32, 90 }, { 332, 90 }, { 332, 95 },  { 32, 70 }, { 332, 70 }, { 332, 75 },  { 32, 50 }, { 332, 55 },  { 32, 40 },  { 332, 45 }, { 332, 40 },  { 32, 80 }, { 332, 85 }, { 332, 80 },  { 32, 60 }, { 332, 65 },  });




 NOUSEM3 = assign({              { 33, 150 }, { 33, 151 }, { 33, 152 }, { 33, 170 }, { 33, 171 }, { 33, 172 }, { 333, 151 }, { 333, 152 }, { 333, 171 }, { 333, 172 }, { 333, 161 }, { 333, 162 }, { 333, 181 }, { 333, 182 },  { 33, 200 }, { 33, 201 }, { 33, 202 }, { 33, 220 }, { 33, 221 }, { 33, 222 }, { 333, 201 }, { 333, 202 }, { 333, 221 }, { 333, 222 }, { 333, 211 }, { 333, 212 }, { 333, 231 }, { 333, 232 },   { 33, 300 }, { 33, 320 }, { 333, 300 }, { 333, 310 }, { 333, 320 }, { 333, 330 },  { 33, 500 }, { 33, 501 }, { 33, 502 }, { 33, 520 }, { 33, 521 }, { 33, 522 }, { 333, 501 }, { 333, 502 }, { 333, 521 }, { 333, 522 }, { 333, 511 }, { 333, 512 }, { 333, 531 }, { 333, 532 },  { 33, 550 }, { 33, 551 }, { 33, 552 }, { 33, 570 }, { 33, 571 }, { 33, 572 }, { 333, 551 }, { 333, 552 }, { 333, 571 }, { 333, 572 }, { 333, 561 }, { 333, 562 }, { 333, 581 }, { 333, 582 },  { 33, 350 }, { 33, 351 }, { 33, 352 }, { 33, 370 }, { 33, 371 }, { 33, 372 }, { 333, 351 }, { 333, 352 }, { 333, 371 }, { 333, 372 }, { 333, 361 }, { 333, 362 }, { 333, 381 }, { 333, 382 }, { 333, 353 }, { 333, 354 }, { 333, 373 }, { 333, 374 },  { 33, 400 }, { 33, 401 }, { 33, 402 }, { 33, 420 }, { 33, 421 }, { 33, 422 }, { 333, 401 },  { 333, 402 },  { 333, 421 },  { 333, 422 },  { 333, 411 },  { 333, 412 },  { 333, 431 },  { 333, 432 },  { 33, 950 }, { 33, 960 }, { 333, 950 }, { 333, 960 }, { 333, 955 }, { 333, 965 },  { 33, 800 }, { 33, 810 }, { 333, 800 }, { 333, 810 }, { 333, 805 }, { 333, 815 },  { 33, 920 }, { 33, 930 }, { 333, 920 }, { 333, 930 }, { 333, 925 }, { 333, 935 },  { 33, 970 }, { 33, 980 }, { 333, 970 }, { 333, 980 }, { 333, 975 }, { 333, 985 },  { 33, 90 }, { 333, 90 }, { 333, 95 },  { 33, 70 }, { 333, 70 }, { 333, 75 },  { 33, 50 }, { 333, 55 },  { 33, 40 },  { 333, 45 }, { 333, 40 },  { 33, 80 }, { 333, 85 }, { 333, 80 },  { 33, 60 }, { 333, 65 },  });




 NOUSEM4 = assign({              { 34, 150 }, { 34, 151 }, { 34, 152 }, { 34, 170 }, { 34, 171 }, { 34, 172 }, { 334, 151 }, { 334, 152 }, { 334, 171 }, { 334, 172 }, { 334, 161 }, { 334, 162 }, { 334, 181 }, { 334, 182 },  { 34, 200 }, { 34, 201 }, { 34, 202 }, { 34, 220 }, { 34, 221 }, { 34, 222 }, { 334, 201 }, { 334, 202 }, { 334, 221 }, { 334, 222 }, { 334, 211 }, { 334, 212 }, { 334, 231 }, { 334, 232 },  { 34, 250 }, { 34, 270 }, { 334, 250 }, { 334, 260 }, { 334, 270 }, { 334, 280 },   { 34, 500 }, { 34, 501 }, { 34, 502 }, { 34, 520 }, { 34, 521 }, { 34, 522 }, { 334, 501 }, { 334, 502 }, { 334, 521 }, { 334, 522 }, { 334, 511 }, { 334, 512 }, { 334, 531 }, { 334, 532 },  { 34, 550 }, { 34, 551 }, { 34, 552 }, { 34, 570 }, { 34, 571 }, { 34, 572 }, { 334, 551 }, { 334, 552 }, { 334, 571 }, { 334, 572 }, { 334, 561 }, { 334, 562 }, { 334, 581 }, { 334, 582 },  { 34, 350 }, { 34, 351 }, { 34, 352 }, { 34, 370 }, { 34, 371 }, { 34, 372 }, { 334, 351 }, { 334, 352 }, { 334, 371 }, { 334, 372 }, { 334, 361 }, { 334, 362 }, { 334, 381 }, { 334, 382 }, { 334, 353 }, { 334, 354 }, { 334, 373 }, { 334, 374 },  { 34, 400 }, { 34, 401 }, { 34, 402 }, { 34, 420 }, { 34, 421 }, { 34, 422 }, { 334, 401 },  { 334, 402 },  { 334, 421 },  { 334, 422 },  { 334, 411 },  { 334, 412 },  { 334, 431 },  { 334, 432 },  { 34, 950 }, { 34, 960 }, { 334, 950 }, { 334, 960 }, { 334, 955 }, { 334, 965 },  { 34, 800 }, { 34, 810 }, { 334, 800 }, { 334, 810 }, { 334, 805 }, { 334, 815 },  { 34, 920 }, { 34, 930 }, { 334, 920 }, { 334, 930 }, { 334, 925 }, { 334, 935 },  { 34, 970 }, { 34, 980 }, { 334, 970 }, { 334, 980 }, { 334, 975 }, { 334, 985 },  { 34, 90 }, { 334, 90 }, { 334, 95 },  { 34, 70 }, { 334, 70 }, { 334, 75 },  { 34, 50 }, { 334, 55 },  { 34, 40 },  { 334, 45 }, { 334, 40 },  { 34, 80 }, { 334, 85 }, { 334, 80 },  { 34, 60 }, { 334, 65 },  });




 NOUSEM5 = assign({              { 35, 150 }, { 35, 151 }, { 35, 152 }, { 35, 170 }, { 35, 171 }, { 35, 172 }, { 335, 151 }, { 335, 152 }, { 335, 171 }, { 335, 172 }, { 335, 161 }, { 335, 162 }, { 335, 181 }, { 335, 182 },  { 35, 200 }, { 35, 201 }, { 35, 202 }, { 35, 220 }, { 35, 221 }, { 35, 222 }, { 335, 201 }, { 335, 202 }, { 335, 221 }, { 335, 222 }, { 335, 211 }, { 335, 212 }, { 335, 231 }, { 335, 232 },  { 35, 250 }, { 35, 270 }, { 335, 250 }, { 335, 260 }, { 335, 270 }, { 335, 280 },  { 35, 300 }, { 35, 320 }, { 335, 300 }, { 335, 310 }, { 335, 320 }, { 335, 330 },  { 35, 500 }, { 35, 501 }, { 35, 502 }, { 35, 520 }, { 35, 521 }, { 35, 522 }, { 335, 501 }, { 335, 502 }, { 335, 521 }, { 335, 522 }, { 335, 511 }, { 335, 512 }, { 335, 531 }, { 335, 532 },  { 35, 550 }, { 35, 551 }, { 35, 552 }, { 35, 570 }, { 35, 571 }, { 35, 572 }, { 335, 551 }, { 335, 552 }, { 335, 571 }, { 335, 572 }, { 335, 561 }, { 335, 562 }, { 335, 581 }, { 335, 582 },   { 35, 400 }, { 35, 401 }, { 35, 402 }, { 35, 420 }, { 35, 421 }, { 35, 422 }, { 335, 401 },  { 335, 402 },  { 335, 421 },  { 335, 422 },  { 335, 411 },  { 335, 412 },  { 335, 431 },  { 335, 432 },  { 35, 950 }, { 35, 960 }, { 335, 950 }, { 335, 960 }, { 335, 955 }, { 335, 965 },  { 35, 800 }, { 35, 810 }, { 335, 800 }, { 335, 810 }, { 335, 805 }, { 335, 815 },  { 35, 920 }, { 35, 930 }, { 335, 920 }, { 335, 930 }, { 335, 925 }, { 335, 935 },  { 35, 970 }, { 35, 980 }, { 335, 970 }, { 335, 980 }, { 335, 975 }, { 335, 985 },  { 35, 90 }, { 335, 90 }, { 335, 95 },  { 35, 70 }, { 335, 70 }, { 335, 75 },  { 35, 50 }, { 335, 55 },  { 35, 40 },  { 335, 45 }, { 335, 40 },  { 35, 80 }, { 335, 85 }, { 335, 80 },  { 35, 60 }, { 335, 65 },  });




 NOUSEM6 = assign({              { 36, 150 }, { 36, 151 }, { 36, 152 }, { 36, 170 }, { 36, 171 }, { 36, 172 }, { 336, 151 }, { 336, 152 }, { 336, 171 }, { 336, 172 }, { 336, 161 }, { 336, 162 }, { 336, 181 }, { 336, 182 },  { 36, 200 }, { 36, 201 }, { 36, 202 }, { 36, 220 }, { 36, 221 }, { 36, 222 }, { 336, 201 }, { 336, 202 }, { 336, 221 }, { 336, 222 }, { 336, 211 }, { 336, 212 }, { 336, 231 }, { 336, 232 },  { 36, 250 }, { 36, 270 }, { 336, 250 }, { 336, 260 }, { 336, 270 }, { 336, 280 },  { 36, 300 }, { 36, 320 }, { 336, 300 }, { 336, 310 }, { 336, 320 }, { 336, 330 },  { 36, 500 }, { 36, 501 }, { 36, 502 }, { 36, 520 }, { 36, 521 }, { 36, 522 }, { 336, 501 }, { 336, 502 }, { 336, 521 }, { 336, 522 }, { 336, 511 }, { 336, 512 }, { 336, 531 }, { 336, 532 },  { 36, 550 }, { 36, 551 }, { 36, 552 }, { 36, 570 }, { 36, 571 }, { 36, 572 }, { 336, 551 }, { 336, 552 }, { 336, 571 }, { 336, 572 }, { 336, 561 }, { 336, 562 }, { 336, 581 }, { 336, 582 },  { 36, 350 }, { 36, 351 }, { 36, 352 }, { 36, 370 }, { 36, 371 }, { 36, 372 }, { 336, 351 }, { 336, 352 }, { 336, 371 }, { 336, 372 }, { 336, 361 }, { 336, 362 }, { 336, 381 }, { 336, 382 }, { 336, 353 }, { 336, 354 }, { 336, 373 }, { 336, 374 },  { 36, 400 }, { 36, 401 }, { 36, 402 }, { 36, 420 }, { 36, 421 }, { 36, 422 }, { 336, 401 },  { 336, 402 },  { 336, 421 },  { 336, 422 },  { 336, 411 },  { 336, 412 },  { 336, 431 },  { 336, 432 },   { 36, 800 }, { 36, 810 }, { 336, 800 }, { 336, 810 }, { 336, 805 }, { 336, 815 },  { 36, 920 }, { 36, 930 }, { 336, 920 }, { 336, 930 }, { 336, 925 }, { 336, 935 },  { 36, 970 }, { 36, 980 }, { 336, 970 }, { 336, 980 }, { 336, 975 }, { 336, 985 },  { 36, 90 }, { 336, 90 }, { 336, 95 },  { 36, 70 }, { 336, 70 }, { 336, 75 },  { 36, 50 }, { 336, 55 },  { 36, 40 },  { 336, 45 }, { 336, 40 },  { 36, 80 }, { 336, 85 }, { 336, 80 },  { 36, 60 }, { 336, 65 },  });




 NOUSEM7 = assign({              { 37, 150 }, { 37, 151 }, { 37, 152 }, { 37, 170 }, { 37, 171 }, { 37, 172 }, { 337, 151 }, { 337, 152 }, { 337, 171 }, { 337, 172 }, { 337, 161 }, { 337, 162 }, { 337, 181 }, { 337, 182 },  { 37, 200 }, { 37, 201 }, { 37, 202 }, { 37, 220 }, { 37, 221 }, { 37, 222 }, { 337, 201 }, { 337, 202 }, { 337, 221 }, { 337, 222 }, { 337, 211 }, { 337, 212 }, { 337, 231 }, { 337, 232 },  { 37, 250 }, { 37, 270 }, { 337, 250 }, { 337, 260 }, { 337, 270 }, { 337, 280 },  { 37, 300 }, { 37, 320 }, { 337, 300 }, { 337, 310 }, { 337, 320 }, { 337, 330 },  { 37, 500 }, { 37, 501 }, { 37, 502 }, { 37, 520 }, { 37, 521 }, { 37, 522 }, { 337, 501 }, { 337, 502 }, { 337, 521 }, { 337, 522 }, { 337, 511 }, { 337, 512 }, { 337, 531 }, { 337, 532 },  { 37, 550 }, { 37, 551 }, { 37, 552 }, { 37, 570 }, { 37, 571 }, { 37, 572 }, { 337, 551 }, { 337, 552 }, { 337, 571 }, { 337, 572 }, { 337, 561 }, { 337, 562 }, { 337, 581 }, { 337, 582 },  { 37, 350 }, { 37, 351 }, { 37, 352 }, { 37, 370 }, { 37, 371 }, { 37, 372 }, { 337, 351 }, { 337, 352 }, { 337, 371 }, { 337, 372 }, { 337, 361 }, { 337, 362 }, { 337, 381 }, { 337, 382 }, { 337, 353 }, { 337, 354 }, { 337, 373 }, { 337, 374 },  { 37, 400 }, { 37, 401 }, { 37, 402 }, { 37, 420 }, { 37, 421 }, { 37, 422 }, { 337, 401 },  { 337, 402 },  { 337, 421 },  { 337, 422 },  { 337, 411 },  { 337, 412 },  { 337, 431 },  { 337, 432 },  { 37, 950 }, { 37, 960 }, { 337, 950 }, { 337, 960 }, { 337, 955 }, { 337, 965 },   { 37, 920 }, { 37, 930 }, { 337, 920 }, { 337, 930 }, { 337, 925 }, { 337, 935 },  { 37, 970 }, { 37, 980 }, { 337, 970 }, { 337, 980 }, { 337, 975 }, { 337, 985 },  { 37, 90 }, { 337, 90 }, { 337, 95 },  { 37, 70 }, { 337, 70 }, { 337, 75 },  { 37, 50 }, { 337, 55 },  { 37, 40 },  { 337, 45 }, { 337, 40 },  { 37, 80 }, { 337, 85 }, { 337, 80 },  { 37, 60 }, { 337, 65 },  });




 NOUSEM8 = assign({              { 38, 150 }, { 38, 151 }, { 38, 152 }, { 38, 170 }, { 38, 171 }, { 38, 172 }, { 338, 151 }, { 338, 152 }, { 338, 171 }, { 338, 172 }, { 338, 161 }, { 338, 162 }, { 338, 181 }, { 338, 182 },  { 38, 200 }, { 38, 201 }, { 38, 202 }, { 38, 220 }, { 38, 221 }, { 38, 222 }, { 338, 201 }, { 338, 202 }, { 338, 221 }, { 338, 222 }, { 338, 211 }, { 338, 212 }, { 338, 231 }, { 338, 232 },  { 38, 250 }, { 38, 270 }, { 338, 250 }, { 338, 260 }, { 338, 270 }, { 338, 280 },  { 38, 300 }, { 38, 320 }, { 338, 300 }, { 338, 310 }, { 338, 320 }, { 338, 330 },  { 38, 500 }, { 38, 501 }, { 38, 502 }, { 38, 520 }, { 38, 521 }, { 38, 522 }, { 338, 501 }, { 338, 502 }, { 338, 521 }, { 338, 522 }, { 338, 511 }, { 338, 512 }, { 338, 531 }, { 338, 532 },  { 38, 550 }, { 38, 551 }, { 38, 552 }, { 38, 570 }, { 38, 571 }, { 38, 572 }, { 338, 551 }, { 338, 552 }, { 338, 571 }, { 338, 572 }, { 338, 561 }, { 338, 562 }, { 338, 581 }, { 338, 582 },  { 38, 350 }, { 38, 351 }, { 38, 352 }, { 38, 370 }, { 38, 371 }, { 38, 372 }, { 338, 351 }, { 338, 352 }, { 338, 371 }, { 338, 372 }, { 338, 361 }, { 338, 362 }, { 338, 381 }, { 338, 382 }, { 338, 353 }, { 338, 354 }, { 338, 373 }, { 338, 374 },  { 38, 400 }, { 38, 401 }, { 38, 402 }, { 38, 420 }, { 38, 421 }, { 38, 422 }, { 338, 401 },  { 338, 402 },  { 338, 421 },  { 338, 422 },  { 338, 411 },  { 338, 412 },  { 338, 431 },  { 338, 432 },  { 38, 950 }, { 38, 960 }, { 338, 950 }, { 338, 960 }, { 338, 955 }, { 338, 965 },  { 38, 800 }, { 38, 810 }, { 338, 800 }, { 338, 810 }, { 338, 805 }, { 338, 815 },  { 38, 920 }, { 38, 930 }, { 338, 920 }, { 338, 930 }, { 338, 925 }, { 338, 935 },   { 38, 90 }, { 338, 90 }, { 338, 95 },  { 38, 70 }, { 338, 70 }, { 338, 75 },  { 38, 50 }, { 338, 55 },  { 38, 40 },  { 338, 45 }, { 338, 40 },  { 38, 80 }, { 338, 85 }, { 338, 80 },  { 38, 60 }, { 338, 65 },  });




 NOUSEM9 = assign({              { 39, 150 }, { 39, 151 }, { 39, 152 }, { 39, 170 }, { 39, 171 }, { 39, 172 }, { 339, 151 }, { 339, 152 }, { 339, 171 }, { 339, 172 }, { 339, 161 }, { 339, 162 }, { 339, 181 }, { 339, 182 },  { 39, 200 }, { 39, 201 }, { 39, 202 }, { 39, 220 }, { 39, 221 }, { 39, 222 }, { 339, 201 }, { 339, 202 }, { 339, 221 }, { 339, 222 }, { 339, 211 }, { 339, 212 }, { 339, 231 }, { 339, 232 },  { 39, 250 }, { 39, 270 }, { 339, 250 }, { 339, 260 }, { 339, 270 }, { 339, 280 },  { 39, 300 }, { 39, 320 }, { 339, 300 }, { 339, 310 }, { 339, 320 }, { 339, 330 },  { 39, 500 }, { 39, 501 }, { 39, 502 }, { 39, 520 }, { 39, 521 }, { 39, 522 }, { 339, 501 }, { 339, 502 }, { 339, 521 }, { 339, 522 }, { 339, 511 }, { 339, 512 }, { 339, 531 }, { 339, 532 },  { 39, 550 }, { 39, 551 }, { 39, 552 }, { 39, 570 }, { 39, 571 }, { 39, 572 }, { 339, 551 }, { 339, 552 }, { 339, 571 }, { 339, 572 }, { 339, 561 }, { 339, 562 }, { 339, 581 }, { 339, 582 },  { 39, 350 }, { 39, 351 }, { 39, 352 }, { 39, 370 }, { 39, 371 }, { 39, 372 }, { 339, 351 }, { 339, 352 }, { 339, 371 }, { 339, 372 }, { 339, 361 }, { 339, 362 }, { 339, 381 }, { 339, 382 }, { 339, 353 }, { 339, 354 }, { 339, 373 }, { 339, 374 },  { 39, 400 }, { 39, 401 }, { 39, 402 }, { 39, 420 }, { 39, 421 }, { 39, 422 }, { 339, 401 },  { 339, 402 },  { 339, 421 },  { 339, 422 },  { 339, 411 },  { 339, 412 },  { 339, 431 },  { 339, 432 },  { 39, 950 }, { 39, 960 }, { 339, 950 }, { 339, 960 }, { 339, 955 }, { 339, 965 },  { 39, 800 }, { 39, 810 }, { 339, 800 }, { 339, 810 }, { 339, 805 }, { 339, 815 },  { 39, 920 }, { 39, 930 }, { 339, 920 }, { 339, 930 }, { 339, 925 }, { 339, 935 },   { 39, 90 }, { 339, 90 }, { 339, 95 },  { 39, 70 }, { 339, 70 }, { 339, 75 },  { 39, 50 }, { 339, 55 },  { 39, 40 },  { 339, 45 }, { 339, 40 },  { 39, 80 }, { 339, 85 }, { 339, 80 },  { 39, 60 }, { 339, 65 },  });




 NOUSEM10 = assign({              { 40, 150 }, { 40, 151 }, { 40, 152 }, { 40, 170 }, { 40, 171 }, { 40, 172 }, { 340, 151 }, { 340, 152 }, { 340, 171 }, { 340, 172 }, { 340, 161 }, { 340, 162 }, { 340, 181 }, { 340, 182 },  { 40, 200 }, { 40, 201 }, { 40, 202 }, { 40, 220 }, { 40, 221 }, { 40, 222 }, { 340, 201 }, { 340, 202 }, { 340, 221 }, { 340, 222 }, { 340, 211 }, { 340, 212 }, { 340, 231 }, { 340, 232 },  { 40, 250 }, { 40, 270 }, { 340, 250 }, { 340, 260 }, { 340, 270 }, { 340, 280 },  { 40, 300 }, { 40, 320 }, { 340, 300 }, { 340, 310 }, { 340, 320 }, { 340, 330 },  { 40, 500 }, { 40, 501 }, { 40, 502 }, { 40, 520 }, { 40, 521 }, { 40, 522 }, { 340, 501 }, { 340, 502 }, { 340, 521 }, { 340, 522 }, { 340, 511 }, { 340, 512 }, { 340, 531 }, { 340, 532 },  { 40, 550 }, { 40, 551 }, { 40, 552 }, { 40, 570 }, { 40, 571 }, { 40, 572 }, { 340, 551 }, { 340, 552 }, { 340, 571 }, { 340, 572 }, { 340, 561 }, { 340, 562 }, { 340, 581 }, { 340, 582 },  { 40, 350 }, { 40, 351 }, { 40, 352 }, { 40, 370 }, { 40, 371 }, { 40, 372 }, { 340, 351 }, { 340, 352 }, { 340, 371 }, { 340, 372 }, { 340, 361 }, { 340, 362 }, { 340, 381 }, { 340, 382 }, { 340, 353 }, { 340, 354 }, { 340, 373 }, { 340, 374 },  { 40, 400 }, { 40, 401 }, { 40, 402 }, { 40, 420 }, { 40, 421 }, { 40, 422 }, { 340, 401 },  { 340, 402 },  { 340, 421 },  { 340, 422 },  { 340, 411 },  { 340, 412 },  { 340, 431 },  { 340, 432 },  { 40, 950 }, { 40, 960 }, { 340, 950 }, { 340, 960 }, { 340, 955 }, { 340, 965 },  { 40, 800 }, { 40, 810 }, { 340, 800 }, { 340, 810 }, { 340, 805 }, { 340, 815 },  { 40, 920 }, { 40, 930 }, { 340, 920 }, { 340, 930 }, { 340, 925 }, { 340, 935 },   { 40, 90 }, { 340, 90 }, { 340, 95 },  { 40, 70 }, { 340, 70 }, { 340, 75 },  { 40, 50 }, { 340, 55 },  { 40, 40 },  { 340, 45 }, { 340, 40 },  { 40, 80 }, { 340, 85 }, { 340, 80 },  { 40, 60 }, { 340, 65 },  });




 NOUSEM11 = assign({              { 41, 150 }, { 41, 151 }, { 41, 152 }, { 41, 170 }, { 41, 171 }, { 41, 172 }, { 341, 151 }, { 341, 152 }, { 341, 171 }, { 341, 172 }, { 341, 161 }, { 341, 162 }, { 341, 181 }, { 341, 182 },  { 41, 200 }, { 41, 201 }, { 41, 202 }, { 41, 220 }, { 41, 221 }, { 41, 222 }, { 341, 201 }, { 341, 202 }, { 341, 221 }, { 341, 222 }, { 341, 211 }, { 341, 212 }, { 341, 231 }, { 341, 232 },  { 41, 250 }, { 41, 270 }, { 341, 250 }, { 341, 260 }, { 341, 270 }, { 341, 280 },  { 41, 300 }, { 41, 320 }, { 341, 300 }, { 341, 310 }, { 341, 320 }, { 341, 330 },  { 41, 500 }, { 41, 501 }, { 41, 502 }, { 41, 520 }, { 41, 521 }, { 41, 522 }, { 341, 501 }, { 341, 502 }, { 341, 521 }, { 341, 522 }, { 341, 511 }, { 341, 512 }, { 341, 531 }, { 341, 532 },  { 41, 550 }, { 41, 551 }, { 41, 552 }, { 41, 570 }, { 41, 571 }, { 41, 572 }, { 341, 551 }, { 341, 552 }, { 341, 571 }, { 341, 572 }, { 341, 561 }, { 341, 562 }, { 341, 581 }, { 341, 582 },  { 41, 350 }, { 41, 351 }, { 41, 352 }, { 41, 370 }, { 41, 371 }, { 41, 372 }, { 341, 351 }, { 341, 352 }, { 341, 371 }, { 341, 372 }, { 341, 361 }, { 341, 362 }, { 341, 381 }, { 341, 382 }, { 341, 353 }, { 341, 354 }, { 341, 373 }, { 341, 374 },  { 41, 400 }, { 41, 401 }, { 41, 402 }, { 41, 420 }, { 41, 421 }, { 41, 422 }, { 341, 401 },  { 341, 402 },  { 341, 421 },  { 341, 422 },  { 341, 411 },  { 341, 412 },  { 341, 431 },  { 341, 432 },  { 41, 950 }, { 41, 960 }, { 341, 950 }, { 341, 960 }, { 341, 955 }, { 341, 965 },  { 41, 800 }, { 41, 810 }, { 341, 800 }, { 341, 810 }, { 341, 805 }, { 341, 815 },  { 41, 920 }, { 41, 930 }, { 341, 920 }, { 341, 930 }, { 341, 925 }, { 341, 935 },   { 41, 90 }, { 341, 90 }, { 341, 95 },  { 41, 70 }, { 341, 70 }, { 341, 75 },  { 41, 50 }, { 341, 55 },  { 41, 40 },  { 341, 45 }, { 341, 40 },  { 41, 80 }, { 341, 85 }, { 341, 80 },  { 41, 60 }, { 341, 65 },  });




 NOUSEM12 = assign({              { 42, 150 }, { 42, 151 }, { 42, 152 }, { 42, 170 }, { 42, 171 }, { 42, 172 }, { 342, 151 }, { 342, 152 }, { 342, 171 }, { 342, 172 }, { 342, 161 }, { 342, 162 }, { 342, 181 }, { 342, 182 },  { 42, 200 }, { 42, 201 }, { 42, 202 }, { 42, 220 }, { 42, 221 }, { 42, 222 }, { 342, 201 }, { 342, 202 }, { 342, 221 }, { 342, 222 }, { 342, 211 }, { 342, 212 }, { 342, 231 }, { 342, 232 },  { 42, 250 }, { 42, 270 }, { 342, 250 }, { 342, 260 }, { 342, 270 }, { 342, 280 },  { 42, 300 }, { 42, 320 }, { 342, 300 }, { 342, 310 }, { 342, 320 }, { 342, 330 },  { 42, 500 }, { 42, 501 }, { 42, 502 }, { 42, 520 }, { 42, 521 }, { 42, 522 }, { 342, 501 }, { 342, 502 }, { 342, 521 }, { 342, 522 }, { 342, 511 }, { 342, 512 }, { 342, 531 }, { 342, 532 },  { 42, 550 }, { 42, 551 }, { 42, 552 }, { 42, 570 }, { 42, 571 }, { 42, 572 }, { 342, 551 }, { 342, 552 }, { 342, 571 }, { 342, 572 }, { 342, 561 }, { 342, 562 }, { 342, 581 }, { 342, 582 },  { 42, 350 }, { 42, 351 }, { 42, 352 }, { 42, 370 }, { 42, 371 }, { 42, 372 }, { 342, 351 }, { 342, 352 }, { 342, 371 }, { 342, 372 }, { 342, 361 }, { 342, 362 }, { 342, 381 }, { 342, 382 }, { 342, 353 }, { 342, 354 }, { 342, 373 }, { 342, 374 },  { 42, 400 }, { 42, 401 }, { 42, 402 }, { 42, 420 }, { 42, 421 }, { 42, 422 }, { 342, 401 },  { 342, 402 },  { 342, 421 },  { 342, 422 },  { 342, 411 },  { 342, 412 },  { 342, 431 },  { 342, 432 },  { 42, 950 }, { 42, 960 }, { 342, 950 }, { 342, 960 }, { 342, 955 }, { 342, 965 },  { 42, 800 }, { 42, 810 }, { 342, 800 }, { 342, 810 }, { 342, 805 }, { 342, 815 },  { 42, 920 }, { 42, 930 }, { 342, 920 }, { 342, 930 }, { 342, 925 }, { 342, 935 },   { 42, 90 }, { 342, 90 }, { 342, 95 },  { 42, 70 }, { 342, 70 }, { 342, 75 },  { 42, 50 }, { 342, 55 },  { 42, 40 },  { 342, 45 }, { 342, 40 },  { 42, 80 }, { 342, 85 }, { 342, 80 },  { 42, 60 }, { 342, 65 },  });




 NOUSEM13 = assign({              { 43, 150 }, { 43, 151 }, { 43, 152 }, { 43, 170 }, { 43, 171 }, { 43, 172 }, { 343, 151 }, { 343, 152 }, { 343, 171 }, { 343, 172 }, { 343, 161 }, { 343, 162 }, { 343, 181 }, { 343, 182 },  { 43, 200 }, { 43, 201 }, { 43, 202 }, { 43, 220 }, { 43, 221 }, { 43, 222 }, { 343, 201 }, { 343, 202 }, { 343, 221 }, { 343, 222 }, { 343, 211 }, { 343, 212 }, { 343, 231 }, { 343, 232 },  { 43, 250 }, { 43, 270 }, { 343, 250 }, { 343, 260 }, { 343, 270 }, { 343, 280 },  { 43, 300 }, { 43, 320 }, { 343, 300 }, { 343, 310 }, { 343, 320 }, { 343, 330 },  { 43, 500 }, { 43, 501 }, { 43, 502 }, { 43, 520 }, { 43, 521 }, { 43, 522 }, { 343, 501 }, { 343, 502 }, { 343, 521 }, { 343, 522 }, { 343, 511 }, { 343, 512 }, { 343, 531 }, { 343, 532 },  { 43, 550 }, { 43, 551 }, { 43, 552 }, { 43, 570 }, { 43, 571 }, { 43, 572 }, { 343, 551 }, { 343, 552 }, { 343, 571 }, { 343, 572 }, { 343, 561 }, { 343, 562 }, { 343, 581 }, { 343, 582 },  { 43, 350 }, { 43, 351 }, { 43, 352 }, { 43, 370 }, { 43, 371 }, { 43, 372 }, { 343, 351 }, { 343, 352 }, { 343, 371 }, { 343, 372 }, { 343, 361 }, { 343, 362 }, { 343, 381 }, { 343, 382 }, { 343, 353 }, { 343, 354 }, { 343, 373 }, { 343, 374 },  { 43, 400 }, { 43, 401 }, { 43, 402 }, { 43, 420 }, { 43, 421 }, { 43, 422 }, { 343, 401 },  { 343, 402 },  { 343, 421 },  { 343, 422 },  { 343, 411 },  { 343, 412 },  { 343, 431 },  { 343, 432 },  { 43, 950 }, { 43, 960 }, { 343, 950 }, { 343, 960 }, { 343, 955 }, { 343, 965 },  { 43, 800 }, { 43, 810 }, { 343, 800 }, { 343, 810 }, { 343, 805 }, { 343, 815 },  { 43, 920 }, { 43, 930 }, { 343, 920 }, { 343, 930 }, { 343, 925 }, { 343, 935 },   { 43, 90 }, { 343, 90 }, { 343, 95 },  { 43, 70 }, { 343, 70 }, { 343, 75 },  { 43, 50 }, { 343, 55 },  { 43, 40 },  { 343, 45 }, { 343, 40 },  { 43, 80 }, { 343, 85 }, { 343, 80 },  { 43, 60 }, { 343, 65 },  });




 NOUSEM14 = assign({              { 44, 150 }, { 44, 151 }, { 44, 152 }, { 44, 170 }, { 44, 171 }, { 44, 172 }, { 344, 151 }, { 344, 152 }, { 344, 171 }, { 344, 172 }, { 344, 161 }, { 344, 162 }, { 344, 181 }, { 344, 182 },  { 44, 200 }, { 44, 201 }, { 44, 202 }, { 44, 220 }, { 44, 221 }, { 44, 222 }, { 344, 201 }, { 344, 202 }, { 344, 221 }, { 344, 222 }, { 344, 211 }, { 344, 212 }, { 344, 231 }, { 344, 232 },  { 44, 250 }, { 44, 270 }, { 344, 250 }, { 344, 260 }, { 344, 270 }, { 344, 280 },  { 44, 300 }, { 44, 320 }, { 344, 300 }, { 344, 310 }, { 344, 320 }, { 344, 330 },  { 44, 500 }, { 44, 501 }, { 44, 502 }, { 44, 520 }, { 44, 521 }, { 44, 522 }, { 344, 501 }, { 344, 502 }, { 344, 521 }, { 344, 522 }, { 344, 511 }, { 344, 512 }, { 344, 531 }, { 344, 532 },  { 44, 550 }, { 44, 551 }, { 44, 552 }, { 44, 570 }, { 44, 571 }, { 44, 572 }, { 344, 551 }, { 344, 552 }, { 344, 571 }, { 344, 572 }, { 344, 561 }, { 344, 562 }, { 344, 581 }, { 344, 582 },  { 44, 350 }, { 44, 351 }, { 44, 352 }, { 44, 370 }, { 44, 371 }, { 44, 372 }, { 344, 351 }, { 344, 352 }, { 344, 371 }, { 344, 372 }, { 344, 361 }, { 344, 362 }, { 344, 381 }, { 344, 382 }, { 344, 353 }, { 344, 354 }, { 344, 373 }, { 344, 374 },  { 44, 400 }, { 44, 401 }, { 44, 402 }, { 44, 420 }, { 44, 421 }, { 44, 422 }, { 344, 401 },  { 344, 402 },  { 344, 421 },  { 344, 422 },  { 344, 411 },  { 344, 412 },  { 344, 431 },  { 344, 432 },  { 44, 950 }, { 44, 960 }, { 344, 950 }, { 344, 960 }, { 344, 955 }, { 344, 965 },  { 44, 800 }, { 44, 810 }, { 344, 800 }, { 344, 810 }, { 344, 805 }, { 344, 815 },  { 44, 920 }, { 44, 930 }, { 344, 920 }, { 344, 930 }, { 344, 925 }, { 344, 935 },  { 44, 970 }, { 44, 980 }, { 344, 970 }, { 344, 980 }, { 344, 975 }, { 344, 985 },   { 44, 70 }, { 344, 70 }, { 344, 75 },  { 44, 50 }, { 344, 55 },  { 44, 40 },  { 344, 45 }, { 344, 40 },  { 44, 80 }, { 344, 85 }, { 344, 80 },  { 44, 60 }, { 344, 65 },  });




 NOUSEM15 = assign({              { 45, 150 }, { 45, 151 }, { 45, 152 }, { 45, 170 }, { 45, 171 }, { 45, 172 }, { 345, 151 }, { 345, 152 }, { 345, 171 }, { 345, 172 }, { 345, 161 }, { 345, 162 }, { 345, 181 }, { 345, 182 },  { 45, 200 }, { 45, 201 }, { 45, 202 }, { 45, 220 }, { 45, 221 }, { 45, 222 }, { 345, 201 }, { 345, 202 }, { 345, 221 }, { 345, 222 }, { 345, 211 }, { 345, 212 }, { 345, 231 }, { 345, 232 },  { 45, 250 }, { 45, 270 }, { 345, 250 }, { 345, 260 }, { 345, 270 }, { 345, 280 },  { 45, 300 }, { 45, 320 }, { 345, 300 }, { 345, 310 }, { 345, 320 }, { 345, 330 },  { 45, 500 }, { 45, 501 }, { 45, 502 }, { 45, 520 }, { 45, 521 }, { 45, 522 }, { 345, 501 }, { 345, 502 }, { 345, 521 }, { 345, 522 }, { 345, 511 }, { 345, 512 }, { 345, 531 }, { 345, 532 },  { 45, 550 }, { 45, 551 }, { 45, 552 }, { 45, 570 }, { 45, 571 }, { 45, 572 }, { 345, 551 }, { 345, 552 }, { 345, 571 }, { 345, 572 }, { 345, 561 }, { 345, 562 }, { 345, 581 }, { 345, 582 },  { 45, 350 }, { 45, 351 }, { 45, 352 }, { 45, 370 }, { 45, 371 }, { 45, 372 }, { 345, 351 }, { 345, 352 }, { 345, 371 }, { 345, 372 }, { 345, 361 }, { 345, 362 }, { 345, 381 }, { 345, 382 }, { 345, 353 }, { 345, 354 }, { 345, 373 }, { 345, 374 },  { 45, 400 }, { 45, 401 }, { 45, 402 }, { 45, 420 }, { 45, 421 }, { 45, 422 }, { 345, 401 },  { 345, 402 },  { 345, 421 },  { 345, 422 },  { 345, 411 },  { 345, 412 },  { 345, 431 },  { 345, 432 },  { 45, 950 }, { 45, 960 }, { 345, 950 }, { 345, 960 }, { 345, 955 }, { 345, 965 },  { 45, 800 }, { 45, 810 }, { 345, 800 }, { 345, 810 }, { 345, 805 }, { 345, 815 },  { 45, 920 }, { 45, 930 }, { 345, 920 }, { 345, 930 }, { 345, 925 }, { 345, 935 },  { 45, 970 }, { 45, 980 }, { 345, 970 }, { 345, 980 }, { 345, 975 }, { 345, 985 },   { 45, 70 }, { 345, 70 }, { 345, 75 },  { 45, 50 }, { 345, 55 },  { 45, 40 },  { 345, 45 }, { 345, 40 },  { 45, 80 }, { 345, 85 }, { 345, 80 },  { 45, 60 }, { 345, 65 },  });




 NOUSEM16 = assign({              { 46, 150 }, { 46, 151 }, { 46, 152 }, { 46, 170 }, { 46, 171 }, { 46, 172 }, { 346, 151 }, { 346, 152 }, { 346, 171 }, { 346, 172 }, { 346, 161 }, { 346, 162 }, { 346, 181 }, { 346, 182 },  { 46, 200 }, { 46, 201 }, { 46, 202 }, { 46, 220 }, { 46, 221 }, { 46, 222 }, { 346, 201 }, { 346, 202 }, { 346, 221 }, { 346, 222 }, { 346, 211 }, { 346, 212 }, { 346, 231 }, { 346, 232 },  { 46, 250 }, { 46, 270 }, { 346, 250 }, { 346, 260 }, { 346, 270 }, { 346, 280 },  { 46, 300 }, { 46, 320 }, { 346, 300 }, { 346, 310 }, { 346, 320 }, { 346, 330 },  { 46, 500 }, { 46, 501 }, { 46, 502 }, { 46, 520 }, { 46, 521 }, { 46, 522 }, { 346, 501 }, { 346, 502 }, { 346, 521 }, { 346, 522 }, { 346, 511 }, { 346, 512 }, { 346, 531 }, { 346, 532 },  { 46, 550 }, { 46, 551 }, { 46, 552 }, { 46, 570 }, { 46, 571 }, { 46, 572 }, { 346, 551 }, { 346, 552 }, { 346, 571 }, { 346, 572 }, { 346, 561 }, { 346, 562 }, { 346, 581 }, { 346, 582 },  { 46, 350 }, { 46, 351 }, { 46, 352 }, { 46, 370 }, { 46, 371 }, { 46, 372 }, { 346, 351 }, { 346, 352 }, { 346, 371 }, { 346, 372 }, { 346, 361 }, { 346, 362 }, { 346, 381 }, { 346, 382 }, { 346, 353 }, { 346, 354 }, { 346, 373 }, { 346, 374 },  { 46, 400 }, { 46, 401 }, { 46, 402 }, { 46, 420 }, { 46, 421 }, { 46, 422 }, { 346, 401 },  { 346, 402 },  { 346, 421 },  { 346, 422 },  { 346, 411 },  { 346, 412 },  { 346, 431 },  { 346, 432 },  { 46, 950 }, { 46, 960 }, { 346, 950 }, { 346, 960 }, { 346, 955 }, { 346, 965 },  { 46, 800 }, { 46, 810 }, { 346, 800 }, { 346, 810 }, { 346, 805 }, { 346, 815 },  { 46, 920 }, { 46, 930 }, { 346, 920 }, { 346, 930 }, { 346, 925 }, { 346, 935 },  { 46, 970 }, { 46, 980 }, { 346, 970 }, { 346, 980 }, { 346, 975 }, { 346, 985 },  { 46, 90 }, { 346, 90 }, { 346, 95 },   { 46, 50 }, { 346, 55 },  { 46, 40 },  { 346, 45 }, { 346, 40 },  { 46, 80 }, { 346, 85 }, { 346, 80 },  { 46, 60 }, { 346, 65 },  });




 NOUSEM17 = assign({              { 47, 150 }, { 47, 151 }, { 47, 152 }, { 47, 170 }, { 47, 171 }, { 47, 172 }, { 347, 151 }, { 347, 152 }, { 347, 171 }, { 347, 172 }, { 347, 161 }, { 347, 162 }, { 347, 181 }, { 347, 182 },  { 47, 200 }, { 47, 201 }, { 47, 202 }, { 47, 220 }, { 47, 221 }, { 47, 222 }, { 347, 201 }, { 347, 202 }, { 347, 221 }, { 347, 222 }, { 347, 211 }, { 347, 212 }, { 347, 231 }, { 347, 232 },  { 47, 250 }, { 47, 270 }, { 347, 250 }, { 347, 260 }, { 347, 270 }, { 347, 280 },  { 47, 300 }, { 47, 320 }, { 347, 300 }, { 347, 310 }, { 347, 320 }, { 347, 330 },  { 47, 500 }, { 47, 501 }, { 47, 502 }, { 47, 520 }, { 47, 521 }, { 47, 522 }, { 347, 501 }, { 347, 502 }, { 347, 521 }, { 347, 522 }, { 347, 511 }, { 347, 512 }, { 347, 531 }, { 347, 532 },  { 47, 550 }, { 47, 551 }, { 47, 552 }, { 47, 570 }, { 47, 571 }, { 47, 572 }, { 347, 551 }, { 347, 552 }, { 347, 571 }, { 347, 572 }, { 347, 561 }, { 347, 562 }, { 347, 581 }, { 347, 582 },  { 47, 350 }, { 47, 351 }, { 47, 352 }, { 47, 370 }, { 47, 371 }, { 47, 372 }, { 347, 351 }, { 347, 352 }, { 347, 371 }, { 347, 372 }, { 347, 361 }, { 347, 362 }, { 347, 381 }, { 347, 382 }, { 347, 353 }, { 347, 354 }, { 347, 373 }, { 347, 374 },  { 47, 400 }, { 47, 401 }, { 47, 402 }, { 47, 420 }, { 47, 421 }, { 47, 422 }, { 347, 401 },  { 347, 402 },  { 347, 421 },  { 347, 422 },  { 347, 411 },  { 347, 412 },  { 347, 431 },  { 347, 432 },  { 47, 950 }, { 47, 960 }, { 347, 950 }, { 347, 960 }, { 347, 955 }, { 347, 965 },  { 47, 800 }, { 47, 810 }, { 347, 800 }, { 347, 810 }, { 347, 805 }, { 347, 815 },  { 47, 920 }, { 47, 930 }, { 347, 920 }, { 347, 930 }, { 347, 925 }, { 347, 935 },  { 47, 970 }, { 47, 980 }, { 347, 970 }, { 347, 980 }, { 347, 975 }, { 347, 985 },  { 47, 90 }, { 347, 90 }, { 347, 95 },   { 47, 50 }, { 347, 55 },  { 47, 40 },  { 347, 45 }, { 347, 40 },  { 47, 80 }, { 347, 85 }, { 347, 80 },  { 47, 60 }, { 347, 65 },  });




 NOUSEM18 = assign({              { 48, 150 }, { 48, 151 }, { 48, 152 }, { 48, 170 }, { 48, 171 }, { 48, 172 }, { 348, 151 }, { 348, 152 }, { 348, 171 }, { 348, 172 }, { 348, 161 }, { 348, 162 }, { 348, 181 }, { 348, 182 },  { 48, 200 }, { 48, 201 }, { 48, 202 }, { 48, 220 }, { 48, 221 }, { 48, 222 }, { 348, 201 }, { 348, 202 }, { 348, 221 }, { 348, 222 }, { 348, 211 }, { 348, 212 }, { 348, 231 }, { 348, 232 },  { 48, 250 }, { 48, 270 }, { 348, 250 }, { 348, 260 }, { 348, 270 }, { 348, 280 },  { 48, 300 }, { 48, 320 }, { 348, 300 }, { 348, 310 }, { 348, 320 }, { 348, 330 },  { 48, 500 }, { 48, 501 }, { 48, 502 }, { 48, 520 }, { 48, 521 }, { 48, 522 }, { 348, 501 }, { 348, 502 }, { 348, 521 }, { 348, 522 }, { 348, 511 }, { 348, 512 }, { 348, 531 }, { 348, 532 },  { 48, 550 }, { 48, 551 }, { 48, 552 }, { 48, 570 }, { 48, 571 }, { 48, 572 }, { 348, 551 }, { 348, 552 }, { 348, 571 }, { 348, 572 }, { 348, 561 }, { 348, 562 }, { 348, 581 }, { 348, 582 },  { 48, 350 }, { 48, 351 }, { 48, 352 }, { 48, 370 }, { 48, 371 }, { 48, 372 }, { 348, 351 }, { 348, 352 }, { 348, 371 }, { 348, 372 }, { 348, 361 }, { 348, 362 }, { 348, 381 }, { 348, 382 }, { 348, 353 }, { 348, 354 }, { 348, 373 }, { 348, 374 },  { 48, 400 }, { 48, 401 }, { 48, 402 }, { 48, 420 }, { 48, 421 }, { 48, 422 }, { 348, 401 },  { 348, 402 },  { 348, 421 },  { 348, 422 },  { 348, 411 },  { 348, 412 },  { 348, 431 },  { 348, 432 },  { 48, 950 }, { 48, 960 }, { 348, 950 }, { 348, 960 }, { 348, 955 }, { 348, 965 },  { 48, 800 }, { 48, 810 }, { 348, 800 }, { 348, 810 }, { 348, 805 }, { 348, 815 },  { 48, 920 }, { 48, 930 }, { 348, 920 }, { 348, 930 }, { 348, 925 }, { 348, 935 },  { 48, 970 }, { 48, 980 }, { 348, 970 }, { 348, 980 }, { 348, 975 }, { 348, 985 },  { 48, 90 }, { 348, 90 }, { 348, 95 },  { 48, 70 }, { 348, 70 }, { 348, 75 },  { 48, 50 }, { 348, 55 },  { 48, 40 },  { 348, 45 }, { 348, 40 },   { 48, 60 }, { 348, 65 },  });




 NOUSEM19 = assign({              { 49, 150 }, { 49, 151 }, { 49, 152 }, { 49, 170 }, { 49, 171 }, { 49, 172 }, { 349, 151 }, { 349, 152 }, { 349, 171 }, { 349, 172 }, { 349, 161 }, { 349, 162 }, { 349, 181 }, { 349, 182 },  { 49, 200 }, { 49, 201 }, { 49, 202 }, { 49, 220 }, { 49, 221 }, { 49, 222 }, { 349, 201 }, { 349, 202 }, { 349, 221 }, { 349, 222 }, { 349, 211 }, { 349, 212 }, { 349, 231 }, { 349, 232 },  { 49, 250 }, { 49, 270 }, { 349, 250 }, { 349, 260 }, { 349, 270 }, { 349, 280 },  { 49, 300 }, { 49, 320 }, { 349, 300 }, { 349, 310 }, { 349, 320 }, { 349, 330 },  { 49, 500 }, { 49, 501 }, { 49, 502 }, { 49, 520 }, { 49, 521 }, { 49, 522 }, { 349, 501 }, { 349, 502 }, { 349, 521 }, { 349, 522 }, { 349, 511 }, { 349, 512 }, { 349, 531 }, { 349, 532 },  { 49, 550 }, { 49, 551 }, { 49, 552 }, { 49, 570 }, { 49, 571 }, { 49, 572 }, { 349, 551 }, { 349, 552 }, { 349, 571 }, { 349, 572 }, { 349, 561 }, { 349, 562 }, { 349, 581 }, { 349, 582 },  { 49, 350 }, { 49, 351 }, { 49, 352 }, { 49, 370 }, { 49, 371 }, { 49, 372 }, { 349, 351 }, { 349, 352 }, { 349, 371 }, { 349, 372 }, { 349, 361 }, { 349, 362 }, { 349, 381 }, { 349, 382 }, { 349, 353 }, { 349, 354 }, { 349, 373 }, { 349, 374 },  { 49, 400 }, { 49, 401 }, { 49, 402 }, { 49, 420 }, { 49, 421 }, { 49, 422 }, { 349, 401 },  { 349, 402 },  { 349, 421 },  { 349, 422 },  { 349, 411 },  { 349, 412 },  { 349, 431 },  { 349, 432 },  { 49, 950 }, { 49, 960 }, { 349, 950 }, { 349, 960 }, { 349, 955 }, { 349, 965 },  { 49, 800 }, { 49, 810 }, { 349, 800 }, { 349, 810 }, { 349, 805 }, { 349, 815 },  { 49, 920 }, { 49, 930 }, { 349, 920 }, { 349, 930 }, { 349, 925 }, { 349, 935 },  { 49, 970 }, { 49, 980 }, { 349, 970 }, { 349, 980 }, { 349, 975 }, { 349, 985 },  { 49, 90 }, { 349, 90 }, { 349, 95 },  { 49, 70 }, { 349, 70 }, { 349, 75 },  { 49, 50 }, { 349, 55 },  { 49, 40 },  { 349, 45 }, { 349, 40 },   { 49, 60 }, { 349, 65 },  });





VIA0 = assign({ { 50, 200 } });

DVIA0_O = assign({ { 350, 200 } }, layer_intent = { LAYER_INTENT_FILL });


VIA1  = assign({ { 51, 200 } });
DVIA1_O = assign({ { 351, 200 } }, layer_intent = { LAYER_INTENT_FILL });


VIA2 = assign({ { 52, 250 } });
DVIA2_O = assign({ { 352, 250 } }, layer_intent = { LAYER_INTENT_FILL });


VIA3 = assign({ { 53, 300 } });
VIA3_CA = assign({ { 53, 301 } });
VIA3_CB = assign({ { 53, 302 } });
DVIA3_O_CA = assign({ { 353, 301 } }, layer_intent = { LAYER_INTENT_FILL });
DVIA3_O_CB = assign({ { 353, 302 } }, layer_intent = { LAYER_INTENT_FILL });
VIA3_CA_HINT = assign({ { 53, 131 } });
VIA3_CB_HINT = assign({ { 53, 132 } });
VIA3_DA = assign({ { 53, 321 } });
VIA3_DB = assign({ { 53, 322 } });


VIA4 = assign({ { 54, 350 } });
VIA4_CA = assign({ { 54, 351 } });
VIA4_CB = assign({ { 54, 352 } });
DVIA4_O_CA = assign({ { 354, 351 } }, layer_intent = { LAYER_INTENT_FILL });
DVIA4_O_CB = assign({ { 354, 352 } }, layer_intent = { LAYER_INTENT_FILL });
VIA4_DA = assign({ { 54, 371 } });
VIA4_DB = assign({ { 54, 372 } });


VIA5 = assign({ { 55, 950 } });
DVIA5 = assign({ { 355, 955 } }, layer_intent = { LAYER_INTENT_FILL });
DVIA5_O = assign({ { 355, 950 } }, layer_intent = { LAYER_INTENT_FILL });


VIA6 = assign({ { 56, 800 } });
DVIA6 = assign({ { 356, 805 } }, layer_intent = { LAYER_INTENT_FILL });
DVIA6_O = assign({ { 356, 800 } }, layer_intent = { LAYER_INTENT_FILL });


VIA7 = assign({ { 57, 970 } });
DVIA7 = assign({ { 357, 975 } }, layer_intent = { LAYER_INTENT_FILL });
DVIA7_O = assign({ { 357, 970 } }, layer_intent = { LAYER_INTENT_FILL });


VIA8 = assign({ { 58, 970 } });
DVIA8 = assign({ { 358, 975 } }, layer_intent = { LAYER_INTENT_FILL });
DVIA8_O = assign({ { 358, 970 } }, layer_intent = { LAYER_INTENT_FILL });


VIA9 = assign({ { 59, 970 } });
DVIA9 = assign({ { 359, 975 } }, layer_intent = { LAYER_INTENT_FILL });
DVIA9_O = assign({ { 359, 970 } }, layer_intent = { LAYER_INTENT_FILL });


VIA10 = assign({ { 60, 970 } });
DVIA10 = assign({ { 360, 975 } }, layer_intent = { LAYER_INTENT_FILL });
DVIA10_O = assign({ { 360, 970 } }, layer_intent = { LAYER_INTENT_FILL });


VIA11 = assign({ { 61, 970 } });
DVIA11 = assign({ { 361, 975 } }, layer_intent = { LAYER_INTENT_FILL });
DVIA11_O = assign({ { 361, 970 } }, layer_intent = { LAYER_INTENT_FILL });


VIA12 = assign({ { 62, 970 } });
DVIA12 = assign({ { 362, 975 } }, layer_intent = { LAYER_INTENT_FILL });
DVIA12_O = assign({ { 362, 970 } }, layer_intent = { LAYER_INTENT_FILL });


VIA13 = assign({ { 63, 90 } });
DVIA13 = assign({ { 363, 95 } }, layer_intent = { LAYER_INTENT_FILL });
DVIA13_O = assign({ { 363, 90 } }, layer_intent = { LAYER_INTENT_FILL });


VIA14 = assign({ { 64, 90 } });
DVIA14 = assign({ { 364, 95 } }, layer_intent = { LAYER_INTENT_FILL });
DVIA14_O = assign({ { 364, 90 } }, layer_intent = { LAYER_INTENT_FILL });


VIA15 = assign({ { 65, 70 } });
DVIA15 = assign({ { 365, 75 } }, layer_intent = { LAYER_INTENT_FILL });


VIA16 = assign({ { 66, 70 } });
DVIA16 = assign({ { 366, 75 } }, layer_intent = { LAYER_INTENT_FILL });


VIA17 = assign({ { 67, 80 } });


VIA18 = assign({ { 68, 80 } });



 NOUSEV1 = assign({  { 51, 150 }, { 51, 171 }, { 51, 172 }, { 351, 151 }, { 351, 152 }, { 51, 101 }, { 51, 102 },   { 51, 250 }, { 351, 250 },  { 51, 300 }, { 51, 301 }, { 51, 302 }, { 51, 321 }, { 51, 322 }, { 351, 301 }, { 351, 302 }, { 51, 131 }, { 51, 132 },  { 51, 500 }, { 351, 500 },  { 51, 550 }, { 51, 551 }, { 51, 552 }, { 51, 571 }, { 51, 572 }, { 351, 551 }, { 351, 552 },  { 51, 350 }, { 51, 351 }, { 51, 352 }, { 51, 371 }, { 51, 372 }, { 351, 351 }, { 351, 352 },  { 51, 400 }, { 351, 400 },  { 51, 950 }, { 351, 955 }, { 351, 950 },  { 51, 800 }, { 351, 805 }, { 351, 800 },  { 51, 920 }, { 351, 925 },  { 51, 970 }, { 351, 975 }, { 351, 970 },  { 51, 90 }, { 351, 95 }, { 351, 90 },  { 51, 70 }, { 351, 75 },  { 51, 50 },  { 51, 40 }, { 351, 45 },  { 51, 80 },  { 51, 60 },  });



 NOUSEV2 = assign({  { 52, 150 }, { 52, 171 }, { 52, 172 }, { 352, 151 }, { 352, 152 }, { 52, 101 }, { 52, 102 },  { 52, 200 }, { 352, 200 },   { 52, 300 }, { 52, 301 }, { 52, 302 }, { 52, 321 }, { 52, 322 }, { 352, 301 }, { 352, 302 }, { 52, 131 }, { 52, 132 },  { 52, 500 }, { 352, 500 },  { 52, 550 }, { 52, 551 }, { 52, 552 }, { 52, 571 }, { 52, 572 }, { 352, 551 }, { 352, 552 },  { 52, 350 }, { 52, 351 }, { 52, 352 }, { 52, 371 }, { 52, 372 }, { 352, 351 }, { 352, 352 },  { 52, 400 }, { 352, 400 },  { 52, 950 }, { 352, 955 }, { 352, 950 },  { 52, 800 }, { 352, 805 }, { 352, 800 },  { 52, 920 }, { 352, 925 },  { 52, 970 }, { 352, 975 }, { 352, 970 },  { 52, 90 }, { 352, 95 }, { 352, 90 },  { 52, 70 }, { 352, 75 },  { 52, 50 },  { 52, 40 }, { 352, 45 },  { 52, 80 },  { 52, 60 },  });



 NOUSEV3 = assign({  { 53, 150 }, { 53, 171 }, { 53, 172 }, { 353, 151 }, { 353, 152 }, { 53, 101 }, { 53, 102 },  { 53, 200 }, { 353, 200 },  { 53, 250 }, { 353, 250 },   { 53, 500 }, { 353, 500 },  { 53, 550 }, { 53, 551 }, { 53, 552 }, { 53, 571 }, { 53, 572 }, { 353, 551 }, { 353, 552 },  { 53, 350 }, { 53, 351 }, { 53, 352 }, { 53, 371 }, { 53, 372 }, { 353, 351 }, { 353, 352 },  { 53, 400 }, { 353, 400 },  { 53, 950 }, { 353, 955 }, { 353, 950 },  { 53, 800 }, { 353, 805 }, { 353, 800 },  { 53, 920 }, { 353, 925 },  { 53, 970 }, { 353, 975 }, { 353, 970 },  { 53, 90 }, { 353, 95 }, { 353, 90 },  { 53, 70 }, { 353, 75 },  { 53, 50 },  { 53, 40 }, { 353, 45 },  { 53, 80 },  { 53, 60 },  });



 NOUSEV4 = assign({  { 54, 150 }, { 54, 171 }, { 54, 172 }, { 354, 151 }, { 354, 152 }, { 54, 101 }, { 54, 102 },  { 54, 200 }, { 354, 200 },  { 54, 250 }, { 354, 250 },  { 54, 300 }, { 54, 301 }, { 54, 302 }, { 54, 321 }, { 54, 322 }, { 354, 301 }, { 354, 302 }, { 54, 131 }, { 54, 132 },  { 54, 500 }, { 354, 500 },  { 54, 550 }, { 54, 551 }, { 54, 552 }, { 54, 571 }, { 54, 572 }, { 354, 551 }, { 354, 552 },   { 54, 400 }, { 354, 400 },  { 54, 950 }, { 354, 955 }, { 354, 950 },  { 54, 800 }, { 354, 805 }, { 354, 800 },  { 54, 920 }, { 354, 925 },  { 54, 970 }, { 354, 975 }, { 354, 970 },  { 54, 90 }, { 354, 95 }, { 354, 90 },  { 54, 70 }, { 354, 75 },  { 54, 50 },  { 54, 40 }, { 354, 45 },  { 54, 80 },  { 54, 60 },  });



 NOUSEV5 = assign({  { 55, 150 }, { 55, 171 }, { 55, 172 }, { 355, 151 }, { 355, 152 }, { 55, 101 }, { 55, 102 },  { 55, 200 }, { 355, 200 },  { 55, 250 }, { 355, 250 },  { 55, 300 }, { 55, 301 }, { 55, 302 }, { 55, 321 }, { 55, 322 }, { 355, 301 }, { 355, 302 }, { 55, 131 }, { 55, 132 },  { 55, 500 }, { 355, 500 },  { 55, 550 }, { 55, 551 }, { 55, 552 }, { 55, 571 }, { 55, 572 }, { 355, 551 }, { 355, 552 },  { 55, 350 }, { 55, 351 }, { 55, 352 }, { 55, 371 }, { 55, 372 }, { 355, 351 }, { 355, 352 },  { 55, 400 }, { 355, 400 },   { 55, 800 }, { 355, 805 }, { 355, 800 },  { 55, 920 }, { 355, 925 },  { 55, 970 }, { 355, 975 }, { 355, 970 },  { 55, 90 }, { 355, 95 }, { 355, 90 },  { 55, 70 }, { 355, 75 },  { 55, 50 },  { 55, 40 }, { 355, 45 },  { 55, 80 },  { 55, 60 },  });



 NOUSEV6 = assign({  { 56, 150 }, { 56, 171 }, { 56, 172 }, { 356, 151 }, { 356, 152 }, { 56, 101 }, { 56, 102 },  { 56, 200 }, { 356, 200 },  { 56, 250 }, { 356, 250 },  { 56, 300 }, { 56, 301 }, { 56, 302 }, { 56, 321 }, { 56, 322 }, { 356, 301 }, { 356, 302 }, { 56, 131 }, { 56, 132 },  { 56, 500 }, { 356, 500 },  { 56, 550 }, { 56, 551 }, { 56, 552 }, { 56, 571 }, { 56, 572 }, { 356, 551 }, { 356, 552 },  { 56, 350 }, { 56, 351 }, { 56, 352 }, { 56, 371 }, { 56, 372 }, { 356, 351 }, { 356, 352 },  { 56, 400 }, { 356, 400 },  { 56, 950 }, { 356, 955 }, { 356, 950 },   { 56, 920 }, { 356, 925 },  { 56, 970 }, { 356, 975 }, { 356, 970 },  { 56, 90 }, { 356, 95 }, { 356, 90 },  { 56, 70 }, { 356, 75 },  { 56, 50 },  { 56, 40 }, { 356, 45 },  { 56, 80 },  { 56, 60 },  });



 NOUSEV7 = assign({  { 57, 150 }, { 57, 171 }, { 57, 172 }, { 357, 151 }, { 357, 152 }, { 57, 101 }, { 57, 102 },  { 57, 200 }, { 357, 200 },  { 57, 250 }, { 357, 250 },  { 57, 300 }, { 57, 301 }, { 57, 302 }, { 57, 321 }, { 57, 322 }, { 357, 301 }, { 357, 302 }, { 57, 131 }, { 57, 132 },  { 57, 500 }, { 357, 500 },  { 57, 550 }, { 57, 551 }, { 57, 552 }, { 57, 571 }, { 57, 572 }, { 357, 551 }, { 357, 552 },  { 57, 350 }, { 57, 351 }, { 57, 352 }, { 57, 371 }, { 57, 372 }, { 357, 351 }, { 357, 352 },  { 57, 400 }, { 357, 400 },  { 57, 950 }, { 357, 955 }, { 357, 950 },  { 57, 800 }, { 357, 805 }, { 357, 800 },  { 57, 920 }, { 357, 925 },   { 57, 90 }, { 357, 95 }, { 357, 90 },  { 57, 70 }, { 357, 75 },  { 57, 50 },  { 57, 40 }, { 357, 45 },  { 57, 80 },  { 57, 60 },  });



 NOUSEV8 = assign({  { 58, 150 }, { 58, 171 }, { 58, 172 }, { 358, 151 }, { 358, 152 }, { 58, 101 }, { 58, 102 },  { 58, 200 }, { 358, 200 },  { 58, 250 }, { 358, 250 },  { 58, 300 }, { 58, 301 }, { 58, 302 }, { 58, 321 }, { 58, 322 }, { 358, 301 }, { 358, 302 }, { 58, 131 }, { 58, 132 },  { 58, 500 }, { 358, 500 },  { 58, 550 }, { 58, 551 }, { 58, 552 }, { 58, 571 }, { 58, 572 }, { 358, 551 }, { 358, 552 },  { 58, 350 }, { 58, 351 }, { 58, 352 }, { 58, 371 }, { 58, 372 }, { 358, 351 }, { 358, 352 },  { 58, 400 }, { 358, 400 },  { 58, 950 }, { 358, 955 }, { 358, 950 },  { 58, 800 }, { 358, 805 }, { 358, 800 },  { 58, 920 }, { 358, 925 },   { 58, 90 }, { 358, 95 }, { 358, 90 },  { 58, 70 }, { 358, 75 },  { 58, 50 },  { 58, 40 }, { 358, 45 },  { 58, 80 },  { 58, 60 },  });



 NOUSEV9 = assign({  { 59, 150 }, { 59, 171 }, { 59, 172 }, { 359, 151 }, { 359, 152 }, { 59, 101 }, { 59, 102 },  { 59, 200 }, { 359, 200 },  { 59, 250 }, { 359, 250 },  { 59, 300 }, { 59, 301 }, { 59, 302 }, { 59, 321 }, { 59, 322 }, { 359, 301 }, { 359, 302 }, { 59, 131 }, { 59, 132 },  { 59, 500 }, { 359, 500 },  { 59, 550 }, { 59, 551 }, { 59, 552 }, { 59, 571 }, { 59, 572 }, { 359, 551 }, { 359, 552 },  { 59, 350 }, { 59, 351 }, { 59, 352 }, { 59, 371 }, { 59, 372 }, { 359, 351 }, { 359, 352 },  { 59, 400 }, { 359, 400 },  { 59, 950 }, { 359, 955 }, { 359, 950 },  { 59, 800 }, { 359, 805 }, { 359, 800 },  { 59, 920 }, { 359, 925 },   { 59, 90 }, { 359, 95 }, { 359, 90 },  { 59, 70 }, { 359, 75 },  { 59, 50 },  { 59, 40 }, { 359, 45 },  { 59, 80 },  { 59, 60 },  });



 NOUSEV10 = assign({  { 60, 150 }, { 60, 171 }, { 60, 172 }, { 360, 151 }, { 360, 152 }, { 60, 101 }, { 60, 102 },  { 60, 200 }, { 360, 200 },  { 60, 250 }, { 360, 250 },  { 60, 300 }, { 60, 301 }, { 60, 302 }, { 60, 321 }, { 60, 322 }, { 360, 301 }, { 360, 302 }, { 60, 131 }, { 60, 132 },  { 60, 500 }, { 360, 500 },  { 60, 550 }, { 60, 551 }, { 60, 552 }, { 60, 571 }, { 60, 572 }, { 360, 551 }, { 360, 552 },  { 60, 350 }, { 60, 351 }, { 60, 352 }, { 60, 371 }, { 60, 372 }, { 360, 351 }, { 360, 352 },  { 60, 400 }, { 360, 400 },  { 60, 950 }, { 360, 955 }, { 360, 950 },  { 60, 800 }, { 360, 805 }, { 360, 800 },  { 60, 920 }, { 360, 925 },   { 60, 90 }, { 360, 95 }, { 360, 90 },  { 60, 70 }, { 360, 75 },  { 60, 50 },  { 60, 40 }, { 360, 45 },  { 60, 80 },  { 60, 60 },  });



 NOUSEV11 = assign({  { 61, 150 }, { 61, 171 }, { 61, 172 }, { 361, 151 }, { 361, 152 }, { 61, 101 }, { 61, 102 },  { 61, 200 }, { 361, 200 },  { 61, 250 }, { 361, 250 },  { 61, 300 }, { 61, 301 }, { 61, 302 }, { 61, 321 }, { 61, 322 }, { 361, 301 }, { 361, 302 }, { 61, 131 }, { 61, 132 },  { 61, 500 }, { 361, 500 },  { 61, 550 }, { 61, 551 }, { 61, 552 }, { 61, 571 }, { 61, 572 }, { 361, 551 }, { 361, 552 },  { 61, 350 }, { 61, 351 }, { 61, 352 }, { 61, 371 }, { 61, 372 }, { 361, 351 }, { 361, 352 },  { 61, 400 }, { 361, 400 },  { 61, 950 }, { 361, 955 }, { 361, 950 },  { 61, 800 }, { 361, 805 }, { 361, 800 },  { 61, 920 }, { 361, 925 },   { 61, 90 }, { 361, 95 }, { 361, 90 },  { 61, 70 }, { 361, 75 },  { 61, 50 },  { 61, 40 }, { 361, 45 },  { 61, 80 },  { 61, 60 },  });



 NOUSEV12 = assign({  { 62, 150 }, { 62, 171 }, { 62, 172 }, { 362, 151 }, { 362, 152 }, { 62, 101 }, { 62, 102 },  { 62, 200 }, { 362, 200 },  { 62, 250 }, { 362, 250 },  { 62, 300 }, { 62, 301 }, { 62, 302 }, { 62, 321 }, { 62, 322 }, { 362, 301 }, { 362, 302 }, { 62, 131 }, { 62, 132 },  { 62, 500 }, { 362, 500 },  { 62, 550 }, { 62, 551 }, { 62, 552 }, { 62, 571 }, { 62, 572 }, { 362, 551 }, { 362, 552 },  { 62, 350 }, { 62, 351 }, { 62, 352 }, { 62, 371 }, { 62, 372 }, { 362, 351 }, { 362, 352 },  { 62, 400 }, { 362, 400 },  { 62, 950 }, { 362, 955 }, { 362, 950 },  { 62, 800 }, { 362, 805 }, { 362, 800 },  { 62, 920 }, { 362, 925 },   { 62, 90 }, { 362, 95 }, { 362, 90 },  { 62, 70 }, { 362, 75 },  { 62, 50 },  { 62, 40 }, { 362, 45 },  { 62, 80 },  { 62, 60 },  });



 NOUSEV13 = assign({  { 63, 150 }, { 63, 171 }, { 63, 172 }, { 363, 151 }, { 363, 152 }, { 63, 101 }, { 63, 102 },  { 63, 200 }, { 363, 200 },  { 63, 250 }, { 363, 250 },  { 63, 300 }, { 63, 301 }, { 63, 302 }, { 63, 321 }, { 63, 322 }, { 363, 301 }, { 363, 302 }, { 63, 131 }, { 63, 132 },  { 63, 500 }, { 363, 500 },  { 63, 550 }, { 63, 551 }, { 63, 552 }, { 63, 571 }, { 63, 572 }, { 363, 551 }, { 363, 552 },  { 63, 350 }, { 63, 351 }, { 63, 352 }, { 63, 371 }, { 63, 372 }, { 363, 351 }, { 363, 352 },  { 63, 400 }, { 363, 400 },  { 63, 950 }, { 363, 955 }, { 363, 950 },  { 63, 800 }, { 363, 805 }, { 363, 800 },  { 63, 920 }, { 363, 925 },  { 63, 970 }, { 363, 975 }, { 363, 970 },   { 63, 70 }, { 363, 75 },  { 63, 50 },  { 63, 40 }, { 363, 45 },  { 63, 80 },  { 63, 60 },  });



 NOUSEV14 = assign({  { 64, 150 }, { 64, 171 }, { 64, 172 }, { 364, 151 }, { 364, 152 }, { 64, 101 }, { 64, 102 },  { 64, 200 }, { 364, 200 },  { 64, 250 }, { 364, 250 },  { 64, 300 }, { 64, 301 }, { 64, 302 }, { 64, 321 }, { 64, 322 }, { 364, 301 }, { 364, 302 }, { 64, 131 }, { 64, 132 },  { 64, 500 }, { 364, 500 },  { 64, 550 }, { 64, 551 }, { 64, 552 }, { 64, 571 }, { 64, 572 }, { 364, 551 }, { 364, 552 },  { 64, 350 }, { 64, 351 }, { 64, 352 }, { 64, 371 }, { 64, 372 }, { 364, 351 }, { 364, 352 },  { 64, 400 }, { 364, 400 },  { 64, 950 }, { 364, 955 }, { 364, 950 },  { 64, 800 }, { 364, 805 }, { 364, 800 },  { 64, 920 }, { 364, 925 },  { 64, 970 }, { 364, 975 }, { 364, 970 },   { 64, 70 }, { 364, 75 },  { 64, 50 },  { 64, 40 }, { 364, 45 },  { 64, 80 },  { 64, 60 },  });



 NOUSEV15 = assign({  { 65, 150 }, { 65, 171 }, { 65, 172 }, { 365, 151 }, { 365, 152 }, { 65, 101 }, { 65, 102 },  { 65, 200 }, { 365, 200 },  { 65, 250 }, { 365, 250 },  { 65, 300 }, { 65, 301 }, { 65, 302 }, { 65, 321 }, { 65, 322 }, { 365, 301 }, { 365, 302 }, { 65, 131 }, { 65, 132 },  { 65, 500 }, { 365, 500 },  { 65, 550 }, { 65, 551 }, { 65, 552 }, { 65, 571 }, { 65, 572 }, { 365, 551 }, { 365, 552 },  { 65, 350 }, { 65, 351 }, { 65, 352 }, { 65, 371 }, { 65, 372 }, { 365, 351 }, { 365, 352 },  { 65, 400 }, { 365, 400 },  { 65, 950 }, { 365, 955 }, { 365, 950 },  { 65, 800 }, { 365, 805 }, { 365, 800 },  { 65, 920 }, { 365, 925 },  { 65, 970 }, { 365, 975 }, { 365, 970 },  { 65, 90 }, { 365, 95 }, { 365, 90 },   { 65, 50 },  { 65, 40 }, { 365, 45 },  { 65, 80 },  { 65, 60 },  });



 NOUSEV16 = assign({  { 66, 150 }, { 66, 171 }, { 66, 172 }, { 366, 151 }, { 366, 152 }, { 66, 101 }, { 66, 102 },  { 66, 200 }, { 366, 200 },  { 66, 250 }, { 366, 250 },  { 66, 300 }, { 66, 301 }, { 66, 302 }, { 66, 321 }, { 66, 322 }, { 366, 301 }, { 366, 302 }, { 66, 131 }, { 66, 132 },  { 66, 500 }, { 366, 500 },  { 66, 550 }, { 66, 551 }, { 66, 552 }, { 66, 571 }, { 66, 572 }, { 366, 551 }, { 366, 552 },  { 66, 350 }, { 66, 351 }, { 66, 352 }, { 66, 371 }, { 66, 372 }, { 366, 351 }, { 366, 352 },  { 66, 400 }, { 366, 400 },  { 66, 950 }, { 366, 955 }, { 366, 950 },  { 66, 800 }, { 366, 805 }, { 366, 800 },  { 66, 920 }, { 366, 925 },  { 66, 970 }, { 366, 975 }, { 366, 970 },  { 66, 90 }, { 366, 95 }, { 366, 90 },   { 66, 50 },  { 66, 40 }, { 366, 45 },  { 66, 80 },  { 66, 60 },  });



 NOUSEV17 = assign({  { 67, 150 }, { 67, 171 }, { 67, 172 }, { 367, 151 }, { 367, 152 }, { 67, 101 }, { 67, 102 },  { 67, 200 }, { 367, 200 },  { 67, 250 }, { 367, 250 },  { 67, 300 }, { 67, 301 }, { 67, 302 }, { 67, 321 }, { 67, 322 }, { 367, 301 }, { 367, 302 }, { 67, 131 }, { 67, 132 },  { 67, 500 }, { 367, 500 },  { 67, 550 }, { 67, 551 }, { 67, 552 }, { 67, 571 }, { 67, 572 }, { 367, 551 }, { 367, 552 },  { 67, 350 }, { 67, 351 }, { 67, 352 }, { 67, 371 }, { 67, 372 }, { 367, 351 }, { 367, 352 },  { 67, 400 }, { 367, 400 },  { 67, 950 }, { 367, 955 }, { 367, 950 },  { 67, 800 }, { 367, 805 }, { 367, 800 },  { 67, 920 }, { 367, 925 },  { 67, 970 }, { 367, 975 }, { 367, 970 },  { 67, 90 }, { 367, 95 }, { 367, 90 },  { 67, 70 }, { 367, 75 },  { 67, 50 },  { 67, 40 }, { 367, 45 },   { 67, 60 },  });



 NOUSEV18 = assign({  { 68, 150 }, { 68, 171 }, { 68, 172 }, { 368, 151 }, { 368, 152 }, { 68, 101 }, { 68, 102 },  { 68, 200 }, { 368, 200 },  { 68, 250 }, { 368, 250 },  { 68, 300 }, { 68, 301 }, { 68, 302 }, { 68, 321 }, { 68, 322 }, { 368, 301 }, { 368, 302 }, { 68, 131 }, { 68, 132 },  { 68, 500 }, { 368, 500 },  { 68, 550 }, { 68, 551 }, { 68, 552 }, { 68, 571 }, { 68, 572 }, { 368, 551 }, { 368, 552 },  { 68, 350 }, { 68, 351 }, { 68, 352 }, { 68, 371 }, { 68, 372 }, { 368, 351 }, { 368, 352 },  { 68, 400 }, { 368, 400 },  { 68, 950 }, { 368, 955 }, { 368, 950 },  { 68, 800 }, { 368, 805 }, { 368, 800 },  { 68, 920 }, { 368, 925 },  { 68, 970 }, { 368, 975 }, { 368, 970 },  { 68, 90 }, { 368, 95 }, { 368, 90 },  { 68, 70 }, { 368, 75 },  { 68, 50 },  { 68, 40 }, { 368, 45 },   { 68, 60 },  });




/* M0 must-join pin marker used for must-join checking */
M0_PIN_MRK  = assign({ { 630, 0 } });
/* DRC marker layer to waive MJ_M* violations */
MJ_WAV = assign({ { 630, 1 } });
/* M0 must-join pin marker used for must-join checking */
M0_MJ_PIN_0 = assign({ { 630, 20 } }); 
/* M0 must-join pin marker used for must-join checking */
M0_MJ_PIN_1 = assign({ { 630, 21 } }); 
/* M0 must-join pin marker used for must-join checking */
M0_MJ_PIN_2 = assign({ { 630, 22 } }); 
/* M0 must-join pin marker used for must-join checking */
M0_MJ_PIN_3 = assign({ { 630, 23 } }); 
/* M0 must-join pin marker used for must-join checking */
M0_MJ_PIN_4 = assign({ { 630, 24 } }); 
/* M0 must-join Grp marker used for must-join checking */
M0_MJ_GRP_0 = assign({ { 630, 40 } }); 
/* M0 must-join Grp marker used for must-join checking */
M0_MJ_GRP_1 = assign({ { 630, 41 } }); 
/* M0 must-join Grp marker used for must-join checking */
M0_MJ_GRP_2 = assign({ { 630, 42 } }); 
/* M0 must-join Grp marker used for must-join checking */
M0_MJ_GRP_3 = assign({ { 630, 43 } }); 
/* M0 must-join Grp marker used for must-join checking */
M0_MJ_GRP_4 = assign({ { 630, 44 } }); 


/* M1 must-join pin marker used for must-join checking */
M1_PIN_MRK  = assign({ { 631, 0 } }); 
/* M1 must-join pin marker used for must-join checking */
M1_MJ_PIN_0 = assign({ { 631, 20 } }); 
/* M1 must-join pin marker used for must-join checking */
M1_MJ_PIN_1 = assign({ { 631, 21 } }); 
/* M1 must-join pin marker used for must-join checking */
M1_MJ_PIN_2 = assign({ { 631, 22 } }); 
/* M1 must-join pin marker used for must-join checking */
M1_MJ_PIN_3 = assign({ { 631, 23 } }); 
/* M1 must-join pin marker used for must-join checking */
M1_MJ_PIN_4 = assign({ { 631, 24 } }); 
/* M1 must-join Grp marker used for must-join checking */
M1_MJ_GRP_0 = assign({ { 631, 40 } }); 
/* M1 must-join Grp marker used for must-join checking */
M1_MJ_GRP_1 = assign({ { 631, 41 } }); 
/* M1 must-join Grp marker used for must-join checking */
M1_MJ_GRP_2 = assign({ { 631, 42 } }); 
/* M1 must-join Grp marker used for must-join checking */
M1_MJ_GRP_3 = assign({ { 631, 43 } }); 
/* M1 must-join Grp marker used for must-join checking */
M1_MJ_GRP_4 = assign({ { 631, 44 } }); 

/* M2 must-join pin marker used for must-join checking */
M2_PIN_MRK  = assign({ { 632, 0 } }); 
/* M2 must-join pin marker used for must-join checking */
M2_MJ_PIN_0 = assign({ { 632, 20 } }); 
/* M2 must-join pin marker used for must-join checking */
M2_MJ_PIN_1 = assign({ { 632, 21 } }); 
/* M2 must-join pin marker used for must-join checking */
M2_MJ_PIN_2 = assign({ { 632, 22 } }); 
/* M2 must-join pin marker used for must-join checking */
M2_MJ_PIN_3 = assign({ { 632, 23 } }); 
/* M2 must-join pin marker used for must-join checking */
M2_MJ_PIN_4 = assign({ { 632, 24 } }); 
/* M2 must-join Grp marker used for must-join checking */
M2_MJ_GRP_0 = assign({ { 632, 40 } }); 
/* M2 must-join Grp marker used for must-join checking */
M2_MJ_GRP_1 = assign({ { 632, 41 } }); 
/* M2 must-join Grp marker used for must-join checking */
M2_MJ_GRP_2 = assign({ { 632, 42 } }); 
/* M2 must-join Grp marker used for must-join checking */
M2_MJ_GRP_3 = assign({ { 632, 43 } }); 
/* M2 must-join Grp marker used for must-join checking */
M2_MJ_GRP_4 = assign({ { 632, 44 } }); 

/* ICOVL pattern layers, forbid to use */
NOUSE_ICOVL = assign({ { 165, [80, 309] }, { 165, 321 }, { 165, [500, 514] }, { 165, [870, 879] } }); 



/* Beginning of rule select section */
/* End of rule select section */

FORBID_31_170 = assign({ { 31, 170 } }); // N3 layer, cannot be used in N3E

FORBID_31_171 = assign({ { 31, 171 } }); // N3 layer, cannot be used in N3E

FORBID_31_172 = assign({ { 31, 172 } }); // N3 layer, cannot be used in N3E

FORBID_50_101 = assign({ { 50, 101 } }); // N3 layer, cannot be used in N3E

FORBID_50_102 = assign({ { 50, 102 } }); // N3 layer, cannot be used in N3E

FORBID_50_150 = assign({ { 50, 150 } }); // N3 layer, cannot be used in N3E

FORBID_50_151 = assign({ { 50, 151 } }); // N3 layer, cannot be used in N3E

FORBID_50_152 = assign({ { 50, 152 } }); // N3 layer, cannot be used in N3E

FORBID_50_171 = assign({ { 50, 171 } }); // N3 layer, cannot be used in N3E

FORBID_50_172 = assign({ { 50, 172 } }); // N3 layer, cannot be used in N3E

FORBID_331_171 = assign({ { 331, 171 } }); // N3 layer, cannot be used in N3E

FORBID_331_172 = assign({ { 331, 172 } }); // N3 layer, cannot be used in N3E

FORBID_331_181 = assign({ { 331, 181 } }); // N3 layer, cannot be used in N3E

FORBID_331_182 = assign({ { 331, 182 } }); // N3 layer, cannot be used in N3E

FORBID_350_151 = assign({ { 350, 151 } }); // N3 layer, cannot be used in N3E

FORBID_350_152 = assign({ { 350, 152 } }); // N3 layer, cannot be used in N3E

FORBID_255_125 = assign({ { 255, 125 } }); // N3 layer, cannot be used in N3E

FORBID_255_126 = assign({ { 255, 126 } }); // N3 layer, cannot be used in N3E

FORBID_255_127 = assign({ { 255, 127 } }); // N3 layer, cannot be used in N3E

FORBID_431_170 = assign({ { 431, 170 } }); // N3 layer, cannot be used in N3E

FORBID_431_175 = assign({ { 431, 175 } }); // N3 layer, cannot be used in N3E

FORBID_531_170 = assign({ { 531, 170 } }); // N3 layer, cannot be used in N3E

FORBID_531_175 = assign({ { 531, 175 } }); // N3 layer, cannot be used in N3E




METAL_ABOVE_TOP = assign({ { 550 } });

VIA_ABOVE_TOP = assign({ { 69 } });



CHIPWINDOW = assign({ { 1000 } }); // Pseduo layer to construct chip boundary by user's input coordinate  





#pragma icv insert patch_assigns

/* Added from other EV files */







CHIP_MT = layer_extent_list({
 APBLK, INDDMY_APCHECK, CHIP_BOUNDARY, PRBOUNDARY, TD_CHIP_BOUNDARY, TDSBOUNDARY, ARL_S_F2F, ARL_S_F2F_T1, ARL_S_F2F_T2, ARL_S_F2F_T3, ARL_S_F2F_T4, ARL_S_F2F_T5, ARL_S_F2B, ARL_S_F2B_T1, ARL_S_F2B_T2, ARL_S_F2B_T3, ARL_S_F2B_T4, ARL_S_F2B_T5, ARL_C_TDUB, ARL_I_TDBP, ARL_I_BDBP, ARL_I_TDPM0, ARL_I_INFO3D, ARL_F_TD, ARL_DOW_TDUB, ARL_WOW, ARL_WOW_T1, ARL_WOW_T2, ARL_WOW_T3, ARL_WOW_T4, ARL_WOW_T5, ARL_S_F2F_TF, ARL_S_F2F_T1_FC, ARL_S_F2F_T1_INFO, ARL_S_F2F_T1_DOW, ARL_S_F2F_T1_COWOS, ARL_S_F2F_T1_INFO3D, ARL_S_F2B_TF, ARL_S_F2B_T1_FC, ARL_S_F2B_T1_INFO, ARL_S_F2B_T1_DOW, ARL_S_F2B_T1_COWOS, ARL_S_F2B_T1_INFO3D, ARL_WOW_BD, ARL_WOW_TD_FC, ARL_WOW_TD_INFO, ARL_WOW_TD_DOW, ARL_WOW_TD_COWOS, ARL_WOW_TD_INFO3D, FB_1, FB_2, FB_3, FB_4, FB_5, FB_6, FB_7, FB_8, FB_9, FB_10, FB_11, FB_12, FB_13, FB_14, FB_15, FB_16, FB_17, FB_18, FB_19, FB_26, FB_28, FB_29, FB_31, FB_36, FB_38, FB1_STD, FB_A, FB_B, FB_C, FB_31_A, FB_31_B, FB_31_C, FB_HS, SRM_1R1W, SRM_2R1W, SRM_2R2W, SRM_1R1W_2ROW, SRM_ROM, SRM_12R6W, SRM_4R1W_2W, SRM_2R2W_T2, SRM_1RST2R1W, FB_10_H, FB_10_F, FB_AN, FB_AN_OD, T16_STD, T18_STD, AN_HD, AN_U1, AN_C1, ANA_EXP, AN_HDU1M0_3T, AN_HDU1M0_4T, AN_HDC1M0, AN_HDU3M0, AN_HDC2M0, AN_HDU4M0, BE_3T, BE_4T, AN_HD_V2_18, AN_HD_V1_18, AN_HD_V0_16, AN_HD_V1_16, AN_HD_V2_16, ECO_REGION, ECO_DECAP, ECO_TAP_DMY, ECO_ACT, D130_P45_2FN, D130_P45_2FP, D208_P45_4FN, D208_P45_4FP, D260_P45_2_2FN, D260_P45_2_2FP, D260_P45_6FN, D260_P45_6FP, D260_P45_8FN, D260_P45_8FP, D260_P135_2_2FN, D260_P135_2_2FP, D260_P135_6FN, D260_P135_6FP, D260_P135_8FN, D260_P135_8FP, D280_P135_6FN, D280_P135_6FP, D336_P135_6FN, D336_P135_6FP, D280_P166_6FN, D280_P166_6FP, D336_P166_8FN, D336_P166_8FP, D130_PL_2FN, D130_PL_2FP, D208_PL_4FN, D208_PL_4FP, D260_PL_2_2FN, D260_PL_2_2FP, D260_PL_6FN, D260_PL_6FP, C260_PL_2FN2FP, C260_PL_2FN2FP_G, C520_PL_2FN2FP, C520_PL_2X2FN2FP, C520_PL_6FN6FP, S208_P45_4FN, S208_P45_4FP, C260_P45_2FN2FP, C260_P45_2FN2FP_G, C520_P45_2FN2FP, C520_P45_2X2FN2FP, C520_P45_6FN6FP, C560_P166_6FN6FP, C672_P166_6FN6FP, C672_P166_8FN8FP, CCP_3, CCP_4, CCP_5, CCP_6, CCP_7, CCP_8, CCP_9, CCP_10, CCP_11, CCP_12, CCP_13, CCP_14, CCP_15, CCP_16, CCP_17, CCP_18, CCP_19, CCP_26, CCP_28, CCP_29, CCP_31, CCP_36, CCP_38, STD_FILLER_1, STD_FILLER_4, STD_FILLER, STD_FILLER_H_BOUND, PADDED_DPO, DNW, NW, OD, SR_DOD, OD_SRAM1, OD_20, OD_DA, OD_DN_BLK, FB_BOUNDARY_BLK_H, FB_BOUNDARY_BLK, FB_CORNER_BLK, FB6_1X_BLK, FB_26_1X_BLK, COD_H, COD_V, COD_V2, COD_BLOCK, ODMMB, DCOD_H, DCOD_V, DCOD_V2, DCOD_BLOCK, GCOD_H, GCOD_V, ODMUO, PO, SR_DPO, CPO_SRAM, TPO, CPO, SR_DCPO, BPO, BPO_2, PO_P42, PO_P48, PO_P51, PO_P81, PO_P81_WPO, PO_P57, PO_P54, PA_CORE_MIN, EPI_BLK, PODE_GATE, M2_PG_MARKER, M3_PG_MARKER, M4_PG_MARKER, M5_PG_MARKER, M6_PG_MARKER, M7_PG_MARKER, M8_PG_MARKER, M9_PG_MARKER, M10_PG_MARKER, M11_PG_MARKER, M12_PG_MARKER, M13_PG_MARKER, M14_PG_MARKER, M15_PG_MARKER, M16_PG_MARKER, M17_PG_MARKER, M18_PG_MARKER, M19_PG_MARKER, M20_PG_MARKER, M21_PG_MARKER, MPG_MARKER_M2, MPG_MARKER_M3, MPG_MARKER_M4, MPG_MARKER_M5, MPG_MARKER_M6, MPG_MARKER_M7, MPG_MARKER_M8, MPG_MARKER_M9, MPG_MARKER_M10, MPG_MARKER_M11, MPG_MARKER_M12, MPG_MARKER_M13, MPG_MARKER_M14, MPG_MARKER_M15, MPG_MARKER_M16, MPG_MARKER_M17, MPG_MARKER_M18, MPG_MARKER_M19, MPG_MARKER_M20, MPG_MARKER_M21, MOSDMY, CPODE, DCPODE, MD, SR_DMD, CMD, SR_DCMD, BCMD, MP, VDR, VG, BVG, VD, VD2, BVD2, OD_12, OD12_10, OD12_15, OD_15, OD15_12, OD_18, OD18_12, OD18_15, OD18_10, PP, gNP, NP_BOUNDARY_BLK, VTS_N, VTSN_LL, VTS_P, VTSP_LL, VTL_N, VTLN_LL, VTL_P, VTLP_LL, VTXL_N, VTXL_P, VTH_N, VTH_P, VTUL_N, VTULN_LL, VTUL_P, VTULP_LL, VTML_N, VTML_P, VTEL_N, VTEL_P, NT_N, VAR, CB, CBD, RV, AP, APS, BPMT, D_BPMT, CU_RV, CU_RDL, DCU_RDL, BTSV, HBC, HBL, BSHBC, IFO_VIA, CPS, CPS2, MCBAM, AP_14P5_MARKER, CU_28_MARKER, CU_PAD_MARKER, CU_UPAD_MARKER, CU_UPAD_MARKER_P36, CU_UPAD_MARKER_P25, CU_UPAD_MARKER_P90, COWAP_MARKER, AP_UPAD_MARKER, CB2_WB, CB2_FC, DR_CB2, CB2_SAC, CB2_SAC_ISO, CB2B, CB2S, CB2_F2B, CU_CB2_FC, CU_CB2_FCU, CU_CB2_FCU_P36, CU_CB2_FCU_P25, CU_CB2_FCU_P90, PM, PM_IN, PM_INU, PM0, PM0_SAC, PM0_IN, PM0_INU, PM0_PAD, UBM, UBM_FC, UBM_FCU, UBM_F2B, UUBM, V_UUBM, PM_FC, PM_FCU, BSAM, CB2_FCU, CB2_IN, CB2_INU, TSV, DRTSV, BTPM, NWDMY_0, NWDMY_1, RH_TN, SR_DTN, RH_TNB, RHDMY_ALL, RH_TNE, RH_MATCHING_2, RHDMY0, RHDMY1, RHDMY2, RHDMY3, RHDMY4, RHDMY5, RHDMY6, RHDMY7, RHDMY8, RHDMY9, RHDMY10, RHDMY11, RHDMY12, RHDMY13, RHDMY14, RHDMY15, RHDMY16, RHDMY17, RHDMY18, RHDMY19, GR_TSV_OD_DA, GR_TSV_PO, GR_TSV_MD, GR_TSV_VDR, TSV_BLK, DIODMY, AN_SD, AN_SD_4, HIA_DUMMY, IHIADMY, BJTDMY, BJTEDMY, IBJTDMY, PBJT_COR, IBJT_COR, BJTDMY_C2, BJTEDMY_C2, BJTDMY_CD1, BJTEDMY_CD1, DECAPDMY, MATCHING, CRAM_LP, BUMP_BLOCKAGE, ANARRAY_H, ANARRAY_M, ANARRAY_HS, ANARRAY_S, RH_MATCHING, METALFUSE, METALFUSELINK, METALFUSE_B1, INDDMY, LOGO, TCDDMY, TCDDMY_ALL, CAP_18V, RDR_ANALOG, RDR, TCDDMY_NON_OPC, TCDDMY_NON_OPC_STACK, TCDDMY_NON_OPC_BEOL0, TCDDMY_NON_OPC_BEOL1, TCDDMY_NON_OPC_BEOL2, TCDDMY_NON_OPC_BEOL3, TCDDMY_NON_OPC_BEOL4, TCDDMY_NON_OPC_BEOL5, TCDDMY_NON_OPC_BEOL6, TCDDMY_NON_OPC_BEOL7, TCDDMY_NON_OPC_BEOL8, TCDDMY_M0, TCDDMY_M1, TCDDMY_M2, TCDDMY_M3, TCDDMY_M4, TCDDMY_M5, TCDDMY_M6, TCDDMY_M7, TCDDMY_M8, TCDDMY_M9, TCDDMY_M10, TCDDMY_M11, TCDDMY_M12, TCDDMY_M13, TCDDMY_M14, TCDDMY_M15, TCDDMY_M16, TCDDMY_M17, TCDDMY_M18, TCDDMY_M19, TCDDMY_V0, TCDDMY_V1, TCDDMY_V2, TCDDMY_V3, TCDDMY_V4, TCDDMY_V5, TCDDMY_V6, TCDDMY_V7, TCDDMY_V8, TCDDMY_V9, TCDDMY_V10, TCDDMY_V11, TCDDMY_V12, TCDDMY_V13, TCDDMY_V14, TCDDMY_V15, TCDDMY_V16, TCDDMY_V17, TCDDMY_V18, RTMOMDMY, MOMDMY, VIAMOMDMY, MOMDMY_0, MOMDMY_1, MOMDMY_2, MOMDMY_3, MOMDMY_4, MOMDMY_5, MOMDMY_6, MOMDMY_7, MOMDMY_8, MOMDMY_9, MOMDMY_10, MOMDMY_11, MOMDMY_12, MOMDMY_13, MOMDMY_14, MOMDMY_15, MOMDMY_16, MOMDMY_17, MOMDMY_18, MOMDMY_19, MOMDMY_20, MOMDMY_21, MOMDMY_CU, MOMDMY_AP, MOM_WAIVE_FLOAT_M0, MOM_WAIVE_FLOAT_M1, MOMCAP_FS, MOMDMY_QCM, MOMDMY_QFM, ICOVL_A, ICOVL_B, ICOVL_C, ICOVL_D, ICOVL_E, ICOVL_F, ICOVL_G, ICOVL_H, ICOVL_I, ICOVL_J, ICOVL_SINGLE, TPC, TPC_O, TPC_RVDMY, TPCDMY, TPC2_O, MPC, MPC_O, MPC_RVDMY, MPCDMY, BPC, BPC_O, BPC_RVDMY, BPCDMY, TPCDMY_CU, TPCDMY_AP, TPCDMY_AP2, TPCDMY_AP3, PMIM_1, PMIM_2, PMIM2_1, AN_GM_SENS, BPVT, BPVB, BPC_LV, BPC_LV_O, BPC_LVHV_DMY, BPC_HV1, BPC_HV2, BPC_HV2_O, BPC_HV1_O, BPC_GND, BPC_GND_O, BPC_GND_DMY, MPC_LV, MPC_LV_O, MPC_LV_DMY, TPC_GND, TPC_GND_O, TPC_GND_DMY, TPC_LV, TPC_LV_O, TPC_LV_DMY, M0_BREAK_BLK, VIRT_M1_TRACK, ODBLK, POBLK, MDBLK, SIGE_DRAW, SIC_DRAW, SEALRING, SEALRING_DB, SEALRING_ALL, SEALRING_EN, SEALRING_RE, SEALRING_IN, SEALRING_OUT, SEALRING_CORNER, SEALRING_EPT_S, LMARK, COWAM, COWAMS, AP_AMDMY, SR_ESD, SDI, SDI_2, SDI_3, LUPWDMY, LUPWDMY_2, PAD_WAV, LUP6IEDMY_ENG, LUPDWDMY, CNODWVR, LUP_VTR170_LOGIC, LUP_VTR180_LOGIC, LUP_VTR160_SRM, LUPWDMY_ENG, IODMYI, LC_DMY, LUPIEDMY, LUPVIEDMY, LUPVIEDMY_BUMP, LUP15VIEDMY, LUP15VIEDMY_BUMP, LUP18VIEDMY, LUP18VIEDMY_BUMP, PADDMY, LUPULVIEDMY, LUPULVIEDMY_BUMP, SRM, SRM_1, SRM_3, SRM_4, SRM_7, SRM_9, SRM_10, SRM_11, SRM_12, SRM_13, SRM_14, SRM_15, SRM_16, SRM_17, SRM_18, SRM_19, SRM_20, SRM_21, SRM_22, SRM_23, SRM_24, SRM_25, SRM_26, SRM_27, SRM_28, SRM_29, SRM_30, SRM_31, SRM_32, SRM_33, SRM_34, SRM_35, SRM_36, SRM_37, SRM_38, SRM_39, SRM_40, SRM_41, SRM_42, SRM_43, SRM_44, SRM_45, SRM_46, SRM_47, SRM_48, SRM_49, SET0_5, SET6_M, SET6_E, RODMY, SRAMDMY, SRAMDMY_1, SRAMDMY_2, PERI_MONITOR, ULHD_WLD, SRAM_PERI_STD, SRAM_PERI, SRAM_MACRO, ISO_CPODE_WLD, DAISYC_RES_M12, DAISYC_RES_M13, CO_SRAM, CO_SRAM11, CO_SRAM12, CO_SRAM13, CO_SRAM14, CO_SRAM15, CO_SRAM16, CO_SRAM17, CO_SRAM18, CO_SRAM19, CO_SRAM20, CO_SRAM21, CO_SRAM22, CO_SRAM23, CO_SRAM24, CO_SRAM25, CO_SRAM26, CO_SRAM27, CO_SRAM28, CO_SRAM29, CO_SRAM30, CO_SRAM31, CO_SRAM32, CO_SRAM33, CO_SRAM34, CO_SRAM35, CO_SRAM36, CO_SRAM37, CO_SRAM38, CO_SRAM39, CO_SRAM40, CO_SRAM41, CO_SRAM42, CO_SRAM43, CO_SRAM44, CO_SRAM45, CO_SRAM46, CO_SRAM47, CO_SRAM48, CO_SRAM49, CO_SRAM50, CO_SRAM51, CO_SRAM52, CO_SRAM53, CO_SRAM54, CO_SRAM55, CO_SRAM56, CO_SRAM57, CO_SRAM58, CO_SRAM59, CO_SRAM60, M0_JUMP, M1_JUMP, M2_JUMP, M3_JUMP, M3_NO_OPC, CRAM1, BLK_WF, BLK_WB, BCWDMY, BLK_M0, BLK_M1, BLK_M2, BLK_M3, BLK_M4, DAISYC_BLK, UNFEOLBLK, UNBEOLBLK, DC1, DC2_MANDREL, DC2_CORE, DC2_CORE_TYPE3, DC2_IO, DC3_FB2, DC4_CORE, DC4_IO, DC4_CORE_TYPE2, DC5_1, DC5_2, DC6_1, DC6_2, DC7, DC8_1, DC8_2, DC9, LOWMEDN, DFBC, DFBC_H, DFBC_V, DFBC_ALL, PCH_DC, DI_WPO, FEOL_BLK_T, FEOL_BLK_R, BEOL_BLK_T, BEOL_BLK_R, AP_DUMMY, CM0A_MAIN, CM0B_MAIN, DCM0A, DCM0B, BCM0H, BCM0V, M0_BASE, M0_MAIN_CA, M0_MAIN_CB, DM0_O_CA, DM0_O_CB, DM0_CA, DM0_CB, M1_MAIN, DM1_O, DM1, M2_BASE_H, M2_MAIN_CA_H, M2_MAIN_CB_H, DM2_O_CA_H, DM2_O_CB_H, DM2_CA_H, DM2_CB_H, M2_BASE_V, M2_MAIN_CA_V, M2_MAIN_CB_V, DM2_O_CA_V, DM2_O_CB_V, DM2_CA_V, DM2_CB_V, M3_MAIN_H, DM3_O_H, DM3_H, M3_MAIN_V, DM3_O_V, DM3_V, M4_MAIN_H, DM4_O_H, DM4_H, M4_MAIN_V, DM4_O_V, DM4_V, M5_BASE_H, M5_MAIN_CA_H, M5_MAIN_CB_H, DM5_O_CA_H, DM5_O_CB_H, DM5_CA_H, DM5_CB_H, M5_BASE_V, M5_MAIN_CA_V, M5_MAIN_CB_V, DM5_O_CA_V, DM5_O_CB_V, DM5_CA_V, DM5_CB_V, M6_MAIN_H, DM6_O_H, DM6_H, M6_MAIN_V, DM6_O_V, DM6_V, M7_MAIN_H, DM7_O_H, DM7_H, M7_MAIN_V, DM7_O_V, DM7_V, M8_MAIN_H, DM8_O_H, DM8_H, M8_MAIN_V, DM8_O_V, DM8_V, M9_MAIN_H, DM9_O_H, DM9_H, M9_MAIN_V, DM9_O_V, DM9_V, M10_MAIN_H, DM10_O_H, DM10_H, M10_MAIN_V, DM10_O_V, DM10_V, M11_MAIN_H, DM11_O_H, DM11_H, M11_MAIN_V, DM11_O_V, DM11_V, M12_MAIN_H, DM12_O_H, DM12_H, M12_MAIN_V, DM12_O_V, DM12_V, M13_MAIN_H, DM13_O_H, DM13_H, M13_MAIN_V, DM13_O_V, DM13_V, M14_MAIN, DM14_O, DM14, M15_MAIN, DM15_O, DM15, M16_MAIN, DM16, M17_MAIN, DM17, M18_MAIN, DM18, M19_MAIN, DM19, VIA0, DVIA0_O, VIA1, DVIA1_O, VIA2, DVIA2_O, VIA3, VIA3_CA, VIA3_CB, DVIA3_O_CA, DVIA3_O_CB, VIA3_CA_HINT, VIA3_CB_HINT, VIA3_DA, VIA3_DB, VIA4, VIA4_CA, VIA4_CB, DVIA4_O_CA, DVIA4_O_CB, VIA4_DA, VIA4_DB, VIA5, DVIA5, DVIA5_O, VIA6, DVIA6, DVIA6_O, VIA7, DVIA7, DVIA7_O, VIA8, DVIA8, DVIA8_O, VIA9, DVIA9, DVIA9_O, VIA10, DVIA10, DVIA10_O, VIA11, DVIA11, DVIA11_O, VIA12, DVIA12, DVIA12_O, VIA13, DVIA13, DVIA13_O, VIA14, DVIA14, DVIA14_O, VIA15, DVIA15, VIA16, DVIA16, VIA17, VIA18, M0_PIN_MRK, MJ_WAV, M0_MJ_PIN_0, M0_MJ_PIN_1, M0_MJ_PIN_2, M0_MJ_PIN_3, M0_MJ_PIN_4, M0_MJ_GRP_0, M0_MJ_GRP_1, M0_MJ_GRP_2, M0_MJ_GRP_3, M0_MJ_GRP_4, M1_PIN_MRK, M1_MJ_PIN_0, M1_MJ_PIN_1, M1_MJ_PIN_2, M1_MJ_PIN_3, M1_MJ_PIN_4, M1_MJ_GRP_0, M1_MJ_GRP_1, M1_MJ_GRP_2, M1_MJ_GRP_3, M1_MJ_GRP_4, M2_PIN_MRK, M2_MJ_PIN_0, M2_MJ_PIN_1, M2_MJ_PIN_2, M2_MJ_PIN_3, M2_MJ_PIN_4, M2_MJ_GRP_0, M2_MJ_GRP_1, M2_MJ_GRP_2, M2_MJ_GRP_3, M2_MJ_GRP_4, 
});



PRECISION : double = 20000;
CONNECT_DB : connect_database = NULL_CONNECT_DATABASE;
CONNECT_DB_DV : connect_database = NULL_CONNECT_DATABASE;
CONNECT_DB_C : connect_database = NULL_CONNECT_DATABASE;
CONNECT_DB_U : connect_database = NULL_CONNECT_DATABASE;
CONNECT_DB_J : connect_database = NULL_CONNECT_DATABASE;

dv_trace_error_nets_input : list of dv_voltage_source_s = { }; 
dv_error_voltage_source_error_nets : published function (
    dv_error_in : error_layer,
    properties_in : list of string,
    cdb_in : connect_database,
    layer1_in : data_layer,
    layer2_in : data_layer = NULL_DATA_LAYER,
    layer2_voltage_from_in : property_source_e = CONNECT_DATABASE
) returning void {
    dv_error_voltage_source( dv_error_in, properties_in, cdb_in, layer1_in, layer2_in, layer2_voltage_from_in );
    dv_trace_error_nets_input.push_back({ dv_error_in, layer1_in, layer2_in, layer2_voltage_from = layer2_voltage_from_in });
}

_dfm_rdb_layer : string;
_dfm_rdb_comment : string;
u_dv_switch : integer;
u_dv_layer1 : string;
u_dv_layer2 : string;
u_dv_space_val : double;
u_dv_space_val_low : double;
full_neighborhood : list of window_offset_e = {
    UPPER_LEFT, UP, UPPER_RIGHT,
    LEFT, RIGHT,
    LOWER_LEFT, DOWN, LOWER_RIGHT
};
adjacent_neighborhood : list of window_offset_e = {
    UP, LEFT, RIGHT, DOWN
};

corner_neighborhood : list of window_offset_e = {
    UPPER_LEFT, UPPER_RIGHT,
    LOWER_LEFT, LOWER_RIGHT
};
HV_ID_TOP_tag :  list of string = {};
LV_ID_TOP_tag :  list of string = {};
HV_marker_tag :  list of string = {};
HV_marker_voltage : list of double = {};


GAP : double;
SHIFT : double;
_den_print : boolean = false;
_den_print_only : boolean;
_den_con : constraint of double;
_den_con_val : double;
_den_win_val : double;
_den_step_val : double;
_den_half_win_area_val : double;
_den_polygon_area_clip : boolean;
_gden_con : constraint of double;
_gden_gcon : constraint of double;
_gden_exc_val : double;
_gden_absolute : boolean;
_gden_corner : boolean;
_gden_corner_value : double;
_gden_polygon_area_clip : boolean = false;
_gden_print : boolean = false;
_gden_print_only : boolean;
//Double compare function
dbl_gt : function (val1 : double, val2 : double ) returning dblgt_result : double
{
    dblgt_result = (dblgt(val1, val2) ? 1.0 : 0.0);
}
dbl_lt : function (val1 : double, val2 : double ) returning dbllt_result : double
{
    dbllt_result = (dbllt(val1, val2) ? 1.0 : 0.0);
}
dbl_or : function (val1 : double, val2 : double ) returning dblor_result : double
{
    dblor_result = (((((val1) < 0.0) || ((val1) > 0.0)) || (((val2) < 0.0) || ((val2) > 0.0))) ? 1.0 : 0.0);
}
dbl_qc : function (test : double, val1 : double, val2 : double ) returning dblqc_result : double
{
    dblqc_result = ((((test) < 0.0) || ((test) > 0.0)) ? val1 : val2);
}
dbl_eq : function (val1 : double, val2 : double ) returning dbleq_result : double 
{
    dbleq_result = (dbleq(val1, val2) ? 1.0 : 0.0);
}
dbl_and : function (val1 : double, val2 : double ) returning dbland_result : double 
{
    dbland_result = (((((val1) < 0.0) || ((val1) > 0.0)) && (((val2) < 0.0) || ((val2) > 0.0))) ? 1.0 : 0.0);
}
dblnp : function (value : double) returning dblnp_result : double
{
    dblnp_result = ((value > 0.0) ? 0.0 : 1.0);
}
dblnz : function (value : double) returning dblnz_result : double
{
    dblnz_result = (((value < 0.0) || (value > 0.0)) ? 1.0 : 0.0);
}
dblp : function (value : double) returning dblp_result : double
{
    dblp_result = ((value > 0.0) ? 1.0 : 0.0);
}
dblz : function (value : double) returning dblz_result : double
{
    dblz_result = (((value < 0.0) || (value > 0.0)) ? 0.0 : 1.0);
}
dbl_ne : function (val1 : double, val2 : double ) returning dblne_result : double 
{
    dblne_result = (dblne(val1, val2) ? 1.0 : 0.0);
}
dbl_ge : function (val1 : double, val2 : double ) returning dblge_result : double 
{
    dblge_result = (dblge(val1, val2) ? 1.0 : 0.0);
}
double_constraint_contains : published function (
    con : constraint of double,
    val : double
)
    returning result : boolean
{
    cat = con.category();

    result = false;

    if (cat == CONSTRAINT_EQ) {
        result = dbleq(val, con.lo());
    }
    elif (cat == CONSTRAINT_NE) {
        result = dblne(val, con.lo());
    }
    elif (cat == CONSTRAINT_GE) {
        result = dblge(val, con.lo());
    }
    elif (cat == CONSTRAINT_GT) {
        result = dblgt(val, con.lo());
    }
    elif (cat == CONSTRAINT_LE) {
        result = dblle(val, con.hi());
    }
    elif (cat == CONSTRAINT_LT) {
        result = dbllt(val, con.hi());
    }
    elif (cat == CONSTRAINT_GELE) {
        result = (dblge(val, con.lo()) && dblle(val, con.hi()));
    }
    elif (cat == CONSTRAINT_GELT) {
        result = (dblge(val, con.lo()) && dbllt(val, con.hi()));
    }
    elif (cat == CONSTRAINT_GTLE) {
        result = (dblgt(val, con.lo()) && dblle(val, con.hi()));
    }
    elif (cat == CONSTRAINT_GTLT) {
        result = (dblgt(val, con.lo()) && dbllt(val, con.hi()));
    }
}
nar_funcs_e : newtype enum of {
    UNKNOWN,
    FLOAT_TRGATE_FUNC_1,
    FLOAT_NSD_PSD_FUNC_1 
};
nar_void_func_s : newtype struct of {
    func : function (void) returning void;
};
nar_void_func_h : newtype hash of nar_funcs_e to nar_void_func_s;
nar_constrained_area_s : newtype struct of {
    area    : constraint of double = > 0;
    layer1  : string               = "";
    factor1 : double               = 1.0;
    layer2  : string               = "";
    factor2 : double               = 1.0;
};
nar_constrained_areas_h : newtype hash of string to nar_constrained_area_s;

net_area_ratio : published function (
    cdb_in            : connect_database,
    con               : constraint of double,
    layer_groups      : layer_groups_h,
    denominator_start : integer,
    denominator_end   : integer,
    constrained_areas : nar_constrained_areas_h = { },
    func_enum         : nar_funcs_e             = UNKNOWN,
    expr_is_default   : boolean                 = false
)
    returning net_area_ratio_result : polygon_layer
{
    nar_funcs   : nar_void_func_h = { };
    nar_func    : function (void) returning void;
    con2any     : list of polygon_layer = { };
    not_con2any : list of polygon_layer = { };
    n_layer_0   : polygon_layer;

    /* Declare and register equation code function. */
    float_trgate_func_1 : function (void) returning void
    {
        areaL2 = ns_net_area("layer2");
        areaL3 = ns_net_area("layer3");
        areaL4 = ns_net_area("layer4");
        areaL5 = ns_net_area("layer5");
        areaL6 = ns_net_area("layer6");
        areaL7 = ns_net_area("layer7");
        areaL8 = ns_net_area("layer8");
        areaL9 = ns_net_area("layer9");
        areaL10 = ns_net_area("layer10");

        ratio = dblz(areaL2) * dblz(areaL3) * dblz(areaL4) * dblz(areaL5) * dblz(areaL6) * dblz(areaL7) * dblz(areaL8) * dblz(areaL9) + dblz(areaL10);

        if (double_constraint_contains(con, ratio)) {
            ns_save_net({"ratio"}, {ratio});
        }
    }
    nar_funcs[FLOAT_TRGATE_FUNC_1] = { float_trgate_func_1 };
 
    /* Declare and register equation code function. */
    float_nsd_psd_func_1 : function (void) returning void
    {
        countL1 = ns_net_data_count("layer1");
        areaL2 = ns_net_area("layer2");
        areaL3 = ns_net_area("layer3");
        areaL4 = ns_net_area("layer4");
        areaL5 = ns_net_area("layer5");
        areaL6 = ns_net_area("layer6");
        areaL7 = ns_net_area("layer7");
        areaL8 = ns_net_area("layer8");
        areaL9 = ns_net_area("layer9");

        ratio = dblnp( countL1 - 1 ) * dblz(areaL2) * dblz(areaL3) * dblz(areaL4) * dblz(areaL5) * dblz(areaL6) * dblz(areaL7) * dblz(areaL8) * dblz(areaL9);

        if (double_constraint_contains(con, ratio)) {
            ns_save_net({"ratio"}, {ratio});
        }
    }
    nar_funcs[FLOAT_NSD_PSD_FUNC_1] = { float_nsd_psd_func_1 };

    /* Lookup the net_function to use in this num/den instance. */
    nar_func = nar_funcs[func_enum].func;

    n_layer_0 = layer_groups["layer1"][0];

    if (expr_is_default && (layer_groups.size() > 1)) {
        d_layers : list of polygon_layer = { };

        for (i = denominator_start to denominator_end) {
            d_layers.push_back(layer_groups["layer" + i][0]);
        }

        if ((con.category() == CONSTRAINT_EQ) && !((con.lo() > 0.0) || (con.lo() < 0.0))) {
            not_con2any = d_layers;
        }
        else {
            con2any = d_layers;
        }
    }

    net_area_ratio_result = net_select(
        connect_sequence     = cdb_in,
        net_function         = nar_func,
        layer_groups         = layer_groups,
        connected_to_all     = { n_layer_0 },
        connected_to_any     = con2any,
        not_connected_to_any = not_con2any,
        output_from_layers   = { n_layer_0 }
    );
}

round_to : published function (
    value  : double,
    target : double = 0.0/0.0
)
    returning round_to_result : double
{
    if (isnan(target)) {
        /* ROUND(x) : rounds x to nearest integer. */
        round_to_result = round(value);
    }
    else {
        /* ROUND(x,y) : rounds x to nearest multiple of y (n*y, where n is an integer and result [n*y] is a double). */
        recip = 1.0 / target;
        round_to_result = round(value * recip) / recip;
    }
}

floor_to : published function (
    value  : double,
    target : double = 0.0/0.0
)
    returning floor_to_result : double
{
    if (isnan(target)) {
        /* FLOOR(x) : rounds x to down to the nearest integer. */
        floor_to_result = floor(value);
    }
    else {
        /* FLOOR(x,y) : rounds x down to nearest multiple of y (n*y, where n is an integer and result [n*y] is a double). */
        recip = 1.0 / target;
        floor_to_result = floor(value * recip) / recip;
    }
}


size_inside_wrapper : published function (
    layer1           : polygon_layer,
    bounding         : polygon_layer,
    distance         : double,
    increment        : double = 0.0,
    clip_acute       : clip_acute_e = NONE,
    corner_extension : corner_extension_e = INTERSECTION,
    radial_sectors   : integer = 0
)
    returning size_inside_wrapper_result : polygon_layer
{
    size_pl : polygon_layer;

    if (dblge(increment, distance) || dbleq(increment, 0.0)) {
        size_pl  = size(layer1, distance, clip_acute = clip_acute, corner_extension = corner_extension, radial_sectors   = radial_sectors);
        size_inside_wrapper_result = and(size_pl, bounding);
    }
    else {
        size_pl  = size(layer1, increment, clip_acute = clip_acute, corner_extension = corner_extension, radial_sectors   = radial_sectors);
        size_inside_wrapper_result =
            size_inside(size_pl,
                        bounding,
                        distance         = distance - increment,
                        increment        = increment,
                        output_type      = OVERSIZE,
                        corner_extension = corner_extension,
                        radial_sectors   = radial_sectors);
    }
}
ec_proj_constraint : constraint;
dfm_property_func_ec_proj : function (void) returning void
{
    primary_data = df_get_current_data();
    rlayer1_set = df_error_layer(primary_data, "");
    projection_lengthL1 = df_error_sum_projection_length(rlayer1_set);

    v1 = projection_lengthL1;

    if (double_constraint_contains( ec_proj_constraint, v1)) {
        df_save_data(primary_data);
    }
}


extents_squares : published function (
    layer1 : polygon_layer
)
    returning extents_squares_result : polygon_layer
{
    square_function : function (void) returning void {
        pgon_extent = pf_polygon_extent(pf_get_current_polygon());

        delta_x = abs(pf_polygon_coordinate_x(pgon_extent, 2) - pf_polygon_coordinate_x(pgon_extent, 0));
        delta_y = abs(pf_polygon_coordinate_y(pgon_extent, 2) - pf_polygon_coordinate_y(pgon_extent, 0));

        side_length : double = (delta_x > delta_y) ? delta_x : delta_y;

        pgon_square = pf_polygon_center_square(pgon_extent, side_length);

        pf_save_polygon(pgon_square);
    }

    extents_squares_result = polygon_features(layer1, square_function);
}



Mn_R_18_dfm_property_func_173 : function (void) returning void
{
    primary_data = df_get_current_data();
    player2_set = df_polygon_layer(primary_data, "layer2");
    countL2 = df_polygon_count(player2_set);

    VIA_COUNT = countL2; 

    if (double_constraint_contains(> 0, VIA_COUNT)) { 
        df_save_properties(primary_data, { { "VIA_COUNT", VIA_COUNT } }); 
        df_save_data(primary_data);
    }
}

Mn_R_18_dfm_property_func_174 : function (void) returning void
{
    primary_data = df_get_current_data();
    player1_set = df_polygon_layer(primary_data, "");
    sum_propL1_VIA_COUNT_valid = df_get_polygon_sum_double_property(player1_set, "VIA_COUNT", sum_propL1_VIA_COUNT);

    v1 = sum_propL1_VIA_COUNT;

    if (double_constraint_contains(>= 4, v1) && sum_propL1_VIA_COUNT_valid && !(isinf(v1) || isnan(v1))) {
        df_save_data(primary_data);
    }
}

Mn_R_18_dfm_property_func_175 : function (void) returning void
{
    primary_data = df_get_current_data();
    player1_set = df_polygon_layer(primary_data, "");
    sum_propL1_VIA_COUNT_valid = df_get_polygon_sum_double_property(player1_set, "VIA_COUNT", sum_propL1_VIA_COUNT);

    v1 = sum_propL1_VIA_COUNT;

    if (double_constraint_contains(== 3, v1) && sum_propL1_VIA_COUNT_valid && !(isinf(v1) || isnan(v1))) {
        df_save_data(primary_data);
    }
}

Mn_R_18_dfm_property_func_176 : function (void) returning void
{
    primary_data = df_get_current_data();
    player2_set = df_polygon_layer(primary_data, "layer2");
    countL2 = df_polygon_count(player2_set);

    v1 = countL2;

    if (double_constraint_contains(>= 4, v1)) {
        df_save_data(primary_data);
    }
}


Mn_R_18_dfm_property_func_177 : function (void) returning void
{
    primary_data = df_get_current_data();
    player1_set = df_polygon_layer(primary_data, "");
    sum_propL1_VIA_COUNT_valid = df_get_polygon_sum_double_property(player1_set, "VIA_COUNT", sum_propL1_VIA_COUNT);

    v1 = sum_propL1_VIA_COUNT;

    if (double_constraint_contains(== 4, v1) && sum_propL1_VIA_COUNT_valid && !(isinf(v1) || isnan(v1))) {
        df_save_data(primary_data);
    }
}

contain_xy : function (
	    inlayer : polygon_layer,
	    value_x : double,
	    value_y : double
) returning result : polygon_layer {
    pre2 : polygon_layer;
  if ( dblgt(value_x,value_y) ){
    pre1 = shrink(inlayer, north = 0, south = 0, east = (value_x - value_y)/2, west = (value_x - value_y)/2);
    pre2 = contains(pre1, dimensions = {value_y, value_y}, rotate = NONE);
  } elseif ( dbllt(value_x,value_y) ) {
    pre1 = shrink(inlayer, north = (value_y - value_x)/2, south = (value_y - value_x)/2, east = 0, west = 0 );
    pre2 = contains(pre1, dimensions = {value_x, value_x}, rotate = NONE);
  } elseif ( dbleq(value_x,value_y) ) {
    pre1 = copy(inlayer);
    pre2 = contains(pre1, dimensions = {value_x, value_y}, rotate = NONE);
  }
  result = inlayer interacting pre2; 
}
contain_xy : function (
	    inlayer : polygon_layer,
	    value_x : double,
	    value_y : double
) returning void {
    pre2 : polygon_layer;
  if ( dblgt(value_x,value_y) ){
    pre1 = shrink(inlayer, north = 0, south = 0, east = (value_x - value_y)/2, west = (value_x - value_y)/2);
    pre2 = contains(pre1, dimensions = {value_y, value_y}, rotate = NONE);
  } elseif ( dbllt(value_x,value_y) ) {
    pre1 = shrink(inlayer, north = (value_y - value_x)/2, south = (value_y - value_x)/2, east = 0, west = 0 );
    pre2 = contains(pre1, dimensions = {value_x, value_x}, rotate = NONE);
  } elseif ( dbleq(value_x,value_y) ) {
    pre1 = copy(inlayer);
    pre2 = contains(pre1, dimensions = {value_x, value_y}, rotate = NONE);
  }
  inlayer interacting pre2; 
}

mn_dn_1_3_1_func_1 : function (void) returning void
{
    areaL1 = den_polygon_area("layer1", clip = _den_polygon_area_clip);
    areaL2 = den_polygon_area("layer2", clip = _den_polygon_area_clip);
    
    ratio = areaL1 / areaL2;

    if (double_constraint_contains(_den_con, ratio) && !isinf(ratio) && !isnan(ratio)) {
        if (!_den_print_only) {
            den_save_window(error_names = { "ratio", "areaL1", "areaL2" },
                            values      = { ratio, areaL1, areaL2 }
            );
        }
    
        if (_den_print || _den_print_only) {
            den_window_statistics(
                which_file  = 0,
                error_names = { "ratio", "areaL1", "areaL2" },
                values      = { ratio, areaL1, areaL2 }
            );
        }
    }
}
contains_xy : published function (
    layer1     : polygon_layer,
    dimensions : rectangle_dimensions_s,
    rotate     : rectangle_rotate_e = NONE
)
    returning contains_xy_result : polygon_layer
{
    pre2 : polygon_layer;
    value_x : double = dimensions.length1;
    value_y : double = dimensions.length2;

    if (dblgt(value_x, value_y)){
        pre1 = shrink(layer1, north = 0, south = 0, east = (value_x - value_y)/2, west = (value_x - value_y)/2);
        pre2 = contains(pre1, dimensions = { value_y, value_y }, rotate = rotate);
    }
    elseif (dbllt(value_x, value_y)){
        pre1 = shrink(layer1, north = (value_y - value_x)/2, south = (value_y - value_x)/2, east = 0, west = 0);
        pre2 = contains(pre1, dimensions = { value_x, value_x }, rotate = rotate);
    }
    else {
        pre2 = contains(layer1, dimensions = { value_x, value_y }, rotate = rotate);
    }

    contains_xy_result = layer1 interacting pre2;
}

rectangle_xy : function (
	    inlayer : polygon_layer,
	    orien : rect_orientation_e,
	    const_x : positive_constraint_t,
	    const_y : positive_constraint_t
	) returning void {
	pre1 = rectangles( inlayer, orientation = ORTHOGONAL, sides = { const_x, const_y } );
	in_x = angle_edge( layer1 = pre1, angles = 0 );
	pre2 = adjacent_edge( layer1 = pre1, length = const_x, angle1 = 90, angle2 = 90, adjacent_length1 = const_y, adjacent_length2 = const_y );
	pre3 = interacting_edge( pre2, in_x, include_touch = EDGE );
	pre1 interacting pre3;
	}
rectangle_xy : function (
	    inlayer : polygon_layer,
	    orien : rect_orientation_e,
	    const_x : positive_constraint_t,
	    const_y : positive_constraint_t
	) returning result : polygon_layer  {
	pre1 = rectangles( inlayer, orientation = ORTHOGONAL, sides = { const_x, const_y } );
	in_x = angle_edge( layer1 = pre1, angles = 0 );
	pre2 = adjacent_edge( layer1 = pre1, length = const_x, angle1 = 90, angle2 = 90, adjacent_length1 = const_y, adjacent_length2 = const_y );
	pre3 = interacting_edge( pre2, in_x, include_touch = EDGE );
	result = pre1 interacting pre3;
	}

ceil_to : published function (
    value  : double,
    target : double = 0.0/0.0
)
    returning ceil_to_result : double
{
    if (isnan(target)) {
        /* CEIL(x) : rounds x up to the nearest integer. */
        ceil_to_result = ceil(value);
    }
    else {
        /* CEIL(x,y) : rounds x up to the nearest multiple of y (n*y, where n is an integer and result [n*y] is a double). */
        recip = 1.0 / target;
        ceil_to_result = ceil(round_to((value * recip), (target * 10))) / recip;
    }
}
discrete_width_vertical_func_3 : function (void) returning void
{
    primary_data = df_get_current_data();
    elayer1_set = df_edge_layer(primary_data, "");
    lengthL1 = df_edge_sum_length(elayer1_set);

    v1 = fmod(round_to((lengthL1-SHIFT)*10000),round_to(GAP*10000));

    if (double_constraint_contains(!= 0, v1)) {
            df_save_data(primary_data);
    }
}
discrete_width_horizontal_func_3 : function (void) returning void
{
    primary_data = df_get_current_data();
    elayer1_set = df_edge_layer(primary_data, "");
    lengthL1 = df_edge_sum_length(elayer1_set);

    v1 = fmod(round_to((lengthL1-SHIFT)*10000),round_to(GAP*10000));

    if (double_constraint_contains(!= 0, v1)) {
            df_save_data(primary_data);
    }
}
discrete_270_270_edge_length_vertical_func_3 : function (void) returning void
{
    primary_data = df_get_current_data();
    elayer1_set = df_edge_layer(primary_data, "");
    lengthL1 = df_edge_sum_length(elayer1_set);

    v1 = fmod(round_to((lengthL1-SHIFT)*10000),round_to(GAP*10000));

    if (double_constraint_contains(!= 0, v1)) {
            df_save_data(primary_data);
    }
}

density_global_min_func_1 : function (void) returning void
{
    areaL1 = den_polygon_area("layer1", clip = _den_polygon_area_clip);
    areaL2 = den_polygon_area("layer2", clip = _den_polygon_area_clip);
    
    ratio = areaL1 / areaL2;

    if (double_constraint_contains(_den_con, ratio) && !isinf(ratio) && !isnan(ratio)) {
        if (!_den_print_only) {
            den_save_window(error_names = { "ratio", "areaL1", "areaL2" },
                            values      = { ratio, areaL1, areaL2 }
            );
        }
    
        if (_den_print || _den_print_only) {
            den_window_statistics(
                which_file  = 0,
                error_names = { "ratio", "areaL1", "areaL2" },
                values      = { ratio, areaL1, areaL2 }
            );
        }
    }
}
density_global_max_func_1 : function (void) returning void
{
    areaL1 = den_polygon_area("layer1", clip = _den_polygon_area_clip);
    areaL2 = den_polygon_area("layer2", clip = _den_polygon_area_clip);
    
    ratio = areaL1 / areaL2;

    if (double_constraint_contains(_den_con, ratio) && !isinf(ratio) && !isnan(ratio)) {
        if (!_den_print_only) {
            den_save_window(error_names = { "ratio", "areaL1", "areaL2" },
                            values      = { ratio, areaL1, areaL2 }
            );
        }
    
        if (_den_print || _den_print_only) {
            den_window_statistics(
                which_file  = 0,
                error_names = { "ratio", "areaL1", "areaL2" },
                values      = { ratio, areaL1, areaL2 }
            );
        }
    }
}

density_local_min_func_1 : function (void) returning void
{
    areaL1 = den_polygon_area("layer1", clip = _den_polygon_area_clip);
    areaL2 = den_polygon_area("layer2", clip = _den_polygon_area_clip);
    areaL3 = den_polygon_area("layer3", clip = _den_polygon_area_clip);
    areaL4 = den_polygon_area("layer4", clip = _den_polygon_area_clip);
    areaL5 = den_polygon_area("layer5", clip = _den_polygon_area_clip);
    
    ratio = dblnp( areaL1 - _den_half_win_area_val) * dblnz( areaL1 - _den_half_win_area_val ) + areaL4 / areaL5 + dblp( areaL2 / areaL3 - _den_con_val) + dblz( areaL2 / areaL3 - _den_con_val);

    if (double_constraint_contains(_den_con, ratio) && !isinf(ratio) && !isnan(ratio)) {
        if (!_den_print_only) {
            den_save_window(error_names = { "ratio", "areaL1", "areaL2", "areaL3", "areaL4", "areaL5" },
                            values      = { ratio, areaL1, areaL2, areaL3, areaL4, areaL5 }
            );
        }
    
        if (_den_print || _den_print_only) {
            den_window_statistics(
                which_file  = 0,
                error_names = { "ratio", "areaL1", "areaL2", "areaL3", "areaL4", "areaL5" },
                values      = { ratio, areaL1, areaL2, areaL3, areaL4, areaL5 }
            );
        }
    }
}
density_local_max_func_1 : function (void) returning void
{
    areaL1 = den_polygon_area("layer1", clip = _den_polygon_area_clip);
    areaL2 = den_polygon_area("layer2", clip = _den_polygon_area_clip);
    areaL3 = den_polygon_area("layer3", clip = _den_polygon_area_clip);
    areaL4 = den_polygon_area("layer4", clip = _den_polygon_area_clip);
    areaL5 = den_polygon_area("layer5", clip = _den_polygon_area_clip);
    
    ratio = dblnp( _den_half_win_area_val - areaL1 ) * areaL4 / areaL5 * dblp( areaL2 / areaL3 - _den_con_val);

    if (double_constraint_contains(_den_con, ratio) && !isinf(ratio) && !isnan(ratio)) {
        if (!_den_print_only) {
            den_save_window(error_names = { "ratio", "areaL1", "areaL2", "areaL3", "areaL4", "areaL5" },
                            values      = { ratio, areaL1, areaL2, areaL3, areaL4, areaL5 }
            );
        }
    
        if (_den_print || _den_print_only) {
            den_window_statistics(
                which_file  = 0,
                error_names = { "ratio", "areaL1", "areaL2", "areaL3", "areaL4", "areaL5" },
                values      = { ratio, areaL1, areaL2, areaL3, areaL4, areaL5 }
            );
        }
    }
}

density_gradient_max_func_1 : function (void) returning void
{
    neighborhood : list of window_offset_e;
    ratio_center : double = 0.0;
    max_gradient_g : double = 0.0;
    abs_ratio_center_g : double;
    abs_ratio_neighbor_g : double;

    areaL1_center_g = gden_polygon_area("layer1", CENTER, clip = _gden_polygon_area_clip);
    areaL2_center_g = gden_polygon_area("layer2", CENTER, clip = _gden_polygon_area_clip);
    areaL3_center_g = gden_polygon_area("layer3", CENTER, clip = _gden_polygon_area_clip);

    if (dblne(areaL3_center_g, 0)) {
        ratio_center = ( areaL1_center_g + areaL2_center_g * _gden_exc_val ) / areaL3_center_g;
        abs_ratio_center_g = abs(ratio_center);
    
        neighborhood = (_gden_corner) ? full_neighborhood : adjacent_neighborhood;
    
        foreach (neighbor in neighborhood) {
            if (gden_window_valid(neighbor)) {
                areaL1_neighbor_g = gden_polygon_area("layer1", neighbor, clip = _gden_polygon_area_clip);
                areaL2_neighbor_g = gden_polygon_area("layer2", neighbor, clip = _gden_polygon_area_clip);
                areaL3_neighbor_g = gden_polygon_area("layer3", neighbor, clip = _gden_polygon_area_clip);
    
                if (dblne(areaL3_neighbor_g, 0)) {
                    ratio_neighbor = ( areaL1_neighbor_g + areaL2_neighbor_g * _gden_exc_val ) / areaL3_neighbor_g;
                    abs_ratio_neighbor_g = abs(ratio_neighbor);
        
                    gradient = (dbleq(abs_ratio_center_g, abs_ratio_neighbor_g))
                                 ? 0
                                 : (_gden_absolute)
                                     ? abs(abs_ratio_center_g - abs_ratio_neighbor_g)
                                     : abs(abs_ratio_center_g - abs_ratio_neighbor_g) / max(abs_ratio_center_g, abs_ratio_neighbor_g);
        
                    if (dblne(_gden_corner_value, -1.0) && corner_neighborhood.contains(neighbor)) {
                        gradient = gradient * _gden_corner_value;
                    }
        
                    max_gradient_g = max(max_gradient_g, gradient);
                }
            }
        }
    
        if (double_constraint_contains(_gden_con, ratio_center) && !isinf(ratio_center) && !isnan(ratio_center) &&
            double_constraint_contains(_gden_gcon, max_gradient_g) && !isinf(max_gradient_g) && !isnan(max_gradient_g)) {
            if (!_gden_print_only) {
                gden_save_window(error_names = { "ratio_center", "areaL1_center_g", "areaL2_center_g", "areaL3_center_g", "Unsigned Gradient" },
                                 values      = { ratio_center, areaL1_center_g, areaL2_center_g, areaL3_center_g, max_gradient_g },
                                 offset      = CENTER
                );
            }
    
            if (_gden_print || _gden_print_only) {
                gden_window_statistics(
                    which_file  = 0,
                    error_names = { "ratio_center", "areaL1_center_g", "areaL2_center_g", "areaL3_center_g", "Unsigned Gradient" },
                    values      = { ratio_center, areaL1_center_g, areaL2_center_g, areaL3_center_g, max_gradient_g },
                    offset      = CENTER
                );
            }
        }
    }
}





//******************************************************************************
//      CHIP_snps BOUNDARY
//******************************************************************************
GRID    : const double = 0.001;
CSR_R_1 : const double = 66.3485;
vGRID : double = 0.0005;
SQRT2 : double = 1.415; 

DRCGRID : const double = 0.00005; //user value



#ifdef UseprBoundary
    #ifdef FULL_CHIP
        BULK_PRE = layer_extent( PRBOUNDARY );
    #else
        BULK_PRE = copy( PRBOUNDARY );
    #endif
#else
    #ifdef ChipWindowUsed
        BULK_PRE = polygons( { { { xLB, yLB }, { xRT, yRT } } } );
    #else
        BULK_PRE = layer_extent( CHIP_MT );	    
    #endif
#endif


#ifdef FULL_CHIP
    #ifdef WITH_SEALRING
        CHIP_snps = BULK_PRE not SEALRING_ALL; // sealring + SLDB +  CSR corner + Assembly isolation
    #else
	CHIP_snps = BULK_PRE not vertex( BULK_PRE, shape = TRIANGLE, angles = { 90 }, shape_size = CSR_R_1 );
    #endif
#else
    CHIP_snps = copy( BULK_PRE );
#endif



// GLOBAL DERIVED LAYER
//=====================

gCHIP = chip_extent();
CHIPX = copy( gCHIP, ancestry = true );    /* for density DRC coding */


gBULK = size( gCHIP, clip_acute = NONE, distance = 1 );
gEMPTY = empty_layer();                     /* for DRC coding */
EMPTYC = empty_layer();
EMPTYS = empty_layer();
EMPTYJ = empty_layer();
EMPTYU = empty_layer();
EMPTYV = empty_layer();
CHIPA = copy( gCHIP, ancestry = true );                   /* for density DRC coding */ 



EMPTY_EDGE = angle_edge( gEMPTY, == 0 );    /* for DRC coding */ 


IODMY = copy( IODMYI, ancestry = true ); 




CHIP_W = angle_edge( CHIPX, == 0 ); 
CHIP_L = angle_edge( CHIPX, == 90 );

PW = gBULK not NW; 
layerdef_derive_5 = interacting( NW, DNW ); 
layerdef_derive_4 = donut_holes( layerdef_derive_5, outer_boundary_point_touch = CLOSED_OUTER_BOUNDARY );
layerdef_derive_3 = layerdef_derive_4 not NW; 
RW = layerdef_derive_3 inside DNW; 
NWDMY = NWDMY_0 or NWDMY_1; 
layerdef_derive_7 = NW and NWDMY; 
layerdef_derive_6 = layerdef_derive_7 not OD; 
NWRSTI = interacting( NW, layerdef_derive_6 ); 

ALL_SRM = ( SRM or SRAMDMY ) or SRM_1;
ALL_MD = MD or SR_DMD; 
ALL_CMD = CMD or SR_DCMD; 

SRAM_CMD = copy( CO_SRAM12, ancestry = true ); 
FINAL_CMD = ALL_CMD or SRAM_CMD; 

gFINAL_CMD_SM_PRE = ALL_CMD or SRAM_CMD; 
FINAL_CMD_SM = shrink( grow( gFINAL_CMD_SM_PRE, north = 0.0065, south = 0.0065 ), north = 0.0065, south = 0.0065 );

gREAL_ALL_MD_SM_PRE1 = ALL_CMD or SRAM_CMD; 
gREAL_ALL_MD_SM_PRE2 = shrink( grow( gREAL_ALL_MD_SM_PRE1, north = 0.0065, south = 0.0065 ), north = 0.0065, south = 0.0065 );
REAL_ALL_MD_SM = ALL_MD not gREAL_ALL_MD_SM_PRE2; 

REAL_ALL_MD = ALL_MD not FINAL_CMD; 
REAL_ALL_MD_LOGIC = ALL_MD not ALL_CMD;
gREAL_MD_PRE = CMD or SRAM_CMD; 
REAL_MD = MD not gREAL_MD_PRE; 



ALL_MD_HE = angle_edge( ALL_MD, == 0 ); 
ALL_MD_VE = angle_edge( ALL_MD, == 90 ); 
MD_HE = angle_edge( MD, == 0 ); 
MD_VE = angle_edge( MD, == 90 ); 

ALL_CMD_HE = angle_edge( ALL_CMD, == 0 ); 
ALL_CMD_VE = angle_edge( ALL_CMD, == 90 ); 






CMD_MD = CMD and MD; 
ALL_OD = OD or SR_DOD; 
ALL_OD_SM = shrink( grow( ALL_OD, north = 0.010, south = 0.010 ), north = 0.010, south = 0.010 ); 
ALL_PO = PO or SR_DPO; 

gALL_OD_SR_NW_PRE_2 = ALL_OD or OD_DA; 
gALL_OD_SR_NW_PRE_1 = interacting( gALL_OD_SR_NW_PRE_2, SEALRING_ALL ); 
ALL_OD_SR_NW = interacting( gALL_OD_SR_NW_PRE_1, NW );


ALL_CPO = CPO or SR_DCPO; 
FINAL_CPO = ALL_CPO or CPO_SRAM; 

OD2 = OD_12 or OD12_15;








// VT layers













gVT_E_1_PRE1 = VTS_P and FB_A; 
gVT_E_1_PRE2 = gVT_E_1_PRE1 or VTL_P; 
gVT_E_1_PRE3 = gVT_E_1_PRE2 or VTUL_P; 
gVT_E_1_PRE4 = gVT_E_1_PRE3 or VTUL_N; 
gVT_E_1_PRE5 = gVT_E_1_PRE4 or VTLN_LL; 
gVT_E_1_PRE6 = VTS_N not FB_A; 
VT_E_1 = gVT_E_1_PRE5 or gVT_E_1_PRE6; 
gVT_E_2_PRE1 = VTS_P not FB_A; 
gVT_E_2_PRE2 = gVT_E_2_PRE1 or VTEL_P; 
gVT_E_2_PRE3 = gVT_E_2_PRE2 or VTULN_LL; 
gVT_E_2_PRE4 = VTS_N and FB_A; 
VT_E_2 = gVT_E_2_PRE3 or gVT_E_2_PRE4; 
VT_E_3 = or_list({ VTULP_LL, VTUL_P, VTEL_P, VTS_N });
VT_E_4 = or_list({ VTLP_LL, VTL_P, VTL_N, VTLN_LL });
VT_E_5 = or_list({ VTS_P, VTEL_N, VTUL_N, VTULN_LL });


VTEL_N_AND_FB_A = VTEL_N and FB_A; 
VTEL_P_AND_FB_A = VTEL_P and FB_A; 
VTL_N_AND_FB_A = VTL_N and FB_A; 
VTLN_LL_AND_FB_A = VTLN_LL and FB_A; 
VTL_P_AND_FB_A = VTL_P and FB_A; 
VTLP_LL_AND_FB_A = VTLP_LL and FB_A; 
VTS_N_AND_FB_A = VTS_N and FB_A; 
VTS_P_AND_FB_A = VTS_P and FB_A; 
VTUL_N_AND_FB_A = VTUL_N and FB_A; 
VTULN_LL_AND_FB_A = VTULN_LL and FB_A; 
VTUL_P_AND_FB_A = VTUL_P and FB_A; 
VTULP_LL_AND_FB_A = VTULP_LL and FB_A; 



    gVT_5_WPO_PRE1 = angle_edge( ALL_PO, == 90 ); 
    gVT_5_WPO_PRE2 = internal1( gVT_5_WPO_PRE1, ( 0.003, 0.136 ), extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC );
    gVT_5_WPO_PRE3 = or_list({ VTL_N, VTS_N, VTUL_P });
    VT_5_WPO = interacting( gVT_5_WPO_PRE3, gVT_5_WPO_PRE2 ); 
    
    
    gVT_8_WPO_PRE1 = or_list( { VTUL_N, VTL_N, VTL_P } ); 
    gVT_8_WPO_PRE2 = angle_edge( ALL_PO, == 90 ); 
    gVT_8_WPO_PRE3 = internal1( gVT_8_WPO_PRE2, ( 0.003, 0.136 ), extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC );
    VT_8_WPO = interacting( gVT_8_WPO_PRE1, gVT_8_WPO_PRE3);
     
    gVT_9_WPO_PRE2 = angle_edge( ALL_PO, == 90 ); 
    gVT_9_WPO_PRE3 = internal1( gVT_9_WPO_PRE2, ( 0.003, 0.136 ), extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC );
    VT_9_WPO = interacting( VTS_P, gVT_9_WPO_PRE3); 















   ALL_STD_20 = or_list( { FB_29, FB_28, FB_26, FB_31, FB_36, FB_38 } ); 
   ALL_STD_20_HE = angle_edge( ALL_STD_20, == 0 ); 
   ALL_STD_20_VE = angle_edge( ALL_STD_20, == 90 ); 



VC = VG or VD; 


NPOD = OD and gNP; 
PPOD = OD and PP; 
layerdef_derive_11 = OD and gNP; 
NACT = layerdef_derive_11 not NW; 
layerdef_derive_12 = OD and PP; 
PACT = layerdef_derive_12 and NW; 

layerdef_derive_14 = OD and gNP; 
layerdef_derive_15 = interacting( NW, NWDMY ); 
layerdef_derive_16 = NW not layerdef_derive_15; 
NSTP = layerdef_derive_14 and layerdef_derive_16; 

layerdef_derive_17 = OD and PP; 
PSTP = layerdef_derive_17 not NW; 
ACTIVE = NACT or PACT; 
NWSTRAP = copy( NSTP, ancestry = true );
PWSTRAP = copy( PSTP, ancestry = true );
RWSTRAP = PSTP and RW;

IOPMOS_NSTRAP = (( OD12_15 and NW ) and ( PP or gNP )) or ( ( OD12_15 not NW ) and PP );

STRAP = NSTP or PSTP; 





PP_OD2 = PP and OD2;
IO_PW = OD2 not ( NW or NT_N ); 
IO_NW = ( OD2 and NW ) not NT_N; 
GATE = PO and OD; 

TPCFINAL = TPC not TPC_O; 
MPCFINAL = MPC not MPC_O; 
BPCFINAL = BPC not BPC_O; 
MIM_CHIP = interacting( CHIPX, BPC ); 
BPC_ALL = BPC or BPCDMY; 

MIM_CHIPA = copy( MIM_CHIP, ancestry = true ); // for density DRC coding
MIM_CHIPA = copy( MIM_CHIP, ancestry = true ); // for density DRC coding
















DVIA3_O = DVIA3_O_CA or DVIA3_O_CB; 






DVIA4_O = DVIA4_O_CA or DVIA4_O_CB; 


























































DVIA0 = empty_layer();

DVIA1 = empty_layer();

DVIA2 = empty_layer();

DVIA3 = empty_layer();

DVIA4 = empty_layer();











DVIA15_O = size( gEMPTY, clip_acute = TRUNCATE, distance = 7 ); 

DVIA16_O = size( gEMPTY, clip_acute = TRUNCATE, distance = 7 ); 



DVIA17 = size( gEMPTY, clip_acute = TRUNCATE, distance = 7 ); 
DVIA17_O = size( gEMPTY, clip_acute = TRUNCATE, distance = 8 );




DVIA18 = size( gEMPTY, clip_acute = TRUNCATE, distance = 8 ); 
DVIA18_O = size( gEMPTY, clip_acute = TRUNCATE, distance = 9 );



ALL_DVIA0 = DVIA0 or DVIA0_O; 
ALL_VIA0 = VIA0 or ALL_DVIA0;
ALL_DVIA1 = DVIA1 or DVIA1_O; 
ALL_VIA1 = VIA1 or ALL_DVIA1;
ALL_DVIA2 = DVIA2 or DVIA2_O; 
ALL_VIA2 = VIA2 or ALL_DVIA2;
ALL_DVIA3 = DVIA3 or DVIA3_O; 
ALL_VIA3 = VIA3 or ALL_DVIA3;
ALL_DVIA4 = DVIA4 or DVIA4_O; 
ALL_VIA4 = VIA4 or ALL_DVIA4;
ALL_DVIA5 = DVIA5 or DVIA5_O; 
ALL_VIA5 = VIA5 or ALL_DVIA5;
ALL_DVIA6 = DVIA6 or DVIA6_O; 
ALL_VIA6 = VIA6 or ALL_DVIA6;
ALL_DVIA7 = DVIA7 or DVIA7_O; 
ALL_VIA7 = VIA7 or ALL_DVIA7;
ALL_DVIA8 = DVIA8 or DVIA8_O; 
ALL_VIA8 = VIA8 or ALL_DVIA8;
ALL_DVIA9 = DVIA9 or DVIA9_O; 
ALL_VIA9 = VIA9 or ALL_DVIA9;
ALL_DVIA10 = DVIA10 or DVIA10_O; 
ALL_VIA10 = VIA10 or ALL_DVIA10;
ALL_DVIA11 = DVIA11 or DVIA11_O; 
ALL_VIA11 = VIA11 or ALL_DVIA11;
ALL_DVIA12 = DVIA12 or DVIA12_O; 
ALL_VIA12 = VIA12 or ALL_DVIA12;
ALL_DVIA13 = DVIA13 or DVIA13_O; 
ALL_VIA13 = VIA13 or ALL_DVIA13;
ALL_DVIA14 = DVIA14 or DVIA14_O; 
ALL_VIA14 = VIA14 or ALL_DVIA14;
ALL_DVIA15 = DVIA15 or DVIA15_O; 
ALL_VIA15 = VIA15 or ALL_DVIA15;
ALL_DVIA16 = DVIA16 or DVIA16_O; 
ALL_VIA16 = VIA16 or ALL_DVIA16;
ALL_DVIA17 = DVIA17 or DVIA17_O; 
ALL_VIA17 = VIA17 or ALL_DVIA17;
ALL_DVIA18 = DVIA18 or DVIA18_O; 
ALL_VIA18 = VIA18 or ALL_DVIA18;


STRAP_ALLOD = (  gNP and ALL_OD ) and ( NW not interacting( NW, NWDMY ) ) or ( ( PP and ALL_OD ) not NW ); 








layerdef_derive_24 = enclosing( ACTIVE, GATE ); 
SD = layerdef_derive_24 not GATE;                 /* Source, drain areas (ACTIVE) */ 
IMP = gNP or PP; 




layerdef_derive_119 = CPO or CPO_SRAM;
layerdef_derive_120 = PO not layerdef_derive_119;
ILP1I = copy( layerdef_derive_120, ancestry = true );             /* Final_CPO = OR ALL_CPO CPO_SRAM */

layerdef_derive_117 = CMD or SRAM_CMD;
layerdef_derive_118 = MD not layerdef_derive_117;
MD_NOT_CMDI = copy( layerdef_derive_118, ancestry = true );       /* SRAM_CMD = OR CO_SRAM12 CO_SRAM13 CO_SRAM14  */





M0_MAIN = M0_MAIN_CA or M0_MAIN_CB;
M0_MAIN_NOT_SR = M0_MAIN not SEALRING_ALL;

DM0_O = DM0_O_CA or DM0_O_CB; 
DM0 = DM0_CA or DM0_CB; 
M0_CA = M0_MAIN_CA or DM0_O_CA; 
M0_CB = M0_MAIN_CB or DM0_O_CB; 
ALL_M0_CA = or_list( { M0_MAIN_CA, DM0_O_CA, DM0_CA } ); 
ALL_M0_CB = or_list( { M0_MAIN_CB, DM0_O_CB, DM0_CB } ); 
ALL_DM0 = DM0_O or DM0; 
ALL_DM0_CA = DM0_O_CA or DM0_CA; 
ALL_DM0_CB = DM0_O_CB or DM0_CB; 
CM0A = CM0A_MAIN or DCM0A; 
CM0B = CM0B_MAIN or DCM0B; 
M0_CA_SIZE = size( M0_CA, clip_acute = TRUNCATE, distance = 0.0005 ); 
DM0_CA_SIZE = size( DM0_CA, clip_acute = TRUNCATE, distance = 0.0005 ); 
ALL_CM0 = CM0A or CM0B;
REAL_M0_CA = M0_CA not CM0A; 
REAL_M0_CB = M0_CB not CM0B; 
REAL_M0 = REAL_M0_CA or REAL_M0_CB; 
REAL_M0_MAIN_CA = M0_MAIN_CA not CM0A_MAIN; 
REAL_M0_MAIN_CB = M0_MAIN_CB not CM0B_MAIN; 
REAL_M0_MAIN = REAL_M0_MAIN_CA or REAL_M0_MAIN_CB; 

gDM0_O_GT42_PRE = internal1( DM0_O, <= 0.042, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC, direction = VERTICAL, orthogonal = BOTH );
DM0_O_GT42 = DM0_O not gDM0_O_GT42_PRE; 

gDM1_O_GT42_PRE = internal1( DM1_O, <= 0.042, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC, direction = HORIZONTAL, orthogonal = BOTH );
DM1_O_GT42 = DM1_O not gDM1_O_GT42_PRE; 



REAL_DM0_O_CA = DM0_O_CA not DCM0A; 
REAL_DM0_O_CB = DM0_O_CB not DCM0B; 
REAL_DM0_O = REAL_DM0_O_CA or REAL_DM0_O_CB; 
CM0A_M0CA = CM0A and M0_CA;
CM0B_M0CB = CM0B and M0_CB;
CM0B_M0CA = CM0B and M0_CA;
CM0A_NOTM0CA = CM0A not M0_CA;
CM0B_NOTM0CB = CM0B not M0_CB;

REAL_ALL_DM0 = or_list({ REAL_DM0_O_CA, REAL_DM0_O_CB, DM0 });

M0_CA_ANDBLK = M0_CA and BLK_M0; 
M0_CB_ANDBLK = M0_CB and BLK_M0;
M0_CA_ANDBLK_NOTJUMP = M0_CA_ANDBLK not M0_JUMP;
M0_CB_ANDBLK_NOTJUMP = M0_CB_ANDBLK not M0_JUMP;
M0_MAIN_NOTPAD = M0_MAIN not PAD_WAV; 
M0_MAIN_NOTBLK_PAD = M0_MAIN not ( BLK_M0 or PAD_WAV );




M1_MAIN_NOT_SR = M1_MAIN not SEALRING_ALL;


ALL_DM1 = DM1_O or DM1; 
















M2_BASE = M2_BASE_H or M2_BASE_V;
M2_MAIN_CA = M2_MAIN_CA_H or M2_MAIN_CA_V; 
M2_MAIN_CB = M2_MAIN_CB_H or M2_MAIN_CB_V; 

DM2_O_CA = DM2_O_CA_H or DM2_O_CA_V; 
DM2_O_CB = DM2_O_CB_H or DM2_O_CB_V; 
DM2_CA = DM2_CA_H or DM2_CA_V; 
DM2_CB = DM2_CB_H or DM2_CB_V; 
M2_MAIN = M2_MAIN_CA or M2_MAIN_CB; 
M2_MAIN_NOT_SR = M2_MAIN not SEALRING_ALL;
DM2_O = DM2_O_CA or DM2_O_CB; 
DM2 = DM2_CA or DM2_CB; 
M2_CA = M2_MAIN_CA or DM2_O_CA; 
M2_CB = M2_MAIN_CB or DM2_O_CB; 
ALL_M2_CA = or_list( { M2_MAIN_CA, DM2_O_CA, DM2_CA } ); 
ALL_M2_CB = or_list( { M2_MAIN_CB, DM2_O_CB, DM2_CB } );
ALL_DM2_CA = DM2_O_CA or DM2_CA; 
ALL_DM2_CB = DM2_O_CB or DM2_CB; 
ALL_DM2 = ALL_DM2_CA or ALL_DM2_CB;




M3_MAIN = M3_MAIN_H or M3_MAIN_V; 



M3DX = M3_MAIN_H or DM3_O_H; 
M3DY = M3_MAIN_V or DM3_O_V; 

DM3_O = DM3_O_H or DM3_O_V; 
DM3 = DM3_H or DM3_V; 
ALL_DM3 = DM3_O or DM3;
M3_MAIN_NOT_SR = M3_MAIN not SEALRING_ALL;

M3_MAIN_NOTPAD = M3_MAIN not PAD_WAV; 
M3_MAIN_NOTBLK_PAD = M3_MAIN not ( BLK_M3 or PAD_WAV );



M4_MAIN = M4_MAIN_H or M4_MAIN_V; 



M4DX = M4_MAIN_H or DM4_O_H; 
M4DY = M4_MAIN_V or DM4_O_V; 

DM4_O = DM4_O_H or DM4_O_V; 
DM4 = DM4_H or DM4_V; 
ALL_DM4 = DM4_O or DM4;
M4_MAIN_NOT_SR = M4_MAIN not SEALRING_ALL;

M4_MAIN_NOTPAD = M4_MAIN not PAD_WAV;



M5_BASE = M5_BASE_H or M5_BASE_V;
M5_MAIN_CA = M5_MAIN_CA_H or M5_MAIN_CA_V; 
M5_MAIN_CB = M5_MAIN_CB_H or M5_MAIN_CB_V; 

M5DX_CA = M5_MAIN_CA_H or DM5_O_CA_H; 
M5DY_CA = M5_MAIN_CA_V or DM5_O_CA_V; 
M5DX_CB = M5_MAIN_CB_H or DM5_O_CB_H; 
M5DY_CB = M5_MAIN_CB_V or DM5_O_CB_V; 

DM5_O_CA = DM5_O_CA_H or DM5_O_CA_V; 
DM5_O_CB = DM5_O_CB_H or DM5_O_CB_V; 
DM5_CA = DM5_CA_H or DM5_CA_V; 
DM5_CB = DM5_CB_H or DM5_CB_V; 
M5_MAIN = M5_MAIN_CA or M5_MAIN_CB; 
DM5_O = DM5_O_CA or DM5_O_CB; 
DM5 = DM5_CA or DM5_CB; 
M5_MAIN_NOT_SR = M5_MAIN not SEALRING_ALL;
M5_CA = M5_MAIN_CA or DM5_O_CA; 
M5_CB = M5_MAIN_CB or DM5_O_CB; 
ALL_M5_CA = or_list( { M5_MAIN_CA, DM5_O_CA, DM5_CA } ); 
ALL_M5_CB = or_list( { M5_MAIN_CB, DM5_O_CB, DM5_CB } ); 
ALL_DM5_CA = DM5_O_CA or DM5_CA; 
ALL_DM5_CB = DM5_O_CB or DM5_CB; 
ALL_DM5 = ALL_DM5_CA or ALL_DM5_CB; 

M5_MAIN_NOTPAD = M5_MAIN not PAD_WAV;
M5_CA_SIZE = size( M5_CA, clip_acute = TRUNCATE, distance = 0.0005 ); 
DM5_CA_SIZE = size( DM5_CA, clip_acute = TRUNCATE, distance = 0.0005 ); 

M5DX = M5DX_CA or M5DX_CB; 
M5DY = M5DY_CA or M5DY_CB; 


M6_MAIN = M6_MAIN_H or M6_MAIN_V; 

M6DX = M6_MAIN_H or DM6_O_H; 
M6DY = M6_MAIN_V or DM6_O_V; 

DM6_O = DM6_O_H or DM6_O_V; 
DM6 = DM6_H or DM6_V; 
ALL_DM6 = DM6_O or DM6;
M6_MAIN_NOT_SR = M6_MAIN not SEALRING_ALL;





M7_MAIN = M7_MAIN_H or M7_MAIN_V; 

M7DX = M7_MAIN_H or DM7_O_H; 
M7DY = M7_MAIN_V or DM7_O_V; 

DM7_O = DM7_O_H or DM7_O_V; 
DM7 = DM7_H or DM7_V; 
ALL_DM7 = DM7_O or DM7;
M7_MAIN_NOT_SR = M7_MAIN not SEALRING_ALL;





M8_MAIN = M8_MAIN_H or M8_MAIN_V; 

M8DX = M8_MAIN_H or DM8_O_H; 
M8DY = M8_MAIN_V or DM8_O_V; 

DM8_O = DM8_O_H or DM8_O_V; 
DM8 = DM8_H or DM8_V; 
ALL_DM8 = DM8_O or DM8;
M8_MAIN_NOT_SR = M8_MAIN not SEALRING_ALL;





M9_MAIN = M9_MAIN_H or M9_MAIN_V; 

M9DX = M9_MAIN_H or DM9_O_H; 
M9DY = M9_MAIN_V or DM9_O_V; 

DM9_O = DM9_O_H or DM9_O_V; 
DM9 = DM9_H or DM9_V; 
ALL_DM9 = DM9_O or DM9;
M9_MAIN_NOT_SR = M9_MAIN not SEALRING_ALL;





M10_MAIN = M10_MAIN_H or M10_MAIN_V; 

M10DX = M10_MAIN_H or DM10_O_H; 
M10DY = M10_MAIN_V or DM10_O_V; 

DM10_O = DM10_O_H or DM10_O_V; 
DM10 = DM10_H or DM10_V; 
ALL_DM10 = DM10_O or DM10;
M10_MAIN_NOT_SR = M10_MAIN not SEALRING_ALL;





M11_MAIN = M11_MAIN_H or M11_MAIN_V; 

M11DX = M11_MAIN_H or DM11_O_H; 
M11DY = M11_MAIN_V or DM11_O_V; 

DM11_O = DM11_O_H or DM11_O_V; 
DM11 = DM11_H or DM11_V; 
ALL_DM11 = DM11_O or DM11;
M11_MAIN_NOT_SR = M11_MAIN not SEALRING_ALL;





M12_MAIN = M12_MAIN_H or M12_MAIN_V; 

M12DX = M12_MAIN_H or DM12_O_H; 
M12DY = M12_MAIN_V or DM12_O_V; 

DM12_O = DM12_O_H or DM12_O_V; 
DM12 = DM12_H or DM12_V; 
ALL_DM12 = DM12_O or DM12;
M12_MAIN_NOT_SR = M12_MAIN not SEALRING_ALL;





M13_MAIN = M13_MAIN_H or M13_MAIN_V; 

M13DX = M13_MAIN_H or DM13_O_H; 
M13DY = M13_MAIN_V or DM13_O_V; 

DM13_O = DM13_O_H or DM13_O_V; 
DM13 = DM13_H or DM13_V; 
ALL_DM13 = DM13_O or DM13;
M13_MAIN_NOT_SR = M13_MAIN not SEALRING_ALL;





ALL_DM14 = DM14_O or DM14;

ALL_DM15 = DM15_O or DM15;

DM16_O = empty_layer();
ALL_DM16 = DM16_O or DM16;



DM17_O = empty_layer();
ALL_DM17 = DM17_O or DM17;




DM18_O = empty_layer();
ALL_DM18 = DM18;



DM19_O = empty_layer();
ALL_DM19 = DM19;



M0 = M0_MAIN or DM0_O; 
ALL_M0 = or_list( { M0_MAIN, DM0_O, DM0 } );

M1 = M1_MAIN or DM1_O; 
ALL_M1 = or_list( { M1_MAIN, DM1_O, DM1 } );

M2 = M2_MAIN or DM2_O; 
ALL_M2 = or_list( { M2_MAIN, DM2_O, DM2 } );

M3 = M3_MAIN or DM3_O; 
ALL_M3 = or_list( { M3_MAIN, DM3_O, DM3 } );

M4 = M4_MAIN or DM4_O; 
ALL_M4 = or_list( { M4_MAIN, DM4_O, DM4 } );

M5 = M5_MAIN or DM5_O; 
ALL_M5 = or_list( { M5_MAIN, DM5_O, DM5 } );

M6 = M6_MAIN or DM6_O; 
ALL_M6 = or_list( { M6_MAIN, DM6_O, DM6 } );

M7 = M7_MAIN or DM7_O; 
ALL_M7 = or_list( { M7_MAIN, DM7_O, DM7 } );

M8 = M8_MAIN or DM8_O; 
ALL_M8 = or_list( { M8_MAIN, DM8_O, DM8 } );

M9 = M9_MAIN or DM9_O; 
ALL_M9 = or_list( { M9_MAIN, DM9_O, DM9 } );

M10 = M10_MAIN or DM10_O; 
ALL_M10 = or_list( { M10_MAIN, DM10_O, DM10 } );

M11 = M11_MAIN or DM11_O; 
ALL_M11 = or_list( { M11_MAIN, DM11_O, DM11 } );

M12 = M12_MAIN or DM12_O; 
ALL_M12 = or_list( { M12_MAIN, DM12_O, DM12 } );

M13 = M13_MAIN or DM13_O; 
ALL_M13 = or_list( { M13_MAIN, DM13_O, DM13 } );

M14 = M14_MAIN or DM14_O; 
ALL_M14 = or_list( { M14_MAIN, DM14_O, DM14 } );

M15 = M15_MAIN or DM15_O; 
ALL_M15 = or_list( { M15_MAIN, DM15_O, DM15 } );

M16 = M16_MAIN or DM16_O; 
ALL_M16 = or_list( { M16_MAIN, DM16_O, DM16 } );

M17 = M17_MAIN or DM17_O; 
ALL_M17 = or_list( { M17_MAIN, DM17_O, DM17 } );

M18 = M18_MAIN or DM18_O; 
ALL_M18 = or_list( { M18_MAIN, DM18_O, DM18 } );

M19 = M19_MAIN or DM19_O; 
ALL_M19 = or_list( { M19_MAIN, DM19_O, DM19 } );




REAL_M0_CA_AND_CM0B_AND_SRAMDMY = ( REAL_M0_CA and CM0B ) and SRAMDMY;
FLOATING_M0_JUMPER = M0 inside M0_JUMP;

M0_LT16 = wide( M0, < 0.016, forty_five = INTERNAL );
M0_LT18 = wide( M0, < 0.018, forty_five = INTERNAL );
M0_LT20 = wide( M0, < 0.02, forty_five = INTERNAL );
M0_LT24 = wide( M0, < 0.024, forty_five = INTERNAL );
M0_LT28 = wide( M0, < 0.028, forty_five = INTERNAL );
M0_MAIN_W39 = internal1( M0_MAIN, == 0.039, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC, direction = VERTICAL, orthogonal = BOTH ); 
REAL_M0_INSIDE_BCM0H = REAL_M0 inside BCM0H; 
DENSE_W13_PRE = shrink( grow( wide( M0, == 0.013, forty_five = INTERNAL ), north = 0.005, south = 0.005 ), north = 0.005, south = 0.005 );
DENSE_W13 = shrink( DENSE_W13_PRE, north = 0.046, south = 0.046 );
DENSE_W14_PRE = shrink( grow( wide( M0, == 0.014, forty_five = INTERNAL ), north = 0.005, south = 0.005 ), north = 0.005, south = 0.005 );
DENSE_W14 = shrink( DENSE_W14_PRE, north = 0.048, south = 0.048 );
DENSE_W16_PRE = shrink( grow( wide( M0, == 0.016, forty_five = INTERNAL ), north = 0.005, south = 0.005 ), north = 0.005, south = 0.005 );
DENSE_W16 = shrink( DENSE_W16_PRE, north = 0.052, south = 0.052 );




























METALFUSELINK_99NM = grow( METALFUSELINK, north = 0.099, south = 0.099 ); 
METALFUSELINK_M2_1NM = grow( ( M2 and METALFUSELINK ), north = 0.001, south = 0.001 ); 
SLR_PO = SEALRING_ALL and ALL_PO;
CHIP_CB2_FC = gCHIP interacting CB2_FC; 
CHIP_PM = ( gCHIP not SEALRING_ALL ) interacting PM; 

CHIP_PMA = CHIP_PM or gEMPTY;             /* fOR density DRC coding */
CHIP_CB2_FCA = CHIP_CB2_FC or gEMPTY;     /* fOR density DRC coding */

CHIP_AP_UPAD_MARKER = interacting( gCHIP, AP_UPAD_MARKER ); 
CHIP_RV = interacting( gCHIP, RV ); 
CHIP_CU_RV = interacting( gCHIP, CU_RV ); 
CHIP_AP = interacting( gCHIP, AP ); 
CHIP_CU_RDL = interacting( gCHIP, CU_RDL ); 

CHIP_CU_CB2_FC = gCHIP interacting ( CU_CB2_FC or CU_CB2_FCU ); 






M0_NOTJUMP = M0 not M0_JUMP;
M1_NOTJUMP = M1 not M1_JUMP;
M1_JUMP_BLK_M2 = M1_JUMP and BLK_M2;

M0_MAIN_OR_BREAK = M0_MAIN or M0_BREAK_BLK;
M0_MAIN_W14 = internal1( M0_MAIN, == 0.014, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC, direction = VERTICAL, orthogonal = BOTH );






M1_NOT_INT_BLK = not_interacting( M1, BLK_M1 ); 
M1_MAIN_NOTPAD = M1_MAIN not PAD_WAV; 
M1_MAIN_NOTBLK_PAD = M1_MAIN not ( BLK_M1 or PAD_WAV );






















M2_CA_SIZE = size( M2_CA, clip_acute = TRUNCATE, distance = 0.0005 ); 
DM2_CA_SIZE = size( DM2_CA, clip_acute = TRUNCATE, distance = 0.0005 ); 
M2_NOT_INT_BLK = not_interacting( M2, BLK_M2 ); 
M2_CA_NOT_INT_BLK = M2_CA not_interacting BLK_M2;
M2_CB_NOT_INT_BLK = M2_CB not_interacting BLK_M2;
M2_MAIN_NOTBLK_PAD = M2_MAIN not ( BLK_M2 or PAD_WAV );
M2_CA_ANDBLK = M2_CA and BLK_M2 ;
M2_CB_ANDBLK = M2_CB and BLK_M2;
M2_CA_ANDBLK_NOTJUMP = M2_CA_ANDBLK not M2_JUMP;
M2_CB_ANDBLK_NOTJUMP = M2_CB_ANDBLK not M2_JUMP;
FLOATING_M2_JUMPER = M2 inside M2_JUMP;




























TPC_GND_FINAL = TPC_GND not TPC_GND_O; 
MPC_LV_FINAL = MPC_LV not MPC_LV_O; 
BPC_GND_FINAL = BPC_GND not BPC_GND_O; 
BPC_HV1_FINAL = BPC_HV1 not BPC_HV1_O; 

BPC_HV2_FINAL = BPC_HV2 not BPC_HV2_O; 
BPC_LV_FINAL = BPC_LV not BPC_LV_O; 
PMIM_BPC = or_list({ BPC_LV_FINAL, BPC_HV1_FINAL, BPC_HV2_FINAL }); 

PMIM_CHIP = interacting( gCHIP, PMIM_BPC ); 
GND_FINAL = TPC_GND_FINAL or BPC_GND_FINAL; 
LV_FINAL = or_list({ MPC_LV_FINAL, BPC_LV_FINAL }); 

GND_RV = ((((CU_RV interacting PMIM_CHIP) interacting GND_FINAL) not_interacting LV_FINAL) not_interacting BPC_HV1_FINAL) not_interacting BPC_HV2_FINAL;
HV_RV = (((CU_RV interacting PMIM_CHIP) interacting (BPC_HV1_FINAL or BPC_HV2_FINAL)) not_interacting LV_FINAL) not_interacting GND_FINAL;
LV_RV = ((((CU_RV interacting PMIM_CHIP) interacting LV_FINAL) not_interacting GND_FINAL) not_interacting BPC_HV1_FINAL) not_interacting BPC_HV2_FINAL;


TPC_GND_FINALI = copy( TPC_GND_FINAL, ancestry = true ); 
BPC_GND_FINALI = copy( BPC_GND_FINAL, ancestry = true ); 
MPC_LV_FINALI = copy( MPC_LV_FINAL, ancestry = true ); 
BPC_LV_FINALI = copy( BPC_LV_FINAL, ancestry = true ); 
BPC_HV1_FINALI = copy( BPC_HV1_FINAL, ancestry = true ); 
BPC_HV2_FINALI = copy( BPC_HV2_FINAL, ancestry = true ); 
GND_RVI = copy( GND_RV, ancestry = true ); 
HV_RVI = copy( HV_RV, ancestry = true ); 
LV_RVI = copy( LV_RV, ancestry = true ); 







DNWI = copy( DNW, ancestry = true ); 
NWI = copy( NW, ancestry = true ); 
layerdef_derive_113 = interacting( NW, NWDMY ); 
layerdef_derive_114 = layerdef_derive_113 not NWDMY; 
NWRIT = copy( layerdef_derive_114, ancestry = true ); 
PWI = copy( PW, ancestry = true ); 
RWI = copy( RW, ancestry = true ); 
NSTPI = copy( NSTP, ancestry = true ); 
PSTPI = copy( PSTP, ancestry = true ); 
layerdef_derive_115 = NACT not ALL_PO; 
NSDC = copy( layerdef_derive_115, ancestry = true );
layerdef_derive_116 = PACT not ALL_PO; 
PSDC = copy( layerdef_derive_116, ancestry = true );
ODC = or_list( { NSTPI, PSTPI, NSDC, PSDC } ); 
MPI = copy( MP, ancestry = true ); 
GATEI = copy( GATE, ancestry = true );
CPODE_NET = ILP1I and CPODE;
VDI = copy( VD, ancestry = true ); 
VD_NOT_M0 = VD not M0;
VGI = copy( VG, ancestry = true ); 
VDRI = copy( VDR, ancestry = true );
VD2I = copy( VD2, ancestry = true ); 

layerdef_derive_121 = RH_TN not RHDMY_ALL; 
RHTNC = copy( layerdef_derive_121, ancestry = true );


OD_HV_ID = text_to_double_property( tODV_HIGH, "high", MAX, report_errors = { }, box_size = DRCGRID ); 
OD_LV_ID = text_to_double_property( tODV_LOW, "low", MIN, report_errors = { }, box_size = DRCGRID ); 
PO_HV_ID = text_to_double_property( tPOV_HIGH, "high", MAX, report_errors = { }, box_size = DRCGRID ); 
PO_LV_ID = text_to_double_property( tPOV_LOW, "low", MIN, report_errors = { }, box_size = DRCGRID ); 
MD_HV_ID = text_to_double_property( tMDV_HIGH, "high", MAX, report_errors = { }, box_size = DRCGRID ); 
MD_LV_ID = text_to_double_property( tMDV_LOW, "low", MIN, report_errors = { }, box_size = DRCGRID ); 
MD_USERDV_ID = text_to_double_property( tMD_USERDV, "userdv", MAX, report_errors = { }, box_size = DRCGRID);
MD_USERDV_TOP_ID = text_to_double_property( tMD_USERDV_TOP, "userdv", MAX, report_errors = { }, box_size = DRCGRID);
M0_HV_ID = text_to_double_property( tM0V_HIGH, "high", MAX, report_errors = { }, box_size = DRCGRID ); 
M0_LV_ID = text_to_double_property( tM0V_LOW, "low", MIN, report_errors = { }, box_size = DRCGRID ); 
M0_USERDV_ID = text_to_double_property( tM0_USERDV, "userdv", MAX, report_errors = { }, box_size = DRCGRID);
M1_HV_ID = text_to_double_property( tM1V_HIGH, "high", MAX, report_errors = { }, box_size = DRCGRID ); 
M1_LV_ID = text_to_double_property( tM1V_LOW, "low", MIN, report_errors = { }, box_size = DRCGRID ); 
M1_USERDV_ID = text_to_double_property( tM1_USERDV, "userdv", MAX, report_errors = { }, box_size = DRCGRID);
M2_HV_ID = text_to_double_property( tM2V_HIGH, "high", MAX, report_errors = { }, box_size = DRCGRID ); 
M2_LV_ID = text_to_double_property( tM2V_LOW, "low", MIN, report_errors = { }, box_size = DRCGRID ); 
M2_USERDV_ID = text_to_double_property( tM2_USERDV, "userdv", MAX, report_errors = { }, box_size = DRCGRID);
M3_HV_ID = text_to_double_property( tM3V_HIGH, "high", MAX, report_errors = { }, box_size = DRCGRID ); 
M3_LV_ID = text_to_double_property( tM3V_LOW, "low", MIN, report_errors = { }, box_size = DRCGRID ); 
M3_USERDV_ID = text_to_double_property( tM3_USERDV, "userdv", MAX, report_errors = { }, box_size = DRCGRID);
M4_HV_ID = text_to_double_property( tM4V_HIGH, "high", MAX, report_errors = { }, box_size = DRCGRID ); 
M4_LV_ID = text_to_double_property( tM4V_LOW, "low", MIN, report_errors = { }, box_size = DRCGRID ); 
M4_USERDV_ID = text_to_double_property( tM4_USERDV, "userdv", MAX, report_errors = { }, box_size = DRCGRID);
M5_HV_ID = text_to_double_property( tM5V_HIGH, "high", MAX, report_errors = { }, box_size = DRCGRID ); 
M5_LV_ID = text_to_double_property( tM5V_LOW, "low", MIN, report_errors = { }, box_size = DRCGRID ); 
M5_USERDV_ID = text_to_double_property( tM5_USERDV, "userdv", MAX, report_errors = { }, box_size = DRCGRID);
M6_HV_ID = text_to_double_property( tM6V_HIGH, "high", MAX, report_errors = { }, box_size = DRCGRID ); 
M6_LV_ID = text_to_double_property( tM6V_LOW, "low", MIN, report_errors = { }, box_size = DRCGRID ); 
M6_USERDV_ID = text_to_double_property( tM6_USERDV, "userdv", MAX, report_errors = { }, box_size = DRCGRID);
M7_HV_ID = text_to_double_property( tM7V_HIGH, "high", MAX, report_errors = { }, box_size = DRCGRID ); 
M7_LV_ID = text_to_double_property( tM7V_LOW, "low", MIN, report_errors = { }, box_size = DRCGRID ); 
M7_USERDV_ID = text_to_double_property( tM7_USERDV, "userdv", MAX, report_errors = { }, box_size = DRCGRID);
M8_HV_ID = text_to_double_property( tM8V_HIGH, "high", MAX, report_errors = { }, box_size = DRCGRID ); 
M8_LV_ID = text_to_double_property( tM8V_LOW, "low", MIN, report_errors = { }, box_size = DRCGRID ); 
M8_USERDV_ID = text_to_double_property( tM8_USERDV, "userdv", MAX, report_errors = { }, box_size = DRCGRID);
M9_HV_ID = text_to_double_property( tM9V_HIGH, "high", MAX, report_errors = { }, box_size = DRCGRID ); 
M9_LV_ID = text_to_double_property( tM9V_LOW, "low", MIN, report_errors = { }, box_size = DRCGRID ); 
M9_USERDV_ID = text_to_double_property( tM9_USERDV, "userdv", MAX, report_errors = { }, box_size = DRCGRID);
M10_HV_ID = text_to_double_property( tM10V_HIGH, "high", MAX, report_errors = { }, box_size = DRCGRID ); 
M10_LV_ID = text_to_double_property( tM10V_LOW, "low", MIN, report_errors = { }, box_size = DRCGRID ); 
M10_USERDV_ID = text_to_double_property( tM10_USERDV, "userdv", MAX, report_errors = { }, box_size = DRCGRID);
M11_HV_ID = text_to_double_property( tM11V_HIGH, "high", MAX, report_errors = { }, box_size = DRCGRID ); 
M11_LV_ID = text_to_double_property( tM11V_LOW, "low", MIN, report_errors = { }, box_size = DRCGRID ); 
M11_USERDV_ID = text_to_double_property( tM11_USERDV, "userdv", MAX, report_errors = { }, box_size = DRCGRID);
M12_HV_ID = text_to_double_property( tM12V_HIGH, "high", MAX, report_errors = { }, box_size = DRCGRID ); 
M12_LV_ID = text_to_double_property( tM12V_LOW, "low", MIN, report_errors = { }, box_size = DRCGRID ); 
M12_USERDV_ID = text_to_double_property( tM12_USERDV, "userdv", MAX, report_errors = { }, box_size = DRCGRID);
M13_HV_ID = text_to_double_property( tM13V_HIGH, "high", MAX, report_errors = { }, box_size = DRCGRID ); 
M13_LV_ID = text_to_double_property( tM13V_LOW, "low", MIN, report_errors = { }, box_size = DRCGRID ); 
M13_USERDV_ID = text_to_double_property( tM13_USERDV, "userdv", MAX, report_errors = { }, box_size = DRCGRID);
M14_HV_ID = text_to_double_property( tM14V_HIGH, "high", MAX, report_errors = { }, box_size = DRCGRID ); 
M14_LV_ID = text_to_double_property( tM14V_LOW, "low", MIN, report_errors = { }, box_size = DRCGRID ); 
M14_USERDV_ID = text_to_double_property( tM14_USERDV, "userdv", MAX, report_errors = { }, box_size = DRCGRID);
M15_HV_ID = text_to_double_property( tM15V_HIGH, "high", MAX, report_errors = { }, box_size = DRCGRID ); 
M15_LV_ID = text_to_double_property( tM15V_LOW, "low", MIN, report_errors = { }, box_size = DRCGRID ); 
M15_USERDV_ID = text_to_double_property( tM15_USERDV, "userdv", MAX, report_errors = { }, box_size = DRCGRID);
M16_HV_ID = text_to_double_property( tM16V_HIGH, "high", MAX, report_errors = { }, box_size = DRCGRID ); 
M16_LV_ID = text_to_double_property( tM16V_LOW, "low", MIN, report_errors = { }, box_size = DRCGRID ); 
M16_USERDV_ID = text_to_double_property( tM16_USERDV, "userdv", MAX, report_errors = { }, box_size = DRCGRID);
M17_HV_ID = text_to_double_property( tM17V_HIGH, "high", MAX, report_errors = { }, box_size = DRCGRID ); 
M17_LV_ID = text_to_double_property( tM17V_LOW, "low", MIN, report_errors = { }, box_size = DRCGRID ); 
M17_USERDV_ID = text_to_double_property( tM17_USERDV, "userdv", MAX, report_errors = { }, box_size = DRCGRID);
M18_HV_ID = text_to_double_property( tM18V_HIGH, "high", MAX, report_errors = { }, box_size = DRCGRID ); 
M18_LV_ID = text_to_double_property( tM18V_LOW, "low", MIN, report_errors = { }, box_size = DRCGRID ); 
M18_USERDV_ID = text_to_double_property( tM18_USERDV, "userdv", MAX, report_errors = { }, box_size = DRCGRID);
M19_HV_ID = text_to_double_property( tM19V_HIGH, "high", MAX, report_errors = { }, box_size = DRCGRID ); 
M19_LV_ID = text_to_double_property( tM19V_LOW, "low", MIN, report_errors = { }, box_size = DRCGRID ); 
M19_USERDV_ID = text_to_double_property( tM19_USERDV, "userdv", MAX, report_errors = { }, box_size = DRCGRID);

M0_HV_ID_TOP = text_to_double_property( tM0V_HIGH_TOP, "high", MAX, report_errors = { }, box_size = DRCGRID ); 
M0_LV_ID_TOP = text_to_double_property( tM0V_LOW_TOP, "low", MIN, report_errors = { }, box_size = DRCGRID ); 
M0_USERDV_TOP_ID = text_to_double_property( tM0_USERDV_TOP, "userdv", MAX, report_errors = { }, box_size = DRCGRID);
M1_HV_ID_TOP = text_to_double_property( tM1V_HIGH_TOP, "high", MAX, report_errors = { }, box_size = DRCGRID ); 
M1_LV_ID_TOP = text_to_double_property( tM1V_LOW_TOP, "low", MIN, report_errors = { }, box_size = DRCGRID ); 
M1_USERDV_TOP_ID = text_to_double_property( tM1_USERDV_TOP, "userdv", MAX, report_errors = { }, box_size = DRCGRID);
M2_HV_ID_TOP = text_to_double_property( tM2V_HIGH_TOP, "high", MAX, report_errors = { }, box_size = DRCGRID ); 
M2_LV_ID_TOP = text_to_double_property( tM2V_LOW_TOP, "low", MIN, report_errors = { }, box_size = DRCGRID ); 
M2_USERDV_TOP_ID = text_to_double_property( tM2_USERDV_TOP, "userdv", MAX, report_errors = { }, box_size = DRCGRID);
M3_HV_ID_TOP = text_to_double_property( tM3V_HIGH_TOP, "high", MAX, report_errors = { }, box_size = DRCGRID ); 
M3_LV_ID_TOP = text_to_double_property( tM3V_LOW_TOP, "low", MIN, report_errors = { }, box_size = DRCGRID ); 
M3_USERDV_TOP_ID = text_to_double_property( tM3_USERDV_TOP, "userdv", MAX, report_errors = { }, box_size = DRCGRID);
M4_HV_ID_TOP = text_to_double_property( tM4V_HIGH_TOP, "high", MAX, report_errors = { }, box_size = DRCGRID ); 
M4_LV_ID_TOP = text_to_double_property( tM4V_LOW_TOP, "low", MIN, report_errors = { }, box_size = DRCGRID ); 
M4_USERDV_TOP_ID = text_to_double_property( tM4_USERDV_TOP, "userdv", MAX, report_errors = { }, box_size = DRCGRID);
M5_HV_ID_TOP = text_to_double_property( tM5V_HIGH_TOP, "high", MAX, report_errors = { }, box_size = DRCGRID ); 
M5_LV_ID_TOP = text_to_double_property( tM5V_LOW_TOP, "low", MIN, report_errors = { }, box_size = DRCGRID ); 
M5_USERDV_TOP_ID = text_to_double_property( tM5_USERDV_TOP, "userdv", MAX, report_errors = { }, box_size = DRCGRID);
M6_HV_ID_TOP = text_to_double_property( tM6V_HIGH_TOP, "high", MAX, report_errors = { }, box_size = DRCGRID ); 
M6_LV_ID_TOP = text_to_double_property( tM6V_LOW_TOP, "low", MIN, report_errors = { }, box_size = DRCGRID ); 
M6_USERDV_TOP_ID = text_to_double_property( tM6_USERDV_TOP, "userdv", MAX, report_errors = { }, box_size = DRCGRID);
M7_HV_ID_TOP = text_to_double_property( tM7V_HIGH_TOP, "high", MAX, report_errors = { }, box_size = DRCGRID ); 
M7_LV_ID_TOP = text_to_double_property( tM7V_LOW_TOP, "low", MIN, report_errors = { }, box_size = DRCGRID ); 
M7_USERDV_TOP_ID = text_to_double_property( tM7_USERDV_TOP, "userdv", MAX, report_errors = { }, box_size = DRCGRID);
M8_HV_ID_TOP = text_to_double_property( tM8V_HIGH_TOP, "high", MAX, report_errors = { }, box_size = DRCGRID ); 
M8_LV_ID_TOP = text_to_double_property( tM8V_LOW_TOP, "low", MIN, report_errors = { }, box_size = DRCGRID ); 
M8_USERDV_TOP_ID = text_to_double_property( tM8_USERDV_TOP, "userdv", MAX, report_errors = { }, box_size = DRCGRID);
M9_HV_ID_TOP = text_to_double_property( tM9V_HIGH_TOP, "high", MAX, report_errors = { }, box_size = DRCGRID ); 
M9_LV_ID_TOP = text_to_double_property( tM9V_LOW_TOP, "low", MIN, report_errors = { }, box_size = DRCGRID ); 
M9_USERDV_TOP_ID = text_to_double_property( tM9_USERDV_TOP, "userdv", MAX, report_errors = { }, box_size = DRCGRID);
M10_HV_ID_TOP = text_to_double_property( tM10V_HIGH_TOP, "high", MAX, report_errors = { }, box_size = DRCGRID ); 
M10_LV_ID_TOP = text_to_double_property( tM10V_LOW_TOP, "low", MIN, report_errors = { }, box_size = DRCGRID ); 
M10_USERDV_TOP_ID = text_to_double_property( tM10_USERDV_TOP, "userdv", MAX, report_errors = { }, box_size = DRCGRID);
M11_HV_ID_TOP = text_to_double_property( tM11V_HIGH_TOP, "high", MAX, report_errors = { }, box_size = DRCGRID ); 
M11_LV_ID_TOP = text_to_double_property( tM11V_LOW_TOP, "low", MIN, report_errors = { }, box_size = DRCGRID ); 
M11_USERDV_TOP_ID = text_to_double_property( tM11_USERDV_TOP, "userdv", MAX, report_errors = { }, box_size = DRCGRID);
M12_HV_ID_TOP = text_to_double_property( tM12V_HIGH_TOP, "high", MAX, report_errors = { }, box_size = DRCGRID ); 
M12_LV_ID_TOP = text_to_double_property( tM12V_LOW_TOP, "low", MIN, report_errors = { }, box_size = DRCGRID ); 
M12_USERDV_TOP_ID = text_to_double_property( tM12_USERDV_TOP, "userdv", MAX, report_errors = { }, box_size = DRCGRID);
M13_HV_ID_TOP = text_to_double_property( tM13V_HIGH_TOP, "high", MAX, report_errors = { }, box_size = DRCGRID ); 
M13_LV_ID_TOP = text_to_double_property( tM13V_LOW_TOP, "low", MIN, report_errors = { }, box_size = DRCGRID ); 
M13_USERDV_TOP_ID = text_to_double_property( tM13_USERDV_TOP, "userdv", MAX, report_errors = { }, box_size = DRCGRID);
M14_HV_ID_TOP = text_to_double_property( tM14V_HIGH_TOP, "high", MAX, report_errors = { }, box_size = DRCGRID ); 
M14_LV_ID_TOP = text_to_double_property( tM14V_LOW_TOP, "low", MIN, report_errors = { }, box_size = DRCGRID ); 
M14_USERDV_TOP_ID = text_to_double_property( tM14_USERDV_TOP, "userdv", MAX, report_errors = { }, box_size = DRCGRID);
M15_HV_ID_TOP = text_to_double_property( tM15V_HIGH_TOP, "high", MAX, report_errors = { }, box_size = DRCGRID ); 
M15_LV_ID_TOP = text_to_double_property( tM15V_LOW_TOP, "low", MIN, report_errors = { }, box_size = DRCGRID ); 
M15_USERDV_TOP_ID = text_to_double_property( tM15_USERDV_TOP, "userdv", MAX, report_errors = { }, box_size = DRCGRID);
M16_HV_ID_TOP = text_to_double_property( tM16V_HIGH_TOP, "high", MAX, report_errors = { }, box_size = DRCGRID ); 
M16_LV_ID_TOP = text_to_double_property( tM16V_LOW_TOP, "low", MIN, report_errors = { }, box_size = DRCGRID ); 
M16_USERDV_TOP_ID = text_to_double_property( tM16_USERDV_TOP, "userdv", MAX, report_errors = { }, box_size = DRCGRID);
M17_HV_ID_TOP = text_to_double_property( tM17V_HIGH_TOP, "high", MAX, report_errors = { }, box_size = DRCGRID ); 
M17_LV_ID_TOP = text_to_double_property( tM17V_LOW_TOP, "low", MIN, report_errors = { }, box_size = DRCGRID ); 
M17_USERDV_TOP_ID = text_to_double_property( tM17_USERDV_TOP, "userdv", MAX, report_errors = { }, box_size = DRCGRID);
M18_HV_ID_TOP = text_to_double_property( tM18V_HIGH_TOP, "high", MAX, report_errors = { }, box_size = DRCGRID ); 
M18_LV_ID_TOP = text_to_double_property( tM18V_LOW_TOP, "low", MIN, report_errors = { }, box_size = DRCGRID ); 
M18_USERDV_TOP_ID = text_to_double_property( tM18_USERDV_TOP, "userdv", MAX, report_errors = { }, box_size = DRCGRID);
M19_HV_ID_TOP = text_to_double_property( tM19V_HIGH_TOP, "high", MAX, report_errors = { }, box_size = DRCGRID ); 
M19_LV_ID_TOP = text_to_double_property( tM19V_LOW_TOP, "low", MIN, report_errors = { }, box_size = DRCGRID ); 
M19_USERDV_TOP_ID = text_to_double_property( tM19_USERDV_TOP, "userdv", MAX, report_errors = { }, box_size = DRCGRID);

AP_HV_ID = text_to_double_property( tAPV_HIGH, "high", MAX, report_errors = { }, box_size = DRCGRID ); 
AP_LV_ID = text_to_double_property( tAPV_LOW, "low", MIN, report_errors = { }, box_size = DRCGRID ); 
AP_USERDV_ID = text_to_double_property( tAP_USERDV, "userdv", MAX, report_errors = { }, box_size = DRCGRID);

AP_HV_ID_TOP = text_to_double_property( tAPV_HIGH_TOP, "high", MAX, report_errors = { }, box_size = DRCGRID ); 
AP_LV_ID_TOP = text_to_double_property( tAPV_LOW_TOP, "low", MIN, report_errors = { }, box_size = DRCGRID ); 
AP_USERDV_TOP_ID = text_to_double_property( tAP_USERDV_TOP, "userdv", MAX, report_errors = { }, box_size = DRCGRID);


CU_RDL_HV_ID = text_to_double_property( tCU_RDLV_HIGH, "high", MAX, report_errors = { }, box_size = DRCGRID ); 
CU_RDL_LV_ID = text_to_double_property( tCU_RDLV_LOW, "low", MIN, report_errors = { }, box_size = DRCGRID ); 
CU_RDL_USERDV_ID = text_to_double_property( tCU_RDL_USERDV, "userdv", MAX, report_errors = { }, box_size = DRCGRID);

CU_RDL_HV_ID_TOP = text_to_double_property( tCU_RDLV_HIGH_TOP, "high", MAX, report_errors = { }, box_size = DRCGRID ); 
CU_RDL_LV_ID_TOP = text_to_double_property( tCU_RDLV_LOW_TOP, "low", MIN, report_errors = { }, box_size = DRCGRID ); 
CU_RDL_USERDV_TOP_ID = text_to_double_property( tCU_RDL_USERDV_TOP, "userdv", MAX, report_errors = { }, box_size = DRCGRID);



M0_NOT_CM0I = copy( REAL_M0_MAIN, ancestry = true ); 

M0_NOT_CM0I = M0_NOT_CM0I or (size(M0_HV_ID, clip_acute = TRUNCATE, distance = GRID ) and M0_NOT_CM0I) or (size(M0_LV_ID, clip_acute = TRUNCATE, distance = GRID ) and M0_NOT_CM0I);


M1I = copy( M1_MAIN, ancestry = true ); 

M2I = copy( M2_MAIN, ancestry = true ); 

M3I = copy( M3_MAIN, ancestry = true ); 


M4I = copy( M4_MAIN, ancestry = true ); 


M5I = copy( M5_MAIN, ancestry = true ); 


M6I = copy( M6_MAIN, ancestry = true ); 


M7I = copy( M7_MAIN, ancestry = true ); 


M8I = copy( M8_MAIN, ancestry = true ); 


M9I = copy( M9_MAIN, ancestry = true ); 


M10I = copy( M10_MAIN, ancestry = true ); 


M11I = copy( M11_MAIN, ancestry = true ); 


M12I = copy( M12_MAIN, ancestry = true ); 


M13I = copy( M13_MAIN, ancestry = true ); 


M14I = copy( M14_MAIN, ancestry = true );

M15I = copy( M15_MAIN, ancestry = true );

M16I = copy( M16_MAIN, ancestry = true ); 


M17I = copy( M17_MAIN, ancestry = true ); 


M18I = copy( M18_MAIN, ancestry = true ); 


M19I = copy( M19_MAIN, ancestry = true ); 





VIA0I = copy( VIA0, ancestry = true ); 

VIA1I = copy( VIA1, ancestry = true ); 

VIA2I = copy( VIA2, ancestry = true ); 

VIA3I = copy( VIA3, ancestry = true ); 

VIA4I = copy( VIA4, ancestry = true ); 

VIA5I = copy( VIA5, ancestry = true ); 

VIA6I = copy( VIA6, ancestry = true ); 

VIA7I = copy( VIA7, ancestry = true ); 

VIA8I = copy( VIA8, ancestry = true ); 

VIA9I = copy( VIA9, ancestry = true ); 

VIA10I = copy( VIA10, ancestry = true ); 

VIA11I = copy( VIA11, ancestry = true ); 

VIA12I = copy( VIA12, ancestry = true ); 

VIA13I = copy( VIA13, ancestry = true ); 

VIA14I = copy( VIA14, ancestry = true ); 

VIA15I = copy( VIA15, ancestry = true ); 

VIA16I = copy( VIA16, ancestry = true ); 

VIA17I = copy( VIA17, ancestry = true ); 

VIA18I = copy( VIA18, ancestry = true ); 

TSVI = copy( TSV, ancestry = true ); 

RVI = copy( RV, ancestry = true ); 

CU_RVI = copy( CU_RV, ancestry = true ); 

CBI = copy( CB, ancestry = true ); 
HBCI = copy( HBC, ancestry = true ); 
API = copy( AP, ancestry = true ); 

CU_RDLI = copy( CU_RDL, ancestry = true );
HBLI = copy( HBL, ancestry = true ); 


CU_CB2_FCI = copy( CU_CB2_FC, ancestry = true ); 
CU_CB2_FCUI = copy( CU_CB2_FCU, ancestry = true ); 
CU_CB2_FCU_P36I = copy( CU_CB2_FCU_P36, ancestry = true ); 

CB2WI = copy( CB2_WB, ancestry = true ); 
CB2FI = copy( CB2_FC, ancestry = true );  // duplicate with CB2_FCi to keep old derived term for general customer
UBMI = copy( UBM, ancestry = true ); 
UUBMI = copy( UUBM, ancestry = true ); 
V_UUBMI = copy( V_UUBM, ancestry = true ); 
PM0I = copy( PM0, ancestry = true ); 
PMI = copy( PM, ancestry = true ); 
CB2_FCI = copy( CB2_FC, ancestry = true ); 
PM_FCI = copy( PM_FC, ancestry = true ); 
UBM_FCI = copy( UBM_FC, ancestry = true ); 
CB2_FCUI = copy( CB2_FCU, ancestry = true ); 
PM_FCUI = copy( PM_FCU, ancestry = true ); 
UBM_FCUI = copy( UBM_FCU, ancestry = true ); 
CB2_INI = copy( CB2_IN, ancestry = true ); 
PM_INI = copy( PM_IN, ancestry = true ); 
PM0_INI = copy( PM0_IN, ancestry = true ); 
CB2_INUI = copy( CB2_INU, ancestry = true ); 
PM_INUI = copy( PM_INU, ancestry = true ); 
PM0_INUI = copy( PM0_INU, ancestry = true ); 
BPMTI = copy( BPMT, ancestry = true ); 
BPVTI = copy( BPVT, ancestry = true ); 
CB2_SACI = copy( CB2_SAC, ancestry = true );
PM0_SACI = copy( PM0_SAC, ancestry = true );

BPCI = BPCFINAL inside TPCDMY_AP;
MPCI = MPCFINAL inside TPCDMY_AP;
TPCI = TPCFINAL inside TPCDMY_AP;

BPC_CUI = BPCFINAL inside TPCDMY_CU;  // BPCFINAL_Cu_net (BPCFINAL tsmc_inside TPCDMY_Cu) with net connection property (connection broken after HiR Resistor). DRC use BPC_Cui as connection terms.
MPC_CUI = MPCFINAL inside TPCDMY_CU;  // MPCFINAL_Cu_net (MPCFINAL tsmc_inside TPCDMY_Cu) with net connection property (connection broken after HiR Resistor). DRC use MPC_Cui as connection terms.
TPC_CUI = TPCFINAL inside TPCDMY_CU;  // TPCFINAL_Cu_net (TPCFINAL tsmc_inside TPCDMY_Cu) with net connection property (connection broken after HiR Resistor). DRC use TPC_Cui as connection terms.








//================ FBE connection layer derived start :Combo1+Combo2 ====================

//================ FBE connection layer derived end :Combo1+Combo2 ====================
// i connection start


CONNECT_DB = incremental_connect( CONNECT_DB, {{{ NWI, DNWI }}} ); 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ NSTPI, NWI }}} ); 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PSTPI, PWI }}} ); 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PSTPI, RWI }}} ); 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ NSTPI, PSDC }}} ); 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PSTPI, NSDC }}} ); 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ NSDC, ODC }}} ); 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PSDC, ODC }}} ); 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PSTPI, ODC }}} ); 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ NSTPI, ODC }}} ); 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ MD_NOT_CMDI, NWRIT }}} ); 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ MD_NOT_CMDI, NSDC }}} ); 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ MD_NOT_CMDI, PSDC }}} ); 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ MD_NOT_CMDI, PSTPI }}} ); 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ MD_NOT_CMDI, NSTPI }}} ); 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ VDI, MD_NOT_CMDI }}} ); 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ VGI, ILP1I }}} ); 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ VDRI, MD_NOT_CMDI }}} ); 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ GATEI, ILP1I }}} ); 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ VGI, VDRI }}} ); 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M0_NOT_CM0I, VDI }}} ); 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M0_NOT_CM0I, VGI }}} ); 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M0_NOT_CM0I, VDRI }}} ); 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M1I, M0_NOT_CM0I }, VIA0I, NONE }} ); 

CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M2I, M1I }, VIA1I, NONE }} ); 


CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M3I, M2I }, VIA2I, NONE }} ); 


CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M4I, M3I }, VIA3I, NONE }} ); 


CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M5I, M4I }, VIA4I, NONE }} ); 


CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M6I, M5I }, VIA5I, NONE }} ); 


CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M7I, RHTNC, M6I }, VIA6I, NONE, SHIELDED_OVERLAP }} ); 



CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M8I, M7I }, VIA7I, NONE }} ); 


CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M9I, M8I }, VIA8I, NONE }} ); 


CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M10I, M9I }, VIA9I, NONE }} ); 


CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M11I, M10I }, VIA10I, NONE }} ); 


CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M12I, M11I }, VIA11I, NONE }} ); 


CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M13I, M12I }, VIA12I, NONE }} ); 


CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M14I, M13I }, VIA13I, NONE }} ); 


CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M15I, M14I }, VIA14I, NONE }} ); 


CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M16I, M15I }, VIA15I, NONE }} ); 


CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M17I, M16I }, VIA16I, NONE }} ); 


CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M18I, M17I }, VIA17I, NONE }} ); 


CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M19I, M18I }, VIA18I, NONE }} ); 



CONNECT_DB = incremental_connect( CONNECT_DB, {{{ TSVI, M18I }}} ); 

CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M19I, RVI }}} ); 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M19I, CBI }}} ); 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M19I, CU_RVI }}} );
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M19I, HBCI }}} ); 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ RVI, API }}} ); 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ CBI, API }}} );

CONNECT_DB = incremental_connect( CONNECT_DB, {{{ CBI, CU_RDLI }}} );
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ CU_RVI, CU_RDLI }}} );
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ HBCI, HBLI }}} ); 


CONNECT_DB = incremental_connect( CONNECT_DB, {{{ RVI, M19I }}} ); 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ RVI, BPCI }}} ); 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ RVI, MPCI }}} ); 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ RVI, TPCI }}} ); 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ API, RVI }}} ); 


CONNECT_DB = incremental_connect( CONNECT_DB, {{{ CU_RVI, M19I }}} ); 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ CU_RVI, BPC_CUI }}} ); 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ CU_RVI, MPC_CUI }}} ); 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ CU_RVI, TPC_CUI }}} ); 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ CU_RDLI, CU_RVI }}} ); 



CONNECT_DB = incremental_connect( CONNECT_DB, {{{ LV_RVI, M19I }}} ); 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ LV_RVI, BPC_LV_FINALI }}} ); 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ LV_RVI, MPC_LV_FINALI }}} ); 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ CU_RDLI, LV_RVI }}} ); 

CONNECT_DB = incremental_connect( CONNECT_DB, {{{ GND_RVI, M19I }}} ); 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ GND_RVI, BPC_GND_FINALI }}} ); 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ GND_RVI, TPC_GND_FINALI }}} ); 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ CU_RDLI, GND_RVI }}} ); 

CONNECT_DB = incremental_connect( CONNECT_DB, {{{ HV_RVI, M19I }}} ); 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ HV_RVI, BPC_HV1_FINALI }}} ); 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ HV_RVI, BPC_HV2_FINALI }}} ); 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ CU_RDLI, HV_RVI }}} ); 


//================ FBE connection start :Combo1+Combo2 ====================



// i connection end
//================ FBE connection end :Combo1+Combo2 ====================












TSV_VIA0 = VIA0 and TSV_BLK; 
TSV_M1 = M1_MAIN and TSV_BLK; 


TSV_VIA1 = VIA1 and TSV_BLK; 
TSV_M2 = M2_MAIN and TSV_BLK; 



TSV_VIA2 = VIA2 and TSV_BLK; 
TSV_M3 = M3_MAIN and TSV_BLK; 



TSV_VIA3 = VIA3 and TSV_BLK; 
TSV_M4 = M4_MAIN and TSV_BLK; 



TSV_VIA4 = VIA4 and TSV_BLK; 
TSV_M5 = M5_MAIN and TSV_BLK; 



TSV_VIA5 = VIA5 and TSV_BLK; 
TSV_M6 = M6_MAIN and TSV_BLK; 



TSV_VIA6 = VIA6 and TSV_BLK; 
TSV_M7 = M7_MAIN and TSV_BLK; 



TSV_VIA7 = VIA7 and TSV_BLK; 
TSV_M8 = M8_MAIN and TSV_BLK; 


TSV_VIA8 = VIA8 and TSV_BLK; 
TSV_M9 = M9_MAIN and TSV_BLK; 


TSV_VIA9 = VIA9 and TSV_BLK; 
TSV_M10 = M10_MAIN and TSV_BLK; 


TSV_VIA10 = VIA10 and TSV_BLK; 
TSV_M11 = M11_MAIN and TSV_BLK; 


TSV_VIA11 = VIA11 and TSV_BLK; 
TSV_M12 = M12_MAIN and TSV_BLK; 


TSV_VIA12 = VIA12 and TSV_BLK; 
TSV_M13 = M13_MAIN and TSV_BLK; 



TSV_VIA13 = VIA13 and TSV_BLK; 
TSV_M14 = M14_MAIN and TSV_BLK; 


TSV_VIA14 = VIA14 and TSV_BLK; 
TSV_M15 = M15_MAIN and TSV_BLK; 



TSV_VIA15 = VIA15 and TSV_BLK; 
TSV_M16 = M16_MAIN and TSV_BLK; 


TSV_VIA16 = VIA16 and TSV_BLK; 
TSV_M17 = M17_MAIN and TSV_BLK; 







CORE_VOLT : const double = 0.75; 

voltage_1 = interacting( PSDC, GATE ); 
voltage_3 = DIODMY not OD2; 
voltage_2 = or_list({ BJTDMY, IBJTDMY, voltage_3 }); 
PSD_DEVICE = not_interacting( voltage_1, voltage_2 ); 

voltage_4 = interacting( NSDC, GATE ); 
voltage_6 = DIODMY not OD2; 
voltage_5 = or_list({ BJTDMY, IBJTDMY, voltage_6 }); 
NSD_DEVICE = not_interacting( voltage_4, voltage_5 ); 


VAR_DEVICE = interacting( NSTPI, VAR ); 

VOL_12 = OD_12 not OD12_15; 
VOL_15 = copy(OD12_15); 

voltage_7 = or_list( { PSD_DEVICE, NSD_DEVICE, VAR_DEVICE } ); 
GATE_DEVICE = interacting( GATEI, voltage_7 ); 
GATE_CORE = GATE_DEVICE not OD2; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB, {{{ GATE_CORE, GATEI }}} );
GATE_12 = GATE_DEVICE and VOL_12; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ GATE_12, GATEI }}} );
GATE_15 = GATE_DEVICE and VOL_15; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ GATE_15, GATEI }}} );
PSD_CORE = PSD_DEVICE outside OD2; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ PSD_CORE, PSDC }}} );
PSD_12 = PSD_DEVICE not_outside VOL_12; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ PSD_12, PSDC }}} );
PSD_15 = PSD_DEVICE not_outside VOL_15; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ PSD_15, PSDC }}} );
NSD_CORE = NSD_DEVICE outside OD2; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ NSD_CORE, NSDC }}} );
NSD_12 = NSD_DEVICE not_outside VOL_12; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ NSD_12, NSDC }}} );
NSD_15 = NSD_DEVICE not_outside VOL_15; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ NSD_15, NSDC }}} );
VAR_CORE = VAR_DEVICE outside OD2; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ VAR_CORE, NSTPI }}} );
VAR_12 = VAR_DEVICE not_outside VOL_12; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ VAR_12, NSTPI }}} );
VAR_15 = VAR_DEVICE not_outside VOL_15; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ VAR_15, NSTPI }}} );
PSTP_00 = PSTPI not_inside RW; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ PSTP_00, PSTPI }}} );









CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ OD_HV_ID, ODC }}} ); 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ OD_LV_ID, ODC }}} ); 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ PO_HV_ID, ILP1I }}} ); 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ PO_LV_ID, ILP1I }}} ); 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ MD_HV_ID, MD_NOT_CMDI }}} ); 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ MD_LV_ID, MD_NOT_CMDI }}} ); 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M0_HV_ID, M0_NOT_CM0I }}} ); 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M0_LV_ID, M0_NOT_CM0I }}} ); 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M0_HV_ID_TOP, M0_NOT_CM0I }}} ); 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M0_LV_ID_TOP, M0_NOT_CM0I }}} ); 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M1_HV_ID, M1I }}} ); 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M1_LV_ID, M1I }}} ); 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M1_HV_ID_TOP, M1I }}} ); 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M1_LV_ID_TOP, M1I }}} ); 

CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M2_HV_ID, M2I }}} ); 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M2_LV_ID, M2I }}} ); 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M2_HV_ID_TOP, M2I }}} ); 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M2_LV_ID_TOP, M2I }}} ); 

CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M3_HV_ID, M3I }}} ); 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M3_LV_ID, M3I }}} ); 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M3_HV_ID_TOP, M3I }}} ); 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M3_LV_ID_TOP, M3I }}} ); 

CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M4_HV_ID, M4I }}} ); 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M4_LV_ID, M4I }}} ); 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M4_HV_ID_TOP, M4I }}} ); 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M4_LV_ID_TOP, M4I }}} ); 

CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M5_HV_ID, M5I }}} ); 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M5_LV_ID, M5I }}} ); 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M5_HV_ID_TOP, M5I }}} ); 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M5_LV_ID_TOP, M5I }}} ); 

CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M6_HV_ID, M6I }}} ); 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M6_LV_ID, M6I }}} ); 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M6_HV_ID_TOP, M6I }}} ); 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M6_LV_ID_TOP, M6I }}} ); 

CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M7_HV_ID, M7I }}} ); 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M7_LV_ID, M7I }}} ); 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M7_HV_ID_TOP, M7I }}} ); 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M7_LV_ID_TOP, M7I }}} ); 

CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M8_HV_ID, M8I }}} ); 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M8_LV_ID, M8I }}} ); 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M8_HV_ID_TOP, M8I }}} ); 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M8_LV_ID_TOP, M8I }}} ); 

CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M9_HV_ID, M9I }}} ); 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M9_LV_ID, M9I }}} ); 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M9_HV_ID_TOP, M9I }}} ); 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M9_LV_ID_TOP, M9I }}} ); 

CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M10_HV_ID, M10I }}} ); 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M10_LV_ID, M10I }}} ); 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M10_HV_ID_TOP, M10I }}} ); 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M10_LV_ID_TOP, M10I }}} ); 

CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M11_HV_ID, M11I }}} ); 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M11_LV_ID, M11I }}} ); 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M11_HV_ID_TOP, M11I }}} ); 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M11_LV_ID_TOP, M11I }}} ); 

CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M12_HV_ID, M12I }}} ); 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M12_LV_ID, M12I }}} ); 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M12_HV_ID_TOP, M12I }}} ); 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M12_LV_ID_TOP, M12I }}} ); 

CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M13_HV_ID, M13I }}} ); 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M13_LV_ID, M13I }}} ); 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M13_HV_ID_TOP, M13I }}} ); 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M13_LV_ID_TOP, M13I }}} ); 

CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M14_HV_ID, M14I }}} ); 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M14_LV_ID, M14I }}} ); 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M14_HV_ID_TOP, M14I }}} ); 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M14_LV_ID_TOP, M14I }}} ); 

CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M15_HV_ID, M15I }}} ); 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M15_LV_ID, M15I }}} ); 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M15_HV_ID_TOP, M15I }}} ); 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M15_LV_ID_TOP, M15I }}} ); 

CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M16_HV_ID, M16I }}} ); 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M16_LV_ID, M16I }}} ); 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M16_HV_ID_TOP, M16I }}} ); 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M16_LV_ID_TOP, M16I }}} ); 

CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M17_HV_ID, M17I }}} ); 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M17_LV_ID, M17I }}} ); 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M17_HV_ID_TOP, M17I }}} ); 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M17_LV_ID_TOP, M17I }}} ); 

CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M18_HV_ID, M18I }}} ); 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M18_LV_ID, M18I }}} ); 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M18_HV_ID_TOP, M18I }}} ); 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M18_LV_ID_TOP, M18I }}} ); 

CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M19_HV_ID, M19I }}} ); 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M19_LV_ID, M19I }}} ); 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M19_HV_ID_TOP, M19I }}} ); 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M19_LV_ID_TOP, M19I }}} ); 

CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ AP_HV_ID, API }}} ); 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ AP_LV_ID, API }}} ); 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ AP_HV_ID_TOP, API }}} ); 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ AP_LV_ID_TOP, API }}} );

CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ CU_RDL_HV_ID, CU_RDLI }}} ); 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ CU_RDL_LV_ID, CU_RDLI }}} ); 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ CU_RDL_HV_ID_TOP, CU_RDLI }}} ); 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ CU_RDL_LV_ID_TOP, CU_RDLI }}} );


MD_12VM = MD_NOT_CMDI and MD_12V;
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ MD_12VM, MD_NOT_CMDI}}} ); 
MD_25VM = MD_NOT_CMDI and MD_25V;
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ MD_25VM, MD_NOT_CMDI}}} ); 
MD_33VM = MD_NOT_CMDI and MD_33V;
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ MD_33VM, MD_NOT_CMDI}}} ); 

M0_00VM = M0_NOT_CM0I and M0_00V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M0_00VM, M0_NOT_CM0I }}} ); 
M0_01VM = M0_NOT_CM0I and M0_01V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M0_01VM, M0_NOT_CM0I }}} ); 
M0_02VM = M0_NOT_CM0I and M0_02V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M0_02VM, M0_NOT_CM0I }}} ); 
M0_03VM = M0_NOT_CM0I and M0_03V; CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M0_03VM, M0_NOT_CM0I }}} ); 
M0_04VM = M0_NOT_CM0I and M0_04V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M0_04VM, M0_NOT_CM0I }}} ); 
M0_05VM = M0_NOT_CM0I and M0_05V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M0_05VM, M0_NOT_CM0I }}} ); 
M0_06VM = M0_NOT_CM0I and M0_06V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M0_06VM, M0_NOT_CM0I }}} ); 
M0_07VM = M0_NOT_CM0I and M0_07V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M0_07VM, M0_NOT_CM0I }}} ); 
M0_08VM = M0_NOT_CM0I and M0_08V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M0_08VM, M0_NOT_CM0I }}} ); 
M0_09VM = M0_NOT_CM0I and M0_09V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M0_09VM, M0_NOT_CM0I }}} ); 
M0_10VM = M0_NOT_CM0I and M0_10V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M0_10VM, M0_NOT_CM0I }}} ); 
M0_11VM = M0_NOT_CM0I and M0_11V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M0_11VM, M0_NOT_CM0I }}} ); 
M0_12VM = M0_NOT_CM0I and M0_12V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M0_12VM, M0_NOT_CM0I }}} ); 
M0_13VM = M0_NOT_CM0I and M0_13V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M0_13VM, M0_NOT_CM0I }}} ); 
M0_14VM = M0_NOT_CM0I and M0_14V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M0_14VM, M0_NOT_CM0I }}} ); 
M0_15VM = M0_NOT_CM0I and M0_15V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M0_15VM, M0_NOT_CM0I }}} ); 
M0_16VM = M0_NOT_CM0I and M0_16V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M0_16VM, M0_NOT_CM0I }}} ); 
M0_17VM = M0_NOT_CM0I and M0_17V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M0_17VM, M0_NOT_CM0I }}} ); 
M0_18VM = M0_NOT_CM0I and M0_18V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M0_18VM, M0_NOT_CM0I }}} ); 
M0_25VM = M0_NOT_CM0I and M0_25V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M0_25VM, M0_NOT_CM0I }}} ); 
M0_33VM = M0_NOT_CM0I and M0_33V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M0_33VM, M0_NOT_CM0I }}} ); 
M0_50VM = M0_NOT_CM0I and M0_50V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M0_50VM, M0_NOT_CM0I }}} ); 
M0_70VM = M0_NOT_CM0I and M0_70V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M0_70VM, M0_NOT_CM0I }}} ); 
M1_00VM = M1I and M1_00V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M1_00VM, M1I }}} ); 
M1_01VM = M1I and M1_01V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M1_01VM, M1I }}} ); 
M1_02VM = M1I and M1_02V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M1_02VM, M1I }}} ); 
M1_03VM = M1I and M1_03V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M1_03VM, M1I }}} ); 
M1_04VM = M1I and M1_04V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M1_04VM, M1I }}} ); 
M1_05VM = M1I and M1_05V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M1_05VM, M1I }}} ); 
M1_06VM = M1I and M1_06V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M1_06VM, M1I }}} ); 
M1_07VM = M1I and M1_07V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M1_07VM, M1I }}} ); 
M1_08VM = M1I and M1_08V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M1_08VM, M1I }}} ); 
M1_09VM = M1I and M1_09V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M1_09VM, M1I }}} ); 
M1_10VM = M1I and M1_10V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M1_10VM, M1I }}} ); 
M1_11VM = M1I and M1_11V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M1_11VM, M1I }}} ); 
M1_12VM = M1I and M1_12V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M1_12VM, M1I }}} ); 
M1_13VM = M1I and M1_13V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M1_13VM, M1I }}} ); 
M1_14VM = M1I and M1_14V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M1_14VM, M1I }}} ); 
M1_15VM = M1I and M1_15V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M1_15VM, M1I }}} ); 
M1_16VM = M1I and M1_16V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M1_16VM, M1I }}} ); 
M1_17VM = M1I and M1_17V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M1_17VM, M1I }}} ); 
M1_18VM = M1I and M1_18V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M1_18VM, M1I }}} ); 
M1_25VM = M1I and M1_25V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M1_25VM, M1I }}} ); 
M1_33VM = M1I and M1_33V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M1_33VM, M1I }}} ); 
M1_50VM = M1I and M1_50V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M1_50VM, M1I }}} ); 
M1_70VM = M1I and M1_70V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M1_70VM, M1I }}} ); 

M2_00VM = M2I and M2_00V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M2_00VM, M2I }}} ); 
M2_01VM = M2I and M2_01V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M2_01VM, M2I }}} ); 
M2_02VM = M2I and M2_02V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M2_02VM, M2I }}} ); 
M2_03VM = M2I and M2_03V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M2_03VM, M2I }}} ); 
M2_04VM = M2I and M2_04V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M2_04VM, M2I }}} ); 
M2_05VM = M2I and M2_05V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M2_05VM, M2I }}} ); 
M2_06VM = M2I and M2_06V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M2_06VM, M2I }}} ); 
M2_07VM = M2I and M2_07V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M2_07VM, M2I }}} ); 
M2_08VM = M2I and M2_08V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M2_08VM, M2I }}} ); 
M2_09VM = M2I and M2_09V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M2_09VM, M2I }}} ); 
M2_10VM = M2I and M2_10V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M2_10VM, M2I }}} ); 
M2_11VM = M2I and M2_11V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M2_11VM, M2I }}} ); 
M2_12VM = M2I and M2_12V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M2_12VM, M2I }}} ); 
M2_13VM = M2I and M2_13V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M2_13VM, M2I }}} ); 
M2_14VM = M2I and M2_14V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M2_14VM, M2I }}} ); 
M2_15VM = M2I and M2_15V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M2_15VM, M2I }}} ); 
M2_16VM = M2I and M2_16V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M2_16VM, M2I }}} ); 
M2_17VM = M2I and M2_17V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M2_17VM, M2I }}} ); 
M2_18VM = M2I and M2_18V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M2_18VM, M2I }}} ); 
M2_25VM = M2I and M2_25V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M2_25VM, M2I }}} ); 
M2_33VM = M2I and M2_33V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M2_33VM, M2I }}} ); 
M2_50VM = M2I and M2_50V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M2_50VM, M2I }}} ); 
M2_70VM = M2I and M2_70V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M2_70VM, M2I }}} ); 

M3_00VM = M3I and M3_00V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M3_00VM, M3I }}} ); 
M3_01VM = M3I and M3_01V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M3_01VM, M3I }}} ); 
M3_02VM = M3I and M3_02V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M3_02VM, M3I }}} ); 
M3_03VM = M3I and M3_03V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M3_03VM, M3I }}} ); 
M3_04VM = M3I and M3_04V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M3_04VM, M3I }}} ); 
M3_05VM = M3I and M3_05V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M3_05VM, M3I }}} ); 
M3_06VM = M3I and M3_06V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M3_06VM, M3I }}} ); 
M3_07VM = M3I and M3_07V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M3_07VM, M3I }}} ); 
M3_08VM = M3I and M3_08V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M3_08VM, M3I }}} ); 
M3_09VM = M3I and M3_09V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M3_09VM, M3I }}} ); 
M3_10VM = M3I and M3_10V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M3_10VM, M3I }}} ); 
M3_11VM = M3I and M3_11V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M3_11VM, M3I }}} ); 
M3_12VM = M3I and M3_12V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M3_12VM, M3I }}} ); 
M3_13VM = M3I and M3_13V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M3_13VM, M3I }}} ); 
M3_14VM = M3I and M3_14V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M3_14VM, M3I }}} ); 
M3_15VM = M3I and M3_15V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M3_15VM, M3I }}} ); 
M3_16VM = M3I and M3_16V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M3_16VM, M3I }}} ); 
M3_17VM = M3I and M3_17V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M3_17VM, M3I }}} ); 
M3_18VM = M3I and M3_18V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M3_18VM, M3I }}} ); 
M3_25VM = M3I and M3_25V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M3_25VM, M3I }}} ); 
M3_33VM = M3I and M3_33V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M3_33VM, M3I }}} ); 
M3_50VM = M3I and M3_50V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M3_50VM, M3I }}} ); 
M3_70VM = M3I and M3_70V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M3_70VM, M3I }}} ); 

M4_00VM = M4I and M4_00V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M4_00VM, M4I }}} ); 
M4_01VM = M4I and M4_01V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M4_01VM, M4I }}} ); 
M4_02VM = M4I and M4_02V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M4_02VM, M4I }}} ); 
M4_03VM = M4I and M4_03V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M4_03VM, M4I }}} ); 
M4_04VM = M4I and M4_04V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M4_04VM, M4I }}} ); 
M4_05VM = M4I and M4_05V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M4_05VM, M4I }}} ); 
M4_06VM = M4I and M4_06V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M4_06VM, M4I }}} ); 
M4_07VM = M4I and M4_07V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M4_07VM, M4I }}} ); 
M4_08VM = M4I and M4_08V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M4_08VM, M4I }}} ); 
M4_09VM = M4I and M4_09V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M4_09VM, M4I }}} ); 
M4_10VM = M4I and M4_10V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M4_10VM, M4I }}} ); 
M4_11VM = M4I and M4_11V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M4_11VM, M4I }}} ); 
M4_12VM = M4I and M4_12V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M4_12VM, M4I }}} ); 
M4_13VM = M4I and M4_13V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M4_13VM, M4I }}} ); 
M4_14VM = M4I and M4_14V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M4_14VM, M4I }}} ); 
M4_15VM = M4I and M4_15V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M4_15VM, M4I }}} ); 
M4_16VM = M4I and M4_16V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M4_16VM, M4I }}} ); 
M4_17VM = M4I and M4_17V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M4_17VM, M4I }}} ); 
M4_18VM = M4I and M4_18V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M4_18VM, M4I }}} ); 
M4_25VM = M4I and M4_25V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M4_25VM, M4I }}} ); 
M4_33VM = M4I and M4_33V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M4_33VM, M4I }}} ); 
M4_50VM = M4I and M4_50V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M4_50VM, M4I }}} ); 
M4_70VM = M4I and M4_70V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M4_70VM, M4I }}} ); 

M5_00VM = M5I and M5_00V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M5_00VM, M5I }}} ); 
M5_01VM = M5I and M5_01V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M5_01VM, M5I }}} ); 
M5_02VM = M5I and M5_02V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M5_02VM, M5I }}} ); 
M5_03VM = M5I and M5_03V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M5_03VM, M5I }}} ); 
M5_04VM = M5I and M5_04V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M5_04VM, M5I }}} ); 
M5_05VM = M5I and M5_05V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M5_05VM, M5I }}} ); 
M5_06VM = M5I and M5_06V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M5_06VM, M5I }}} ); 
M5_07VM = M5I and M5_07V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M5_07VM, M5I }}} ); 
M5_08VM = M5I and M5_08V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M5_08VM, M5I }}} ); 
M5_09VM = M5I and M5_09V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M5_09VM, M5I }}} ); 
M5_10VM = M5I and M5_10V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M5_10VM, M5I }}} ); 
M5_11VM = M5I and M5_11V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M5_11VM, M5I }}} ); 
M5_12VM = M5I and M5_12V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M5_12VM, M5I }}} ); 
M5_13VM = M5I and M5_13V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M5_13VM, M5I }}} ); 
M5_14VM = M5I and M5_14V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M5_14VM, M5I }}} ); 
M5_15VM = M5I and M5_15V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M5_15VM, M5I }}} ); 
M5_16VM = M5I and M5_16V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M5_16VM, M5I }}} ); 
M5_17VM = M5I and M5_17V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M5_17VM, M5I }}} ); 
M5_18VM = M5I and M5_18V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M5_18VM, M5I }}} ); 
M5_25VM = M5I and M5_25V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M5_25VM, M5I }}} ); 
M5_33VM = M5I and M5_33V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M5_33VM, M5I }}} ); 
M5_50VM = M5I and M5_50V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M5_50VM, M5I }}} ); 
M5_70VM = M5I and M5_70V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M5_70VM, M5I }}} ); 

M6_00VM = M6I and M6_00V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M6_00VM, M6I }}} ); 
M6_01VM = M6I and M6_01V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M6_01VM, M6I }}} ); 
M6_02VM = M6I and M6_02V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M6_02VM, M6I }}} ); 
M6_03VM = M6I and M6_03V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M6_03VM, M6I }}} ); 
M6_04VM = M6I and M6_04V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M6_04VM, M6I }}} ); 
M6_05VM = M6I and M6_05V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M6_05VM, M6I }}} ); 
M6_06VM = M6I and M6_06V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M6_06VM, M6I }}} ); 
M6_07VM = M6I and M6_07V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M6_07VM, M6I }}} ); 
M6_08VM = M6I and M6_08V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M6_08VM, M6I }}} ); 
M6_09VM = M6I and M6_09V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M6_09VM, M6I }}} ); 
M6_10VM = M6I and M6_10V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M6_10VM, M6I }}} ); 
M6_11VM = M6I and M6_11V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M6_11VM, M6I }}} ); 
M6_12VM = M6I and M6_12V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M6_12VM, M6I }}} ); 
M6_13VM = M6I and M6_13V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M6_13VM, M6I }}} ); 
M6_14VM = M6I and M6_14V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M6_14VM, M6I }}} ); 
M6_15VM = M6I and M6_15V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M6_15VM, M6I }}} ); 
M6_16VM = M6I and M6_16V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M6_16VM, M6I }}} ); 
M6_17VM = M6I and M6_17V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M6_17VM, M6I }}} ); 
M6_18VM = M6I and M6_18V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M6_18VM, M6I }}} ); 
M6_25VM = M6I and M6_25V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M6_25VM, M6I }}} ); 
M6_33VM = M6I and M6_33V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M6_33VM, M6I }}} ); 
M6_50VM = M6I and M6_50V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M6_50VM, M6I }}} ); 
M6_70VM = M6I and M6_70V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M6_70VM, M6I }}} ); 

M7_00VM = M7I and M7_00V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M7_00VM, M7I }}} ); 
M7_01VM = M7I and M7_01V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M7_01VM, M7I }}} ); 
M7_02VM = M7I and M7_02V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M7_02VM, M7I }}} ); 
M7_03VM = M7I and M7_03V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M7_03VM, M7I }}} ); 
M7_04VM = M7I and M7_04V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M7_04VM, M7I }}} ); 
M7_05VM = M7I and M7_05V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M7_05VM, M7I }}} ); 
M7_06VM = M7I and M7_06V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M7_06VM, M7I }}} ); 
M7_07VM = M7I and M7_07V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M7_07VM, M7I }}} ); 
M7_08VM = M7I and M7_08V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M7_08VM, M7I }}} ); 
M7_09VM = M7I and M7_09V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M7_09VM, M7I }}} ); 
M7_10VM = M7I and M7_10V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M7_10VM, M7I }}} ); 
M7_11VM = M7I and M7_11V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M7_11VM, M7I }}} ); 
M7_12VM = M7I and M7_12V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M7_12VM, M7I }}} ); 
M7_13VM = M7I and M7_13V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M7_13VM, M7I }}} ); 
M7_14VM = M7I and M7_14V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M7_14VM, M7I }}} ); 
M7_15VM = M7I and M7_15V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M7_15VM, M7I }}} ); 
M7_16VM = M7I and M7_16V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M7_16VM, M7I }}} ); 
M7_17VM = M7I and M7_17V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M7_17VM, M7I }}} ); 
M7_18VM = M7I and M7_18V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M7_18VM, M7I }}} ); 
M7_25VM = M7I and M7_25V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M7_25VM, M7I }}} ); 
M7_33VM = M7I and M7_33V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M7_33VM, M7I }}} ); 
M7_50VM = M7I and M7_50V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M7_50VM, M7I }}} ); 
M7_70VM = M7I and M7_70V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M7_70VM, M7I }}} ); 

M8_00VM = M8I and M8_00V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M8_00VM, M8I }}} ); 
M8_01VM = M8I and M8_01V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M8_01VM, M8I }}} ); 
M8_02VM = M8I and M8_02V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M8_02VM, M8I }}} ); 
M8_03VM = M8I and M8_03V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M8_03VM, M8I }}} ); 
M8_04VM = M8I and M8_04V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M8_04VM, M8I }}} ); 
M8_05VM = M8I and M8_05V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M8_05VM, M8I }}} ); 
M8_06VM = M8I and M8_06V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M8_06VM, M8I }}} ); 
M8_07VM = M8I and M8_07V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M8_07VM, M8I }}} ); 
M8_08VM = M8I and M8_08V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M8_08VM, M8I }}} ); 
M8_09VM = M8I and M8_09V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M8_09VM, M8I }}} ); 
M8_10VM = M8I and M8_10V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M8_10VM, M8I }}} ); 
M8_11VM = M8I and M8_11V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M8_11VM, M8I }}} ); 
M8_12VM = M8I and M8_12V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M8_12VM, M8I }}} ); 
M8_13VM = M8I and M8_13V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M8_13VM, M8I }}} ); 
M8_14VM = M8I and M8_14V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M8_14VM, M8I }}} ); 
M8_15VM = M8I and M8_15V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M8_15VM, M8I }}} ); 
M8_16VM = M8I and M8_16V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M8_16VM, M8I }}} ); 
M8_17VM = M8I and M8_17V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M8_17VM, M8I }}} ); 
M8_18VM = M8I and M8_18V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M8_18VM, M8I }}} ); 
M8_25VM = M8I and M8_25V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M8_25VM, M8I }}} ); 
M8_33VM = M8I and M8_33V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M8_33VM, M8I }}} ); 
M8_50VM = M8I and M8_50V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M8_50VM, M8I }}} ); 
M8_70VM = M8I and M8_70V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M8_70VM, M8I }}} ); 

M9_00VM = M9I and M9_00V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M9_00VM, M9I }}} ); 
M9_01VM = M9I and M9_01V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M9_01VM, M9I }}} ); 
M9_02VM = M9I and M9_02V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M9_02VM, M9I }}} ); 
M9_03VM = M9I and M9_03V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M9_03VM, M9I }}} ); 
M9_04VM = M9I and M9_04V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M9_04VM, M9I }}} ); 
M9_05VM = M9I and M9_05V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M9_05VM, M9I }}} ); 
M9_06VM = M9I and M9_06V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M9_06VM, M9I }}} ); 
M9_07VM = M9I and M9_07V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M9_07VM, M9I }}} ); 
M9_08VM = M9I and M9_08V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M9_08VM, M9I }}} ); 
M9_09VM = M9I and M9_09V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M9_09VM, M9I }}} ); 
M9_10VM = M9I and M9_10V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M9_10VM, M9I }}} ); 
M9_11VM = M9I and M9_11V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M9_11VM, M9I }}} ); 
M9_12VM = M9I and M9_12V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M9_12VM, M9I }}} ); 
M9_13VM = M9I and M9_13V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M9_13VM, M9I }}} ); 
M9_14VM = M9I and M9_14V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M9_14VM, M9I }}} ); 
M9_15VM = M9I and M9_15V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M9_15VM, M9I }}} ); 
M9_16VM = M9I and M9_16V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M9_16VM, M9I }}} ); 
M9_17VM = M9I and M9_17V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M9_17VM, M9I }}} ); 
M9_18VM = M9I and M9_18V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M9_18VM, M9I }}} ); 
M9_25VM = M9I and M9_25V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M9_25VM, M9I }}} ); 
M9_33VM = M9I and M9_33V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M9_33VM, M9I }}} ); 
M9_50VM = M9I and M9_50V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M9_50VM, M9I }}} ); 
M9_70VM = M9I and M9_70V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M9_70VM, M9I }}} ); 

M10_00VM = M10I and M10_00V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M10_00VM, M10I }}} ); 
M10_01VM = M10I and M10_01V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M10_01VM, M10I }}} ); 
M10_02VM = M10I and M10_02V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M10_02VM, M10I }}} ); 
M10_03VM = M10I and M10_03V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M10_03VM, M10I }}} ); 
M10_04VM = M10I and M10_04V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M10_04VM, M10I }}} ); 
M10_05VM = M10I and M10_05V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M10_05VM, M10I }}} ); 
M10_06VM = M10I and M10_06V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M10_06VM, M10I }}} ); 
M10_07VM = M10I and M10_07V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M10_07VM, M10I }}} ); 
M10_08VM = M10I and M10_08V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M10_08VM, M10I }}} ); 
M10_09VM = M10I and M10_09V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M10_09VM, M10I }}} ); 
M10_10VM = M10I and M10_10V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M10_10VM, M10I }}} ); 
M10_11VM = M10I and M10_11V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M10_11VM, M10I }}} ); 
M10_12VM = M10I and M10_12V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M10_12VM, M10I }}} ); 
M10_13VM = M10I and M10_13V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M10_13VM, M10I }}} ); 
M10_14VM = M10I and M10_14V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M10_14VM, M10I }}} ); 
M10_15VM = M10I and M10_15V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M10_15VM, M10I }}} ); 
M10_16VM = M10I and M10_16V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M10_16VM, M10I }}} ); 
M10_17VM = M10I and M10_17V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M10_17VM, M10I }}} ); 
M10_18VM = M10I and M10_18V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M10_18VM, M10I }}} ); 
M10_25VM = M10I and M10_25V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M10_25VM, M10I }}} ); 
M10_33VM = M10I and M10_33V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M10_33VM, M10I }}} ); 
M10_50VM = M10I and M10_50V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M10_50VM, M10I }}} ); 
M10_70VM = M10I and M10_70V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M10_70VM, M10I }}} ); 

M11_00VM = M11I and M11_00V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M11_00VM, M11I }}} ); 
M11_01VM = M11I and M11_01V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M11_01VM, M11I }}} ); 
M11_02VM = M11I and M11_02V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M11_02VM, M11I }}} ); 
M11_03VM = M11I and M11_03V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M11_03VM, M11I }}} ); 
M11_04VM = M11I and M11_04V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M11_04VM, M11I }}} ); 
M11_05VM = M11I and M11_05V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M11_05VM, M11I }}} ); 
M11_06VM = M11I and M11_06V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M11_06VM, M11I }}} ); 
M11_07VM = M11I and M11_07V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M11_07VM, M11I }}} ); 
M11_08VM = M11I and M11_08V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M11_08VM, M11I }}} ); 
M11_09VM = M11I and M11_09V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M11_09VM, M11I }}} ); 
M11_10VM = M11I and M11_10V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M11_10VM, M11I }}} ); 
M11_11VM = M11I and M11_11V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M11_11VM, M11I }}} ); 
M11_12VM = M11I and M11_12V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M11_12VM, M11I }}} ); 
M11_13VM = M11I and M11_13V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M11_13VM, M11I }}} ); 
M11_14VM = M11I and M11_14V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M11_14VM, M11I }}} ); 
M11_15VM = M11I and M11_15V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M11_15VM, M11I }}} ); 
M11_16VM = M11I and M11_16V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M11_16VM, M11I }}} ); 
M11_17VM = M11I and M11_17V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M11_17VM, M11I }}} ); 
M11_18VM = M11I and M11_18V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M11_18VM, M11I }}} ); 
M11_25VM = M11I and M11_25V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M11_25VM, M11I }}} ); 
M11_33VM = M11I and M11_33V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M11_33VM, M11I }}} ); 
M11_50VM = M11I and M11_50V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M11_50VM, M11I }}} ); 
M11_70VM = M11I and M11_70V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M11_70VM, M11I }}} ); 

M12_00VM = M12I and M12_00V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M12_00VM, M12I }}} ); 
M12_01VM = M12I and M12_01V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M12_01VM, M12I }}} ); 
M12_02VM = M12I and M12_02V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M12_02VM, M12I }}} ); 
M12_03VM = M12I and M12_03V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M12_03VM, M12I }}} ); 
M12_04VM = M12I and M12_04V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M12_04VM, M12I }}} ); 
M12_05VM = M12I and M12_05V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M12_05VM, M12I }}} ); 
M12_06VM = M12I and M12_06V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M12_06VM, M12I }}} ); 
M12_07VM = M12I and M12_07V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M12_07VM, M12I }}} ); 
M12_08VM = M12I and M12_08V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M12_08VM, M12I }}} ); 
M12_09VM = M12I and M12_09V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M12_09VM, M12I }}} ); 
M12_10VM = M12I and M12_10V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M12_10VM, M12I }}} ); 
M12_11VM = M12I and M12_11V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M12_11VM, M12I }}} ); 
M12_12VM = M12I and M12_12V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M12_12VM, M12I }}} ); 
M12_13VM = M12I and M12_13V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M12_13VM, M12I }}} ); 
M12_14VM = M12I and M12_14V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M12_14VM, M12I }}} ); 
M12_15VM = M12I and M12_15V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M12_15VM, M12I }}} ); 
M12_16VM = M12I and M12_16V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M12_16VM, M12I }}} ); 
M12_17VM = M12I and M12_17V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M12_17VM, M12I }}} ); 
M12_18VM = M12I and M12_18V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M12_18VM, M12I }}} ); 
M12_25VM = M12I and M12_25V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M12_25VM, M12I }}} ); 
M12_33VM = M12I and M12_33V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M12_33VM, M12I }}} ); 
M12_50VM = M12I and M12_50V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M12_50VM, M12I }}} ); 
M12_70VM = M12I and M12_70V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M12_70VM, M12I }}} ); 

M13_00VM = M13I and M13_00V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M13_00VM, M13I }}} ); 
M13_01VM = M13I and M13_01V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M13_01VM, M13I }}} ); 
M13_02VM = M13I and M13_02V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M13_02VM, M13I }}} ); 
M13_03VM = M13I and M13_03V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M13_03VM, M13I }}} ); 
M13_04VM = M13I and M13_04V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M13_04VM, M13I }}} ); 
M13_05VM = M13I and M13_05V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M13_05VM, M13I }}} ); 
M13_06VM = M13I and M13_06V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M13_06VM, M13I }}} ); 
M13_07VM = M13I and M13_07V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M13_07VM, M13I }}} ); 
M13_08VM = M13I and M13_08V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M13_08VM, M13I }}} ); 
M13_09VM = M13I and M13_09V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M13_09VM, M13I }}} ); 
M13_10VM = M13I and M13_10V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M13_10VM, M13I }}} ); 
M13_11VM = M13I and M13_11V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M13_11VM, M13I }}} ); 
M13_12VM = M13I and M13_12V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M13_12VM, M13I }}} ); 
M13_13VM = M13I and M13_13V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M13_13VM, M13I }}} ); 
M13_14VM = M13I and M13_14V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M13_14VM, M13I }}} ); 
M13_15VM = M13I and M13_15V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M13_15VM, M13I }}} ); 
M13_16VM = M13I and M13_16V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M13_16VM, M13I }}} ); 
M13_17VM = M13I and M13_17V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M13_17VM, M13I }}} ); 
M13_18VM = M13I and M13_18V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M13_18VM, M13I }}} ); 
M13_25VM = M13I and M13_25V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M13_25VM, M13I }}} ); 
M13_33VM = M13I and M13_33V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M13_33VM, M13I }}} ); 
M13_50VM = M13I and M13_50V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M13_50VM, M13I }}} ); 
M13_70VM = M13I and M13_70V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M13_70VM, M13I }}} ); 

M14_00VM = M14I and M14_00V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M14_00VM, M14I }}} ); 
M14_01VM = M14I and M14_01V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M14_01VM, M14I }}} ); 
M14_02VM = M14I and M14_02V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M14_02VM, M14I }}} ); 
M14_03VM = M14I and M14_03V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M14_03VM, M14I }}} ); 
M14_04VM = M14I and M14_04V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M14_04VM, M14I }}} ); 
M14_05VM = M14I and M14_05V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M14_05VM, M14I }}} ); 
M14_06VM = M14I and M14_06V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M14_06VM, M14I }}} ); 
M14_07VM = M14I and M14_07V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M14_07VM, M14I }}} ); 
M14_08VM = M14I and M14_08V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M14_08VM, M14I }}} ); 
M14_09VM = M14I and M14_09V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M14_09VM, M14I }}} ); 
M14_10VM = M14I and M14_10V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M14_10VM, M14I }}} ); 
M14_11VM = M14I and M14_11V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M14_11VM, M14I }}} ); 
M14_12VM = M14I and M14_12V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M14_12VM, M14I }}} ); 
M14_13VM = M14I and M14_13V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M14_13VM, M14I }}} ); 
M14_14VM = M14I and M14_14V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M14_14VM, M14I }}} ); 
M14_15VM = M14I and M14_15V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M14_15VM, M14I }}} ); 
M14_16VM = M14I and M14_16V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M14_16VM, M14I }}} ); 
M14_17VM = M14I and M14_17V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M14_17VM, M14I }}} ); 
M14_18VM = M14I and M14_18V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M14_18VM, M14I }}} ); 
M14_25VM = M14I and M14_25V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M14_25VM, M14I }}} ); 
M14_33VM = M14I and M14_33V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M14_33VM, M14I }}} ); 
M14_50VM = M14I and M14_50V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M14_50VM, M14I }}} ); 
M14_70VM = M14I and M14_70V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M14_70VM, M14I }}} ); 

M15_00VM = M15I and M15_00V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M15_00VM, M15I }}} ); 
M15_01VM = M15I and M15_01V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M15_01VM, M15I }}} ); 
M15_02VM = M15I and M15_02V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M15_02VM, M15I }}} ); 
M15_03VM = M15I and M15_03V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M15_03VM, M15I }}} ); 
M15_04VM = M15I and M15_04V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M15_04VM, M15I }}} ); 
M15_05VM = M15I and M15_05V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M15_05VM, M15I }}} ); 
M15_06VM = M15I and M15_06V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M15_06VM, M15I }}} ); 
M15_07VM = M15I and M15_07V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M15_07VM, M15I }}} ); 
M15_08VM = M15I and M15_08V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M15_08VM, M15I }}} ); 
M15_09VM = M15I and M15_09V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M15_09VM, M15I }}} ); 
M15_10VM = M15I and M15_10V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M15_10VM, M15I }}} ); 
M15_11VM = M15I and M15_11V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M15_11VM, M15I }}} ); 
M15_12VM = M15I and M15_12V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M15_12VM, M15I }}} ); 
M15_13VM = M15I and M15_13V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M15_13VM, M15I }}} ); 
M15_14VM = M15I and M15_14V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M15_14VM, M15I }}} ); 
M15_15VM = M15I and M15_15V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M15_15VM, M15I }}} ); 
M15_16VM = M15I and M15_16V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M15_16VM, M15I }}} ); 
M15_17VM = M15I and M15_17V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M15_17VM, M15I }}} ); 
M15_18VM = M15I and M15_18V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M15_18VM, M15I }}} ); 
M15_25VM = M15I and M15_25V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M15_25VM, M15I }}} ); 
M15_33VM = M15I and M15_33V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M15_33VM, M15I }}} ); 
M15_50VM = M15I and M15_50V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M15_50VM, M15I }}} ); 
M15_70VM = M15I and M15_70V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M15_70VM, M15I }}} ); 

M16_00VM = M16I and M16_00V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M16_00VM, M16I }}} ); 
M16_01VM = M16I and M16_01V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M16_01VM, M16I }}} ); 
M16_02VM = M16I and M16_02V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M16_02VM, M16I }}} ); 
M16_03VM = M16I and M16_03V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M16_03VM, M16I }}} ); 
M16_04VM = M16I and M16_04V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M16_04VM, M16I }}} ); 
M16_05VM = M16I and M16_05V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M16_05VM, M16I }}} ); 
M16_06VM = M16I and M16_06V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M16_06VM, M16I }}} ); 
M16_07VM = M16I and M16_07V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M16_07VM, M16I }}} ); 
M16_08VM = M16I and M16_08V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M16_08VM, M16I }}} ); 
M16_09VM = M16I and M16_09V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M16_09VM, M16I }}} ); 
M16_10VM = M16I and M16_10V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M16_10VM, M16I }}} ); 
M16_11VM = M16I and M16_11V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M16_11VM, M16I }}} ); 
M16_12VM = M16I and M16_12V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M16_12VM, M16I }}} ); 
M16_13VM = M16I and M16_13V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M16_13VM, M16I }}} ); 
M16_14VM = M16I and M16_14V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M16_14VM, M16I }}} ); 
M16_15VM = M16I and M16_15V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M16_15VM, M16I }}} ); 
M16_16VM = M16I and M16_16V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M16_16VM, M16I }}} ); 
M16_17VM = M16I and M16_17V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M16_17VM, M16I }}} ); 
M16_18VM = M16I and M16_18V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M16_18VM, M16I }}} ); 
M16_25VM = M16I and M16_25V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M16_25VM, M16I }}} ); 
M16_33VM = M16I and M16_33V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M16_33VM, M16I }}} ); 
M16_50VM = M16I and M16_50V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M16_50VM, M16I }}} ); 
M16_70VM = M16I and M16_70V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M16_70VM, M16I }}} ); 

M17_00VM = M17I and M17_00V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M17_00VM, M17I }}} ); 
M17_01VM = M17I and M17_01V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M17_01VM, M17I }}} ); 
M17_02VM = M17I and M17_02V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M17_02VM, M17I }}} ); 
M17_03VM = M17I and M17_03V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M17_03VM, M17I }}} ); 
M17_04VM = M17I and M17_04V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M17_04VM, M17I }}} ); 
M17_05VM = M17I and M17_05V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M17_05VM, M17I }}} ); 
M17_06VM = M17I and M17_06V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M17_06VM, M17I }}} ); 
M17_07VM = M17I and M17_07V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M17_07VM, M17I }}} ); 
M17_08VM = M17I and M17_08V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M17_08VM, M17I }}} ); 
M17_09VM = M17I and M17_09V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M17_09VM, M17I }}} ); 
M17_10VM = M17I and M17_10V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M17_10VM, M17I }}} ); 
M17_11VM = M17I and M17_11V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M17_11VM, M17I }}} ); 
M17_12VM = M17I and M17_12V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M17_12VM, M17I }}} ); 
M17_13VM = M17I and M17_13V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M17_13VM, M17I }}} ); 
M17_14VM = M17I and M17_14V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M17_14VM, M17I }}} ); 
M17_15VM = M17I and M17_15V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M17_15VM, M17I }}} ); 
M17_16VM = M17I and M17_16V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M17_16VM, M17I }}} ); 
M17_17VM = M17I and M17_17V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M17_17VM, M17I }}} ); 
M17_18VM = M17I and M17_18V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M17_18VM, M17I }}} ); 
M17_25VM = M17I and M17_25V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M17_25VM, M17I }}} ); 
M17_33VM = M17I and M17_33V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M17_33VM, M17I }}} ); 
M17_50VM = M17I and M17_50V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M17_50VM, M17I }}} ); 
M17_70VM = M17I and M17_70V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M17_70VM, M17I }}} ); 

M18_00VM = M18I and M18_00V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M18_00VM, M18I }}} ); 
M18_01VM = M18I and M18_01V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M18_01VM, M18I }}} ); 
M18_02VM = M18I and M18_02V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M18_02VM, M18I }}} ); 
M18_03VM = M18I and M18_03V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M18_03VM, M18I }}} ); 
M18_04VM = M18I and M18_04V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M18_04VM, M18I }}} ); 
M18_05VM = M18I and M18_05V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M18_05VM, M18I }}} ); 
M18_06VM = M18I and M18_06V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M18_06VM, M18I }}} ); 
M18_07VM = M18I and M18_07V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M18_07VM, M18I }}} ); 
M18_08VM = M18I and M18_08V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M18_08VM, M18I }}} ); 
M18_09VM = M18I and M18_09V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M18_09VM, M18I }}} ); 
M18_10VM = M18I and M18_10V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M18_10VM, M18I }}} ); 
M18_11VM = M18I and M18_11V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M18_11VM, M18I }}} ); 
M18_12VM = M18I and M18_12V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M18_12VM, M18I }}} ); 
M18_13VM = M18I and M18_13V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M18_13VM, M18I }}} ); 
M18_14VM = M18I and M18_14V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M18_14VM, M18I }}} ); 
M18_15VM = M18I and M18_15V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M18_15VM, M18I }}} ); 
M18_16VM = M18I and M18_16V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M18_16VM, M18I }}} ); 
M18_17VM = M18I and M18_17V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M18_17VM, M18I }}} ); 
M18_18VM = M18I and M18_18V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M18_18VM, M18I }}} ); 
M18_25VM = M18I and M18_25V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M18_25VM, M18I }}} ); 
M18_33VM = M18I and M18_33V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M18_33VM, M18I }}} ); 
M18_50VM = M18I and M18_50V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M18_50VM, M18I }}} ); 
M18_70VM = M18I and M18_70V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M18_70VM, M18I }}} ); 

M19_00VM = M19I and M19_00V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M19_00VM, M19I }}} ); 
M19_01VM = M19I and M19_01V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M19_01VM, M19I }}} ); 
M19_02VM = M19I and M19_02V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M19_02VM, M19I }}} ); 
M19_03VM = M19I and M19_03V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M19_03VM, M19I }}} ); 
M19_04VM = M19I and M19_04V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M19_04VM, M19I }}} ); 
M19_05VM = M19I and M19_05V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M19_05VM, M19I }}} ); 
M19_06VM = M19I and M19_06V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M19_06VM, M19I }}} ); 
M19_07VM = M19I and M19_07V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M19_07VM, M19I }}} ); 
M19_08VM = M19I and M19_08V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M19_08VM, M19I }}} ); 
M19_09VM = M19I and M19_09V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M19_09VM, M19I }}} ); 
M19_10VM = M19I and M19_10V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M19_10VM, M19I }}} ); 
M19_11VM = M19I and M19_11V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M19_11VM, M19I }}} ); 
M19_12VM = M19I and M19_12V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M19_12VM, M19I }}} ); 
M19_13VM = M19I and M19_13V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M19_13VM, M19I }}} ); 
M19_14VM = M19I and M19_14V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M19_14VM, M19I }}} ); 
M19_15VM = M19I and M19_15V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M19_15VM, M19I }}} ); 
M19_16VM = M19I and M19_16V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M19_16VM, M19I }}} ); 
M19_17VM = M19I and M19_17V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M19_17VM, M19I }}} ); 
M19_18VM = M19I and M19_18V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M19_18VM, M19I }}} ); 
M19_25VM = M19I and M19_25V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M19_25VM, M19I }}} ); 
M19_33VM = M19I and M19_33V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M19_33VM, M19I }}} ); 
M19_50VM = M19I and M19_50V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M19_50VM, M19I }}} ); 
M19_70VM = M19I and M19_70V; 
CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M19_70VM, M19I }}} ); 


//DV recognition start

HV_ID_TOP_tag.push_back("AP_HV_ID_TOP");
HV_ID_TOP_tag.push_back("CU_RDL_HV_ID_TOP");

HV_ID_TOP_tag.push_back("M19_HV_ID_TOP");
HV_ID_TOP_tag.push_back("M18_HV_ID_TOP");
HV_ID_TOP_tag.push_back("M17_HV_ID_TOP");
HV_ID_TOP_tag.push_back("M16_HV_ID_TOP");
HV_ID_TOP_tag.push_back("M15_HV_ID_TOP");
HV_ID_TOP_tag.push_back("M14_HV_ID_TOP");
HV_ID_TOP_tag.push_back("M13_HV_ID_TOP");
HV_ID_TOP_tag.push_back("M12_HV_ID_TOP");
HV_ID_TOP_tag.push_back("M11_HV_ID_TOP");
HV_ID_TOP_tag.push_back("M10_HV_ID_TOP");
HV_ID_TOP_tag.push_back("M9_HV_ID_TOP");
HV_ID_TOP_tag.push_back("M8_HV_ID_TOP");
HV_ID_TOP_tag.push_back("M7_HV_ID_TOP");
HV_ID_TOP_tag.push_back("M6_HV_ID_TOP");
HV_ID_TOP_tag.push_back("M5_HV_ID_TOP");
HV_ID_TOP_tag.push_back("M4_HV_ID_TOP");
HV_ID_TOP_tag.push_back("M3_HV_ID_TOP");
HV_ID_TOP_tag.push_back("M2_HV_ID_TOP");
HV_ID_TOP_tag.push_back("M1_HV_ID_TOP");
HV_ID_TOP_tag.push_back("M0_HV_ID_TOP");

LV_ID_TOP_tag.push_back("AP_LV_ID_TOP");
LV_ID_TOP_tag.push_back("CU_RDL_LV_ID_TOP");
LV_ID_TOP_tag.push_back("M19_LV_ID_TOP");
LV_ID_TOP_tag.push_back("M18_LV_ID_TOP");
LV_ID_TOP_tag.push_back("M17_LV_ID_TOP");
LV_ID_TOP_tag.push_back("M16_LV_ID_TOP");
LV_ID_TOP_tag.push_back("M15_LV_ID_TOP");
LV_ID_TOP_tag.push_back("M14_LV_ID_TOP");
LV_ID_TOP_tag.push_back("M13_LV_ID_TOP");
LV_ID_TOP_tag.push_back("M12_LV_ID_TOP");
LV_ID_TOP_tag.push_back("M11_LV_ID_TOP");
LV_ID_TOP_tag.push_back("M10_LV_ID_TOP");
LV_ID_TOP_tag.push_back("M9_LV_ID_TOP");
LV_ID_TOP_tag.push_back("M8_LV_ID_TOP");
LV_ID_TOP_tag.push_back("M7_LV_ID_TOP");
LV_ID_TOP_tag.push_back("M6_LV_ID_TOP");
LV_ID_TOP_tag.push_back("M5_LV_ID_TOP");
LV_ID_TOP_tag.push_back("M4_LV_ID_TOP");
LV_ID_TOP_tag.push_back("M3_LV_ID_TOP");
LV_ID_TOP_tag.push_back("M2_LV_ID_TOP");
LV_ID_TOP_tag.push_back("M1_LV_ID_TOP");
LV_ID_TOP_tag.push_back("M0_LV_ID_TOP");

HV_marker_tag.push_back("MALL_70VM");
HV_marker_voltage.push_back(7.0);

HV_marker_tag.push_back("MALL_50VM");
HV_marker_voltage.push_back(5.0);

HV_marker_tag.push_back("MD_33VM");
HV_marker_voltage.push_back(3.3);

HV_marker_tag.push_back("MALL_33VM");
HV_marker_voltage.push_back(3.3);

HV_marker_tag.push_back("MD_25VM");
HV_marker_voltage.push_back(2.5);

HV_marker_tag.push_back("MALL_25VM");
HV_marker_voltage.push_back(2.5);

HV_marker_tag.push_back("MALL_18VM");
HV_marker_voltage.push_back(1.8);

HV_marker_tag.push_back("MALL_17VM");
HV_marker_voltage.push_back(1.7);

HV_marker_tag.push_back("MALL_16VM");
HV_marker_voltage.push_back(1.6);

HV_marker_tag.push_back("MALL_15VM");
HV_marker_voltage.push_back(1.5);

HV_marker_tag.push_back("MALL_14VM");
HV_marker_voltage.push_back(1.4);

HV_marker_tag.push_back("MALL_13VM");
HV_marker_voltage.push_back(1.3);

HV_marker_tag.push_back("MD_12VM");
HV_marker_voltage.push_back(1.2);

HV_marker_tag.push_back("MALL_12VM");
HV_marker_voltage.push_back(1.2);

HV_marker_tag.push_back("MALL_11VM");
HV_marker_voltage.push_back(1.1);

HV_marker_tag.push_back("MALL_10VM");
HV_marker_voltage.push_back(1.0);

HV_marker_tag.push_back("MALL_09VM");
HV_marker_voltage.push_back(0.9);

HV_marker_tag.push_back("MALL_08VM");
HV_marker_voltage.push_back(0.8);

HV_marker_tag.push_back("MALL_07VM");
HV_marker_voltage.push_back(0.7);

HV_marker_tag.push_back("MALL_06VM");
HV_marker_voltage.push_back(0.6);

HV_marker_tag.push_back("MALL_05VM");
HV_marker_voltage.push_back(0.5);

HV_marker_tag.push_back("MALL_04VM");
HV_marker_voltage.push_back(0.4);

HV_marker_tag.push_back("MALL_03VM");
HV_marker_voltage.push_back(0.3);

HV_marker_tag.push_back("MALL_02VM");
HV_marker_voltage.push_back(0.2);

HV_marker_tag.push_back("MALL_01VM");
HV_marker_voltage.push_back(0.1);

HV_marker_tag.push_back("MALL_00VM");
HV_marker_voltage.push_back(0.0);

		// device connection part (connect core/IO devices, choose IO voltage)
 		HV_marker_tag.push_back("PSTP_00");
		HV_marker_voltage.push_back(0);

 		HV_marker_tag.push_back("PSD_15");
		HV_marker_voltage.push_back(1.5);
 		HV_marker_tag.push_back("NSD_15");
		HV_marker_voltage.push_back(1.5);
 		HV_marker_tag.push_back("VAR_15"); 
		HV_marker_voltage.push_back(1.5);
 		HV_marker_tag.push_back("GATE_15"); 
		HV_marker_voltage.push_back(1.5);

 		HV_marker_tag.push_back("PSD_12");
		HV_marker_voltage.push_back(1.32);
 		HV_marker_tag.push_back("NSD_12"); 
		HV_marker_voltage.push_back(1.32);
 		HV_marker_tag.push_back("VAR_12");
		HV_marker_voltage.push_back(1.32);
 		HV_marker_tag.push_back("GATE_12");
		HV_marker_voltage.push_back(1.32);
		
 		HV_marker_tag.push_back("PSD_CORE");
		HV_marker_voltage.push_back(CORE_VOLT);
 		HV_marker_tag.push_back("NSD_CORE");
		HV_marker_voltage.push_back(CORE_VOLT);
 		HV_marker_tag.push_back("VAR_CORE"); 
		HV_marker_voltage.push_back(CORE_VOLT);
 		HV_marker_tag.push_back("GATE_CORE"); 
		HV_marker_voltage.push_back(CORE_VOLT);


//DV recognition end

u_net_voltage : function (void) returning void
{
    vh_temp : double;
    vh : double;
    vl_temp : double;
    vl : double;
    vh = 0.0;
    vl = 0.0;
    vh_top : double;
    vl_top : double;
    top_flag1 : boolean = false;
    top_flag2 : boolean = false;

    // volt high
    for (i = 0 to HV_ID_TOP_tag.size()-1) {
        if (!top_flag1) {
            top_flag1 = ptn_get_max_double_property(HV_ID_TOP_tag[i], "high", vh_top);
        }
    }

    if(top_flag1) {
	    vh = vh_top;
    } elseif (ptn_get_max_double_property("MVH", "high", vh_temp)) {
	    vh = vh_temp;
    } else {
            mkrflag : boolean = false;
            for (i = 0 to HV_marker_tag.size()-1) {
	        if (!mkrflag) {
                    mkrflag = mkrflag || ptn_net_data_exist(HV_marker_tag[i]);
                    if (mkrflag) { 
            			vh = HV_marker_voltage[i]; 
		            }
                }
	    }
            if (!mkrflag) { 
		        vh = 0.0; 
	        }
    } 
    
    // volt low
    for (i = 0 to LV_ID_TOP_tag.size()-1) {
        if (!top_flag2) {
            top_flag2 = ptn_get_min_double_property(LV_ID_TOP_tag[i], "low", vl_top);
        }
    }

    if (top_flag2) { 
	    vl = vl_top;
    } elseif (ptn_get_min_double_property("MVL", "low", vl_temp)) {
	    vl = vl_temp;
    } else {
	    vl = 0.0;
    }

    ptn_save_double_property("high", vh);
    ptn_save_double_property("low", vl);
}







































CONNECT_DB_DV_without_prop = CONNECT_DB_DV;

u_net_voltage_id : function (void) returning void
{
    flag : double = 0;
    if (ptn_net_data_exist("ID"))
    {
        flag = 1;
    }
    ptn_save_double_property("flag", flag);
}


CONNECT_DB_DV_LUP_UNDEF = property_to_net( 
	connect_sequence = CONNECT_DB_DV_without_prop,
	net_property_function = u_net_voltage_id,
	layer_groups = {
	    "ID" => { OD_HV_ID, PO_HV_ID, MD_HV_ID, M0_HV_ID, M1_HV_ID, M2_HV_ID, M3_HV_ID, M4_HV_ID, M5_HV_ID, M6_HV_ID, M7_HV_ID, M8_HV_ID, M9_HV_ID, M10_HV_ID, M11_HV_ID, M12_HV_ID, M13_HV_ID, M14_HV_ID, M15_HV_ID, M16_HV_ID, M17_HV_ID, M18_HV_ID, M19_HV_ID, AP_HV_ID, CU_RDL_HV_ID, OD_LV_ID, PO_LV_ID, MD_LV_ID, M0_LV_ID, M1_LV_ID, M2_LV_ID, M3_LV_ID, M4_LV_ID, M5_LV_ID, M6_LV_ID, M7_LV_ID, M8_LV_ID, M9_LV_ID, M10_LV_ID, M11_LV_ID, M12_LV_ID, M13_LV_ID, M14_LV_ID, M15_LV_ID, M16_LV_ID, M17_LV_ID, M18_LV_ID, M19_LV_ID, AP_LV_ID, CU_RDL_LV_ID,
	    M0_HV_ID_TOP,
	    M1_HV_ID_TOP,
	    M2_HV_ID_TOP,
	    M3_HV_ID_TOP,
	    M4_HV_ID_TOP,
	    M5_HV_ID_TOP,
	    M6_HV_ID_TOP,
	    M7_HV_ID_TOP,
	    M8_HV_ID_TOP,
	    M9_HV_ID_TOP,
	    M10_HV_ID_TOP,
	    M11_HV_ID_TOP,
	    M12_HV_ID_TOP,
	    M13_HV_ID_TOP,
	    M14_HV_ID_TOP,
	    M15_HV_ID_TOP,
	    M16_HV_ID_TOP,
	    M17_HV_ID_TOP,
	    M18_HV_ID_TOP,
	    M19_HV_ID_TOP,
	    M0_LV_ID_TOP,
	    M1_LV_ID_TOP,
	    M2_LV_ID_TOP,
	    M3_LV_ID_TOP,
	    M4_LV_ID_TOP,
	    M5_LV_ID_TOP,
	    M6_LV_ID_TOP,
	    M7_LV_ID_TOP,
	    M8_LV_ID_TOP,
	    M9_LV_ID_TOP,
	    M10_LV_ID_TOP,
	    M11_LV_ID_TOP,
	    M12_LV_ID_TOP,
	    M13_LV_ID_TOP,
	    M14_LV_ID_TOP,
	    M15_LV_ID_TOP,
	    M16_LV_ID_TOP,
	    M17_LV_ID_TOP,
	    M18_LV_ID_TOP,
	    M19_LV_ID_TOP,
	    AP_HV_ID_TOP,
	    AP_LV_ID_TOP,
	    CU_RDL_HV_ID_TOP,
	    CU_RDL_LV_ID_TOP,
	    PSTP_00,
	    PSD_15, 
	    NSD_15, 
	    VAR_15,
	    GATE_15, 
	    PSD_12,
	    NSD_12,
	    VAR_12,
	    GATE_12,
	    PSD_CORE,
	    NSD_CORE,
	    VAR_CORE,
	    GATE_CORE,
	    MD_12VM,
	    MD_25VM,
	    MD_33VM,
	    M0_00VM, M1_00VM, M2_00VM, M3_00VM, M4_00VM, M5_00VM, M6_00VM, M7_00VM, M8_00VM, M9_00VM, M10_00VM, M11_00VM, M12_00VM, M13_00VM, M14_00VM, M15_00VM, M16_00VM, M17_00VM, M18_00VM, M19_00VM,
	    M0_01VM, M1_01VM, M2_01VM, M3_01VM, M4_01VM, M5_01VM, M6_01VM, M7_01VM, M8_01VM, M9_01VM, M10_01VM, M11_01VM, M12_01VM, M13_01VM, M14_01VM, M15_01VM, M16_01VM, M17_01VM, M18_01VM, M19_01VM,
	    M0_02VM, M1_02VM, M2_02VM, M3_02VM, M4_02VM, M5_02VM, M6_02VM, M7_02VM, M8_02VM, M9_02VM, M10_02VM, M11_02VM, M12_02VM, M13_02VM, M14_02VM, M15_02VM, M16_02VM, M17_02VM, M18_02VM, M19_02VM,
	    M0_03VM, M1_03VM, M2_03VM, M3_03VM, M4_03VM, M5_03VM, M6_03VM, M7_03VM, M8_03VM, M9_03VM, M10_03VM, M11_03VM, M12_03VM, M13_03VM, M14_03VM, M15_03VM, M16_03VM, M17_03VM, M18_03VM, M19_03VM,
	    M0_04VM, M1_04VM, M2_04VM, M3_04VM, M4_04VM, M5_04VM, M6_04VM, M7_04VM, M8_04VM, M9_04VM, M10_04VM, M11_04VM, M12_04VM, M13_04VM, M14_04VM, M15_04VM, M16_04VM, M17_04VM, M18_04VM, M19_04VM,
	    M0_05VM, M1_05VM, M2_05VM, M3_05VM, M4_05VM, M5_05VM, M6_05VM, M7_05VM, M8_05VM, M9_05VM, M10_05VM, M11_05VM, M12_05VM, M13_05VM, M14_05VM, M15_05VM, M16_05VM, M17_05VM, M18_05VM, M19_05VM,
	    M0_06VM, M1_06VM, M2_06VM, M3_06VM, M4_06VM, M5_06VM, M6_06VM, M7_06VM, M8_06VM, M9_06VM, M10_06VM, M11_06VM, M12_06VM, M13_06VM, M14_06VM, M15_06VM, M16_06VM, M17_06VM, M18_06VM, M19_06VM,
	    M0_07VM, M1_07VM, M2_07VM, M3_07VM, M4_07VM, M5_07VM, M6_07VM, M7_07VM, M8_07VM, M9_07VM, M10_07VM, M11_07VM, M12_07VM, M13_07VM, M14_07VM, M15_07VM, M16_07VM, M17_07VM, M18_07VM, M19_07VM,
	    M0_08VM, M1_08VM, M2_08VM, M3_08VM, M4_08VM, M5_08VM, M6_08VM, M7_08VM, M8_08VM, M9_08VM, M10_08VM, M11_08VM, M12_08VM, M13_08VM, M14_08VM, M15_08VM, M16_08VM, M17_08VM, M18_08VM, M19_08VM,
	    M0_09VM, M1_09VM, M2_09VM, M3_09VM, M4_09VM, M5_09VM, M6_09VM, M7_09VM, M8_09VM, M9_09VM, M10_09VM, M11_09VM, M12_09VM, M13_09VM, M14_09VM, M15_09VM, M16_09VM, M17_09VM, M18_09VM, M19_09VM,
	    M0_10VM, M1_10VM, M2_10VM, M3_10VM, M4_10VM, M5_10VM, M6_10VM, M7_10VM, M8_10VM, M9_10VM, M10_10VM, M11_10VM, M12_10VM, M13_10VM, M14_10VM, M15_10VM, M16_10VM, M17_10VM, M18_10VM, M19_10VM,
	    M0_11VM, M1_11VM, M2_11VM, M3_11VM, M4_11VM, M5_11VM, M6_11VM, M7_11VM, M8_11VM, M9_11VM, M10_11VM, M11_11VM, M12_11VM, M13_11VM, M14_11VM, M15_11VM, M16_11VM, M17_11VM, M18_11VM, M19_11VM,
	    M0_12VM, M1_12VM, M2_12VM, M3_12VM, M4_12VM, M5_12VM, M6_12VM, M7_12VM, M8_12VM, M9_12VM, M10_12VM, M11_12VM, M12_12VM, M13_12VM, M14_12VM, M15_12VM, M16_12VM, M17_12VM, M18_12VM, M19_12VM,
	    M0_13VM, M1_13VM, M2_13VM, M3_13VM, M4_13VM, M5_13VM, M6_13VM, M7_13VM, M8_13VM, M9_13VM, M10_13VM, M11_13VM, M12_13VM, M13_13VM, M14_13VM, M15_13VM, M16_13VM, M17_13VM, M18_13VM, M19_13VM,
	    M0_14VM, M1_14VM, M2_14VM, M3_14VM, M4_14VM, M5_14VM, M6_14VM, M7_14VM, M8_14VM, M9_14VM, M10_14VM, M11_14VM, M12_14VM, M13_14VM, M14_14VM, M15_14VM, M16_14VM, M17_14VM, M18_14VM, M19_14VM,
	    M0_15VM, M1_15VM, M2_15VM, M3_15VM, M4_15VM, M5_15VM, M6_15VM, M7_15VM, M8_15VM, M9_15VM, M10_15VM, M11_15VM, M12_15VM, M13_15VM, M14_15VM, M15_15VM, M16_15VM, M17_15VM, M18_15VM, M19_15VM,
	    M0_16VM, M1_16VM, M2_16VM, M3_16VM, M4_16VM, M5_16VM, M6_16VM, M7_16VM, M8_16VM, M9_16VM, M10_16VM, M11_16VM, M12_16VM, M13_16VM, M14_16VM, M15_16VM, M16_16VM, M17_16VM, M18_16VM, M19_16VM,
	    M0_17VM, M1_17VM, M2_17VM, M3_17VM, M4_17VM, M5_17VM, M6_17VM, M7_17VM, M8_17VM, M9_17VM, M10_17VM, M11_17VM, M12_17VM, M13_17VM, M14_17VM, M15_17VM, M16_17VM, M17_17VM, M18_17VM, M19_17VM,
	    M0_18VM, M1_18VM, M2_18VM, M3_18VM, M4_18VM, M5_18VM, M6_18VM, M7_18VM, M8_18VM, M9_18VM, M10_18VM, M11_18VM, M12_18VM, M13_18VM, M14_18VM, M15_18VM, M16_18VM, M17_18VM, M18_18VM, M19_18VM,
	    M0_25VM, M1_25VM, M2_25VM, M3_25VM, M4_25VM, M5_25VM, M6_25VM, M7_25VM, M8_25VM, M9_25VM, M10_25VM, M11_25VM, M12_25VM, M13_25VM, M14_25VM, M15_25VM, M16_25VM, M17_25VM, M18_25VM, M19_25VM,
	    M0_33VM, M1_33VM, M2_33VM, M3_33VM, M4_33VM, M5_33VM, M6_33VM, M7_33VM, M8_33VM, M9_33VM, M10_33VM, M11_33VM, M12_33VM, M13_33VM, M14_33VM, M15_33VM, M16_33VM, M17_33VM, M18_33VM, M19_33VM,
	    M0_50VM, M1_50VM, M2_50VM, M3_50VM, M4_50VM, M5_50VM, M6_50VM, M7_50VM, M8_50VM, M9_50VM, M10_50VM, M11_50VM, M12_50VM, M13_50VM, M14_50VM, M15_50VM, M16_50VM, M17_50VM, M18_50VM, M19_50VM,
	    M0_70VM, M1_70VM, M2_70VM, M3_70VM, M4_70VM, M5_70VM, M6_70VM, M7_70VM, M8_70VM, M9_70VM, M10_70VM, M11_70VM, M12_70VM, M13_70VM, M14_70VM, M15_70VM, M16_70VM, M17_70VM, M18_70VM, M19_70VM,
	    }
	},
	sync_nets = {
        	{ ILP1I, MDV_SYNC },
	        { MD_NOT_CMDI, MDV_SYNC },
		{ M0_NOT_CM0I, M0V_SYNC },
		{ M1I, M1V_SYNC },
		{ M2I, M2V_SYNC },
		{ M3I, M3V_SYNC },
		{ M4I, M4V_SYNC },
		{ M5I, M5V_SYNC },
		{ M6I, M6V_SYNC },
		{ M7I, M7V_SYNC },
		{ M8I, M8V_SYNC },
		{ M9I, M9V_SYNC },
		{ M10I, M10V_SYNC },
		{ M11I, M11V_SYNC },
		{ M12I, M12V_SYNC },
		{ M13I, M13V_SYNC },
		{ M14I, M14V_SYNC },
		{ M15I, M15V_SYNC },
		{ M16I, M16V_SYNC },
		{ M17I, M17V_SYNC },
		{ M18I, M18V_SYNC },
		{ M19I, M19V_SYNC },
		{ API, APV_SYNC },
		{ CU_RDLI, CU_RDLV_SYNC }
	},

	sync_name = "sync"

);


CONNECT_DB_DV_MOM_UNDEF = property_to_net( 
	connect_sequence = CONNECT_DB_DV_without_prop,
	net_property_function = u_net_voltage_id,
	layer_groups = {
	    "ID" => { OD_HV_ID, PO_HV_ID, MD_HV_ID, M0_HV_ID, M1_HV_ID, M2_HV_ID, M3_HV_ID, M4_HV_ID, M5_HV_ID, M6_HV_ID, M7_HV_ID, M8_HV_ID, M9_HV_ID, M10_HV_ID, M11_HV_ID, M12_HV_ID, M13_HV_ID, M14_HV_ID, M15_HV_ID, M16_HV_ID, M17_HV_ID, M18_HV_ID, M19_HV_ID, AP_HV_ID, CU_RDL_HV_ID, OD_LV_ID, PO_LV_ID, MD_LV_ID, M0_LV_ID, M1_LV_ID, M2_LV_ID, M3_LV_ID, M4_LV_ID, M5_LV_ID, M6_LV_ID, M7_LV_ID, M8_LV_ID, M9_LV_ID, M10_LV_ID, M11_LV_ID, M12_LV_ID, M13_LV_ID, M14_LV_ID, M15_LV_ID, M16_LV_ID, M17_LV_ID, M18_LV_ID, M19_LV_ID, AP_LV_ID, CU_RDL_LV_ID, 
	    M0_HV_ID_TOP,
	    M1_HV_ID_TOP,
	    M2_HV_ID_TOP,
	    M3_HV_ID_TOP,
	    M4_HV_ID_TOP,
	    M5_HV_ID_TOP,
	    M6_HV_ID_TOP,
	    M7_HV_ID_TOP,
	    M8_HV_ID_TOP,
	    M9_HV_ID_TOP,
	    M10_HV_ID_TOP,
	    M11_HV_ID_TOP,
	    M12_HV_ID_TOP,
	    M13_HV_ID_TOP,
	    M14_HV_ID_TOP,
	    M15_HV_ID_TOP,
	    M16_HV_ID_TOP,
	    M17_HV_ID_TOP,
	    M18_HV_ID_TOP,
	    M19_HV_ID_TOP,
	    M0_LV_ID_TOP,
	    M1_LV_ID_TOP,
	    M2_LV_ID_TOP,
	    M3_LV_ID_TOP,
	    M4_LV_ID_TOP,
	    M5_LV_ID_TOP,
	    M6_LV_ID_TOP,
	    M7_LV_ID_TOP,
	    M8_LV_ID_TOP,
	    M9_LV_ID_TOP,
	    M10_LV_ID_TOP,
	    M11_LV_ID_TOP,
	    M12_LV_ID_TOP,
	    M13_LV_ID_TOP,
	    M14_LV_ID_TOP,
	    M15_LV_ID_TOP,
	    M16_LV_ID_TOP,
	    M17_LV_ID_TOP,
	    M18_LV_ID_TOP,
	    M19_LV_ID_TOP,
	    AP_HV_ID_TOP,
	    AP_LV_ID_TOP,
	    CU_RDL_HV_ID_TOP,
	    CU_RDL_LV_ID_TOP,
	    PSTP_00,
	    PSD_15, 
	    NSD_15, 
	    VAR_15,
	    GATE_15, 
	    PSD_12,
	    NSD_12,
	    VAR_12,
	    GATE_12,
	    PSD_CORE,
	    NSD_CORE,
	    VAR_CORE,
	    GATE_CORE,
	    MD_12VM,
	    MD_25VM,
	    MD_33VM,
	    M0_00VM, M1_00VM, M2_00VM, M3_00VM, M4_00VM, M5_00VM, M6_00VM, M7_00VM, M8_00VM, M9_00VM, M10_00VM, M11_00VM, M12_00VM, M13_00VM, M14_00VM, M15_00VM, M16_00VM, M17_00VM, M18_00VM, M19_00VM,
	    M0_01VM, M1_01VM, M2_01VM, M3_01VM, M4_01VM, M5_01VM, M6_01VM, M7_01VM, M8_01VM, M9_01VM, M10_01VM, M11_01VM, M12_01VM, M13_01VM, M14_01VM, M15_01VM, M16_01VM, M17_01VM, M18_01VM, M19_01VM,
	    M0_02VM, M1_02VM, M2_02VM, M3_02VM, M4_02VM, M5_02VM, M6_02VM, M7_02VM, M8_02VM, M9_02VM, M10_02VM, M11_02VM, M12_02VM, M13_02VM, M14_02VM, M15_02VM, M16_02VM, M17_02VM, M18_02VM, M19_02VM,
	    M0_03VM, M1_03VM, M2_03VM, M3_03VM, M4_03VM, M5_03VM, M6_03VM, M7_03VM, M8_03VM, M9_03VM, M10_03VM, M11_03VM, M12_03VM, M13_03VM, M14_03VM, M15_03VM, M16_03VM, M17_03VM, M18_03VM, M19_03VM,
	    M0_04VM, M1_04VM, M2_04VM, M3_04VM, M4_04VM, M5_04VM, M6_04VM, M7_04VM, M8_04VM, M9_04VM, M10_04VM, M11_04VM, M12_04VM, M13_04VM, M14_04VM, M15_04VM, M16_04VM, M17_04VM, M18_04VM, M19_04VM,
	    M0_05VM, M1_05VM, M2_05VM, M3_05VM, M4_05VM, M5_05VM, M6_05VM, M7_05VM, M8_05VM, M9_05VM, M10_05VM, M11_05VM, M12_05VM, M13_05VM, M14_05VM, M15_05VM, M16_05VM, M17_05VM, M18_05VM, M19_05VM,
	    M0_06VM, M1_06VM, M2_06VM, M3_06VM, M4_06VM, M5_06VM, M6_06VM, M7_06VM, M8_06VM, M9_06VM, M10_06VM, M11_06VM, M12_06VM, M13_06VM, M14_06VM, M15_06VM, M16_06VM, M17_06VM, M18_06VM, M19_06VM,
	    M0_07VM, M1_07VM, M2_07VM, M3_07VM, M4_07VM, M5_07VM, M6_07VM, M7_07VM, M8_07VM, M9_07VM, M10_07VM, M11_07VM, M12_07VM, M13_07VM, M14_07VM, M15_07VM, M16_07VM, M17_07VM, M18_07VM, M19_07VM,
	    M0_08VM, M1_08VM, M2_08VM, M3_08VM, M4_08VM, M5_08VM, M6_08VM, M7_08VM, M8_08VM, M9_08VM, M10_08VM, M11_08VM, M12_08VM, M13_08VM, M14_08VM, M15_08VM, M16_08VM, M17_08VM, M18_08VM, M19_08VM,
	    M0_09VM, M1_09VM, M2_09VM, M3_09VM, M4_09VM, M5_09VM, M6_09VM, M7_09VM, M8_09VM, M9_09VM, M10_09VM, M11_09VM, M12_09VM, M13_09VM, M14_09VM, M15_09VM, M16_09VM, M17_09VM, M18_09VM, M19_09VM,
	    M0_10VM, M1_10VM, M2_10VM, M3_10VM, M4_10VM, M5_10VM, M6_10VM, M7_10VM, M8_10VM, M9_10VM, M10_10VM, M11_10VM, M12_10VM, M13_10VM, M14_10VM, M15_10VM, M16_10VM, M17_10VM, M18_10VM, M19_10VM,
	    M0_11VM, M1_11VM, M2_11VM, M3_11VM, M4_11VM, M5_11VM, M6_11VM, M7_11VM, M8_11VM, M9_11VM, M10_11VM, M11_11VM, M12_11VM, M13_11VM, M14_11VM, M15_11VM, M16_11VM, M17_11VM, M18_11VM, M19_11VM,
	    M0_12VM, M1_12VM, M2_12VM, M3_12VM, M4_12VM, M5_12VM, M6_12VM, M7_12VM, M8_12VM, M9_12VM, M10_12VM, M11_12VM, M12_12VM, M13_12VM, M14_12VM, M15_12VM, M16_12VM, M17_12VM, M18_12VM, M19_12VM,
	    M0_13VM, M1_13VM, M2_13VM, M3_13VM, M4_13VM, M5_13VM, M6_13VM, M7_13VM, M8_13VM, M9_13VM, M10_13VM, M11_13VM, M12_13VM, M13_13VM, M14_13VM, M15_13VM, M16_13VM, M17_13VM, M18_13VM, M19_13VM,
	    M0_14VM, M1_14VM, M2_14VM, M3_14VM, M4_14VM, M5_14VM, M6_14VM, M7_14VM, M8_14VM, M9_14VM, M10_14VM, M11_14VM, M12_14VM, M13_14VM, M14_14VM, M15_14VM, M16_14VM, M17_14VM, M18_14VM, M19_14VM,
	    M0_15VM, M1_15VM, M2_15VM, M3_15VM, M4_15VM, M5_15VM, M6_15VM, M7_15VM, M8_15VM, M9_15VM, M10_15VM, M11_15VM, M12_15VM, M13_15VM, M14_15VM, M15_15VM, M16_15VM, M17_15VM, M18_15VM, M19_15VM,
	    M0_16VM, M1_16VM, M2_16VM, M3_16VM, M4_16VM, M5_16VM, M6_16VM, M7_16VM, M8_16VM, M9_16VM, M10_16VM, M11_16VM, M12_16VM, M13_16VM, M14_16VM, M15_16VM, M16_16VM, M17_16VM, M18_16VM, M19_16VM,
	    M0_17VM, M1_17VM, M2_17VM, M3_17VM, M4_17VM, M5_17VM, M6_17VM, M7_17VM, M8_17VM, M9_17VM, M10_17VM, M11_17VM, M12_17VM, M13_17VM, M14_17VM, M15_17VM, M16_17VM, M17_17VM, M18_17VM, M19_17VM,
	    M0_18VM, M1_18VM, M2_18VM, M3_18VM, M4_18VM, M5_18VM, M6_18VM, M7_18VM, M8_18VM, M9_18VM, M10_18VM, M11_18VM, M12_18VM, M13_18VM, M14_18VM, M15_18VM, M16_18VM, M17_18VM, M18_18VM, M19_18VM,
	    M0_25VM, M1_25VM, M2_25VM, M3_25VM, M4_25VM, M5_25VM, M6_25VM, M7_25VM, M8_25VM, M9_25VM, M10_25VM, M11_25VM, M12_25VM, M13_25VM, M14_25VM, M15_25VM, M16_25VM, M17_25VM, M18_25VM, M19_25VM,
	    M0_33VM, M1_33VM, M2_33VM, M3_33VM, M4_33VM, M5_33VM, M6_33VM, M7_33VM, M8_33VM, M9_33VM, M10_33VM, M11_33VM, M12_33VM, M13_33VM, M14_33VM, M15_33VM, M16_33VM, M17_33VM, M18_33VM, M19_33VM,
	    M0_50VM, M1_50VM, M2_50VM, M3_50VM, M4_50VM, M5_50VM, M6_50VM, M7_50VM, M8_50VM, M9_50VM, M10_50VM, M11_50VM, M12_50VM, M13_50VM, M14_50VM, M15_50VM, M16_50VM, M17_50VM, M18_50VM, M19_50VM,
	    M0_70VM, M1_70VM, M2_70VM, M3_70VM, M4_70VM, M5_70VM, M6_70VM, M7_70VM, M8_70VM, M9_70VM, M10_70VM, M11_70VM, M12_70VM, M13_70VM, M14_70VM, M15_70VM, M16_70VM, M17_70VM, M18_70VM, M19_70VM,
	    }
	},
	sync_nets = {
	        { ILP1I, MDV_SYNC },
	        { MD_NOT_CMDI, MDV_SYNC },
		{ M0_NOT_CM0I, M0V_SYNC },
		{ M1I, M1V_SYNC },
		{ M2I, M2V_SYNC },
		{ M3I, M3V_SYNC },
		{ M4I, M4V_SYNC },
		{ M5I, M5V_SYNC },
		{ M6I, M6V_SYNC },
		{ M7I, M7V_SYNC },
		{ M8I, M8V_SYNC },
		{ M9I, M9V_SYNC },
		{ M10I, M10V_SYNC },
		{ M11I, M11V_SYNC },
		{ M12I, M12V_SYNC },
		{ M13I, M13V_SYNC },
		{ M14I, M14V_SYNC },
		{ M15I, M15V_SYNC },
		{ M16I, M16V_SYNC },
		{ M17I, M17V_SYNC },
		{ M18I, M18V_SYNC },
		{ M19I, M19V_SYNC },
		{ API, APV_SYNC },
		{ CU_RDLI, CU_RDLV_SYNC }
	},

	sync_name = "sync"
);


CONNECT_DB_DV = property_to_net( 
	connect_sequence = CONNECT_DB_DV_without_prop,
	net_property_function = u_net_voltage,
	layer_groups = {
	    "MVH" => { OD_HV_ID, PO_HV_ID, MD_HV_ID, M0_HV_ID, M1_HV_ID, M2_HV_ID, M3_HV_ID, M4_HV_ID, M5_HV_ID, M6_HV_ID, M7_HV_ID, M8_HV_ID, M9_HV_ID, M10_HV_ID, M11_HV_ID, M12_HV_ID, M13_HV_ID, M14_HV_ID, M15_HV_ID, M16_HV_ID, M17_HV_ID, M18_HV_ID, M19_HV_ID, AP_HV_ID, CU_RDL_HV_ID },
	    "MVL" => { OD_LV_ID, PO_LV_ID, MD_LV_ID, M0_LV_ID, M1_LV_ID, M2_LV_ID, M3_LV_ID, M4_LV_ID, M5_LV_ID, M6_LV_ID, M7_LV_ID, M8_LV_ID, M9_LV_ID, M10_LV_ID, M11_LV_ID, M12_LV_ID, M13_LV_ID, M14_LV_ID, M15_LV_ID, M16_LV_ID, M17_LV_ID, M18_LV_ID, M19_LV_ID, AP_LV_ID, CU_RDL_LV_ID },
	    "M0_HV_ID_TOP" => M0_HV_ID_TOP,
	    "M1_HV_ID_TOP" => M1_HV_ID_TOP,
	    "M2_HV_ID_TOP" => M2_HV_ID_TOP,
	    "M3_HV_ID_TOP" => M3_HV_ID_TOP,
	    "M4_HV_ID_TOP" => M4_HV_ID_TOP,
	    "M5_HV_ID_TOP" => M5_HV_ID_TOP,
	    "M6_HV_ID_TOP" => M6_HV_ID_TOP,
	    "M7_HV_ID_TOP" => M7_HV_ID_TOP,
	    "M8_HV_ID_TOP" => M8_HV_ID_TOP,
	    "M9_HV_ID_TOP" => M9_HV_ID_TOP,
	    "M10_HV_ID_TOP" => M10_HV_ID_TOP,
	    "M11_HV_ID_TOP" => M11_HV_ID_TOP,
	    "M12_HV_ID_TOP" => M12_HV_ID_TOP,
	    "M13_HV_ID_TOP" => M13_HV_ID_TOP,
	    "M14_HV_ID_TOP" => M14_HV_ID_TOP,
	    "M15_HV_ID_TOP" => M15_HV_ID_TOP,
	    "M16_HV_ID_TOP" => M16_HV_ID_TOP,
	    "M17_HV_ID_TOP" => M17_HV_ID_TOP,
	    "M18_HV_ID_TOP" => M18_HV_ID_TOP,
	    "M19_HV_ID_TOP" => M19_HV_ID_TOP,
	    "M0_LV_ID_TOP" => M0_LV_ID_TOP,
	    "M1_LV_ID_TOP" => M1_LV_ID_TOP,
	    "M2_LV_ID_TOP" => M2_LV_ID_TOP,
	    "M3_LV_ID_TOP" => M3_LV_ID_TOP,
	    "M4_LV_ID_TOP" => M4_LV_ID_TOP,
	    "M5_LV_ID_TOP" => M5_LV_ID_TOP,
	    "M6_LV_ID_TOP" => M6_LV_ID_TOP,
	    "M7_LV_ID_TOP" => M7_LV_ID_TOP,
	    "M8_LV_ID_TOP" => M8_LV_ID_TOP,
	    "M9_LV_ID_TOP" => M9_LV_ID_TOP,
	    "M10_LV_ID_TOP" => M10_LV_ID_TOP,
	    "M11_LV_ID_TOP" => M11_LV_ID_TOP,
	    "M12_LV_ID_TOP" => M12_LV_ID_TOP,
	    "M13_LV_ID_TOP" => M13_LV_ID_TOP,
	    "M14_LV_ID_TOP" => M14_LV_ID_TOP,
	    "M15_LV_ID_TOP" => M15_LV_ID_TOP,
	    "M16_LV_ID_TOP" => M16_LV_ID_TOP,
	    "M17_LV_ID_TOP" => M17_LV_ID_TOP,
	    "M18_LV_ID_TOP" => M18_LV_ID_TOP,
	    "M19_LV_ID_TOP" => M19_LV_ID_TOP,
	    "AP_HV_ID_TOP" => AP_HV_ID_TOP,
	    "AP_LV_ID_TOP" => AP_LV_ID_TOP,
	    "CU_RDL_HV_ID_TOP" => CU_RDL_HV_ID_TOP,
	    "CU_RDL_LV_ID_TOP" => CU_RDL_LV_ID_TOP,
	    "PSTP_00" => PSTP_00,
	    "PSD_15" => PSD_15, 
	    "NSD_15" => NSD_15, 
	    "VAR_15" => VAR_15,
	    "GATE_15" => GATE_15, 
	    "PSD_12" => PSD_12,
	    "NSD_12" => NSD_12,
	    "VAR_12" => VAR_12,
	    "GATE_12" => GATE_12,
	    "PSD_CORE" => PSD_CORE,
	    "NSD_CORE" => NSD_CORE,
	    "VAR_CORE" => VAR_CORE,
	    "GATE_CORE" => GATE_CORE,
	    "MD_12VM" => MD_12VM,
	    "MD_25VM" => MD_25VM,
	    "MD_33VM" => MD_33VM,
	    "MALL_00VM" => { M0_00VM, M1_00VM, M2_00VM, M3_00VM, M4_00VM, M5_00VM, M6_00VM, M7_00VM, M8_00VM, M9_00VM, M10_00VM, M11_00VM, M12_00VM, M13_00VM, M14_00VM, M15_00VM, M16_00VM, M17_00VM, M18_00VM, M19_00VM },
	    "MALL_01VM" => { M0_01VM, M1_01VM, M2_01VM, M3_01VM, M4_01VM, M5_01VM, M6_01VM, M7_01VM, M8_01VM, M9_01VM, M10_01VM, M11_01VM, M12_01VM, M13_01VM, M14_01VM, M15_01VM, M16_01VM, M17_01VM, M18_01VM, M19_01VM },
	    "MALL_02VM" => { M0_02VM, M1_02VM, M2_02VM, M3_02VM, M4_02VM, M5_02VM, M6_02VM, M7_02VM, M8_02VM, M9_02VM, M10_02VM, M11_02VM, M12_02VM, M13_02VM, M14_02VM, M15_02VM, M16_02VM, M17_02VM, M18_02VM, M19_02VM },
	    "MALL_03VM" => { M0_03VM, M1_03VM, M2_03VM, M3_03VM, M4_03VM, M5_03VM, M6_03VM, M7_03VM, M8_03VM, M9_03VM, M10_03VM, M11_03VM, M12_03VM, M13_03VM, M14_03VM, M15_03VM, M16_03VM, M17_03VM, M18_03VM, M19_03VM },
	    "MALL_04VM" => { M0_04VM, M1_04VM, M2_04VM, M3_04VM, M4_04VM, M5_04VM, M6_04VM, M7_04VM, M8_04VM, M9_04VM, M10_04VM, M11_04VM, M12_04VM, M13_04VM, M14_04VM, M15_04VM, M16_04VM, M17_04VM, M18_04VM, M19_04VM },
	    "MALL_05VM" => { M0_05VM, M1_05VM, M2_05VM, M3_05VM, M4_05VM, M5_05VM, M6_05VM, M7_05VM, M8_05VM, M9_05VM, M10_05VM, M11_05VM, M12_05VM, M13_05VM, M14_05VM, M15_05VM, M16_05VM, M17_05VM, M18_05VM, M19_05VM },
	    "MALL_06VM" => { M0_06VM, M1_06VM, M2_06VM, M3_06VM, M4_06VM, M5_06VM, M6_06VM, M7_06VM, M8_06VM, M9_06VM, M10_06VM, M11_06VM, M12_06VM, M13_06VM, M14_06VM, M15_06VM, M16_06VM, M17_06VM, M18_06VM, M19_06VM },
	    "MALL_07VM" => { M0_07VM, M1_07VM, M2_07VM, M3_07VM, M4_07VM, M5_07VM, M6_07VM, M7_07VM, M8_07VM, M9_07VM, M10_07VM, M11_07VM, M12_07VM, M13_07VM, M14_07VM, M15_07VM, M16_07VM, M17_07VM, M18_07VM, M19_07VM },
	    "MALL_08VM" => { M0_08VM, M1_08VM, M2_08VM, M3_08VM, M4_08VM, M5_08VM, M6_08VM, M7_08VM, M8_08VM, M9_08VM, M10_08VM, M11_08VM, M12_08VM, M13_08VM, M14_08VM, M15_08VM, M16_08VM, M17_08VM, M18_08VM, M19_08VM },
	    "MALL_09VM" => { M0_09VM, M1_09VM, M2_09VM, M3_09VM, M4_09VM, M5_09VM, M6_09VM, M7_09VM, M8_09VM, M9_09VM, M10_09VM, M11_09VM, M12_09VM, M13_09VM, M14_09VM, M15_09VM, M16_09VM, M17_09VM, M18_09VM, M19_09VM },
	    "MALL_10VM" => { M0_10VM, M1_10VM, M2_10VM, M3_10VM, M4_10VM, M5_10VM, M6_10VM, M7_10VM, M8_10VM, M9_10VM, M10_10VM, M11_10VM, M12_10VM, M13_10VM, M14_10VM, M15_10VM, M16_10VM, M17_10VM, M18_10VM, M19_10VM },
	    "MALL_11VM" => { M0_11VM, M1_11VM, M2_11VM, M3_11VM, M4_11VM, M5_11VM, M6_11VM, M7_11VM, M8_11VM, M9_11VM, M10_11VM, M11_11VM, M12_11VM, M13_11VM, M14_11VM, M15_11VM, M16_11VM, M17_11VM, M18_11VM, M19_11VM },
	    "MALL_12VM" => { M0_12VM, M1_12VM, M2_12VM, M3_12VM, M4_12VM, M5_12VM, M6_12VM, M7_12VM, M8_12VM, M9_12VM, M10_12VM, M11_12VM, M12_12VM, M13_12VM, M14_12VM, M15_12VM, M16_12VM, M17_12VM, M18_12VM, M19_12VM },
	    "MALL_13VM" => { M0_13VM, M1_13VM, M2_13VM, M3_13VM, M4_13VM, M5_13VM, M6_13VM, M7_13VM, M8_13VM, M9_13VM, M10_13VM, M11_13VM, M12_13VM, M13_13VM, M14_13VM, M15_13VM, M16_13VM, M17_13VM, M18_13VM, M19_13VM },
	    "MALL_14VM" => { M0_14VM, M1_14VM, M2_14VM, M3_14VM, M4_14VM, M5_14VM, M6_14VM, M7_14VM, M8_14VM, M9_14VM, M10_14VM, M11_14VM, M12_14VM, M13_14VM, M14_14VM, M15_14VM, M16_14VM, M17_14VM, M18_14VM, M19_14VM },
	    "MALL_15VM" => { M0_15VM, M1_15VM, M2_15VM, M3_15VM, M4_15VM, M5_15VM, M6_15VM, M7_15VM, M8_15VM, M9_15VM, M10_15VM, M11_15VM, M12_15VM, M13_15VM, M14_15VM, M15_15VM, M16_15VM, M17_15VM, M18_15VM, M19_15VM },
	    "MALL_16VM" => { M0_16VM, M1_16VM, M2_16VM, M3_16VM, M4_16VM, M5_16VM, M6_16VM, M7_16VM, M8_16VM, M9_16VM, M10_16VM, M11_16VM, M12_16VM, M13_16VM, M14_16VM, M15_16VM, M16_16VM, M17_16VM, M18_16VM, M19_16VM },
	    "MALL_17VM" => { M0_17VM, M1_17VM, M2_17VM, M3_17VM, M4_17VM, M5_17VM, M6_17VM, M7_17VM, M8_17VM, M9_17VM, M10_17VM, M11_17VM, M12_17VM, M13_17VM, M14_17VM, M15_17VM, M16_17VM, M17_17VM, M18_17VM, M19_17VM },
	    "MALL_18VM" => { M0_18VM, M1_18VM, M2_18VM, M3_18VM, M4_18VM, M5_18VM, M6_18VM, M7_18VM, M8_18VM, M9_18VM, M10_18VM, M11_18VM, M12_18VM, M13_18VM, M14_18VM, M15_18VM, M16_18VM, M17_18VM, M18_18VM, M19_18VM },
	    "MALL_25VM" => { M0_25VM, M1_25VM, M2_25VM, M3_25VM, M4_25VM, M5_25VM, M6_25VM, M7_25VM, M8_25VM, M9_25VM, M10_25VM, M11_25VM, M12_25VM, M13_25VM, M14_25VM, M15_25VM, M16_25VM, M17_25VM, M18_25VM, M19_25VM },
	    "MALL_33VM" => { M0_33VM, M1_33VM, M2_33VM, M3_33VM, M4_33VM, M5_33VM, M6_33VM, M7_33VM, M8_33VM, M9_33VM, M10_33VM, M11_33VM, M12_33VM, M13_33VM, M14_33VM, M15_33VM, M16_33VM, M17_33VM, M18_33VM, M19_33VM },
	    "MALL_50VM" => { M0_50VM, M1_50VM, M2_50VM, M3_50VM, M4_50VM, M5_50VM, M6_50VM, M7_50VM, M8_50VM, M9_50VM, M10_50VM, M11_50VM, M12_50VM, M13_50VM, M14_50VM, M15_50VM, M16_50VM, M17_50VM, M18_50VM, M19_50VM },
	    "MALL_70VM" => { M0_70VM, M1_70VM, M2_70VM, M3_70VM, M4_70VM, M5_70VM, M6_70VM, M7_70VM, M8_70VM, M9_70VM, M10_70VM, M11_70VM, M12_70VM, M13_70VM, M14_70VM, M15_70VM, M16_70VM, M17_70VM, M18_70VM, M19_70VM },
	}
);



OD_v = annotate_by_property(
    connect_sequence = CONNECT_DB_DV,
    layer1 = ODC,
    property_names = { "high", "low" } 
);

NWEL_v = annotate_by_property(
    connect_sequence = CONNECT_DB_DV,
    layer1 = NWI,
    property_names = { "high", "low", "sync" } 
);

PWEL_v = annotate_by_property(
    connect_sequence = CONNECT_DB_DV,
    layer1 = PWI,
    property_names = { "high", "low", "sync" } 
);















BLOCK = copy( gEMPTY, ancestry = true ); 










M0_NOT_CM0_v = annotate_by_property (
    connect_sequence = CONNECT_DB_DV,
    layer1 = M0_NOT_CM0I,
    property_names = { "high", "low" } );


M1_v = annotate_by_property (
    connect_sequence = CONNECT_DB_DV,
    layer1 = M1I,
    property_names = { "high", "low" } );

M2_v = annotate_by_property (
    connect_sequence = CONNECT_DB_DV,
    layer1 = M2I,
    property_names = { "high", "low" } );

M3_v = annotate_by_property (
    connect_sequence = CONNECT_DB_DV,
    layer1 = M3I,
    property_names = { "high", "low" } );

M4_v = annotate_by_property (
    connect_sequence = CONNECT_DB_DV,
    layer1 = M4I,
    property_names = { "high", "low" } );

M5_v = annotate_by_property (
    connect_sequence = CONNECT_DB_DV,
    layer1 = M5I,
    property_names = { "high", "low" } );

M6_v = annotate_by_property (
    connect_sequence = CONNECT_DB_DV,
    layer1 = M6I,
    property_names = { "high", "low" } );

M7_v = annotate_by_property (
    connect_sequence = CONNECT_DB_DV,
    layer1 = M7I,
    property_names = { "high", "low" } );

M8_v = annotate_by_property (
    connect_sequence = CONNECT_DB_DV,
    layer1 = M8I,
    property_names = { "high", "low" } );

M9_v = annotate_by_property (
    connect_sequence = CONNECT_DB_DV,
    layer1 = M9I,
    property_names = { "high", "low" } );

M10_v = annotate_by_property (
    connect_sequence = CONNECT_DB_DV,
    layer1 = M10I,
    property_names = { "high", "low" } );

M11_v = annotate_by_property (
    connect_sequence = CONNECT_DB_DV,
    layer1 = M11I,
    property_names = { "high", "low" } );

M12_v = annotate_by_property (
    connect_sequence = CONNECT_DB_DV,
    layer1 = M12I,
    property_names = { "high", "low" } );

M13_v = annotate_by_property (
    connect_sequence = CONNECT_DB_DV,
    layer1 = M13I,
    property_names = { "high", "low" } );

M14_v = annotate_by_property (
    connect_sequence = CONNECT_DB_DV,
    layer1 = M14I,
    property_names = { "high", "low" } );

M15_v = annotate_by_property (
    connect_sequence = CONNECT_DB_DV,
    layer1 = M15I,
    property_names = { "high", "low" } );

M16_v = annotate_by_property (
    connect_sequence = CONNECT_DB_DV,
    layer1 = M16I,
    property_names = { "high", "low" } );

M17_v = annotate_by_property (
    connect_sequence = CONNECT_DB_DV,
    layer1 = M17I,
    property_names = { "high", "low" } );

M18_v = annotate_by_property (
    connect_sequence = CONNECT_DB_DV,
    layer1 = M18I,
    property_names = { "high", "low" } );

M19_v = annotate_by_property (
    connect_sequence = CONNECT_DB_DV,
    layer1 = M19I,
    property_names = { "high", "low" } );


CM0 = CM0A_MAIN or CM0B_MAIN;
DCM0 = DCM0A or DCM0B;




  M0V096_HP_P = select_by_double_property( M0_NOT_CM0_v, "high", > 0.96 ); 
  M0V096_LN_P = select_by_double_property( M0_NOT_CM0_v, "low",< -0.96 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M0V096_HP_P, M0_NOT_CM0I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M0V096_LN_P, M0_NOT_CM0I }}} );
  M0V096_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M0V096_HP_P }, output_from_layers = { M0_NOT_CM0I } );
  M0V096_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M0V096_LN_P }, output_from_layers = { M0_NOT_CM0I } );
  M0_HVN_096V = M0V096_HP or M0V096_LN;


  M0V132_HP_P = select_by_double_property( M0_NOT_CM0_v, "high", > 1.32 ); 
  M0V132_LN_P = select_by_double_property( M0_NOT_CM0_v, "low",< -1.32 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M0V132_HP_P, M0_NOT_CM0I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M0V132_LN_P, M0_NOT_CM0I }}} );
  M0V132_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M0V132_HP_P }, output_from_layers = { M0_NOT_CM0I } );
  M0V132_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M0V132_LN_P }, output_from_layers = { M0_NOT_CM0I } );
  M0_HVN_132V = M0V132_HP or M0V132_LN;


  M0V165_HP_P = select_by_double_property( M0_NOT_CM0_v, "high", > 1.65 ); 
  M0V165_LN_P = select_by_double_property( M0_NOT_CM0_v, "low",< -1.65 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M0V165_HP_P, M0_NOT_CM0I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M0V165_LN_P, M0_NOT_CM0I }}} );
  M0V165_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M0V165_HP_P }, output_from_layers = { M0_NOT_CM0I } );
  M0V165_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M0V165_LN_P }, output_from_layers = { M0_NOT_CM0I } );
  M0_HVN_165V = M0V165_HP or M0V165_LN;


  M0V180_HP_P = select_by_double_property( M0_NOT_CM0_v, "high", > 1.8 ); 
  M0V180_LN_P = select_by_double_property( M0_NOT_CM0_v, "low",< -1.8 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M0V180_HP_P, M0_NOT_CM0I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M0V180_LN_P, M0_NOT_CM0I }}} );
  M0V180_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M0V180_HP_P }, output_from_layers = { M0_NOT_CM0I } );
  M0V180_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M0V180_LN_P }, output_from_layers = { M0_NOT_CM0I } );
  M0_HVN_180V = M0V180_HP or M0V180_LN;


  M0V198_HP_P = select_by_double_property( M0_NOT_CM0_v, "high", > 1.98 ); 
  M0V198_LN_P = select_by_double_property( M0_NOT_CM0_v, "low",< -1.98 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M0V198_HP_P, M0_NOT_CM0I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M0V198_LN_P, M0_NOT_CM0I }}} );
  M0V198_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M0V198_HP_P }, output_from_layers = { M0_NOT_CM0I } );
  M0V198_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M0V198_LN_P }, output_from_layers = { M0_NOT_CM0I } );
  M0_HVN_198V = M0V198_HP or M0V198_LN;


  M0V25_HP_P = select_by_double_property( M0_NOT_CM0_v, "high", > 2.5 ); 
  M0V25_LN_P = select_by_double_property( M0_NOT_CM0_v, "low",< -2.5 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M0V25_HP_P, M0_NOT_CM0I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M0V25_LN_P, M0_NOT_CM0I }}} );
  M0V25_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M0V25_HP_P }, output_from_layers = { M0_NOT_CM0I } );
  M0V25_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M0V25_LN_P }, output_from_layers = { M0_NOT_CM0I } );
  M0_HVN_25V = M0V25_HP or M0V25_LN;


  M0V275_HP_P = select_by_double_property( M0_NOT_CM0_v, "high", > 2.75 ); 
  M0V275_LN_P = select_by_double_property( M0_NOT_CM0_v, "low",< -2.75 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M0V275_HP_P, M0_NOT_CM0I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M0V275_LN_P, M0_NOT_CM0I }}} );
  M0V275_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M0V275_HP_P }, output_from_layers = { M0_NOT_CM0I } );
  M0V275_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M0V275_LN_P }, output_from_layers = { M0_NOT_CM0I } );
  M0_HVN_275V = M0V275_HP or M0V275_LN;


  M0V33_HP_P = select_by_double_property( M0_NOT_CM0_v, "high", > 3.3 ); 
  M0V33_LN_P = select_by_double_property( M0_NOT_CM0_v, "low",< -3.3 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M0V33_HP_P, M0_NOT_CM0I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M0V33_LN_P, M0_NOT_CM0I }}} );
  M0V33_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M0V33_HP_P }, output_from_layers = { M0_NOT_CM0I } );
  M0V33_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M0V33_LN_P }, output_from_layers = { M0_NOT_CM0I } );
  M0_HVN_33V = M0V33_HP or M0V33_LN;


  M0V363_HP_P = select_by_double_property( M0_NOT_CM0_v, "high", > 3.63 ); 
  M0V363_LN_P = select_by_double_property( M0_NOT_CM0_v, "low",< -3.63 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M0V363_HP_P, M0_NOT_CM0I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M0V363_LN_P, M0_NOT_CM0I }}} );
  M0V363_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M0V363_HP_P }, output_from_layers = { M0_NOT_CM0I } );
  M0V363_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M0V363_LN_P }, output_from_layers = { M0_NOT_CM0I } );
  M0_HVN_363V = M0V363_HP or M0V363_LN;


  M0V5_HP_P = select_by_double_property( M0_NOT_CM0_v, "high", > 4.9 ); 
  M0V5_LN_P = select_by_double_property( M0_NOT_CM0_v, "low",< -4.9 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M0V5_HP_P, M0_NOT_CM0I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M0V5_LN_P, M0_NOT_CM0I }}} );
  M0V5_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M0V5_HP_P }, output_from_layers = { M0_NOT_CM0I } );
  M0V5_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M0V5_LN_P }, output_from_layers = { M0_NOT_CM0I } );
  M0_HVN_5V = M0V5_HP or M0V5_LN;



  M1V096_HP_P = select_by_double_property( M1_v, "high", > 0.96 ); 
  M1V096_LN_P = select_by_double_property( M1_v, "low",< -0.96 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M1V096_HP_P, M1I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M1V096_LN_P, M1I }}} );
  M1V096_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M1V096_HP_P }, output_from_layers = { M1I } );
  M1V096_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M1V096_LN_P }, output_from_layers = { M1I } );
  M1_HVN_096V = M1V096_HP or M1V096_LN;


  M1V132_HP_P = select_by_double_property( M1_v, "high", > 1.32 ); 
  M1V132_LN_P = select_by_double_property( M1_v, "low",< -1.32 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M1V132_HP_P, M1I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M1V132_LN_P, M1I }}} );
  M1V132_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M1V132_HP_P }, output_from_layers = { M1I } );
  M1V132_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M1V132_LN_P }, output_from_layers = { M1I } );
  M1_HVN_132V = M1V132_HP or M1V132_LN;


  M1V165_HP_P = select_by_double_property( M1_v, "high", > 1.65 ); 
  M1V165_LN_P = select_by_double_property( M1_v, "low",< -1.65 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M1V165_HP_P, M1I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M1V165_LN_P, M1I }}} );
  M1V165_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M1V165_HP_P }, output_from_layers = { M1I } );
  M1V165_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M1V165_LN_P }, output_from_layers = { M1I } );
  M1_HVN_165V = M1V165_HP or M1V165_LN;


  M1V180_HP_P = select_by_double_property( M1_v, "high", > 1.8 ); 
  M1V180_LN_P = select_by_double_property( M1_v, "low",< -1.8 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M1V180_HP_P, M1I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M1V180_LN_P, M1I }}} );
  M1V180_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M1V180_HP_P }, output_from_layers = { M1I } );
  M1V180_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M1V180_LN_P }, output_from_layers = { M1I } );
  M1_HVN_180V = M1V180_HP or M1V180_LN;


  M1V198_HP_P = select_by_double_property( M1_v, "high", > 1.98 ); 
  M1V198_LN_P = select_by_double_property( M1_v, "low",< -1.98 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M1V198_HP_P, M1I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M1V198_LN_P, M1I }}} );
  M1V198_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M1V198_HP_P }, output_from_layers = { M1I } );
  M1V198_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M1V198_LN_P }, output_from_layers = { M1I } );
  M1_HVN_198V = M1V198_HP or M1V198_LN;


  M1V25_HP_P = select_by_double_property( M1_v, "high", > 2.5 ); 
  M1V25_LN_P = select_by_double_property( M1_v, "low",< -2.5 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M1V25_HP_P, M1I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M1V25_LN_P, M1I }}} );
  M1V25_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M1V25_HP_P }, output_from_layers = { M1I } );
  M1V25_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M1V25_LN_P }, output_from_layers = { M1I } );
  M1_HVN_25V = M1V25_HP or M1V25_LN;


  M1V275_HP_P = select_by_double_property( M1_v, "high", > 2.75 ); 
  M1V275_LN_P = select_by_double_property( M1_v, "low",< -2.75 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M1V275_HP_P, M1I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M1V275_LN_P, M1I }}} );
  M1V275_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M1V275_HP_P }, output_from_layers = { M1I } );
  M1V275_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M1V275_LN_P }, output_from_layers = { M1I } );
  M1_HVN_275V = M1V275_HP or M1V275_LN;


  M1V33_HP_P = select_by_double_property( M1_v, "high", > 3.3 ); 
  M1V33_LN_P = select_by_double_property( M1_v, "low",< -3.3 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M1V33_HP_P, M1I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M1V33_LN_P, M1I }}} );
  M1V33_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M1V33_HP_P }, output_from_layers = { M1I } );
  M1V33_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M1V33_LN_P }, output_from_layers = { M1I } );
  M1_HVN_33V = M1V33_HP or M1V33_LN;


  M1V363_HP_P = select_by_double_property( M1_v, "high", > 3.63 ); 
  M1V363_LN_P = select_by_double_property( M1_v, "low",< -3.63 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M1V363_HP_P, M1I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M1V363_LN_P, M1I }}} );
  M1V363_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M1V363_HP_P }, output_from_layers = { M1I } );
  M1V363_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M1V363_LN_P }, output_from_layers = { M1I } );
  M1_HVN_363V = M1V363_HP or M1V363_LN;


  M1V5_HP_P = select_by_double_property( M1_v, "high", > 4.9 ); 
  M1V5_LN_P = select_by_double_property( M1_v, "low",< -4.9 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M1V5_HP_P, M1I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M1V5_LN_P, M1I }}} );
  M1V5_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M1V5_HP_P }, output_from_layers = { M1I } );
  M1V5_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M1V5_LN_P }, output_from_layers = { M1I } );
  M1_HVN_5V = M1V5_HP or M1V5_LN;


  M2V096_HP_P = select_by_double_property( M2_v, "high", > 0.96 ); 
  M2V096_LN_P = select_by_double_property( M2_v, "low",< -0.96 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M2V096_HP_P, M2I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M2V096_LN_P, M2I }}} );
  M2V096_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M2V096_HP_P }, output_from_layers = { M2I } );
  M2V096_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M2V096_LN_P }, output_from_layers = { M2I } );
  M2_HVN_096V = M2V096_HP or M2V096_LN;


  M2V132_HP_P = select_by_double_property( M2_v, "high", > 1.32 ); 
  M2V132_LN_P = select_by_double_property( M2_v, "low",< -1.32 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M2V132_HP_P, M2I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M2V132_LN_P, M2I }}} );
  M2V132_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M2V132_HP_P }, output_from_layers = { M2I } );
  M2V132_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M2V132_LN_P }, output_from_layers = { M2I } );
  M2_HVN_132V = M2V132_HP or M2V132_LN;


  M2V165_HP_P = select_by_double_property( M2_v, "high", > 1.65 ); 
  M2V165_LN_P = select_by_double_property( M2_v, "low",< -1.65 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M2V165_HP_P, M2I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M2V165_LN_P, M2I }}} );
  M2V165_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M2V165_HP_P }, output_from_layers = { M2I } );
  M2V165_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M2V165_LN_P }, output_from_layers = { M2I } );
  M2_HVN_165V = M2V165_HP or M2V165_LN;


  M2V180_HP_P = select_by_double_property( M2_v, "high", > 1.8 ); 
  M2V180_LN_P = select_by_double_property( M2_v, "low",< -1.8 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M2V180_HP_P, M2I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M2V180_LN_P, M2I }}} );
  M2V180_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M2V180_HP_P }, output_from_layers = { M2I } );
  M2V180_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M2V180_LN_P }, output_from_layers = { M2I } );
  M2_HVN_180V = M2V180_HP or M2V180_LN;


  M2V198_HP_P = select_by_double_property( M2_v, "high", > 1.98 ); 
  M2V198_LN_P = select_by_double_property( M2_v, "low",< -1.98 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M2V198_HP_P, M2I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M2V198_LN_P, M2I }}} );
  M2V198_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M2V198_HP_P }, output_from_layers = { M2I } );
  M2V198_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M2V198_LN_P }, output_from_layers = { M2I } );
  M2_HVN_198V = M2V198_HP or M2V198_LN;


  M2V25_HP_P = select_by_double_property( M2_v, "high", > 2.5 ); 
  M2V25_LN_P = select_by_double_property( M2_v, "low",< -2.5 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M2V25_HP_P, M2I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M2V25_LN_P, M2I }}} );
  M2V25_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M2V25_HP_P }, output_from_layers = { M2I } );
  M2V25_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M2V25_LN_P }, output_from_layers = { M2I } );
  M2_HVN_25V = M2V25_HP or M2V25_LN;


  M2V275_HP_P = select_by_double_property( M2_v, "high", > 2.75 ); 
  M2V275_LN_P = select_by_double_property( M2_v, "low",< -2.75 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M2V275_HP_P, M2I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M2V275_LN_P, M2I }}} );
  M2V275_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M2V275_HP_P }, output_from_layers = { M2I } );
  M2V275_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M2V275_LN_P }, output_from_layers = { M2I } );
  M2_HVN_275V = M2V275_HP or M2V275_LN;


  M2V33_HP_P = select_by_double_property( M2_v, "high", > 3.3 ); 
  M2V33_LN_P = select_by_double_property( M2_v, "low",< -3.3 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M2V33_HP_P, M2I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M2V33_LN_P, M2I }}} );
  M2V33_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M2V33_HP_P }, output_from_layers = { M2I } );
  M2V33_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M2V33_LN_P }, output_from_layers = { M2I } );
  M2_HVN_33V = M2V33_HP or M2V33_LN;


  M2V363_HP_P = select_by_double_property( M2_v, "high", > 3.63 ); 
  M2V363_LN_P = select_by_double_property( M2_v, "low",< -3.63 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M2V363_HP_P, M2I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M2V363_LN_P, M2I }}} );
  M2V363_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M2V363_HP_P }, output_from_layers = { M2I } );
  M2V363_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M2V363_LN_P }, output_from_layers = { M2I } );
  M2_HVN_363V = M2V363_HP or M2V363_LN;


  M2V5_HP_P = select_by_double_property( M2_v, "high", > 4.9 ); 
  M2V5_LN_P = select_by_double_property( M2_v, "low",< -4.9 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M2V5_HP_P, M2I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M2V5_LN_P, M2I }}} );
  M2V5_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M2V5_HP_P }, output_from_layers = { M2I } );
  M2V5_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M2V5_LN_P }, output_from_layers = { M2I } );
  M2_HVN_5V = M2V5_HP or M2V5_LN;


  M3V096_HP_P = select_by_double_property( M3_v, "high", > 0.96 ); 
  M3V096_LN_P = select_by_double_property( M3_v, "low",< -0.96 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M3V096_HP_P, M3I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M3V096_LN_P, M3I }}} );
  M3V096_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M3V096_HP_P }, output_from_layers = { M3I } );
  M3V096_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M3V096_LN_P }, output_from_layers = { M3I } );
  M3_HVN_096V = M3V096_HP or M3V096_LN;


  M3V132_HP_P = select_by_double_property( M3_v, "high", > 1.32 ); 
  M3V132_LN_P = select_by_double_property( M3_v, "low",< -1.32 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M3V132_HP_P, M3I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M3V132_LN_P, M3I }}} );
  M3V132_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M3V132_HP_P }, output_from_layers = { M3I } );
  M3V132_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M3V132_LN_P }, output_from_layers = { M3I } );
  M3_HVN_132V = M3V132_HP or M3V132_LN;


  M3V165_HP_P = select_by_double_property( M3_v, "high", > 1.65 ); 
  M3V165_LN_P = select_by_double_property( M3_v, "low",< -1.65 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M3V165_HP_P, M3I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M3V165_LN_P, M3I }}} );
  M3V165_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M3V165_HP_P }, output_from_layers = { M3I } );
  M3V165_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M3V165_LN_P }, output_from_layers = { M3I } );
  M3_HVN_165V = M3V165_HP or M3V165_LN;


  M3V180_HP_P = select_by_double_property( M3_v, "high", > 1.8 ); 
  M3V180_LN_P = select_by_double_property( M3_v, "low",< -1.8 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M3V180_HP_P, M3I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M3V180_LN_P, M3I }}} );
  M3V180_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M3V180_HP_P }, output_from_layers = { M3I } );
  M3V180_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M3V180_LN_P }, output_from_layers = { M3I } );
  M3_HVN_180V = M3V180_HP or M3V180_LN;


  M3V198_HP_P = select_by_double_property( M3_v, "high", > 1.98 ); 
  M3V198_LN_P = select_by_double_property( M3_v, "low",< -1.98 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M3V198_HP_P, M3I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M3V198_LN_P, M3I }}} );
  M3V198_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M3V198_HP_P }, output_from_layers = { M3I } );
  M3V198_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M3V198_LN_P }, output_from_layers = { M3I } );
  M3_HVN_198V = M3V198_HP or M3V198_LN;


  M3V25_HP_P = select_by_double_property( M3_v, "high", > 2.5 ); 
  M3V25_LN_P = select_by_double_property( M3_v, "low",< -2.5 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M3V25_HP_P, M3I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M3V25_LN_P, M3I }}} );
  M3V25_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M3V25_HP_P }, output_from_layers = { M3I } );
  M3V25_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M3V25_LN_P }, output_from_layers = { M3I } );
  M3_HVN_25V = M3V25_HP or M3V25_LN;


  M3V275_HP_P = select_by_double_property( M3_v, "high", > 2.75 ); 
  M3V275_LN_P = select_by_double_property( M3_v, "low",< -2.75 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M3V275_HP_P, M3I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M3V275_LN_P, M3I }}} );
  M3V275_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M3V275_HP_P }, output_from_layers = { M3I } );
  M3V275_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M3V275_LN_P }, output_from_layers = { M3I } );
  M3_HVN_275V = M3V275_HP or M3V275_LN;


  M3V33_HP_P = select_by_double_property( M3_v, "high", > 3.3 ); 
  M3V33_LN_P = select_by_double_property( M3_v, "low",< -3.3 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M3V33_HP_P, M3I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M3V33_LN_P, M3I }}} );
  M3V33_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M3V33_HP_P }, output_from_layers = { M3I } );
  M3V33_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M3V33_LN_P }, output_from_layers = { M3I } );
  M3_HVN_33V = M3V33_HP or M3V33_LN;


  M3V363_HP_P = select_by_double_property( M3_v, "high", > 3.63 ); 
  M3V363_LN_P = select_by_double_property( M3_v, "low",< -3.63 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M3V363_HP_P, M3I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M3V363_LN_P, M3I }}} );
  M3V363_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M3V363_HP_P }, output_from_layers = { M3I } );
  M3V363_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M3V363_LN_P }, output_from_layers = { M3I } );
  M3_HVN_363V = M3V363_HP or M3V363_LN;


  M3V5_HP_P = select_by_double_property( M3_v, "high", > 4.9 ); 
  M3V5_LN_P = select_by_double_property( M3_v, "low",< -4.9 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M3V5_HP_P, M3I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M3V5_LN_P, M3I }}} );
  M3V5_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M3V5_HP_P }, output_from_layers = { M3I } );
  M3V5_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M3V5_LN_P }, output_from_layers = { M3I } );
  M3_HVN_5V = M3V5_HP or M3V5_LN;


  M4V096_HP_P = select_by_double_property( M4_v, "high", > 0.96 ); 
  M4V096_LN_P = select_by_double_property( M4_v, "low",< -0.96 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M4V096_HP_P, M4I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M4V096_LN_P, M4I }}} );
  M4V096_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M4V096_HP_P }, output_from_layers = { M4I } );
  M4V096_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M4V096_LN_P }, output_from_layers = { M4I } );
  M4_HVN_096V = M4V096_HP or M4V096_LN;


  M4V132_HP_P = select_by_double_property( M4_v, "high", > 1.32 ); 
  M4V132_LN_P = select_by_double_property( M4_v, "low",< -1.32 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M4V132_HP_P, M4I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M4V132_LN_P, M4I }}} );
  M4V132_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M4V132_HP_P }, output_from_layers = { M4I } );
  M4V132_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M4V132_LN_P }, output_from_layers = { M4I } );
  M4_HVN_132V = M4V132_HP or M4V132_LN;


  M4V165_HP_P = select_by_double_property( M4_v, "high", > 1.65 ); 
  M4V165_LN_P = select_by_double_property( M4_v, "low",< -1.65 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M4V165_HP_P, M4I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M4V165_LN_P, M4I }}} );
  M4V165_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M4V165_HP_P }, output_from_layers = { M4I } );
  M4V165_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M4V165_LN_P }, output_from_layers = { M4I } );
  M4_HVN_165V = M4V165_HP or M4V165_LN;


  M4V180_HP_P = select_by_double_property( M4_v, "high", > 1.8 ); 
  M4V180_LN_P = select_by_double_property( M4_v, "low",< -1.8 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M4V180_HP_P, M4I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M4V180_LN_P, M4I }}} );
  M4V180_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M4V180_HP_P }, output_from_layers = { M4I } );
  M4V180_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M4V180_LN_P }, output_from_layers = { M4I } );
  M4_HVN_180V = M4V180_HP or M4V180_LN;


  M4V198_HP_P = select_by_double_property( M4_v, "high", > 1.98 ); 
  M4V198_LN_P = select_by_double_property( M4_v, "low",< -1.98 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M4V198_HP_P, M4I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M4V198_LN_P, M4I }}} );
  M4V198_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M4V198_HP_P }, output_from_layers = { M4I } );
  M4V198_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M4V198_LN_P }, output_from_layers = { M4I } );
  M4_HVN_198V = M4V198_HP or M4V198_LN;


  M4V25_HP_P = select_by_double_property( M4_v, "high", > 2.5 ); 
  M4V25_LN_P = select_by_double_property( M4_v, "low",< -2.5 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M4V25_HP_P, M4I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M4V25_LN_P, M4I }}} );
  M4V25_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M4V25_HP_P }, output_from_layers = { M4I } );
  M4V25_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M4V25_LN_P }, output_from_layers = { M4I } );
  M4_HVN_25V = M4V25_HP or M4V25_LN;


  M4V275_HP_P = select_by_double_property( M4_v, "high", > 2.75 ); 
  M4V275_LN_P = select_by_double_property( M4_v, "low",< -2.75 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M4V275_HP_P, M4I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M4V275_LN_P, M4I }}} );
  M4V275_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M4V275_HP_P }, output_from_layers = { M4I } );
  M4V275_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M4V275_LN_P }, output_from_layers = { M4I } );
  M4_HVN_275V = M4V275_HP or M4V275_LN;


  M4V33_HP_P = select_by_double_property( M4_v, "high", > 3.3 ); 
  M4V33_LN_P = select_by_double_property( M4_v, "low",< -3.3 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M4V33_HP_P, M4I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M4V33_LN_P, M4I }}} );
  M4V33_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M4V33_HP_P }, output_from_layers = { M4I } );
  M4V33_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M4V33_LN_P }, output_from_layers = { M4I } );
  M4_HVN_33V = M4V33_HP or M4V33_LN;


  M4V363_HP_P = select_by_double_property( M4_v, "high", > 3.63 ); 
  M4V363_LN_P = select_by_double_property( M4_v, "low",< -3.63 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M4V363_HP_P, M4I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M4V363_LN_P, M4I }}} );
  M4V363_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M4V363_HP_P }, output_from_layers = { M4I } );
  M4V363_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M4V363_LN_P }, output_from_layers = { M4I } );
  M4_HVN_363V = M4V363_HP or M4V363_LN;


  M4V5_HP_P = select_by_double_property( M4_v, "high", > 4.9 ); 
  M4V5_LN_P = select_by_double_property( M4_v, "low",< -4.9 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M4V5_HP_P, M4I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M4V5_LN_P, M4I }}} );
  M4V5_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M4V5_HP_P }, output_from_layers = { M4I } );
  M4V5_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M4V5_LN_P }, output_from_layers = { M4I } );
  M4_HVN_5V = M4V5_HP or M4V5_LN;


  M5V096_HP_P = select_by_double_property( M5_v, "high", > 0.96 ); 
  M5V096_LN_P = select_by_double_property( M5_v, "low",< -0.96 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M5V096_HP_P, M5I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M5V096_LN_P, M5I }}} );
  M5V096_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M5V096_HP_P }, output_from_layers = { M5I } );
  M5V096_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M5V096_LN_P }, output_from_layers = { M5I } );
  M5_HVN_096V = M5V096_HP or M5V096_LN;


  M5V132_HP_P = select_by_double_property( M5_v, "high", > 1.32 ); 
  M5V132_LN_P = select_by_double_property( M5_v, "low",< -1.32 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M5V132_HP_P, M5I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M5V132_LN_P, M5I }}} );
  M5V132_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M5V132_HP_P }, output_from_layers = { M5I } );
  M5V132_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M5V132_LN_P }, output_from_layers = { M5I } );
  M5_HVN_132V = M5V132_HP or M5V132_LN;


  M5V165_HP_P = select_by_double_property( M5_v, "high", > 1.65 ); 
  M5V165_LN_P = select_by_double_property( M5_v, "low",< -1.65 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M5V165_HP_P, M5I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M5V165_LN_P, M5I }}} );
  M5V165_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M5V165_HP_P }, output_from_layers = { M5I } );
  M5V165_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M5V165_LN_P }, output_from_layers = { M5I } );
  M5_HVN_165V = M5V165_HP or M5V165_LN;


  M5V180_HP_P = select_by_double_property( M5_v, "high", > 1.8 ); 
  M5V180_LN_P = select_by_double_property( M5_v, "low",< -1.8 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M5V180_HP_P, M5I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M5V180_LN_P, M5I }}} );
  M5V180_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M5V180_HP_P }, output_from_layers = { M5I } );
  M5V180_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M5V180_LN_P }, output_from_layers = { M5I } );
  M5_HVN_180V = M5V180_HP or M5V180_LN;


  M5V198_HP_P = select_by_double_property( M5_v, "high", > 1.98 ); 
  M5V198_LN_P = select_by_double_property( M5_v, "low",< -1.98 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M5V198_HP_P, M5I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M5V198_LN_P, M5I }}} );
  M5V198_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M5V198_HP_P }, output_from_layers = { M5I } );
  M5V198_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M5V198_LN_P }, output_from_layers = { M5I } );
  M5_HVN_198V = M5V198_HP or M5V198_LN;


  M5V25_HP_P = select_by_double_property( M5_v, "high", > 2.5 ); 
  M5V25_LN_P = select_by_double_property( M5_v, "low",< -2.5 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M5V25_HP_P, M5I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M5V25_LN_P, M5I }}} );
  M5V25_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M5V25_HP_P }, output_from_layers = { M5I } );
  M5V25_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M5V25_LN_P }, output_from_layers = { M5I } );
  M5_HVN_25V = M5V25_HP or M5V25_LN;


  M5V275_HP_P = select_by_double_property( M5_v, "high", > 2.75 ); 
  M5V275_LN_P = select_by_double_property( M5_v, "low",< -2.75 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M5V275_HP_P, M5I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M5V275_LN_P, M5I }}} );
  M5V275_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M5V275_HP_P }, output_from_layers = { M5I } );
  M5V275_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M5V275_LN_P }, output_from_layers = { M5I } );
  M5_HVN_275V = M5V275_HP or M5V275_LN;


  M5V33_HP_P = select_by_double_property( M5_v, "high", > 3.3 ); 
  M5V33_LN_P = select_by_double_property( M5_v, "low",< -3.3 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M5V33_HP_P, M5I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M5V33_LN_P, M5I }}} );
  M5V33_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M5V33_HP_P }, output_from_layers = { M5I } );
  M5V33_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M5V33_LN_P }, output_from_layers = { M5I } );
  M5_HVN_33V = M5V33_HP or M5V33_LN;


  M5V363_HP_P = select_by_double_property( M5_v, "high", > 3.63 ); 
  M5V363_LN_P = select_by_double_property( M5_v, "low",< -3.63 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M5V363_HP_P, M5I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M5V363_LN_P, M5I }}} );
  M5V363_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M5V363_HP_P }, output_from_layers = { M5I } );
  M5V363_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M5V363_LN_P }, output_from_layers = { M5I } );
  M5_HVN_363V = M5V363_HP or M5V363_LN;


  M5V5_HP_P = select_by_double_property( M5_v, "high", > 4.9 ); 
  M5V5_LN_P = select_by_double_property( M5_v, "low",< -4.9 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M5V5_HP_P, M5I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M5V5_LN_P, M5I }}} );
  M5V5_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M5V5_HP_P }, output_from_layers = { M5I } );
  M5V5_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M5V5_LN_P }, output_from_layers = { M5I } );
  M5_HVN_5V = M5V5_HP or M5V5_LN;


  M6V096_HP_P = select_by_double_property( M6_v, "high", > 0.96 ); 
  M6V096_LN_P = select_by_double_property( M6_v, "low",< -0.96 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M6V096_HP_P, M6I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M6V096_LN_P, M6I }}} );
  M6V096_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M6V096_HP_P }, output_from_layers = { M6I } );
  M6V096_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M6V096_LN_P }, output_from_layers = { M6I } );
  M6_HVN_096V = M6V096_HP or M6V096_LN;


  M6V132_HP_P = select_by_double_property( M6_v, "high", > 1.32 ); 
  M6V132_LN_P = select_by_double_property( M6_v, "low",< -1.32 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M6V132_HP_P, M6I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M6V132_LN_P, M6I }}} );
  M6V132_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M6V132_HP_P }, output_from_layers = { M6I } );
  M6V132_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M6V132_LN_P }, output_from_layers = { M6I } );
  M6_HVN_132V = M6V132_HP or M6V132_LN;


  M6V165_HP_P = select_by_double_property( M6_v, "high", > 1.65 ); 
  M6V165_LN_P = select_by_double_property( M6_v, "low",< -1.65 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M6V165_HP_P, M6I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M6V165_LN_P, M6I }}} );
  M6V165_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M6V165_HP_P }, output_from_layers = { M6I } );
  M6V165_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M6V165_LN_P }, output_from_layers = { M6I } );
  M6_HVN_165V = M6V165_HP or M6V165_LN;


  M6V180_HP_P = select_by_double_property( M6_v, "high", > 1.8 ); 
  M6V180_LN_P = select_by_double_property( M6_v, "low",< -1.8 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M6V180_HP_P, M6I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M6V180_LN_P, M6I }}} );
  M6V180_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M6V180_HP_P }, output_from_layers = { M6I } );
  M6V180_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M6V180_LN_P }, output_from_layers = { M6I } );
  M6_HVN_180V = M6V180_HP or M6V180_LN;


  M6V198_HP_P = select_by_double_property( M6_v, "high", > 1.98 ); 
  M6V198_LN_P = select_by_double_property( M6_v, "low",< -1.98 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M6V198_HP_P, M6I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M6V198_LN_P, M6I }}} );
  M6V198_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M6V198_HP_P }, output_from_layers = { M6I } );
  M6V198_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M6V198_LN_P }, output_from_layers = { M6I } );
  M6_HVN_198V = M6V198_HP or M6V198_LN;


  M6V25_HP_P = select_by_double_property( M6_v, "high", > 2.5 ); 
  M6V25_LN_P = select_by_double_property( M6_v, "low",< -2.5 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M6V25_HP_P, M6I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M6V25_LN_P, M6I }}} );
  M6V25_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M6V25_HP_P }, output_from_layers = { M6I } );
  M6V25_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M6V25_LN_P }, output_from_layers = { M6I } );
  M6_HVN_25V = M6V25_HP or M6V25_LN;


  M6V275_HP_P = select_by_double_property( M6_v, "high", > 2.75 ); 
  M6V275_LN_P = select_by_double_property( M6_v, "low",< -2.75 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M6V275_HP_P, M6I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M6V275_LN_P, M6I }}} );
  M6V275_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M6V275_HP_P }, output_from_layers = { M6I } );
  M6V275_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M6V275_LN_P }, output_from_layers = { M6I } );
  M6_HVN_275V = M6V275_HP or M6V275_LN;


  M6V33_HP_P = select_by_double_property( M6_v, "high", > 3.3 ); 
  M6V33_LN_P = select_by_double_property( M6_v, "low",< -3.3 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M6V33_HP_P, M6I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M6V33_LN_P, M6I }}} );
  M6V33_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M6V33_HP_P }, output_from_layers = { M6I } );
  M6V33_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M6V33_LN_P }, output_from_layers = { M6I } );
  M6_HVN_33V = M6V33_HP or M6V33_LN;


  M6V363_HP_P = select_by_double_property( M6_v, "high", > 3.63 ); 
  M6V363_LN_P = select_by_double_property( M6_v, "low",< -3.63 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M6V363_HP_P, M6I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M6V363_LN_P, M6I }}} );
  M6V363_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M6V363_HP_P }, output_from_layers = { M6I } );
  M6V363_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M6V363_LN_P }, output_from_layers = { M6I } );
  M6_HVN_363V = M6V363_HP or M6V363_LN;


  M6V5_HP_P = select_by_double_property( M6_v, "high", > 4.9 ); 
  M6V5_LN_P = select_by_double_property( M6_v, "low",< -4.9 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M6V5_HP_P, M6I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M6V5_LN_P, M6I }}} );
  M6V5_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M6V5_HP_P }, output_from_layers = { M6I } );
  M6V5_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M6V5_LN_P }, output_from_layers = { M6I } );
  M6_HVN_5V = M6V5_HP or M6V5_LN;


  M7V096_HP_P = select_by_double_property( M7_v, "high", > 0.96 ); 
  M7V096_LN_P = select_by_double_property( M7_v, "low",< -0.96 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M7V096_HP_P, M7I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M7V096_LN_P, M7I }}} );
  M7V096_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M7V096_HP_P }, output_from_layers = { M7I } );
  M7V096_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M7V096_LN_P }, output_from_layers = { M7I } );
  M7_HVN_096V = M7V096_HP or M7V096_LN;


  M7V132_HP_P = select_by_double_property( M7_v, "high", > 1.32 ); 
  M7V132_LN_P = select_by_double_property( M7_v, "low",< -1.32 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M7V132_HP_P, M7I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M7V132_LN_P, M7I }}} );
  M7V132_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M7V132_HP_P }, output_from_layers = { M7I } );
  M7V132_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M7V132_LN_P }, output_from_layers = { M7I } );
  M7_HVN_132V = M7V132_HP or M7V132_LN;


  M7V165_HP_P = select_by_double_property( M7_v, "high", > 1.65 ); 
  M7V165_LN_P = select_by_double_property( M7_v, "low",< -1.65 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M7V165_HP_P, M7I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M7V165_LN_P, M7I }}} );
  M7V165_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M7V165_HP_P }, output_from_layers = { M7I } );
  M7V165_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M7V165_LN_P }, output_from_layers = { M7I } );
  M7_HVN_165V = M7V165_HP or M7V165_LN;


  M7V180_HP_P = select_by_double_property( M7_v, "high", > 1.8 ); 
  M7V180_LN_P = select_by_double_property( M7_v, "low",< -1.8 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M7V180_HP_P, M7I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M7V180_LN_P, M7I }}} );
  M7V180_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M7V180_HP_P }, output_from_layers = { M7I } );
  M7V180_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M7V180_LN_P }, output_from_layers = { M7I } );
  M7_HVN_180V = M7V180_HP or M7V180_LN;


  M7V198_HP_P = select_by_double_property( M7_v, "high", > 1.98 ); 
  M7V198_LN_P = select_by_double_property( M7_v, "low",< -1.98 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M7V198_HP_P, M7I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M7V198_LN_P, M7I }}} );
  M7V198_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M7V198_HP_P }, output_from_layers = { M7I } );
  M7V198_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M7V198_LN_P }, output_from_layers = { M7I } );
  M7_HVN_198V = M7V198_HP or M7V198_LN;


  M7V25_HP_P = select_by_double_property( M7_v, "high", > 2.5 ); 
  M7V25_LN_P = select_by_double_property( M7_v, "low",< -2.5 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M7V25_HP_P, M7I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M7V25_LN_P, M7I }}} );
  M7V25_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M7V25_HP_P }, output_from_layers = { M7I } );
  M7V25_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M7V25_LN_P }, output_from_layers = { M7I } );
  M7_HVN_25V = M7V25_HP or M7V25_LN;


  M7V275_HP_P = select_by_double_property( M7_v, "high", > 2.75 ); 
  M7V275_LN_P = select_by_double_property( M7_v, "low",< -2.75 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M7V275_HP_P, M7I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M7V275_LN_P, M7I }}} );
  M7V275_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M7V275_HP_P }, output_from_layers = { M7I } );
  M7V275_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M7V275_LN_P }, output_from_layers = { M7I } );
  M7_HVN_275V = M7V275_HP or M7V275_LN;


  M7V33_HP_P = select_by_double_property( M7_v, "high", > 3.3 ); 
  M7V33_LN_P = select_by_double_property( M7_v, "low",< -3.3 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M7V33_HP_P, M7I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M7V33_LN_P, M7I }}} );
  M7V33_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M7V33_HP_P }, output_from_layers = { M7I } );
  M7V33_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M7V33_LN_P }, output_from_layers = { M7I } );
  M7_HVN_33V = M7V33_HP or M7V33_LN;


  M7V363_HP_P = select_by_double_property( M7_v, "high", > 3.63 ); 
  M7V363_LN_P = select_by_double_property( M7_v, "low",< -3.63 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M7V363_HP_P, M7I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M7V363_LN_P, M7I }}} );
  M7V363_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M7V363_HP_P }, output_from_layers = { M7I } );
  M7V363_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M7V363_LN_P }, output_from_layers = { M7I } );
  M7_HVN_363V = M7V363_HP or M7V363_LN;


  M7V5_HP_P = select_by_double_property( M7_v, "high", > 4.9 ); 
  M7V5_LN_P = select_by_double_property( M7_v, "low",< -4.9 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M7V5_HP_P, M7I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M7V5_LN_P, M7I }}} );
  M7V5_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M7V5_HP_P }, output_from_layers = { M7I } );
  M7V5_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M7V5_LN_P }, output_from_layers = { M7I } );
  M7_HVN_5V = M7V5_HP or M7V5_LN;


  M8V096_HP_P = select_by_double_property( M8_v, "high", > 0.96 ); 
  M8V096_LN_P = select_by_double_property( M8_v, "low",< -0.96 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M8V096_HP_P, M8I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M8V096_LN_P, M8I }}} );
  M8V096_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M8V096_HP_P }, output_from_layers = { M8I } );
  M8V096_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M8V096_LN_P }, output_from_layers = { M8I } );
  M8_HVN_096V = M8V096_HP or M8V096_LN;


  M8V132_HP_P = select_by_double_property( M8_v, "high", > 1.32 ); 
  M8V132_LN_P = select_by_double_property( M8_v, "low",< -1.32 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M8V132_HP_P, M8I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M8V132_LN_P, M8I }}} );
  M8V132_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M8V132_HP_P }, output_from_layers = { M8I } );
  M8V132_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M8V132_LN_P }, output_from_layers = { M8I } );
  M8_HVN_132V = M8V132_HP or M8V132_LN;


  M8V165_HP_P = select_by_double_property( M8_v, "high", > 1.65 ); 
  M8V165_LN_P = select_by_double_property( M8_v, "low",< -1.65 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M8V165_HP_P, M8I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M8V165_LN_P, M8I }}} );
  M8V165_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M8V165_HP_P }, output_from_layers = { M8I } );
  M8V165_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M8V165_LN_P }, output_from_layers = { M8I } );
  M8_HVN_165V = M8V165_HP or M8V165_LN;


  M8V180_HP_P = select_by_double_property( M8_v, "high", > 1.8 ); 
  M8V180_LN_P = select_by_double_property( M8_v, "low",< -1.8 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M8V180_HP_P, M8I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M8V180_LN_P, M8I }}} );
  M8V180_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M8V180_HP_P }, output_from_layers = { M8I } );
  M8V180_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M8V180_LN_P }, output_from_layers = { M8I } );
  M8_HVN_180V = M8V180_HP or M8V180_LN;


  M8V198_HP_P = select_by_double_property( M8_v, "high", > 1.98 ); 
  M8V198_LN_P = select_by_double_property( M8_v, "low",< -1.98 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M8V198_HP_P, M8I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M8V198_LN_P, M8I }}} );
  M8V198_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M8V198_HP_P }, output_from_layers = { M8I } );
  M8V198_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M8V198_LN_P }, output_from_layers = { M8I } );
  M8_HVN_198V = M8V198_HP or M8V198_LN;


  M8V25_HP_P = select_by_double_property( M8_v, "high", > 2.5 ); 
  M8V25_LN_P = select_by_double_property( M8_v, "low",< -2.5 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M8V25_HP_P, M8I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M8V25_LN_P, M8I }}} );
  M8V25_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M8V25_HP_P }, output_from_layers = { M8I } );
  M8V25_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M8V25_LN_P }, output_from_layers = { M8I } );
  M8_HVN_25V = M8V25_HP or M8V25_LN;


  M8V275_HP_P = select_by_double_property( M8_v, "high", > 2.75 ); 
  M8V275_LN_P = select_by_double_property( M8_v, "low",< -2.75 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M8V275_HP_P, M8I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M8V275_LN_P, M8I }}} );
  M8V275_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M8V275_HP_P }, output_from_layers = { M8I } );
  M8V275_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M8V275_LN_P }, output_from_layers = { M8I } );
  M8_HVN_275V = M8V275_HP or M8V275_LN;


  M8V33_HP_P = select_by_double_property( M8_v, "high", > 3.3 ); 
  M8V33_LN_P = select_by_double_property( M8_v, "low",< -3.3 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M8V33_HP_P, M8I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M8V33_LN_P, M8I }}} );
  M8V33_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M8V33_HP_P }, output_from_layers = { M8I } );
  M8V33_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M8V33_LN_P }, output_from_layers = { M8I } );
  M8_HVN_33V = M8V33_HP or M8V33_LN;


  M8V363_HP_P = select_by_double_property( M8_v, "high", > 3.63 ); 
  M8V363_LN_P = select_by_double_property( M8_v, "low",< -3.63 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M8V363_HP_P, M8I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M8V363_LN_P, M8I }}} );
  M8V363_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M8V363_HP_P }, output_from_layers = { M8I } );
  M8V363_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M8V363_LN_P }, output_from_layers = { M8I } );
  M8_HVN_363V = M8V363_HP or M8V363_LN;


  M8V5_HP_P = select_by_double_property( M8_v, "high", > 4.9 ); 
  M8V5_LN_P = select_by_double_property( M8_v, "low",< -4.9 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M8V5_HP_P, M8I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M8V5_LN_P, M8I }}} );
  M8V5_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M8V5_HP_P }, output_from_layers = { M8I } );
  M8V5_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M8V5_LN_P }, output_from_layers = { M8I } );
  M8_HVN_5V = M8V5_HP or M8V5_LN;


  M9V096_HP_P = select_by_double_property( M9_v, "high", > 0.96 ); 
  M9V096_LN_P = select_by_double_property( M9_v, "low",< -0.96 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M9V096_HP_P, M9I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M9V096_LN_P, M9I }}} );
  M9V096_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M9V096_HP_P }, output_from_layers = { M9I } );
  M9V096_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M9V096_LN_P }, output_from_layers = { M9I } );
  M9_HVN_096V = M9V096_HP or M9V096_LN;


  M9V132_HP_P = select_by_double_property( M9_v, "high", > 1.32 ); 
  M9V132_LN_P = select_by_double_property( M9_v, "low",< -1.32 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M9V132_HP_P, M9I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M9V132_LN_P, M9I }}} );
  M9V132_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M9V132_HP_P }, output_from_layers = { M9I } );
  M9V132_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M9V132_LN_P }, output_from_layers = { M9I } );
  M9_HVN_132V = M9V132_HP or M9V132_LN;


  M9V165_HP_P = select_by_double_property( M9_v, "high", > 1.65 ); 
  M9V165_LN_P = select_by_double_property( M9_v, "low",< -1.65 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M9V165_HP_P, M9I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M9V165_LN_P, M9I }}} );
  M9V165_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M9V165_HP_P }, output_from_layers = { M9I } );
  M9V165_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M9V165_LN_P }, output_from_layers = { M9I } );
  M9_HVN_165V = M9V165_HP or M9V165_LN;


  M9V180_HP_P = select_by_double_property( M9_v, "high", > 1.8 ); 
  M9V180_LN_P = select_by_double_property( M9_v, "low",< -1.8 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M9V180_HP_P, M9I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M9V180_LN_P, M9I }}} );
  M9V180_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M9V180_HP_P }, output_from_layers = { M9I } );
  M9V180_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M9V180_LN_P }, output_from_layers = { M9I } );
  M9_HVN_180V = M9V180_HP or M9V180_LN;


  M9V198_HP_P = select_by_double_property( M9_v, "high", > 1.98 ); 
  M9V198_LN_P = select_by_double_property( M9_v, "low",< -1.98 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M9V198_HP_P, M9I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M9V198_LN_P, M9I }}} );
  M9V198_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M9V198_HP_P }, output_from_layers = { M9I } );
  M9V198_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M9V198_LN_P }, output_from_layers = { M9I } );
  M9_HVN_198V = M9V198_HP or M9V198_LN;


  M9V25_HP_P = select_by_double_property( M9_v, "high", > 2.5 ); 
  M9V25_LN_P = select_by_double_property( M9_v, "low",< -2.5 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M9V25_HP_P, M9I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M9V25_LN_P, M9I }}} );
  M9V25_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M9V25_HP_P }, output_from_layers = { M9I } );
  M9V25_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M9V25_LN_P }, output_from_layers = { M9I } );
  M9_HVN_25V = M9V25_HP or M9V25_LN;


  M9V275_HP_P = select_by_double_property( M9_v, "high", > 2.75 ); 
  M9V275_LN_P = select_by_double_property( M9_v, "low",< -2.75 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M9V275_HP_P, M9I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M9V275_LN_P, M9I }}} );
  M9V275_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M9V275_HP_P }, output_from_layers = { M9I } );
  M9V275_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M9V275_LN_P }, output_from_layers = { M9I } );
  M9_HVN_275V = M9V275_HP or M9V275_LN;


  M9V33_HP_P = select_by_double_property( M9_v, "high", > 3.3 ); 
  M9V33_LN_P = select_by_double_property( M9_v, "low",< -3.3 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M9V33_HP_P, M9I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M9V33_LN_P, M9I }}} );
  M9V33_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M9V33_HP_P }, output_from_layers = { M9I } );
  M9V33_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M9V33_LN_P }, output_from_layers = { M9I } );
  M9_HVN_33V = M9V33_HP or M9V33_LN;


  M9V363_HP_P = select_by_double_property( M9_v, "high", > 3.63 ); 
  M9V363_LN_P = select_by_double_property( M9_v, "low",< -3.63 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M9V363_HP_P, M9I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M9V363_LN_P, M9I }}} );
  M9V363_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M9V363_HP_P }, output_from_layers = { M9I } );
  M9V363_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M9V363_LN_P }, output_from_layers = { M9I } );
  M9_HVN_363V = M9V363_HP or M9V363_LN;


  M9V5_HP_P = select_by_double_property( M9_v, "high", > 4.9 ); 
  M9V5_LN_P = select_by_double_property( M9_v, "low",< -4.9 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M9V5_HP_P, M9I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M9V5_LN_P, M9I }}} );
  M9V5_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M9V5_HP_P }, output_from_layers = { M9I } );
  M9V5_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M9V5_LN_P }, output_from_layers = { M9I } );
  M9_HVN_5V = M9V5_HP or M9V5_LN;


  M10V096_HP_P = select_by_double_property( M10_v, "high", > 0.96 ); 
  M10V096_LN_P = select_by_double_property( M10_v, "low",< -0.96 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M10V096_HP_P, M10I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M10V096_LN_P, M10I }}} );
  M10V096_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M10V096_HP_P }, output_from_layers = { M10I } );
  M10V096_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M10V096_LN_P }, output_from_layers = { M10I } );
  M10_HVN_096V = M10V096_HP or M10V096_LN;


  M10V132_HP_P = select_by_double_property( M10_v, "high", > 1.32 ); 
  M10V132_LN_P = select_by_double_property( M10_v, "low",< -1.32 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M10V132_HP_P, M10I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M10V132_LN_P, M10I }}} );
  M10V132_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M10V132_HP_P }, output_from_layers = { M10I } );
  M10V132_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M10V132_LN_P }, output_from_layers = { M10I } );
  M10_HVN_132V = M10V132_HP or M10V132_LN;


  M10V165_HP_P = select_by_double_property( M10_v, "high", > 1.65 ); 
  M10V165_LN_P = select_by_double_property( M10_v, "low",< -1.65 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M10V165_HP_P, M10I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M10V165_LN_P, M10I }}} );
  M10V165_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M10V165_HP_P }, output_from_layers = { M10I } );
  M10V165_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M10V165_LN_P }, output_from_layers = { M10I } );
  M10_HVN_165V = M10V165_HP or M10V165_LN;


  M10V180_HP_P = select_by_double_property( M10_v, "high", > 1.8 ); 
  M10V180_LN_P = select_by_double_property( M10_v, "low",< -1.8 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M10V180_HP_P, M10I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M10V180_LN_P, M10I }}} );
  M10V180_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M10V180_HP_P }, output_from_layers = { M10I } );
  M10V180_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M10V180_LN_P }, output_from_layers = { M10I } );
  M10_HVN_180V = M10V180_HP or M10V180_LN;


  M10V198_HP_P = select_by_double_property( M10_v, "high", > 1.98 ); 
  M10V198_LN_P = select_by_double_property( M10_v, "low",< -1.98 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M10V198_HP_P, M10I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M10V198_LN_P, M10I }}} );
  M10V198_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M10V198_HP_P }, output_from_layers = { M10I } );
  M10V198_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M10V198_LN_P }, output_from_layers = { M10I } );
  M10_HVN_198V = M10V198_HP or M10V198_LN;


  M10V25_HP_P = select_by_double_property( M10_v, "high", > 2.5 ); 
  M10V25_LN_P = select_by_double_property( M10_v, "low",< -2.5 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M10V25_HP_P, M10I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M10V25_LN_P, M10I }}} );
  M10V25_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M10V25_HP_P }, output_from_layers = { M10I } );
  M10V25_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M10V25_LN_P }, output_from_layers = { M10I } );
  M10_HVN_25V = M10V25_HP or M10V25_LN;


  M10V275_HP_P = select_by_double_property( M10_v, "high", > 2.75 ); 
  M10V275_LN_P = select_by_double_property( M10_v, "low",< -2.75 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M10V275_HP_P, M10I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M10V275_LN_P, M10I }}} );
  M10V275_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M10V275_HP_P }, output_from_layers = { M10I } );
  M10V275_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M10V275_LN_P }, output_from_layers = { M10I } );
  M10_HVN_275V = M10V275_HP or M10V275_LN;


  M10V33_HP_P = select_by_double_property( M10_v, "high", > 3.3 ); 
  M10V33_LN_P = select_by_double_property( M10_v, "low",< -3.3 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M10V33_HP_P, M10I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M10V33_LN_P, M10I }}} );
  M10V33_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M10V33_HP_P }, output_from_layers = { M10I } );
  M10V33_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M10V33_LN_P }, output_from_layers = { M10I } );
  M10_HVN_33V = M10V33_HP or M10V33_LN;


  M10V363_HP_P = select_by_double_property( M10_v, "high", > 3.63 ); 
  M10V363_LN_P = select_by_double_property( M10_v, "low",< -3.63 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M10V363_HP_P, M10I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M10V363_LN_P, M10I }}} );
  M10V363_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M10V363_HP_P }, output_from_layers = { M10I } );
  M10V363_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M10V363_LN_P }, output_from_layers = { M10I } );
  M10_HVN_363V = M10V363_HP or M10V363_LN;


  M10V5_HP_P = select_by_double_property( M10_v, "high", > 4.9 ); 
  M10V5_LN_P = select_by_double_property( M10_v, "low",< -4.9 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M10V5_HP_P, M10I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M10V5_LN_P, M10I }}} );
  M10V5_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M10V5_HP_P }, output_from_layers = { M10I } );
  M10V5_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M10V5_LN_P }, output_from_layers = { M10I } );
  M10_HVN_5V = M10V5_HP or M10V5_LN;


  M11V096_HP_P = select_by_double_property( M11_v, "high", > 0.96 ); 
  M11V096_LN_P = select_by_double_property( M11_v, "low",< -0.96 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M11V096_HP_P, M11I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M11V096_LN_P, M11I }}} );
  M11V096_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M11V096_HP_P }, output_from_layers = { M11I } );
  M11V096_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M11V096_LN_P }, output_from_layers = { M11I } );
  M11_HVN_096V = M11V096_HP or M11V096_LN;


  M11V132_HP_P = select_by_double_property( M11_v, "high", > 1.32 ); 
  M11V132_LN_P = select_by_double_property( M11_v, "low",< -1.32 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M11V132_HP_P, M11I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M11V132_LN_P, M11I }}} );
  M11V132_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M11V132_HP_P }, output_from_layers = { M11I } );
  M11V132_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M11V132_LN_P }, output_from_layers = { M11I } );
  M11_HVN_132V = M11V132_HP or M11V132_LN;


  M11V165_HP_P = select_by_double_property( M11_v, "high", > 1.65 ); 
  M11V165_LN_P = select_by_double_property( M11_v, "low",< -1.65 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M11V165_HP_P, M11I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M11V165_LN_P, M11I }}} );
  M11V165_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M11V165_HP_P }, output_from_layers = { M11I } );
  M11V165_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M11V165_LN_P }, output_from_layers = { M11I } );
  M11_HVN_165V = M11V165_HP or M11V165_LN;


  M11V180_HP_P = select_by_double_property( M11_v, "high", > 1.8 ); 
  M11V180_LN_P = select_by_double_property( M11_v, "low",< -1.8 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M11V180_HP_P, M11I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M11V180_LN_P, M11I }}} );
  M11V180_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M11V180_HP_P }, output_from_layers = { M11I } );
  M11V180_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M11V180_LN_P }, output_from_layers = { M11I } );
  M11_HVN_180V = M11V180_HP or M11V180_LN;


  M11V198_HP_P = select_by_double_property( M11_v, "high", > 1.98 ); 
  M11V198_LN_P = select_by_double_property( M11_v, "low",< -1.98 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M11V198_HP_P, M11I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M11V198_LN_P, M11I }}} );
  M11V198_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M11V198_HP_P }, output_from_layers = { M11I } );
  M11V198_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M11V198_LN_P }, output_from_layers = { M11I } );
  M11_HVN_198V = M11V198_HP or M11V198_LN;


  M11V25_HP_P = select_by_double_property( M11_v, "high", > 2.5 ); 
  M11V25_LN_P = select_by_double_property( M11_v, "low",< -2.5 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M11V25_HP_P, M11I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M11V25_LN_P, M11I }}} );
  M11V25_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M11V25_HP_P }, output_from_layers = { M11I } );
  M11V25_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M11V25_LN_P }, output_from_layers = { M11I } );
  M11_HVN_25V = M11V25_HP or M11V25_LN;


  M11V275_HP_P = select_by_double_property( M11_v, "high", > 2.75 ); 
  M11V275_LN_P = select_by_double_property( M11_v, "low",< -2.75 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M11V275_HP_P, M11I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M11V275_LN_P, M11I }}} );
  M11V275_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M11V275_HP_P }, output_from_layers = { M11I } );
  M11V275_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M11V275_LN_P }, output_from_layers = { M11I } );
  M11_HVN_275V = M11V275_HP or M11V275_LN;


  M11V33_HP_P = select_by_double_property( M11_v, "high", > 3.3 ); 
  M11V33_LN_P = select_by_double_property( M11_v, "low",< -3.3 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M11V33_HP_P, M11I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M11V33_LN_P, M11I }}} );
  M11V33_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M11V33_HP_P }, output_from_layers = { M11I } );
  M11V33_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M11V33_LN_P }, output_from_layers = { M11I } );
  M11_HVN_33V = M11V33_HP or M11V33_LN;


  M11V363_HP_P = select_by_double_property( M11_v, "high", > 3.63 ); 
  M11V363_LN_P = select_by_double_property( M11_v, "low",< -3.63 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M11V363_HP_P, M11I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M11V363_LN_P, M11I }}} );
  M11V363_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M11V363_HP_P }, output_from_layers = { M11I } );
  M11V363_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M11V363_LN_P }, output_from_layers = { M11I } );
  M11_HVN_363V = M11V363_HP or M11V363_LN;


  M11V5_HP_P = select_by_double_property( M11_v, "high", > 4.9 ); 
  M11V5_LN_P = select_by_double_property( M11_v, "low",< -4.9 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M11V5_HP_P, M11I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M11V5_LN_P, M11I }}} );
  M11V5_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M11V5_HP_P }, output_from_layers = { M11I } );
  M11V5_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M11V5_LN_P }, output_from_layers = { M11I } );
  M11_HVN_5V = M11V5_HP or M11V5_LN;


  M12V096_HP_P = select_by_double_property( M12_v, "high", > 0.96 ); 
  M12V096_LN_P = select_by_double_property( M12_v, "low",< -0.96 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M12V096_HP_P, M12I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M12V096_LN_P, M12I }}} );
  M12V096_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M12V096_HP_P }, output_from_layers = { M12I } );
  M12V096_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M12V096_LN_P }, output_from_layers = { M12I } );
  M12_HVN_096V = M12V096_HP or M12V096_LN;


  M12V132_HP_P = select_by_double_property( M12_v, "high", > 1.32 ); 
  M12V132_LN_P = select_by_double_property( M12_v, "low",< -1.32 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M12V132_HP_P, M12I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M12V132_LN_P, M12I }}} );
  M12V132_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M12V132_HP_P }, output_from_layers = { M12I } );
  M12V132_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M12V132_LN_P }, output_from_layers = { M12I } );
  M12_HVN_132V = M12V132_HP or M12V132_LN;


  M12V165_HP_P = select_by_double_property( M12_v, "high", > 1.65 ); 
  M12V165_LN_P = select_by_double_property( M12_v, "low",< -1.65 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M12V165_HP_P, M12I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M12V165_LN_P, M12I }}} );
  M12V165_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M12V165_HP_P }, output_from_layers = { M12I } );
  M12V165_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M12V165_LN_P }, output_from_layers = { M12I } );
  M12_HVN_165V = M12V165_HP or M12V165_LN;


  M12V180_HP_P = select_by_double_property( M12_v, "high", > 1.8 ); 
  M12V180_LN_P = select_by_double_property( M12_v, "low",< -1.8 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M12V180_HP_P, M12I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M12V180_LN_P, M12I }}} );
  M12V180_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M12V180_HP_P }, output_from_layers = { M12I } );
  M12V180_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M12V180_LN_P }, output_from_layers = { M12I } );
  M12_HVN_180V = M12V180_HP or M12V180_LN;


  M12V198_HP_P = select_by_double_property( M12_v, "high", > 1.98 ); 
  M12V198_LN_P = select_by_double_property( M12_v, "low",< -1.98 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M12V198_HP_P, M12I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M12V198_LN_P, M12I }}} );
  M12V198_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M12V198_HP_P }, output_from_layers = { M12I } );
  M12V198_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M12V198_LN_P }, output_from_layers = { M12I } );
  M12_HVN_198V = M12V198_HP or M12V198_LN;


  M12V25_HP_P = select_by_double_property( M12_v, "high", > 2.5 ); 
  M12V25_LN_P = select_by_double_property( M12_v, "low",< -2.5 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M12V25_HP_P, M12I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M12V25_LN_P, M12I }}} );
  M12V25_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M12V25_HP_P }, output_from_layers = { M12I } );
  M12V25_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M12V25_LN_P }, output_from_layers = { M12I } );
  M12_HVN_25V = M12V25_HP or M12V25_LN;


  M12V275_HP_P = select_by_double_property( M12_v, "high", > 2.75 ); 
  M12V275_LN_P = select_by_double_property( M12_v, "low",< -2.75 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M12V275_HP_P, M12I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M12V275_LN_P, M12I }}} );
  M12V275_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M12V275_HP_P }, output_from_layers = { M12I } );
  M12V275_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M12V275_LN_P }, output_from_layers = { M12I } );
  M12_HVN_275V = M12V275_HP or M12V275_LN;


  M12V33_HP_P = select_by_double_property( M12_v, "high", > 3.3 ); 
  M12V33_LN_P = select_by_double_property( M12_v, "low",< -3.3 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M12V33_HP_P, M12I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M12V33_LN_P, M12I }}} );
  M12V33_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M12V33_HP_P }, output_from_layers = { M12I } );
  M12V33_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M12V33_LN_P }, output_from_layers = { M12I } );
  M12_HVN_33V = M12V33_HP or M12V33_LN;


  M12V363_HP_P = select_by_double_property( M12_v, "high", > 3.63 ); 
  M12V363_LN_P = select_by_double_property( M12_v, "low",< -3.63 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M12V363_HP_P, M12I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M12V363_LN_P, M12I }}} );
  M12V363_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M12V363_HP_P }, output_from_layers = { M12I } );
  M12V363_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M12V363_LN_P }, output_from_layers = { M12I } );
  M12_HVN_363V = M12V363_HP or M12V363_LN;


  M12V5_HP_P = select_by_double_property( M12_v, "high", > 4.9 ); 
  M12V5_LN_P = select_by_double_property( M12_v, "low",< -4.9 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M12V5_HP_P, M12I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M12V5_LN_P, M12I }}} );
  M12V5_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M12V5_HP_P }, output_from_layers = { M12I } );
  M12V5_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M12V5_LN_P }, output_from_layers = { M12I } );
  M12_HVN_5V = M12V5_HP or M12V5_LN;


  M13V096_HP_P = select_by_double_property( M13_v, "high", > 0.96 ); 
  M13V096_LN_P = select_by_double_property( M13_v, "low",< -0.96 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M13V096_HP_P, M13I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M13V096_LN_P, M13I }}} );
  M13V096_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M13V096_HP_P }, output_from_layers = { M13I } );
  M13V096_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M13V096_LN_P }, output_from_layers = { M13I } );
  M13_HVN_096V = M13V096_HP or M13V096_LN;


  M13V132_HP_P = select_by_double_property( M13_v, "high", > 1.32 ); 
  M13V132_LN_P = select_by_double_property( M13_v, "low",< -1.32 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M13V132_HP_P, M13I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M13V132_LN_P, M13I }}} );
  M13V132_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M13V132_HP_P }, output_from_layers = { M13I } );
  M13V132_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M13V132_LN_P }, output_from_layers = { M13I } );
  M13_HVN_132V = M13V132_HP or M13V132_LN;


  M13V165_HP_P = select_by_double_property( M13_v, "high", > 1.65 ); 
  M13V165_LN_P = select_by_double_property( M13_v, "low",< -1.65 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M13V165_HP_P, M13I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M13V165_LN_P, M13I }}} );
  M13V165_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M13V165_HP_P }, output_from_layers = { M13I } );
  M13V165_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M13V165_LN_P }, output_from_layers = { M13I } );
  M13_HVN_165V = M13V165_HP or M13V165_LN;


  M13V180_HP_P = select_by_double_property( M13_v, "high", > 1.8 ); 
  M13V180_LN_P = select_by_double_property( M13_v, "low",< -1.8 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M13V180_HP_P, M13I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M13V180_LN_P, M13I }}} );
  M13V180_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M13V180_HP_P }, output_from_layers = { M13I } );
  M13V180_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M13V180_LN_P }, output_from_layers = { M13I } );
  M13_HVN_180V = M13V180_HP or M13V180_LN;


  M13V198_HP_P = select_by_double_property( M13_v, "high", > 1.98 ); 
  M13V198_LN_P = select_by_double_property( M13_v, "low",< -1.98 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M13V198_HP_P, M13I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M13V198_LN_P, M13I }}} );
  M13V198_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M13V198_HP_P }, output_from_layers = { M13I } );
  M13V198_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M13V198_LN_P }, output_from_layers = { M13I } );
  M13_HVN_198V = M13V198_HP or M13V198_LN;


  M13V25_HP_P = select_by_double_property( M13_v, "high", > 2.5 ); 
  M13V25_LN_P = select_by_double_property( M13_v, "low",< -2.5 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M13V25_HP_P, M13I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M13V25_LN_P, M13I }}} );
  M13V25_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M13V25_HP_P }, output_from_layers = { M13I } );
  M13V25_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M13V25_LN_P }, output_from_layers = { M13I } );
  M13_HVN_25V = M13V25_HP or M13V25_LN;


  M13V275_HP_P = select_by_double_property( M13_v, "high", > 2.75 ); 
  M13V275_LN_P = select_by_double_property( M13_v, "low",< -2.75 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M13V275_HP_P, M13I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M13V275_LN_P, M13I }}} );
  M13V275_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M13V275_HP_P }, output_from_layers = { M13I } );
  M13V275_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M13V275_LN_P }, output_from_layers = { M13I } );
  M13_HVN_275V = M13V275_HP or M13V275_LN;


  M13V33_HP_P = select_by_double_property( M13_v, "high", > 3.3 ); 
  M13V33_LN_P = select_by_double_property( M13_v, "low",< -3.3 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M13V33_HP_P, M13I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M13V33_LN_P, M13I }}} );
  M13V33_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M13V33_HP_P }, output_from_layers = { M13I } );
  M13V33_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M13V33_LN_P }, output_from_layers = { M13I } );
  M13_HVN_33V = M13V33_HP or M13V33_LN;


  M13V363_HP_P = select_by_double_property( M13_v, "high", > 3.63 ); 
  M13V363_LN_P = select_by_double_property( M13_v, "low",< -3.63 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M13V363_HP_P, M13I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M13V363_LN_P, M13I }}} );
  M13V363_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M13V363_HP_P }, output_from_layers = { M13I } );
  M13V363_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M13V363_LN_P }, output_from_layers = { M13I } );
  M13_HVN_363V = M13V363_HP or M13V363_LN;


  M13V5_HP_P = select_by_double_property( M13_v, "high", > 4.9 ); 
  M13V5_LN_P = select_by_double_property( M13_v, "low",< -4.9 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M13V5_HP_P, M13I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M13V5_LN_P, M13I }}} );
  M13V5_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M13V5_HP_P }, output_from_layers = { M13I } );
  M13V5_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M13V5_LN_P }, output_from_layers = { M13I } );
  M13_HVN_5V = M13V5_HP or M13V5_LN;


  M14V096_HP_P = select_by_double_property( M14_v, "high", > 0.96 ); 
  M14V096_LN_P = select_by_double_property( M14_v, "low",< -0.96 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M14V096_HP_P, M14I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M14V096_LN_P, M14I }}} );
  M14V096_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M14V096_HP_P }, output_from_layers = { M14I } );
  M14V096_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M14V096_LN_P }, output_from_layers = { M14I } );
  M14_HVN_096V = M14V096_HP or M14V096_LN;


  M14V132_HP_P = select_by_double_property( M14_v, "high", > 1.32 ); 
  M14V132_LN_P = select_by_double_property( M14_v, "low",< -1.32 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M14V132_HP_P, M14I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M14V132_LN_P, M14I }}} );
  M14V132_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M14V132_HP_P }, output_from_layers = { M14I } );
  M14V132_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M14V132_LN_P }, output_from_layers = { M14I } );
  M14_HVN_132V = M14V132_HP or M14V132_LN;


  M14V165_HP_P = select_by_double_property( M14_v, "high", > 1.65 ); 
  M14V165_LN_P = select_by_double_property( M14_v, "low",< -1.65 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M14V165_HP_P, M14I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M14V165_LN_P, M14I }}} );
  M14V165_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M14V165_HP_P }, output_from_layers = { M14I } );
  M14V165_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M14V165_LN_P }, output_from_layers = { M14I } );
  M14_HVN_165V = M14V165_HP or M14V165_LN;


  M14V180_HP_P = select_by_double_property( M14_v, "high", > 1.8 ); 
  M14V180_LN_P = select_by_double_property( M14_v, "low",< -1.8 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M14V180_HP_P, M14I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M14V180_LN_P, M14I }}} );
  M14V180_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M14V180_HP_P }, output_from_layers = { M14I } );
  M14V180_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M14V180_LN_P }, output_from_layers = { M14I } );
  M14_HVN_180V = M14V180_HP or M14V180_LN;


  M14V198_HP_P = select_by_double_property( M14_v, "high", > 1.98 ); 
  M14V198_LN_P = select_by_double_property( M14_v, "low",< -1.98 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M14V198_HP_P, M14I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M14V198_LN_P, M14I }}} );
  M14V198_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M14V198_HP_P }, output_from_layers = { M14I } );
  M14V198_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M14V198_LN_P }, output_from_layers = { M14I } );
  M14_HVN_198V = M14V198_HP or M14V198_LN;


  M14V25_HP_P = select_by_double_property( M14_v, "high", > 2.5 ); 
  M14V25_LN_P = select_by_double_property( M14_v, "low",< -2.5 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M14V25_HP_P, M14I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M14V25_LN_P, M14I }}} );
  M14V25_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M14V25_HP_P }, output_from_layers = { M14I } );
  M14V25_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M14V25_LN_P }, output_from_layers = { M14I } );
  M14_HVN_25V = M14V25_HP or M14V25_LN;


  M14V275_HP_P = select_by_double_property( M14_v, "high", > 2.75 ); 
  M14V275_LN_P = select_by_double_property( M14_v, "low",< -2.75 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M14V275_HP_P, M14I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M14V275_LN_P, M14I }}} );
  M14V275_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M14V275_HP_P }, output_from_layers = { M14I } );
  M14V275_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M14V275_LN_P }, output_from_layers = { M14I } );
  M14_HVN_275V = M14V275_HP or M14V275_LN;


  M14V33_HP_P = select_by_double_property( M14_v, "high", > 3.3 ); 
  M14V33_LN_P = select_by_double_property( M14_v, "low",< -3.3 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M14V33_HP_P, M14I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M14V33_LN_P, M14I }}} );
  M14V33_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M14V33_HP_P }, output_from_layers = { M14I } );
  M14V33_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M14V33_LN_P }, output_from_layers = { M14I } );
  M14_HVN_33V = M14V33_HP or M14V33_LN;


  M14V363_HP_P = select_by_double_property( M14_v, "high", > 3.63 ); 
  M14V363_LN_P = select_by_double_property( M14_v, "low",< -3.63 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M14V363_HP_P, M14I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M14V363_LN_P, M14I }}} );
  M14V363_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M14V363_HP_P }, output_from_layers = { M14I } );
  M14V363_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M14V363_LN_P }, output_from_layers = { M14I } );
  M14_HVN_363V = M14V363_HP or M14V363_LN;


  M14V5_HP_P = select_by_double_property( M14_v, "high", > 4.9 ); 
  M14V5_LN_P = select_by_double_property( M14_v, "low",< -4.9 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M14V5_HP_P, M14I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M14V5_LN_P, M14I }}} );
  M14V5_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M14V5_HP_P }, output_from_layers = { M14I } );
  M14V5_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M14V5_LN_P }, output_from_layers = { M14I } );
  M14_HVN_5V = M14V5_HP or M14V5_LN;


  M15V096_HP_P = select_by_double_property( M15_v, "high", > 0.96 ); 
  M15V096_LN_P = select_by_double_property( M15_v, "low",< -0.96 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M15V096_HP_P, M15I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M15V096_LN_P, M15I }}} );
  M15V096_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M15V096_HP_P }, output_from_layers = { M15I } );
  M15V096_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M15V096_LN_P }, output_from_layers = { M15I } );
  M15_HVN_096V = M15V096_HP or M15V096_LN;


  M15V132_HP_P = select_by_double_property( M15_v, "high", > 1.32 ); 
  M15V132_LN_P = select_by_double_property( M15_v, "low",< -1.32 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M15V132_HP_P, M15I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M15V132_LN_P, M15I }}} );
  M15V132_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M15V132_HP_P }, output_from_layers = { M15I } );
  M15V132_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M15V132_LN_P }, output_from_layers = { M15I } );
  M15_HVN_132V = M15V132_HP or M15V132_LN;


  M15V165_HP_P = select_by_double_property( M15_v, "high", > 1.65 ); 
  M15V165_LN_P = select_by_double_property( M15_v, "low",< -1.65 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M15V165_HP_P, M15I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M15V165_LN_P, M15I }}} );
  M15V165_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M15V165_HP_P }, output_from_layers = { M15I } );
  M15V165_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M15V165_LN_P }, output_from_layers = { M15I } );
  M15_HVN_165V = M15V165_HP or M15V165_LN;


  M15V180_HP_P = select_by_double_property( M15_v, "high", > 1.8 ); 
  M15V180_LN_P = select_by_double_property( M15_v, "low",< -1.8 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M15V180_HP_P, M15I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M15V180_LN_P, M15I }}} );
  M15V180_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M15V180_HP_P }, output_from_layers = { M15I } );
  M15V180_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M15V180_LN_P }, output_from_layers = { M15I } );
  M15_HVN_180V = M15V180_HP or M15V180_LN;


  M15V198_HP_P = select_by_double_property( M15_v, "high", > 1.98 ); 
  M15V198_LN_P = select_by_double_property( M15_v, "low",< -1.98 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M15V198_HP_P, M15I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M15V198_LN_P, M15I }}} );
  M15V198_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M15V198_HP_P }, output_from_layers = { M15I } );
  M15V198_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M15V198_LN_P }, output_from_layers = { M15I } );
  M15_HVN_198V = M15V198_HP or M15V198_LN;


  M15V25_HP_P = select_by_double_property( M15_v, "high", > 2.5 ); 
  M15V25_LN_P = select_by_double_property( M15_v, "low",< -2.5 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M15V25_HP_P, M15I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M15V25_LN_P, M15I }}} );
  M15V25_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M15V25_HP_P }, output_from_layers = { M15I } );
  M15V25_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M15V25_LN_P }, output_from_layers = { M15I } );
  M15_HVN_25V = M15V25_HP or M15V25_LN;


  M15V275_HP_P = select_by_double_property( M15_v, "high", > 2.75 ); 
  M15V275_LN_P = select_by_double_property( M15_v, "low",< -2.75 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M15V275_HP_P, M15I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M15V275_LN_P, M15I }}} );
  M15V275_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M15V275_HP_P }, output_from_layers = { M15I } );
  M15V275_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M15V275_LN_P }, output_from_layers = { M15I } );
  M15_HVN_275V = M15V275_HP or M15V275_LN;


  M15V33_HP_P = select_by_double_property( M15_v, "high", > 3.3 ); 
  M15V33_LN_P = select_by_double_property( M15_v, "low",< -3.3 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M15V33_HP_P, M15I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M15V33_LN_P, M15I }}} );
  M15V33_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M15V33_HP_P }, output_from_layers = { M15I } );
  M15V33_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M15V33_LN_P }, output_from_layers = { M15I } );
  M15_HVN_33V = M15V33_HP or M15V33_LN;


  M15V363_HP_P = select_by_double_property( M15_v, "high", > 3.63 ); 
  M15V363_LN_P = select_by_double_property( M15_v, "low",< -3.63 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M15V363_HP_P, M15I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M15V363_LN_P, M15I }}} );
  M15V363_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M15V363_HP_P }, output_from_layers = { M15I } );
  M15V363_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M15V363_LN_P }, output_from_layers = { M15I } );
  M15_HVN_363V = M15V363_HP or M15V363_LN;


  M15V5_HP_P = select_by_double_property( M15_v, "high", > 4.9 ); 
  M15V5_LN_P = select_by_double_property( M15_v, "low",< -4.9 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M15V5_HP_P, M15I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M15V5_LN_P, M15I }}} );
  M15V5_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M15V5_HP_P }, output_from_layers = { M15I } );
  M15V5_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M15V5_LN_P }, output_from_layers = { M15I } );
  M15_HVN_5V = M15V5_HP or M15V5_LN;


  M16V096_HP_P = select_by_double_property( M16_v, "high", > 0.96 ); 
  M16V096_LN_P = select_by_double_property( M16_v, "low",< -0.96 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M16V096_HP_P, M16I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M16V096_LN_P, M16I }}} );
  M16V096_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M16V096_HP_P }, output_from_layers = { M16I } );
  M16V096_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M16V096_LN_P }, output_from_layers = { M16I } );
  M16_HVN_096V = M16V096_HP or M16V096_LN;


  M16V132_HP_P = select_by_double_property( M16_v, "high", > 1.32 ); 
  M16V132_LN_P = select_by_double_property( M16_v, "low",< -1.32 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M16V132_HP_P, M16I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M16V132_LN_P, M16I }}} );
  M16V132_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M16V132_HP_P }, output_from_layers = { M16I } );
  M16V132_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M16V132_LN_P }, output_from_layers = { M16I } );
  M16_HVN_132V = M16V132_HP or M16V132_LN;


  M16V165_HP_P = select_by_double_property( M16_v, "high", > 1.65 ); 
  M16V165_LN_P = select_by_double_property( M16_v, "low",< -1.65 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M16V165_HP_P, M16I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M16V165_LN_P, M16I }}} );
  M16V165_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M16V165_HP_P }, output_from_layers = { M16I } );
  M16V165_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M16V165_LN_P }, output_from_layers = { M16I } );
  M16_HVN_165V = M16V165_HP or M16V165_LN;


  M16V180_HP_P = select_by_double_property( M16_v, "high", > 1.8 ); 
  M16V180_LN_P = select_by_double_property( M16_v, "low",< -1.8 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M16V180_HP_P, M16I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M16V180_LN_P, M16I }}} );
  M16V180_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M16V180_HP_P }, output_from_layers = { M16I } );
  M16V180_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M16V180_LN_P }, output_from_layers = { M16I } );
  M16_HVN_180V = M16V180_HP or M16V180_LN;


  M16V198_HP_P = select_by_double_property( M16_v, "high", > 1.98 ); 
  M16V198_LN_P = select_by_double_property( M16_v, "low",< -1.98 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M16V198_HP_P, M16I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M16V198_LN_P, M16I }}} );
  M16V198_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M16V198_HP_P }, output_from_layers = { M16I } );
  M16V198_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M16V198_LN_P }, output_from_layers = { M16I } );
  M16_HVN_198V = M16V198_HP or M16V198_LN;


  M16V25_HP_P = select_by_double_property( M16_v, "high", > 2.5 ); 
  M16V25_LN_P = select_by_double_property( M16_v, "low",< -2.5 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M16V25_HP_P, M16I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M16V25_LN_P, M16I }}} );
  M16V25_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M16V25_HP_P }, output_from_layers = { M16I } );
  M16V25_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M16V25_LN_P }, output_from_layers = { M16I } );
  M16_HVN_25V = M16V25_HP or M16V25_LN;


  M16V275_HP_P = select_by_double_property( M16_v, "high", > 2.75 ); 
  M16V275_LN_P = select_by_double_property( M16_v, "low",< -2.75 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M16V275_HP_P, M16I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M16V275_LN_P, M16I }}} );
  M16V275_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M16V275_HP_P }, output_from_layers = { M16I } );
  M16V275_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M16V275_LN_P }, output_from_layers = { M16I } );
  M16_HVN_275V = M16V275_HP or M16V275_LN;


  M16V33_HP_P = select_by_double_property( M16_v, "high", > 3.3 ); 
  M16V33_LN_P = select_by_double_property( M16_v, "low",< -3.3 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M16V33_HP_P, M16I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M16V33_LN_P, M16I }}} );
  M16V33_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M16V33_HP_P }, output_from_layers = { M16I } );
  M16V33_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M16V33_LN_P }, output_from_layers = { M16I } );
  M16_HVN_33V = M16V33_HP or M16V33_LN;


  M16V363_HP_P = select_by_double_property( M16_v, "high", > 3.63 ); 
  M16V363_LN_P = select_by_double_property( M16_v, "low",< -3.63 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M16V363_HP_P, M16I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M16V363_LN_P, M16I }}} );
  M16V363_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M16V363_HP_P }, output_from_layers = { M16I } );
  M16V363_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M16V363_LN_P }, output_from_layers = { M16I } );
  M16_HVN_363V = M16V363_HP or M16V363_LN;


  M16V5_HP_P = select_by_double_property( M16_v, "high", > 4.9 ); 
  M16V5_LN_P = select_by_double_property( M16_v, "low",< -4.9 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M16V5_HP_P, M16I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M16V5_LN_P, M16I }}} );
  M16V5_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M16V5_HP_P }, output_from_layers = { M16I } );
  M16V5_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M16V5_LN_P }, output_from_layers = { M16I } );
  M16_HVN_5V = M16V5_HP or M16V5_LN;


  M17V096_HP_P = select_by_double_property( M17_v, "high", > 0.96 ); 
  M17V096_LN_P = select_by_double_property( M17_v, "low",< -0.96 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M17V096_HP_P, M17I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M17V096_LN_P, M17I }}} );
  M17V096_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M17V096_HP_P }, output_from_layers = { M17I } );
  M17V096_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M17V096_LN_P }, output_from_layers = { M17I } );
  M17_HVN_096V = M17V096_HP or M17V096_LN;


  M17V132_HP_P = select_by_double_property( M17_v, "high", > 1.32 ); 
  M17V132_LN_P = select_by_double_property( M17_v, "low",< -1.32 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M17V132_HP_P, M17I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M17V132_LN_P, M17I }}} );
  M17V132_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M17V132_HP_P }, output_from_layers = { M17I } );
  M17V132_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M17V132_LN_P }, output_from_layers = { M17I } );
  M17_HVN_132V = M17V132_HP or M17V132_LN;


  M17V165_HP_P = select_by_double_property( M17_v, "high", > 1.65 ); 
  M17V165_LN_P = select_by_double_property( M17_v, "low",< -1.65 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M17V165_HP_P, M17I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M17V165_LN_P, M17I }}} );
  M17V165_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M17V165_HP_P }, output_from_layers = { M17I } );
  M17V165_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M17V165_LN_P }, output_from_layers = { M17I } );
  M17_HVN_165V = M17V165_HP or M17V165_LN;


  M17V180_HP_P = select_by_double_property( M17_v, "high", > 1.8 ); 
  M17V180_LN_P = select_by_double_property( M17_v, "low",< -1.8 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M17V180_HP_P, M17I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M17V180_LN_P, M17I }}} );
  M17V180_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M17V180_HP_P }, output_from_layers = { M17I } );
  M17V180_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M17V180_LN_P }, output_from_layers = { M17I } );
  M17_HVN_180V = M17V180_HP or M17V180_LN;


  M17V198_HP_P = select_by_double_property( M17_v, "high", > 1.98 ); 
  M17V198_LN_P = select_by_double_property( M17_v, "low",< -1.98 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M17V198_HP_P, M17I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M17V198_LN_P, M17I }}} );
  M17V198_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M17V198_HP_P }, output_from_layers = { M17I } );
  M17V198_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M17V198_LN_P }, output_from_layers = { M17I } );
  M17_HVN_198V = M17V198_HP or M17V198_LN;


  M17V25_HP_P = select_by_double_property( M17_v, "high", > 2.5 ); 
  M17V25_LN_P = select_by_double_property( M17_v, "low",< -2.5 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M17V25_HP_P, M17I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M17V25_LN_P, M17I }}} );
  M17V25_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M17V25_HP_P }, output_from_layers = { M17I } );
  M17V25_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M17V25_LN_P }, output_from_layers = { M17I } );
  M17_HVN_25V = M17V25_HP or M17V25_LN;


  M17V275_HP_P = select_by_double_property( M17_v, "high", > 2.75 ); 
  M17V275_LN_P = select_by_double_property( M17_v, "low",< -2.75 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M17V275_HP_P, M17I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M17V275_LN_P, M17I }}} );
  M17V275_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M17V275_HP_P }, output_from_layers = { M17I } );
  M17V275_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M17V275_LN_P }, output_from_layers = { M17I } );
  M17_HVN_275V = M17V275_HP or M17V275_LN;


  M17V33_HP_P = select_by_double_property( M17_v, "high", > 3.3 ); 
  M17V33_LN_P = select_by_double_property( M17_v, "low",< -3.3 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M17V33_HP_P, M17I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M17V33_LN_P, M17I }}} );
  M17V33_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M17V33_HP_P }, output_from_layers = { M17I } );
  M17V33_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M17V33_LN_P }, output_from_layers = { M17I } );
  M17_HVN_33V = M17V33_HP or M17V33_LN;


  M17V363_HP_P = select_by_double_property( M17_v, "high", > 3.63 ); 
  M17V363_LN_P = select_by_double_property( M17_v, "low",< -3.63 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M17V363_HP_P, M17I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M17V363_LN_P, M17I }}} );
  M17V363_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M17V363_HP_P }, output_from_layers = { M17I } );
  M17V363_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M17V363_LN_P }, output_from_layers = { M17I } );
  M17_HVN_363V = M17V363_HP or M17V363_LN;


  M17V5_HP_P = select_by_double_property( M17_v, "high", > 4.9 ); 
  M17V5_LN_P = select_by_double_property( M17_v, "low",< -4.9 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M17V5_HP_P, M17I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M17V5_LN_P, M17I }}} );
  M17V5_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M17V5_HP_P }, output_from_layers = { M17I } );
  M17V5_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M17V5_LN_P }, output_from_layers = { M17I } );
  M17_HVN_5V = M17V5_HP or M17V5_LN;


  M18V096_HP_P = select_by_double_property( M18_v, "high", > 0.96 ); 
  M18V096_LN_P = select_by_double_property( M18_v, "low",< -0.96 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M18V096_HP_P, M18I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M18V096_LN_P, M18I }}} );
  M18V096_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M18V096_HP_P }, output_from_layers = { M18I } );
  M18V096_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M18V096_LN_P }, output_from_layers = { M18I } );
  M18_HVN_096V = M18V096_HP or M18V096_LN;


  M18V132_HP_P = select_by_double_property( M18_v, "high", > 1.32 ); 
  M18V132_LN_P = select_by_double_property( M18_v, "low",< -1.32 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M18V132_HP_P, M18I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M18V132_LN_P, M18I }}} );
  M18V132_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M18V132_HP_P }, output_from_layers = { M18I } );
  M18V132_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M18V132_LN_P }, output_from_layers = { M18I } );
  M18_HVN_132V = M18V132_HP or M18V132_LN;


  M18V165_HP_P = select_by_double_property( M18_v, "high", > 1.65 ); 
  M18V165_LN_P = select_by_double_property( M18_v, "low",< -1.65 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M18V165_HP_P, M18I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M18V165_LN_P, M18I }}} );
  M18V165_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M18V165_HP_P }, output_from_layers = { M18I } );
  M18V165_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M18V165_LN_P }, output_from_layers = { M18I } );
  M18_HVN_165V = M18V165_HP or M18V165_LN;


  M18V180_HP_P = select_by_double_property( M18_v, "high", > 1.8 ); 
  M18V180_LN_P = select_by_double_property( M18_v, "low",< -1.8 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M18V180_HP_P, M18I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M18V180_LN_P, M18I }}} );
  M18V180_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M18V180_HP_P }, output_from_layers = { M18I } );
  M18V180_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M18V180_LN_P }, output_from_layers = { M18I } );
  M18_HVN_180V = M18V180_HP or M18V180_LN;


  M18V198_HP_P = select_by_double_property( M18_v, "high", > 1.98 ); 
  M18V198_LN_P = select_by_double_property( M18_v, "low",< -1.98 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M18V198_HP_P, M18I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M18V198_LN_P, M18I }}} );
  M18V198_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M18V198_HP_P }, output_from_layers = { M18I } );
  M18V198_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M18V198_LN_P }, output_from_layers = { M18I } );
  M18_HVN_198V = M18V198_HP or M18V198_LN;


  M18V25_HP_P = select_by_double_property( M18_v, "high", > 2.5 ); 
  M18V25_LN_P = select_by_double_property( M18_v, "low",< -2.5 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M18V25_HP_P, M18I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M18V25_LN_P, M18I }}} );
  M18V25_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M18V25_HP_P }, output_from_layers = { M18I } );
  M18V25_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M18V25_LN_P }, output_from_layers = { M18I } );
  M18_HVN_25V = M18V25_HP or M18V25_LN;


  M18V275_HP_P = select_by_double_property( M18_v, "high", > 2.75 ); 
  M18V275_LN_P = select_by_double_property( M18_v, "low",< -2.75 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M18V275_HP_P, M18I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M18V275_LN_P, M18I }}} );
  M18V275_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M18V275_HP_P }, output_from_layers = { M18I } );
  M18V275_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M18V275_LN_P }, output_from_layers = { M18I } );
  M18_HVN_275V = M18V275_HP or M18V275_LN;


  M18V33_HP_P = select_by_double_property( M18_v, "high", > 3.3 ); 
  M18V33_LN_P = select_by_double_property( M18_v, "low",< -3.3 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M18V33_HP_P, M18I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M18V33_LN_P, M18I }}} );
  M18V33_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M18V33_HP_P }, output_from_layers = { M18I } );
  M18V33_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M18V33_LN_P }, output_from_layers = { M18I } );
  M18_HVN_33V = M18V33_HP or M18V33_LN;


  M18V363_HP_P = select_by_double_property( M18_v, "high", > 3.63 ); 
  M18V363_LN_P = select_by_double_property( M18_v, "low",< -3.63 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M18V363_HP_P, M18I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M18V363_LN_P, M18I }}} );
  M18V363_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M18V363_HP_P }, output_from_layers = { M18I } );
  M18V363_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M18V363_LN_P }, output_from_layers = { M18I } );
  M18_HVN_363V = M18V363_HP or M18V363_LN;


  M18V5_HP_P = select_by_double_property( M18_v, "high", > 4.9 ); 
  M18V5_LN_P = select_by_double_property( M18_v, "low",< -4.9 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M18V5_HP_P, M18I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M18V5_LN_P, M18I }}} );
  M18V5_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M18V5_HP_P }, output_from_layers = { M18I } );
  M18V5_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M18V5_LN_P }, output_from_layers = { M18I } );
  M18_HVN_5V = M18V5_HP or M18V5_LN;


  M19V096_HP_P = select_by_double_property( M19_v, "high", > 0.96 ); 
  M19V096_LN_P = select_by_double_property( M19_v, "low",< -0.96 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M19V096_HP_P, M19I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M19V096_LN_P, M19I }}} );
  M19V096_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M19V096_HP_P }, output_from_layers = { M19I } );
  M19V096_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M19V096_LN_P }, output_from_layers = { M19I } );
  M19_HVN_096V = M19V096_HP or M19V096_LN;


  M19V132_HP_P = select_by_double_property( M19_v, "high", > 1.32 ); 
  M19V132_LN_P = select_by_double_property( M19_v, "low",< -1.32 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M19V132_HP_P, M19I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M19V132_LN_P, M19I }}} );
  M19V132_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M19V132_HP_P }, output_from_layers = { M19I } );
  M19V132_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M19V132_LN_P }, output_from_layers = { M19I } );
  M19_HVN_132V = M19V132_HP or M19V132_LN;


  M19V165_HP_P = select_by_double_property( M19_v, "high", > 1.65 ); 
  M19V165_LN_P = select_by_double_property( M19_v, "low",< -1.65 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M19V165_HP_P, M19I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M19V165_LN_P, M19I }}} );
  M19V165_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M19V165_HP_P }, output_from_layers = { M19I } );
  M19V165_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M19V165_LN_P }, output_from_layers = { M19I } );
  M19_HVN_165V = M19V165_HP or M19V165_LN;


  M19V180_HP_P = select_by_double_property( M19_v, "high", > 1.8 ); 
  M19V180_LN_P = select_by_double_property( M19_v, "low",< -1.8 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M19V180_HP_P, M19I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M19V180_LN_P, M19I }}} );
  M19V180_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M19V180_HP_P }, output_from_layers = { M19I } );
  M19V180_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M19V180_LN_P }, output_from_layers = { M19I } );
  M19_HVN_180V = M19V180_HP or M19V180_LN;


  M19V198_HP_P = select_by_double_property( M19_v, "high", > 1.98 ); 
  M19V198_LN_P = select_by_double_property( M19_v, "low",< -1.98 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M19V198_HP_P, M19I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M19V198_LN_P, M19I }}} );
  M19V198_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M19V198_HP_P }, output_from_layers = { M19I } );
  M19V198_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M19V198_LN_P }, output_from_layers = { M19I } );
  M19_HVN_198V = M19V198_HP or M19V198_LN;


  M19V25_HP_P = select_by_double_property( M19_v, "high", > 2.5 ); 
  M19V25_LN_P = select_by_double_property( M19_v, "low",< -2.5 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M19V25_HP_P, M19I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M19V25_LN_P, M19I }}} );
  M19V25_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M19V25_HP_P }, output_from_layers = { M19I } );
  M19V25_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M19V25_LN_P }, output_from_layers = { M19I } );
  M19_HVN_25V = M19V25_HP or M19V25_LN;


  M19V275_HP_P = select_by_double_property( M19_v, "high", > 2.75 ); 
  M19V275_LN_P = select_by_double_property( M19_v, "low",< -2.75 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M19V275_HP_P, M19I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M19V275_LN_P, M19I }}} );
  M19V275_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M19V275_HP_P }, output_from_layers = { M19I } );
  M19V275_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M19V275_LN_P }, output_from_layers = { M19I } );
  M19_HVN_275V = M19V275_HP or M19V275_LN;


  M19V33_HP_P = select_by_double_property( M19_v, "high", > 3.3 ); 
  M19V33_LN_P = select_by_double_property( M19_v, "low",< -3.3 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M19V33_HP_P, M19I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M19V33_LN_P, M19I }}} );
  M19V33_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M19V33_HP_P }, output_from_layers = { M19I } );
  M19V33_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M19V33_LN_P }, output_from_layers = { M19I } );
  M19_HVN_33V = M19V33_HP or M19V33_LN;


  M19V363_HP_P = select_by_double_property( M19_v, "high", > 3.63 ); 
  M19V363_LN_P = select_by_double_property( M19_v, "low",< -3.63 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M19V363_HP_P, M19I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M19V363_LN_P, M19I }}} );
  M19V363_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M19V363_HP_P }, output_from_layers = { M19I } );
  M19V363_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M19V363_LN_P }, output_from_layers = { M19I } );
  M19_HVN_363V = M19V363_HP or M19V363_LN;


  M19V5_HP_P = select_by_double_property( M19_v, "high", > 4.9 ); 
  M19V5_LN_P = select_by_double_property( M19_v, "low",< -4.9 );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M19V5_HP_P, M19I }}} );
  CONNECT_DB_DV = incremental_connect( CONNECT_DB_DV, {{{ M19V5_LN_P, M19I }}} );
  M19V5_HP   = net_select( CONNECT_DB_DV, connected_to_any = { M19V5_HP_P }, output_from_layers = { M19I } );
  M19V5_LN   = net_select( CONNECT_DB_DV, connected_to_any = { M19V5_LN_P }, output_from_layers = { M19I } );
  M19_HVN_5V = M19V5_HP or M19V5_LN;








































































#endif



//====================================================================================
// Utility - for size command
//
over_under : function (
    inlayer : polygon_layer,
    value : double
) returning result : polygon_layer {
    result = size( size(inlayer, distance = value, clip_acute = NONE), distance = -value, clip_acute = NONE); 
}
under_over : function (
    inlayer : polygon_layer,
    value : double
) returning result : polygon_layer {
    result = size( size(inlayer, distance = -value, clip_acute = NONE), distance = value, clip_acute = NONE); 
}
over_size : function (
    inlayer : polygon_layer,
    value : double
) returning result : polygon_layer {
    result = size(inlayer, distance = value, clip_acute = NONE);
}

over_size_x : published function (
    in_layer : polygon_layer,
    distance : double
)
    returning over_size_x_result : polygon_layer
{
    over_size_x_result = grow(in_layer, north = 0, south = 0, east = distance, west = distance);
}

over_size_y : published function (
    in_layer : polygon_layer,
    distance : double
)
    returning over_size_y_result : polygon_layer
{
    over_size_y_result = grow(in_layer, north = distance, south = distance, east = 0, west = 0);
}


over_size_xy : function (
    inlayer : polygon_layer,
    value_x : double,
    value_y : double
) returning result : polygon_layer {
    result = grow(inlayer, north = value_y, south = value_y, east= value_x, west= value_x);
}


over_size_x_exty : published function (
    in_layer : polygon_layer,
    distance_x : double,
    ext_y : double
)
    returning over_size_xy_result : polygon_layer
{
    over_size_xy_pre1 = angle_edge( in_layer, == 90 ); 
    over_size_xy_pre2 = edge_size(over_size_xy_pre1, outside = distance_x);
    over_size_xy_result = grow(over_size_xy_pre2, north = ext_y, south = ext_y, east = 0, west = 0);
}

over_size_y_extx : published function (
    in_layer : polygon_layer,
    distance_y : double,
    ext_x : double
)
    returning over_size_xy_result : polygon_layer
{
    over_size_xy_pre1 = angle_edge( in_layer, == 0 );
    over_size_xy_pre2 = edge_size(over_size_xy_pre1, outside = distance_y);
    over_size_xy_result = grow(over_size_xy_pre2, north = 0, south = 0, east = ext_x, west = ext_x);     	
}


over_size_x_exty_opposite : published function (
    in_layer : polygon_layer,
    distance_x : double,
    ext_y : double
)
    returning over_size_xy_result : polygon_layer
{
    over_size_xy_result = grow(in_layer, north = ext_y, south = ext_y, east = distance_x, west = distance_x);   
}

over_size_y_extx_opposite : published function (
    in_layer : polygon_layer,
    distance_y : double,
    ext_x : double
)
    returning over_size_xy_result : polygon_layer
{
    over_size_xy_result = grow(in_layer, north = distance_y, south = distance_y, east = ext_x, west = ext_x);
      	
}

//====================================================================================
shrink_x : published function (
    in_layer : polygon_layer,
    distance : double
)
    returning result : polygon_layer
{
    result = shrink(in_layer, north = 0, south = 0, east = distance, west = distance);
}

shrink_y : published function (
    in_layer : polygon_layer,
    distance : double
)
    returning result : polygon_layer
{
    result = shrink(in_layer, north = distance, south = distance, east = 0, west = 0);
}


shrink_xy : function (
    inlayer : polygon_layer,
    value_x : double,
    value_y : double
) returning result : polygon_layer {
    result = shrink(inlayer, north = value_y, south = value_y, east= value_x, west= value_x);
}


//====================================================================================
// find the max. value in a list
find_max : function (
    values : list of double = {}
) returning result : double {
    if ( values.size() > 0 ){
	result = values[0];
	if ( values.size() > 1 ){
	    foreach ( temp in values ){
		result = max(result, temp);
	    }
	}
    }else{
	error("ERROR! The input size of max_in_list should not be zero.");
    }
};

find_min : function (
    values : list of double = {}
) returning result : double {
    if ( values.size() > 0 ){
	result = values[0];
	if ( values.size() > 1 ){
	    foreach ( temp in values ){
		result = min(result, temp);
	    }
	}
    }else{
	error("ERROR! The input size of max_in_list should not be zero.");
    }
};


// -------------------------------------------------------
// Wide related commands
// -------------------------------------------------------
wide_equal : function (
    inlayer : polygon_layer,
    value : double 
) returning result : polygon_layer {
    A = wide( inlayer, > value, forty_five = INTERNAL );
    B = wide( inlayer, >= value, forty_five = INTERNAL );
    result = B not A;
}

wide_range : function (
    inlayer : polygon_layer,
    min_value : double, 
    max_value : double 
) returning result : polygon_layer {
    A = wide( inlayer, >= min_value, forty_five = INTERNAL );
    B = wide( inlayer, > max_value, forty_five = INTERNAL );
    result = A not B;
}

wide_range_max_no_eq : function (
    inlayer : polygon_layer,
    min_value : double, 
    max_value : double 
) returning result : polygon_layer {
    A = wide( inlayer, >= min_value, forty_five = INTERNAL );
    B = wide( inlayer, >= max_value, forty_five = INTERNAL );
    result = A not B;
}


//====================================================================================
// Filliable region related 
//====================================================================================
set_exclude_area : function (
    block : fill_to_signal_spacing_s 
) returning result : polygon_layer {
    inlayer = block.signal_layer;
    result = empty_layer();
    if ( block.context == EXTERIOR ) {
	result = or_list( {
	    over_size( inlayer, block.min_space ),
	    over_size_y( over_size_x( inlayer, block.min_space_x ), block.space_extension_y ) not over_size_y( inlayer, block.space_extension_y),
	    over_size_x( over_size_y( inlayer, block.min_space_y ), block.space_extension_x ) not over_size_x( inlayer, block.space_extension_x),
	});
    } elseif ( block.context == EXTERIOR_INTERIOR ) {
	oversized_block = or_list({
	    over_size( inlayer, block.min_space ),
	    over_size_xy( inlayer, block.min_space_x, block.min_space_y ),
	});
	undersized_block = shrink_xy( inlayer, find_max({block.min_space, block.min_space_x}), find_max({block.min_space, block.min_space_y}) );
	result = oversized_block not undersized_block; 
    } elseif ( block.context == INTERIOR ) {
	fillable_region = shrink_xy( inlayer, find_max({block.min_space, block.min_space_x}), find_max({block.min_space, block.min_space_y}) );
	result = chip_extent() not fillable_region;
    }
}


//====================================================================================
group_exclude_area : function (
    blocks : list of fill_to_signal_spacing_s = {}
) returning result : polygon_layer {
    result = empty_layer();
    list_blockage : list of polygon_layer = {};

    foreach ( block in blocks ) {
	list_blockage.push_back( set_exclude_area( block ) );
    }
    result = or_list( list_blockage );
};


//====================================================================================
// The function is to use signal layers' extent as the full extent

dump_fill_region : function(
    FSS : list of fill_to_signal_spacing_s = {}
) returning result : polygon_layer {
    result = unified_fill_region( FSS, { type = SIGNAL_EXTENT } );
}
dump_fss_region : function(
    FSS : list of fill_to_signal_spacing_s = {}
) returning result : polygon_layer {
    region = unified_fill_region( FSS, { type = SIGNAL_EXTENT } );
    result = layer_extent(region) not region;
}

//====================================================================================
// Density function for Mz
chk_density_global : function (void) returning void
{
   areaL1 = den_polygon_area("layer1", clip = _den_polygon_area_clip);
   areaL2 = den_polygon_area("layer2", clip = _den_polygon_area_clip);
   
   ratio = areaL1 / areaL2;

   if (double_constraint_overlap(_den_con, ratio) && !isinf(ratio) && !isnan(ratio)) {
//       if (!_den_print_only) {
           den_save_window(error_names = { "ratio", "areaL1", "areaL2" },
                           values      = { ratio, areaL1, areaL2 }
           );
//       }
   
       if (_den_print || _den_print_only) {
           den_window_statistics(
               which_file  = 0,
               error_names = { "ratio", "areaL1", "areaL2" },
               values      = { ratio, areaL1, areaL2 }
           );
       }
   }
}
post_drc_projection_corner : UNIFIED_FILL_PUBLISHED function(
fill : polygon_layer,
fill_to_signal : list of fill_to_signal_spacing_s
) returning new_fills : polygon_layer
{
corner_violation = empty_layer_edge();
foreach (fss in fill_to_signal) {
if (fss.projection == CORNER) {
ext_x = max(fss.space_extension_x, fss.min_space_x);
ext_y = max(fss.space_extension_y, fss.min_space_y);
min_x = fss.min_space_x;
min_y = fss.min_space_y;
if (dblgt(min_y, 0.0) && dblgt(ext_x, 0.0)) {
ext_x_min_y_vio_edge = external2_edge(fill, fss.signal_layer, < ext_x, extension = RECTANGLE, extension_distance = min_y, projection = {ON, OUT}, direction = HORIZONTAL, output_layer = LAYER1, extension_look_past = POINT_TO_POINT );
min_y_ext_x_vio_edge = external2_edge(fill, fss.signal_layer, < min_y, extension = RECTANGLE, extension_distance = ext_x, projection = {ON, OUT}, direction = VERTICAL, output_layer = LAYER1, extension_look_past = POINT_TO_POINT );
corner_violation = corner_violation or_edge ext_x_min_y_vio_edge or_edge min_y_ext_x_vio_edge;
}
if (dblgt(min_x, 0.0) && dblgt(ext_y, 0.0)) {
ext_y_min_x_vio_edge = external2_edge(fill, fss.signal_layer, < ext_y, extension = RECTANGLE, extension_distance = min_x, projection = {ON, OUT}, direction = VERTICAL, output_layer = LAYER1, extension_look_past = POINT_TO_POINT );
min_x_ext_y_vio_edge = external2_edge(fill, fss.signal_layer, < min_x, extension = RECTANGLE, extension_distance = ext_y, projection = {ON, OUT}, direction = HORIZONTAL, output_layer = LAYER1, extension_look_past = POINT_TO_POINT );
corner_violation = corner_violation or_edge ext_y_min_x_vio_edge or_edge min_x_ext_y_vio_edge;
}
} 
}
new_fills = not_interacting(fill, corner_violation, include_touch = EDGE);
}

/* 

= unified_fill(
	fill_patterns = {

    },
	fill_boundary = {
	    layer = CHIP_snps,
	    type = LAYER,
	},
    boundary = ALIGN,
	grid = vGRID
);



*/

get_single_polygon_pattern : function (
    cell_prefix : string = "",
    output : string = "",
    width : double = 1,
    height : double = 1,
    step_x : double = 0,
    step_y : double = 0,
    offset_x : double = 0,
    offset_y : double = 0, 
    setback : double = -1,
    setback_type : fill_extension_e = INTERSECTION,
    FSS : list of fill_to_signal_spacing_s = {},
    repeat : integer = 3,
    shift : integer = 2,
    starting_point : starting_point_e  = CENTER
) returning result : uf_fill_pattern_s {

    setback_x : double = -1; 
    setback_y : double = -1;
    if ( setback < 0 ){
        setback_x = step_x;
        setback_y = step_y; 
    }else{
        setback_x = setback;
        setback_y = setback; 
    }


    result = {
        type = UF_POLYGON,
        polygon_fill = {
            pattern_spec = {
                space_x = step_x,
                space_y = step_y,
                stagger_x = offset_x,
                stagger_y = offset_y,
                pattern_spacing = {
                    allowed_spacing_x = { >= setback_x },
                    allowed_spacing_y = { >= setback_y },
                    extension = setback_type,
                },
            },
            insertion = {
                starting_point = starting_point,
                iterations = repeat,
                shift_factor = shift,
            },
            layers = {
                {
                    layer_spec = { output_layer_key = output },
                    polygons = { {{0,0}, {width, height} } },
                },
            },
            fill_to_signal_spacing = FSS,
            //cell_prefix = CELL_PREFIX + cell_prefix
            cell_prefix = cell_prefix
        },
    };

}
/*
.polygon_fill.pattern_spec.other_pattern_spacing = {
    1 => ,
};


*/




get_uf_patterns_polygon : function (
    cell_prefix : string = "",
    hash_name : string = "",
    width : double = 0,
    height : double = 0,
    step_x : double = 0,
    step_y : double = 0,
    setback : double = 0,
    setback_type : fill_extension_e = INTERSECTION,
    fss : list of fill_to_signal_spacing_s = {},
    repeat : integer = 2,
    shift : integer = 1,
    starting_point : starting_point_e = CENTER
) returning result : list of uf_fill_pattern_s {
    result = {
        {
            type = UF_POLYGON,
            polygon_fill = {
                pattern_spec = {
                    space_x = step_x,
                    space_y = step_y,
                    pattern_spacing = {
                        allowed_spacing_x = { >= setback },
                        allowed_spacing_y = { >= setback },
                        extension = setback_type,
                    },
                },
                insertion = {
                    starting_point = starting_point,
                    iterations = repeat,
                    shift_factor = shift,
                },
                layers = {
                    {
                        layer_spec = { output_layer_key = hash_name },
                        polygons = { {{0,0}, {width, height} } },
                    },
                },
                fill_to_signal_spacing = fss,
                //cell_prefix = CELL_PREFIX + cell_prefix
                cell_prefix = cell_prefix
            },
        }        
    };

}//end of get_uf_patterns_polygon






adj_type_e : newtype enum of {
    GROW,
    SHRINK
};

//Defualt does not have color setting & dpt_spacing
get_single_adjustable_pattern : function (
    adj_type : adj_type_e = SHRINK,
    min_bound : coordinate_s = {0,0},
    max_bound : coordinate_s = {0,0},
    color : boolean = false,
    color_scheme : fill_color_scheme_e = UF_LINE_SIDE,
    valid_widths : list of constraint of double = {},
    valid_heights : list of constraint of double = {},
    cell_prefix : string = "",
    output : string = "", //hash_key
    spacing : coordinate_s = {0,0},
    FSS : list of fill_to_signal_spacing_s = {},
    shift : integer = 2,
    repeat : integer = 3,
    starting_point : starting_point_e = CENTER
) returning result : uf_fill_pattern_s {
    min_width : double;
    max_width : double;
    min_height : double;
    max_height : double;

    result = {
        type = UF_ADJUSTABLE,
        adjustable_fill = {
            pattern_spec = {
                space_x = spacing.x,
                space_y = spacing.y,
            },
            layer_spec = {
                output_layer_key = output,
                fill_to_signal_spacing = FSS,
            },
            width = 0,
            height = 0,
            width_bound = 0,
            height_bound = 0,
            width_delta = vGRID,
            height_delta = vGRID,
            valid_widths = valid_widths,
            valid_heights = valid_heights,
            //rotation : cell_rotation_e = ROTATE_0;
            insertion = {
                starting_point = starting_point,
                shift_factor = shift,
                iterations = repeat,
            },
            cell_prefix = cell_prefix,
            color = true,
            color_scheme = color_scheme, //UF_LINE_END, UF_LINE_SIDE, UF_CHECKERED
            //dpt_spacing : dpt_spacing_s = {};
            density_optimization = TOUCH_BOUNDARY,
        }
    };
    if ( adj_type == SHRINK ){
        result.adjustable_fill.width = max_bound.x;
        result.adjustable_fill.height = max_bound.y;
        result.adjustable_fill.width_bound = min_bound.x;
        result.adjustable_fill.height_bound = min_bound.y;
    }else{ //grow
        result.adjustable_fill.width = min_bound.x;
        result.adjustable_fill.height = min_bound.y;
        result.adjustable_fill.width_bound = max_bound.x;
        result.adjustable_fill.height_bound = max_bound.y;
    }

}; //end of single adjustable fill
/*
.adjustable_fill.pattern_spec.other_pattern_spacing = {
    1 => DMX2OR_DMX_O_X
};

.adjustable_fill.dpt_spacing = {
    dpt_space_x = ,
    dpt_space_y = ,
    dpt_space_extension = INTERSECTION,
};

.adjustable_fill.pattern_spec.pattern_spacing = {
    allowed_spacing_x = { >= DMY1OR_SXA2 },
    allowed_spacing_y = { >= DMY1OR_SY },
    extension = INTERSECTION
};
*/


//defualt : with color
//consider only fixed height (valid_widths/valid_heights are on in ICV 2019.12 ) 
tmp_layer = empty_layer();
get_single_linear_pattern : function (
	FSS : list of fill_to_signal_spacing_s,
    colored_layers : list of colored_layer_s,
	minlength : double = 0, //signal's min. length
	output : string = "UFOUTPUT",
	direction : ring_direction_e = HORIZONTAL,
    cell_prefix : string = "",
    height_min : double = 0,
    height_max : double = 0,
    width_min : double = 0,
    width_max : double = 0,
    same_x : double = 0,
    same_y : double = 0,
    diff_x : double = 0,
    diff_y : double = 0,
   	rings : integer = 1,
    size_type : adj_type_e = SHRINK
) returning result : uf_fill_pattern_s {
    result = {
        type = UF_POLYGON,
        polygon_fill = {
            layers = {
                {
                    layer_spec = {
                        output_layer_key = output,
                        fill_to_signal_spacing = FSS,
                    },
                    polygons = {
                        { {0.0, 0.0}, {1.0, 1.0} } //set later
                    }
                }
            },
            fill_context = LINEAR_CONTEXT,
            color = true,
            num_colors = 2,
            signal_linear = {
                ring_count = rings,
                use_fill_to_signal_spacing = true,
                output = SIGNAL_SIDE,
                signal_min_length = minlength,
                //colored_layers = colored_layers,
                colored_layers = {
                    { tmp_layer, COLOR_1 },
                    { tmp_layer, COLOR_2 },    
                },
                direction = direction,
                adjustable_width_bound = 0.0, //set later
            },
            pattern_spec = {
                space_x = 0.0,
                space_y = 0.0,
				/* Set by request
                pattern_spacing = {
                    delta_projection_spec = { min_space = 0.03, min_length = 0.04 },
                },
				*/
            },
            dpt_spacing = {
                dpt_space_x = 0.0,
                dpt_space_y = 0.0,
                dpt_space_extension = INTERSECTION,
            },
        }, //end of polygon_fill
    };//end of result

    result.polygon_fill.signal_linear.colored_layers = colored_layers;
    result.polygon_fill.signal_linear.adjustable_height_bound = height_max;
	if ( size_type == SHRINK ){
		result.polygon_fill.layers[0].polygons = {
			{ {0,0}, {width_max, height_min} },	
		};
		result.polygon_fill.signal_linear.adjustable_width_bound = width_min;
	}else{ // GROW
		result.polygon_fill.layers[0].polygons = {
			{ {0,0}, {width_min, height_min} },	
		};
		result.polygon_fill.signal_linear.adjustable_width_bound = width_max;
	}

    //follow TSMC's setting 
    if ( direction == VERTICAL ){
        result.polygon_fill.pattern_spec.space_x = diff_y;
        result.polygon_fill.pattern_spec.space_y = diff_x;
        result.polygon_fill.dpt_spacing.dpt_space_x = same_y;
        result.polygon_fill.dpt_spacing.dpt_space_y = same_x;
    }else{
        result.polygon_fill.pattern_spec.space_x = diff_x;
        result.polygon_fill.pattern_spec.space_y = diff_y;
        result.polygon_fill.dpt_spacing.dpt_space_x = same_x;
        result.polygon_fill.dpt_spacing.dpt_space_y = same_y;
    }

}//end of get_single_linear_pattern



CENTER_BAR_VALUE : double = 0.0;
#define dblnp(value) (((value) > 0.0) ? 0.0 : 1.0)
dfm_property_func_DV : function (void) returning void
{
    primary_data = df_get_current_data();
    elayer2_set = df_edge_layer(primary_data, "layer2");
    lengthL2 = df_edge_sum_length(elayer2_set);

    METAL_W = (((lengthL2/2)-CENTER_BAR_VALUE)/2); 

    if (!(isinf(METAL_W) || isnan(METAL_W))) { 
        df_save_double_property(primary_data, "Metal_W", METAL_W); 
        df_save_data(primary_data);
    }
}



//projection corner checking
chk_projection_corner : function (
    signal : polygon_layer,
    fill_list : list of polygon_layer = {},
    spacing_value : double = 0.0,
    extension_value : double = 0.0
) returning result : polygon_layer {
    ori_fill = or_list( fill_list );
	result1 = external2(signal, ori_fill, < spacing_value, extension = EDGE, extension_distance = extension_value, look_thru = NOT_ADJACENT, edge_containment = OUTSIDE, intersecting = { }, extension_look_past = POINT_TO_POINT, corner_configuration = CORNER_TO_CORNER_OR_EDGE );
	result2 = external2(signal, ori_fill, < spacing_value, extension = EDGE, extension_distance = extension_value, look_thru = NOT_ADJACENT, edge_containment = OUTSIDE, intersecting = { }, extension_look_past = POINT_TO_POINT,  projection = { ON } );
	result3 = external2(signal, ori_fill, < extension_value, extension = EDGE, extension_distance = spacing_value, look_thru = NOT_ADJACENT, edge_containment = OUTSIDE, intersecting = { }, extension_look_past = POINT_TO_POINT,  projection = { ON } );

	result4 = external2(signal, ori_fill, < spacing_value, extension = EDGE, extension_distance = extension_value, corner_configuration = CORNER_TO_CORNER_INCLUSIVE, extension_look_past = POINT_TO_POINT );
	result5 = external2(signal, ori_fill, < extension_value, extension = EDGE, extension_distance = spacing_value, corner_configuration = CORNER_TO_CORNER_INCLUSIVE, extension_look_past = POINT_TO_POINT );

    result = result4 or result5;

}

chk_DMx1_spacing : function (
    fills : polygon_layer,
    spacing : double,
    extension : double,
    fill_dir : direction_e
) returning result : polygon_layer {
    if ( fill_dir == VERTICAL ){
        result = external1( fills, < spacing, extension = EDGE, intersecting = {  } , intersection_angle = < 90, look_thru = NOT_ADJACENT, extension_distance = extension, extension_look_past = POINT_TO_POINT, direction = HORIZONTAL, orthogonal = BOTH);

    }elseif ( fill_dir == HORIZONTAL ){
        result = external1( fills, < spacing, extension = EDGE, intersecting = {  } , intersection_angle = < 90, look_thru = NOT_ADJACENT, extension_distance = extension, extension_look_past = POINT_TO_POINT, direction = VERTICAL, orthogonal = BOTH);

    }else{
        result = empty_layer();
    }
}

fix_corner_fill2signal : function (
    signal : polygon_layer,
    fill : polygon_layer,
    spacing_value : double = 0.0,
    extension_value : double = 0.0,
    width : double = 0.0,
    min_length : double = 0.0
) returning result : polygon_layer {
    ori_fill = fill;
	err_PPP = external2(signal, ori_fill, < spacing_value, extension = RADIAL, projection = {ON}, look_thru = NOT_ADJACENT, intersecting = { }, extension_look_past = POINT_TO_POINT ); //PPP case
    to_remove = edge_size( adjacent_edge( ori_fill interacting err_PPP, angle2 = == 90, length = == width, angle1 = == 90 ), inside = spacing_value + vGRID) interacting err_PPP;

    new_fill = rectangles( fill not to_remove, sides = { == width, >= min_length } );

    errors = external2(signal, ori_fill, < spacing_value, extension = EDGE, projection = {OUT, ON}, extension_distance = extension_value, look_thru = NOT_ADJACENT, intersecting = { }, extension_look_past = POINT_TO_POINT, corner_configuration = CORNER_TO_CORNER_OR_EDGE  ); 

    good_fill = new_fill not_interacting errors;
    bad_fill = ori_fill interacting errors;
    bad_fill_edge = bad_fill not_coincident_edge errors;
    fixed_fill_pre = internal1( bad_fill_edge, == width, extension = NONE, direction = ORTHOGONAL );
    fixed_fill = rectangles( fixed_fill_pre, sides = { == width, >= min_length } );

    fixed_fill = fixed_fill interacting new_fill;
    result = fixed_fill or good_fill;
} 


fix_FSS_C2C : function (
    fill : polygon_layer,
    width : double,
    height : double,
    C2C_list : list of fill_to_signal_spacing_s = {}
) returning result : polygon_layer {
    foreach (c2c in C2C_list){
        signal = c2c.signal_layer;
        spacing_value = find_max( {c2c.min_space_x, c2c.min_space_y } );
        extension_value = find_max( {c2c.space_extension_x, c2c.space_extension_y } );
        fill = fix_corner_fill2signal( signal, fill, spacing_value, extension_value, width, height );  
    }
    result = fill;
}


chk_FSS_C2C : function (
    fill : polygon_layer,
    color : color_aware_to_fill_e = ALL,
    C2C_list : list of fill_to_signal_spacing_s = {}
) returning result : polygon_layer {

    result = empty_layer();

    foreach (c2c in C2C_list){
        if ( c2c.color_aware_to_fill == color ){
            signal = c2c.signal_layer;
            spacing_value = find_max( {c2c.min_space_x, c2c.min_space_y } );
            extension_value = find_max( {c2c.space_extension_x, c2c.space_extension_y } );
            result = result or external2(signal, fill, < spacing_value, extension = EDGE, extension_distance = extension_value, corner_configuration = CORNER_TO_CORNER_INCLUSIVE, extension_look_past = POINT_TO_POINT );
        }
    }

}


// Remove fills interacting the errors of fill to fill (multiple forbidden spcing)
// this is only for projection checking
//    allowed_spacing = { == 0.02, == 0.062, >= 0.083  },
fix_M3_S_31 : function (
    fills : polygon_layer,
    fill_dir : direction_e = VERTICAL
) returning result : polygon_layer {
    ERR : list of polygon_layer = {};
    if ( fill_dir == VERTICAL ){
        ERR.push_back( external1( fills, < 0.0200,          direction = HORIZONTAL, extension = NONE ) );
        ERR.push_back( external1( fills,  (0.0200, 0.062),  direction = HORIZONTAL, extension = NONE ) );
        ERR.push_back( external1( fills,  (0.0620, 0.0830), direction = HORIZONTAL, extension = NONE ) );
    }else{
        ERR.push_back( external1( fills, < 0.0200,          direction = VERTICAL, extension = NONE ) );
        ERR.push_back( external1( fills,  (0.0200, 0.062),  direction = VERTICAL, extension = NONE ) );
        ERR.push_back( external1( fills,  (0.0620, 0.0830), direction = VERTICAL, extension = NONE ) );
    }

    result = fills not_interacting or_list( ERR );

}













































































































































//******************************************************************************
//      SPECIFICATION
//******************************************************************************


//***** special ****************************************************************
INDDMY_BUFFER_RANGE : const double = 19.8;
ISLAND_SPACE : const double = 0.6;	
LINEEND_RET : const double = 0.65;	

//***** blockage ***************************************************************
DM_BEOLBLK : const double = 0.144;
DM_INDDMY : const double = 0;
DM_DMXEXCL : const double = 0.144;
DM_TCDDMY_MX : const double = 0.21;
DM_CTMFINAL_VIA : const double = 0.1;
DV_DVXEXCL : const double = 0.144;
DV_TCDDMY_VX : const double = 0.5;

//***** DMx1  (DM0/DM1/DMxa) ********************************************************************
DMX1B_W : const double = 0.06;	
DMX1B_L : const double = 0.580;	
DMX1B_SX : const double = 0.04;	
DMX1B_SY : const double = 0.07;	
DMX1B_MX : const double = 4.1;	
DMX1B_DMX_O : const double = 0.07;	
DMX1B_DMX : const double = 0.07;	
DMX1OW_W : const double = 0.080;	
DMX1OW_W_MAX : const double = 0.5;	
DMX1OW_L : const double = 0.060;	// DMn.A.1.1/DMn.W.1.1
DMX1OW_SX : const double = 0.07;	
DMX1OW_SY : const double = 0.06;	
DMX1OW_MX : const double = 0.07;	
DMX1OW_DMX_O : const double = 0.07;	
DMX1OW_DMX : const double = 0.07;	
DMX1OW_DC_MXX : const double = 0.07;	//re-check
DMX1OW_DC_MXY : const double = 0.07;	//re-check
DMX1OW_SC_MXX : const double = 0.07;	//re-check
DMX1OW_SC_MXY : const double = 0.07;	//re-check
DMX1OW_SC_W16 : const double = 0.088;	
DM1OW_FB9M1CBX : const double = 0.1;	
DM1OW_FB9M1CBY : const double = 0.07;	
DMX1OW2_W : const double = 0.042;	
DMX1OW2_L : const double = 0.042;	
DMX1OW2_SX : const double = 0.03;	
DMX1OW2_SY : const double = 0.06;	
DMX1OW2_MX : const double = 0.07;	
DMX1OW2_DMX_OX : const double = 0.07;	
DMX1OW2_DMX_OY : const double = 0.07;	
DMX1OW2_DMX : const double = 0.07;	
DMX1OW2_S_M016 : const double = 0.088;	//re-check
DMX1OW2_DC_MXX : const double = 0.06;	//re-check
DMX1OW2_DC_MXY : const double = 0.07;	//re-check
DMX1OW2_SC_MXX : const double = 0.06;	//re-check
DMX1OW2_SC_MXY : const double = 0.07;	//re-check
DMX1OW2_SC_W16 : const double = 0.06;	

DM1OW2_SX : const double = 0.06;	
DM1OW2_SY : const double = 0.06;	
DMXAOW2_SX : const double = 0.03;	
DMXAOW2_SY : const double = 0.06;	
DMX1OW2_DMX_O : const double = 0.07;	
DMX1OR_W : const double = 0.020;	
DMX1OR_W_MAX : const double = 0.028;	
DMX1OR_L_MAX : const double = 0.5;	
DMX1OR_L : const double = 0.140;	
DMXOR_L : const double = 0.150;
DM0OR_SX_SC : const double = 0.039;	
DMXOR_SX_SC : const double = 0.041;	
DMX1OR_SX_SC : const double = 0.045;	
DMX1OR_SX_DC : const double = 0.018;	
DMX1OR_SY_SC : const double = 0.07;	
DMX1OR_SY_DC : const double = 0.07;	
DMX1OR_SX : const double = DMX1OR_SX_DC;	
DMX1OR_SY : const double = DMX1OR_SY_SC;	
DMX1OR_DC_MXX : const double = 0.03;	
DMX1OR_DC_MXY : const double = 0.070;	

DM0OR_SC_MXX : const double = 0.039;	
DM1OR_SC_MXX : const double = 0.045;	
DMX1OR_SC_MXX : const double = 0.041;	

DMX1OR_SC_MXY : const double = 0.070;	

DM0O_ALLSTD : const double = 0.03;	

DMX1OR_275V_MXY : const double = 0.07;	
DMX1OR_DMX_O : const double = 0.07;	
DM0OR_DMX_OX : const double = 0.039;	
DM0OR_DMX_OY : const double = 0.07;	
DM1OR_DMX_OX : const double = 0.045;	
DM1OR_DMX_OY : const double = 0.07;	
DMX1OR_DMX_OX : const double = 0.041;	
DMX1OR_DMX_OY : const double = 0.07;	
DMX1OR_DMX : const double = 0.07;	
DMX1OR_W_P48 : const double = 0.028;	
DMX1OR_L_MAX_P48 : const double = 0.5;	
DMX1OR_L_P48 : const double = 0.150;	
DMX1OR_SX_SC_P48 : const double = 0.026;	
DMX1OR_SY_SC_P48 : const double = 0.07;	
DMX1OR_SC_MXX_P48 : const double = 0.04;	
DMX1OR_SC_MXY_P48 : const double = 0.070;	
DMX1OR_DMX_O_P48 : const double = 0.07;	
DMX1OR_DMX_P48 : const double = 0.07;	

DMX1_CHIP : const double = DMX1B_MX;	
DMX1O_CHIP : const double = 0.070;	
DMX1O_CHIPR : const double = 0.070;	
DMX1O_CHIPE : const double = 0.070;	
DM0O_CHIPR : const double = 0.078;	
DM0O_CHIPE : const double = 0.070;	
DM0_BEOLBLKR : const double = 0.078;	
DM0_DMXEXCLR : const double = 0.078;	
DMX1_BEOLBLKR : const double = 0.070;	
DMX1_DMXEXCLR : const double = 0.070;	
DMX1_BEOLBLKE : const double = 0.070;	
DMX1_DMXEXCLE : const double = 0.070;	
DMX1_TCDDMY_MX : const double = 0.1;	
MX1HOLE : const double = 0.109;	

DM0_DC_LEW16 : const double = 0.062;	

DMX1_DC_W405 : const double = 0.04;	
DMX1_DC_W160 : const double = 0.07;	


DM0_SC_LEW16 : const double = 0.088;	

DMX1_SC_W285 : const double = 0.046;	
DMX1_SC_W405 : const double = 0.06;	

DMX1_SC_W160 : const double = 0.07;	

DMX1_DMW091 : const double = 0.07;	

DMX1_MX45 : const double = 0.181;	
DMX1_MX096V : const double = 0.042;	
DM1_MX096V : const double = 0.045;	
DMX1_MX132V : const double = 0.048;	
DMX1_MX165V : const double = 0.051;	
DMX1_MX198V : const double = 0.061;	
DMX1_MX275V : const double = 0.069;	
DMX1_VX096V : const double = 0.045;	
DMX1_VX132V : const double = 0.057;	
DMX1_VX165V : const double = 0.060;	
DMX1_VX198V : const double = 0.074;	
DMX1_VX275V : const double = 0.074;	
DMX1_ICOVL : const double = 0.1;	
DMX1_SRM_OUT : const double = 0.05;
DMX1_SRM_IN : const double = 0.035;	
DMX1_O_SRMJUMP : const double = 0.07;	
DMX1_SRMJUMP : const double = 2;	
DMX1_UDBF : const double = 0.1;	
M0_CUT : const double = 0.0505;	
M1_CUT : const double = 0.050;	
ISLAND_SPACE_MX1 : const double = 1;	
DM0_STD : const double = 0.030;	
CM0CELLTOM0 : const double = 1.5;	
CM0CELLTODM0 : const double = 0.5;	
CM1CELLTOM1 : const double = 1.5;	
CM1CELLTODM1 : const double = 0.5;	
CMCELLTOSTD : const double = 0.108;	
DM0_VD2 : const double = 0.082;	

//***** DMx2  (DMxb/DMxc) ********************************************************************
DMX2B_W : const double = 0.06;	
DMX2B_L : const double = 0.580;	
DMX2B_SX : const double = 0.06;	
DMX2B_SY : const double = 0.07;	
DMX2B_MX : const double = 4.1;	
DMX2B_DMX_O_X : const double = 0.083;	
DMX2B_DMX_O_Y : const double = 0.07;	
DMX2B_DMX_X : const double = 0.06;	
DMX2B_DMX_Y : const double = 0.07;	
DMX2B_DMW91 : const double = 0.07;	
DMX2OW_W : const double = 0.090;	
DMX2OW_W_MAX : const double = 0.5;	
DMX2OW_L : const double = 0.060;	// DMn.A.1.1/DMn.W.1.1
DMX2OW_SX : const double = 0.07;	
DMX2OW_SY : const double = 0.07;	
DMX2OW_MX : const double = 0.07;	
DMX2OW_DMX_O_X : const double = 0.083;	
DMX2OW_DMX_O_Y : const double = 0.07;	
DMX2OW_DMX : const double = 0.07;	
DMX2OW_SC_MXX : const double = 0.084;	//re-check
DMX2OW_SC_MXY : const double = 0.07;	//re-check
DMX2OW_SC_GE22 : const double = 0.084;	//re-check
DMX2OW_SC_LT22 : const double = 0.143;	//re-check

DMX2OR_W : const double = 0.022;	
DMX2OR_L_MAX : const double = 0.400;	
DMX2OR_L_MAX_BOUND : const double = 0.620;	
DMX2OR_L : const double = 0.160;	
DMX2OR_SX_SC : const double = 0.083;
DMX2OR_SY_SC : const double = 0.07;	
DMX2OR_SX : const double = DMX2OR_SX_SC;	
DMX2OR_SY : const double = DMX2OR_SY_SC;	


DMX2OR_SC_MXX : const double = 0.087;	
DMX2OR_SC_MXY : const double = 0.090;	
DMX2OR_SC_GE100_SX : const double = 0.139;	
DMX2OR_SC_GE100_SY : const double = 0.090;	
DMX2OR_DMX_O_X : const double = 0.083;	
DMX2OR_DMX_O_Y : const double = 0.07;	
DMX2OR_DMX_X : const double = 0.083;	
DMX2OR_DMX_Y : const double = 0.07;	
DMX2_DMW091 : const double = 0.07;	

DMX2_CHIP : const double = DMX2B_MX;	
DMX2O_CHIP : const double = 0.07;	
DMX2O_CHIPR : const double = 0.044;	
DMX2O_CHIPE : const double = 0.090;	
DMX2_BEOLBLKR : const double = 0.044;	
DMX2_BEOLBLKE : const double = 0.090;	
DMX2_DMXEXCLR : const double = 0.044;	
DMX2_DMXEXCLE : const double = 0.090;	
DMX2_TCDDMY_MX : const double = 0.1;	
MX2HOLE : const double = 0.109;	
DMX2_MX45 : const double = 0.251;	
DMX2_MX096V : const double = 0.042;	
DMX2_MX132V : const double = 0.048;	
DMX2_MX165V : const double = 0.051;	
DMX2_MX198V : const double = 0.061;	
DMX2_MX275V : const double = 0.069;	
DMX2_VX096V : const double = 0.045;	
DMX2_VX132V : const double = 0.057;	
DMX2_VX165V : const double = 0.060;	
DMX2_VX198V : const double = 0.074;	
DMX2_VX275V : const double = 0.074;	
DMX2_ICOVL : const double = 0.1;	
DMX2_SRM : const double = 0.016;	
ISLAND_SPACE_MX2 : const double = 1;	

//***** DMx3 (DMxd) ********************************************************************
DMX3B_W : const double = 0.106;	// DMn.W.1
DMX3B_L : const double = 1.16;	//
DMX3B_SX : const double = 0.076;	// DMn.S.1
DMX3B_SY : const double = 0.12;	//
DMX3B_MX : const double = 2.8;	//
DMX3B_DMXO : const double = 0.16;	
DMX3B_DMX : const double = 0.13;	
DMX3B_CHIP : const double = DMX3B_MX;	
DMX3OW_W : const double = 0.1;	// Mx.W.1.1,DMn.W.1.1
DMX3OW_L : const double = 0.08;	// DMn.A.1.1/DMn.W.1.1
DMX3AWCHIP : const double = 0.144;	// M1.S.5.2,Mx.S.6.2,Mxa.S.6.2
DMX3OW_SX : const double = 0.076;	// Mx.S.4,DMn.S.1.1
DMX3OW_SY : const double = 0.130;	// DMn.S.1.1
DMX3OW_OX : const double = 0.176;	//
DMX3OW_OY : const double = 0;	
DMX3OW_MX : const double = 0.13;	
DMX3OW_DMX : const double = 0.16;	// DMn.S.2.2
DMX3OW_SC_DMXO : const double = 0.13;	
DMX3OW_SC_DMX : const double = 0.16;	
DMX3OR_W : const double = 0.04;	// Mx.W.1.1,DMn.W.1.1
DMX3OR_L_MAX : const double = 1.036;	
DMX3OR_L : const double = 0.26;	// DMn.A.1.1/DMn.W.1.1
DMX3OR_SX_SC : const double = 0.128;	// Mx.S.4,DMn.S.1.1
DMX3OR_SX_DC : const double = 0.044;	// Mx.S.4,DMn.S.1.1
DMX3OR_SY_SC : const double = 0.128;	// DMn.S.1.1
DMX3OR_SY_DC : const double = 0.128;	// DMn.S.1.1
DMX3OR_SX : const double = 0.044;	// Mx.S.4,DMn.S.1.1
DMX3OR_SY : const double = 0.128;	// DMn.S.1.1
DMX3OR_OX : const double = 0;	//
DMX3OR_OY : const double = DMX3OR_L + DMX3OR_SY;	//
DMX3OR_MX : const double = 0.070;	// DMn.S.2.1,DMn.S.2.4
DMX3OR_DMXO : const double = 0.044;	// DMn.S.1.1
DMX3OR_DMX : const double = 0.16;	// DMn.S.2.2
DMX3OR_SC_MX : const double = 0.100;	// DMn.S.2.1,DMn.S.2.4
DMX3OR_SC_DMXO : const double = 0.128;	// DMn.S.1.1
DMX3OR_SC_DMX : const double = 0.16;	// DMn.S.2.2

DMX3_PRBOUNDARY : const double = 2;	
DMX3O_PRBOUNDARY : const double = 0.144;	
DMX3_CHIP : const double = 2;	
DMX3O_CHIP : const double = 0.25;	
MX3HOLE : const double = 0.109;	
DMX3_DC_W20 : const double = 0.07;	
DMX3_DC_W245 : const double = 0.09;	//
DMX3_DC_W60 : const double = 0.100;	//
DMX3_DC_W100 : const double = 0.100;	//
DMX3_DC_W140 : const double = 0.16;	//
DMX3_DC_W180 : const double = 0.18;	//
DMX3_DC_W260 : const double = 0.26;	//
DMX3_SC_W20 : const double = 0.10;	//
DMX3_SC_W245 : const double = 0.13;	//
DMX3_SC_W60 : const double = 0.13;	//
DMX3_SC_W100 : const double = 0.14;	//
DMX3_SC_W140 : const double = 0.16;	//
DMX3_SC_W180 : const double = 0.18;	//
DMX3_SC_W260 : const double = 0.26;	//
DMX3_MX45 : const double = 0.41;	
DMX3_MX180V : const double = 0.115;	
MX3RTOR_G0 : const double = 0.128;	
MX3CORNER : const double = DMX3_DC_W20;	
MX3_SC_END_PRL : const double = DMX3_SC_W20;	
MX3_END_END : const double = 0.128;	
MX3_SC_END_END : const double = 0.128;	
DMX3_ICOVL : const double = 0.2;


//***** DMy1 (DMya/DMy) ********************************************************************
DMY1B_W : const double = 0.106;	// DMn.W.1
DMY1B_L : const double = 1.16;	//
DMY1B_SX : const double = 0.106;	// DMn.S.1
DMY1B_SY : const double = 0.114;	//
DMY1B_OX : const double = 0;	//
DMY1B_OY : const double = 0;	//
DMY1B_MY1 : const double = 1.8;	//
DMY1B_DMY1O : const double = 0.18;	// DMn.S.2.2
DMY1B_DMY1 : const double = 0.106;	// DMn.S.1
DMY1B_CHIP : const double = 2.001;	//

DMY1S_W : const double = 0.108;	// DMn.A.1/DMy1S_L
DMY1S_L : const double = 0.45;	// DMn.A.1/DMy1S_W
DMY1S_SX : const double = 0.108;	//
DMY1S_SY : const double = 0.108;	//
DMY1S_OX : const double = 0.027;	//
DMY1S_OY : const double = 0.019;	//
DMY1S_MY1 : const double = 1;	// DMn.S.2
DMY1S_DMY1O : const double = 0.18;	// DMn.S.2.2
DMY1S_DMY1 : const double = 0.108;	//
DMY1S_CHIP : const double = 2.001;	//

DMY1OR_W : const double = 0.058;	// My1.W.1.1,DMn.W.1.1
DMY1OR_L : const double = 0.280;	// DMn.A.1.1/DMn.W.1.1
DMY1OR_SX : const double = 0.076;	// My1.S.4,DMn.S.1.1
DMY1OR_SXA1 : const double = 0.076;	// My1.S.4
DMY1OR_SXA2 : const double = 0.114;	// My1.S.4
DMY1OR_SY : const double = 0.114;	// DMn.S.1.1
DMY1OR_SC : const double = 0.114;	// 
DMY1OR_OX : const double = 0;	//
DMY1OR_OY : const double = 0;	//
DMY1OR_MY1 : const double = 0.12;	// DMn.S.2.1,DMn.S.2.4
DMY1OR_DMY1O : const double = 0.114;	// DMn.S.1.1
DMY1OR_DMY1 : const double = 0.180;	// DMn.S.2.2

DMY1OW_W : const double = 0.190;	// My1.W.1.2,DMn.W.1.1
DMY1OW_L : const double = 0.114;	//
DMY1OW_SX : const double = 0.114;	// DMn.S.1.1
DMY1OW_SY : const double = 0.114;	//
DMY1OW_OX : const double = 0;	//
DMY1OW_OY : const double = 0;	//
DMY1OW_MY1 : const double = 0.14;	// DMn.S.2.1,DMn.S.2.4->My1.S.14
DMY1OW_DMY1O : const double = 0.114;	// DMn.S.1.1
DMY1OW_DMY1 : const double = 0.18;	// DMn.S.2.2

DMY1_CHIP : const double = 0.144;	// M1.S.5.2,Mx.S.6.2,Mxa.S.6.2
MY1HOLE : const double = 0.218;	// My1.A.4+2*DMn.W.1.1*DMn.A.1.1/DMn.W.1.1
MY1W1 : const double = 0.076;	// My1.S.14
DMY1_MY1W1 : const double = 0.120;	// My1.S.14
MY1W2 : const double = 0.114;	// My1.S.10.1
DMY1_MY1W2 : const double = 0.130;	// My1.S.10.1
MY1W3 : const double = 0.152;	// My1.S.11
DMY1_MY1W3 : const double = 0.150;	// My1.S.11
MY1W4 : const double = 0.180;	// My1.S.26
DMY1_MY1W4 : const double = 0.180;	// My1.S.26
MY1W5 : const double = 0.240;	// DMn.S.3.2
DMY1_MY1W5 : const double = 0.210;	// DMn.S.3.2
MY1W6 : const double = 0.280;	// DMn.S.3.2
DMY1_MY1W6 : const double = 0.240;	
MY1W7 : const double = 0.500;	// DMn.S.3.2
DMY1_MY1W7 : const double = 0.280;	
MY1W8 : const double = 1.350;	// DMn.S.3.2
DMY1_MY1W8 : const double = 0.450;	
DMY1_MY145 : const double = 0.4;
DMY1_VY15V : const double = 0.16;	// My1.S.19.2
DMY1_MY15V : const double = 0.136;	// My1.S.20.1
MY138 : const double = 0.038;	// My1.S.27
DMY1_MY1381 : const double = 0.114;	// My1.S.27
DMY1_MY1382 : const double = 0.190;	// My1.S.27
MY140 : const double = 0.04;	// My1.S.27.1
DMY1_MY1401 : const double = 0.129;	// My1.S.27.1
DMY1_MY1402 : const double = 0.180;	// My1.S.27.1
MY160 : const double = 0.06;	// 
DMY1_MY160 : const double = 0.16;	// 
DMY1_ICOVL : const double = 0.2;	

DMY1ORW38_L_MAX : const double = 1.16;	
DMY1ORW38_SX : const double = 0.114;	
DMY1ORW38_SY : const double = 0.114;	
DMY1ORW38_OX : const double = 0;	
DMY1ORW38_OY : const double = 0;	
DMY1ORW38_W : const double = 0.038;	
DMY1ORW38_L : const double = 0.400;	
DMY1ORW38_SXA1 : const double = 0.114;	
DMY1ORW38_SXA2 : const double = 0.190;	
DMY1ORW38_SC : const double = 0.114;	

DMY1ORW38_MY1 : const double = 0.114;	// DMn.S.2.1.0.3, DMn.S.2.1.0.4

DMY1ORW38_MY1W1 : const double = 0.12;	
DMY1ORW38_MY1W1_PRL : const double = 0.08;	
DMY1ORW38_MY1W2 : const double = 0.3;	

MY1_DN_VALUE : const double = 0.25;	
MY1_DN_W : const double = 10;	
MY1_DN_S : const double = 5;	
MY1_DN_MARGIN : const double = 0.01;	

MY1_DN_2ND : const double = 0.20;	
MY1_DN_2ND_W : const double = 10.000;
MY1_DN_2ND_E : const double = MY1_DN_2ND_W*MY1_DN_2ND_W/2;	//user value
MY1_DN_2ND_S : const double = 5.000;	

//***** DMyy *******************************************************************
DMYYM_W : const double = 0.27;	//
DMYYM_L : const double = 1.8;	//
DMYYM_SX : const double = 0.27;	// DMn.S.1
DMYYM_SY : const double = 0.45;	//
DMYYM_OX : const double = 0.068;	//
DMYYM_OY : const double = 0.113;	//
DMYYM_MYY : const double = 1;	// DMn.S.2
DMYYM_DMYYO : const double = 0.54;	// DMn.S.2.3
DMYYM_DMYY : const double = 0.27;	// DMn.S.1
DMYYM_CHIP : const double = 2.001;	

DMYYS_W : const double = 0.18;	// DMn.W.1
DMYYS_L : const double = 0.9;	// DMn.A.1/DMn.W.1
DMYYS_SX : const double = 0.27;	// DMn.S.1
DMYYS_SY : const double = 0.36;	//
DMYYS_OX : const double = 0.068;	//
DMYYS_OY : const double = 0.09;	//
DMYYS_MYY : const double = 1;	// DMn.S.2
DMYYS_DMYYO : const double = 0.54;	// DMn.S.2.3
DMYYS_DMYY : const double = 0.27;	// DMn.S.1
DMYYS_CHIP : const double = 2.001;	

DMYYO_W : const double = 0.09;	// DMn.W.1.1
DMYYO_L : const double = 0.244;	// DMn.A.1.1/DMn.W.1.1
DMYYO_SX : const double = 0.09;	// DMn.S.1.1
DMYYO_SY : const double = 0.09;	// DMn.S.1.1
DMYYO_OX : const double = 0.023;	//
DMYYO_OY : const double = 0.023;	//
DMYYO_MYY : const double = 0.27;	// DMn.S.2.1
DMYYO_DMYYO : const double = 0.54;	// DMn.S.1.1
DMYYO_DMYY : const double = 0.54;	// DMn.S.2.3

DMYY_CHIP : const double = 0.54;	// Myy.S.3*1.2
MYYHOLE : const double = 0.162+2*DMYYO_W*DMYYO_L;	// Myy.A.3+2*DMn.W.1.1*DMn.A.1.1/DMn.W.1.1
MYYW : const double = 1.35;	// DMyy.S.3.1.1
DMYY_MYYW : const double = 0.45;	// DMyy.S.3.1.1
MYYWB : const double = 4.05;	// DMyy.S.4.1.1
DMYY_MYYWB : const double = 1.35;	// DMyy.S.4.1.1

MYY_DN_2_1 : const double = 0.85;	// Myy.DN.2.1,Mn.DN.2.4
MYY_DN_2_1_W : const double = 112;	// Myy.DN.2.1,Mn.DN.2.4
MYY_DN_2_1_S : const double = 56;	// Myy.DN.2.1,Mn.DN.2.4
MYY_DN_MARGIN : const double = 0.01;	//

DMYYORW62_L_MAX : const double = 1.12;	
DMYYORW62_SX : const double = 0.064;	
DMYYORW62_SY : const double = 0.108;	
DMYYORW62_W : const double = 0.062;	
DMYYORW62_L : const double = 0.500;	
DMYYORW62_SC : const double = 0.108;	
DMYYORW62_DMYYO_W90 : const double = 0.270;	
DMYYORW62_DMYY : const double = 0.540;	

DMYYORW62_MYY : const double = 0.190;	// DMn.S.2.1.0.3, DMn.S.2.1.0.4


MYY_DN_VALUE : const double = 0.25;	
MYY_DN_W : const double = 10;	
MYY_DN_S : const double = 5;	

MYY_DN_2ND : const double = 0.21;	
MYY_DN_2ND_W : const double = 10.000;	
MYY_DN_2ND_E : const double = MYY_DN_2ND_W*MYY_DN_2ND_W/2;	//user value
MYY_DN_2ND_S : const double = 5.000;	

//***** DMyx *******************************************************************
DMYXB_W : const double = 1.8;	//
DMYXB_L : const double = 1.8;	//
DMYXB_SX : const double = 0.72;	//
DMYXB_SY : const double = 0.72;	//
DMYXB_OX : const double = 0.18;	//
DMYXB_OY : const double = 0.18;	//
DMYXB_MYX : const double = 4.5;	//
DMYXB_DMYX : const double = 0.72;	//

DMYXM_W : const double = 0.72;	//
DMYXM_L : const double = 0.72;	//
DMYXM_SX : const double = 0.36;	// DMn.S.1,IND.S.6
DMYXM_SY : const double = 0.36;	// DMn.S.1,IND.S.6
DMYXM_OX : const double = 0.09;	//
DMYXM_OY : const double = 0.09;	//
DMYXM_MYX : const double = 0.54;	// DMn.S.2
DMYXM_DMYX : const double = 0.36;	// DMn.S.1,IND.S.6

DMYXS_W : const double = 0.36;	// DMn.W.1,IND.W.6
DMYXS_L : const double = 1.28;	// DMn.A.1/DMn.W.1
DMYXS_SX : const double = 0.36;	// DMn.S.1,IND.S.6
DMYXS_SY : const double = 0.36;	// DMn.S.1,IND.S.6
DMYXS_OX : const double = 0.09;	//
DMYXS_OY : const double = 0.09;	//
DMYXS_MYX : const double = 0.54;	// DMn.S.2
DMYXS_DMYX : const double = 0.36;	// DMn.S.1,IND.S.6

DMYX_CHIP : const double = 1.62;	// Myx.S.4*1.2
MYXHOLE : const double = 1.1016;	// Myx.A.2+2*DMn.W.1*DMn.A.1/DMn.W.1
MYXW : const double = 1.35;	// Myx.S.4,DMn.S.3.3
DMYX_MYXW : const double = 0.45;	// Myx.S.4,DMn.S.3.3
MYXWB : const double = 4.05;	// Myx.S.4,DMn.S.3.3
DMYX_MYXWB : const double = 1.35;	// Myx.S.4,DMn.S.3.3

MYX_DN_2 : const double = 0.85;	// Myx.DN.2,Mn.DN.2.1
MYX_DN_2_W : const double = 112;	// Myx.DN.2,Mn.DN.2.1
MYX_DN_2_S : const double = 56;	// Myx.DN.2,Mn.DN.2.1
MYX_DN_MARGIN : const double = 0.01;	//


//***** DMyz *******************************************************************
DMYZB_W : const double = 1.8;	//
DMYZB_L : const double = 1.8;	//
DMYZB_SX : const double = 0.72;	//
DMYZB_SY : const double = 0.72;	//
DMYZB_OX : const double = 0.18;	//
DMYZB_OY : const double = 0.18;	//
DMYZB_MYZ : const double = 4.5;	//
DMYZB_DMYZ : const double = 0.72;	//

DMYZM_W : const double = 0.72;	//
DMYZM_L : const double = 0.72;	//
DMYZM_SX : const double = 0.36;	// DMn.S.1,IND.S.6
DMYZM_SY : const double = 0.36;	// DMn.S.1,IND.S.6
DMYZM_OX : const double = 0.09;	//
DMYZM_OY : const double = 0.09;	//
DMYZM_MYZ : const double = 0.54;	// DMn.S.2
DMYZM_DMYZ : const double = 0.36;	// DMn.S.1,IND.S.6

DMYZS_W : const double = 0.36;	// DMn.W.1,IND.W.6
DMYZS_L : const double = 1.28;	// DMn.A.1/DMn.W.1
DMYZS_SX : const double = 0.36;	// DMn.S.1,IND.S.6
DMYZS_SY : const double = 0.36;	// DMn.S.1,IND.S.6
DMYZS_OX : const double = 0.09;	//
DMYZS_OY : const double = 0.09;	//
DMYZS_MYZ : const double = 0.54;	// DMn.S.2
DMYZS_DMYZ : const double = 0.36;	// DMn.S.1,IND.S.6

DMYZ_CHIP : const double = 1.62;	// Myz.S.4*1.2
MYZHOLE : const double = 0.2146+2*DMYZS_W*DMYZS_L;	// Myz.A.2+2*DMn.W.1*DMn.A.1/DMn.W.1
MYZW : const double = 4.05;	// Myz.S.4,DMn.S.3.3
DMYZ_MYZW : const double = 1.35;	// Myz.S.4,DMn.S.3.3

MYZ_DN_2 : const double = 0.85;	// Myz.DN.2,Mn.DN.2.1
MYZ_DN_2_W : const double = 112;	// Myz.DN.2,Mn.DN.2.1
MYZ_DN_2_S : const double = 56;	// Myz.DN.2,Mn.DN.2.1
MYZ_DN_MARGIN : const double = 0.01;	//


//***** DMz ********************************************************************
DMZB_W : const double = 2.6;	//
DMZB_L : const double = 2.6;	//
DMZB_SX : const double = 0.6;	// IND.S.2
DMZB_SY : const double = 0.6;	// IND.S.2
DMZB_OX : const double = 0.18;	//
DMZB_OY : const double = 0.18;	//
DMZB_MZ_HIGH : const double = 20;	//
DMZB_MZ : const double = 4.5;	//
DMZB_DMZ : const double = 0.72;	// IND.S.2
DMZB_DMZ_HIGH : const double = 0.72;	
DMZB_IND : const double = INDDMY_BUFFER_RANGE;	// IND.W.2,IND.S.2

DMZM_W : const double = 0.72;	//
DMZM_L : const double = 0.72;	//
DMZM_SX : const double = 0.36;	// DMn.S.1
DMZM_SY : const double = 0.36;	// DMn.S.1
DMZM_OX : const double = 0.09;	//
DMZM_OY : const double = 0.09;	//
DMZM_MZ : const double = 0.54;	// DMn.S.2
DMZM_DMZ : const double = 0.36;	// DMn.S.1
DMZM_DMZ_HIGH : const double = 0.45;	
DMZM_IND : const double = INDDMY_BUFFER_RANGE;	// IND.W.2,IND.S.2

DMZS_W : const double = 0.36;	// DMn.W.1
DMZS_L : const double = 1.28;	// DMn.A.1/DMn.W.1
DMZS_SX : const double = 0.36;	// DMn.S.1
DMZS_SY : const double = 0.36;	// DMn.S.1
DMZS_OX : const double = 0.09;	//
DMZS_OY : const double = 0.09;	//
DMZS_MZ : const double = 0.54;	// DMn.S.2
DMZS_DMZ : const double = 0.36;	// DMn.S.1
DMZS_DMZ_HIGH : const double = 0.45;	
DMZS_IND : const double = INDDMY_BUFFER_RANGE;	// IND.W.2,IND.S.2
DMZMHD_W : const double = 1;	
DMZMHD_WMAX : const double = 1;	
DMZMHD_L : const double = 1.8;	
DMZMHD_LMAX : const double = 5;	
DMZMHD_SX : const double = 0.36;	
DMZMHD_SY : const double = 0.36;	
DMZMHD_DN1 : const double = 0.45;	
DMZMHD_DN2 : const double = 0.45;	
DMZMHD_DN3 : const double = 0.65;	

DMZSHD_W : const double = 0.36;	
DMZSHD_WMAX : const double = 2;	
DMZSHD_L : const double = 1.28;	
DMZSHD_LMAX : const double = 5;	
DMZSHD_SX : const double = 0.54;	
DMZSHD_SY : const double = 0.54;	

DMZIND_W : const double = 1.8;	//
DMZIND_L : const double = 1.8;	//
DMZIND_SX : const double = 0.72;	// IND.S.2
DMZIND_SY : const double = 0.72;	// IND.S.2
DMZIND_OX : const double = 0.18;	//
DMZIND_OY : const double = 0.18;	//
DMZIND_MZ : const double = 0.72;	// IND.S.2
DMZIND_DMZ : const double = 0.72;	// IND.S.2

DMZ_CHIP : const double = 1.62;	// Mz.S.3*1.2
MZHOLE : const double = 0.509+2*DMZS_W*DMZS_L;	// Mz.A.2+2*DMn.W.1*DMn.A.1/DMn.W.1
MZW : const double = 1.35;	// Mz.S.3,DMn.S.3.3
DMZ_MZW : const double = 0.45;	// Mz.S.3,DMn.S.3.3
MZWB : const double = 4.05;	// Mz.S.3,DMn.S.3.3
DMZ_MZWB : const double = 1.35;	// Mz.S.3,DMn.S.3.3

MZ_DN_2_1 : const double = 0.85;	// Mz.DN.2.1,Mn.DN.2.1
MZ_DN_2_1_W : const double = 112;	// Mz.DN.2.1,Mn.DN.2.1
MZ_DN_2_1_S : const double = 56;	// Mz.DN.2.1,Mn.DN.2.1
MZ_DN_MARGIN : const double = 0.01;	//




















//***** DMr ********************************************************************
DMRB_W : const double = 1.8;	//
DMRB_L : const double = 1.8;	//
DMRB_SX : const double = 0.8;	// IND.S.2
DMRB_SY : const double = 0.8;	// IND.S.2
DMRB_OX : const double = 0.18;	//
DMRB_OY : const double = 0.18;	//
DMRB_MR : const double = 4.5;	//
DMRB_DMR : const double = 0.8;	// IND.S.2
DMRB_IND : const double = INDDMY_BUFFER_RANGE;	// IND.W.3,IND.S.3

DMRM_W : const double = 1.2;	//
DMRM_L : const double = 1.2;	//
DMRM_SX : const double = 0.8;	// DMn.S.1
DMRM_SY : const double = 0.8;	// DMn.S.1
DMRM_OX : const double = 0.18;	//
DMRM_OY : const double = 0.18;	//
DMRM_MR : const double = 0.8;	// DMn.S.2
DMRM_DMR : const double = 0.8;	// DMn.S.1
DMRM_IND : const double = INDDMY_BUFFER_RANGE;	// IND.W.2,IND.S.2

DMRS_W : const double = 0.8;	// DMn.W.1
DMRS_L : const double = 1.8;	// DMn.A.1/DMn.W.1
DMRS_SX : const double = 0.8;	// DMn.S.1
DMRS_SY : const double = 0.8;	// DMn.S.1
DMRS_OX : const double = 0.18;	//
DMRS_OY : const double = 0.18;	//
DMRS_MR : const double = 0.8;	// DMn.S.2
DMRS_DMR : const double = 0.8;	// DMn.S.1
DMRS_IND : const double = INDDMY_BUFFER_RANGE;	// IND.W.2,IND.S.2

DMRIND_W : const double = 2.25;	//
DMRIND_L : const double = 2.25;	//
DMRIND_SX : const double = 0.9;	// IND.S.2
DMRIND_SY : const double = 0.9;	// IND.S.2
DMRIND_OX : const double = 0.203;	//
DMRIND_OY : const double = 0.203;	//
DMRIND_MR : const double = 0.9;	// IND.S.2
DMRIND_DMR : const double = 0.9;	// IND.S.2

DMR_CHIP : const double = 1.62;	// Mr.S.3*1.2
MRHOLE : const double = 0.81+2*DMRS_W*DMRS_L;	// Mr.A.2+2*DMn.W.1*DMn.A.1/DMn.W.1
MRW : const double = 1.35;	// Mr.S.3,DMn.S.3.3
DMR_MRW : const double = 0.45;	// Mr.S.3,DMn.S.3.3
MRWB : const double = 4.05;	// Mr.S.3,DMn.S.3.3
DMR_MRWB : const double = 1.35;	// Mr.S.3,DMn.S.3.3

MR_DN_2_1 : const double = 0.85;	// Mr.DN.2.1,Mn.DN.2.1
MR_DN_2_1_W : const double = 112;	// Mr.DN.2.1,Mn.DN.2.1
MR_DN_2_1_S : const double = 56;	// Mr.DN.2.1,Mn.DN.2.1
MR_DN_MARGIN : const double = 0.01;	//


//***** DMu ********************************************************************
DMU_W : const double = 2.7;	// DMn.W.1
DMU_L : const double = 2.7;	// DMn.W.1
DMU_SX : const double = 2.7;	// DMn.S.1
DMU_SY : const double = 2.7;	// DMn.S.1
DMU_OX : const double = 0.675;	//
DMU_OY : const double = 0.675;	//
DMU_MU : const double = 2.7;	// DMn.S.2
DMU_DMU : const double = 2.7;	// DMn.S.1

DMU_CHIP : const double = 1.62;	// Mu.S.3*1.2
MUHOLE : const double = 7.29+2*DMU_W*DMU_L;	// Mu.A.2+2*DMn.W.1*DMn.W.1

MU_DN_4 : const double = 0.85;	// Mu.DN.4,Mn.DN.10
MU_DN_4_W : const double = 112;	// Mu.DN.4,Mn.DN.10
MU_DN_4_S : const double = 56;	// Mu.DN.4,Mn.DN.10
MU_DN_MARGIN : const double = 0.01;	//

//***** DVIA0 *******************************
DV0_W : const double = 0.012;	
DV0_E : const double = 0.03;	
DV0_S : const double = 0.087;	
DV0NON_S : const double = 0.45;	
DV0_V0 : const double = 0.087;	
DV0_M0 : const double = 0.07;	
DV0_M1 : const double = 0.07;	
DV0_DV0 : const double = 0.087;	
DV0_DCM0AB : const double = 0.02;	
DV0_DCM1AB : const double = 0.02;	
DV0_SRM : const double = 0.098;	
DV0_FORB1 : const double = 3;	
DV0_FORB2 : const double = 4;	
NONOPCMETAL_DV0_E : const double = 0.18;	

//***** DVIAxa *******************************
DVXA_W : const double = 0.012;	
DVXA_E : const double = 0.03;	
DVXA_S : const double = 0.087;	
DVXANON_S : const double = 0.45;	
DVXA_VXA : const double = 0.087;	
DVXA_MXA : const double = 0.087;	
DVXA_DVXA : const double = 0.087;	
DVXA_SRM : const double = 0.098;	
DVXA_FORB1 : const double = 3;	
DVXA_FORB2 : const double = 4;	
NONOPCMETAL_DVXA_E : const double = 0.18;	
VIAXA_R_19 : const double = 4;	

//***** DVIAxb *******************************
DVXB_W : const double = 0.012;	
DVXB_E : const double = 0.03;	
DVXB_S : const double = 0.087;	
DVXBNON_S : const double = 0.5;	
DVXB_VXB : const double = 0.087;	
DVXB_MXB : const double = 0.087;	
DVXB_DVXB : const double = 0.087;	
DVXB_SRM : const double = 0.098;	
DVXB_FORB1 : const double = 3;	
DVXB_FORB2 : const double = 4;	
NONOPCMETAL_DVXB_E : const double = 0.3;	

//***** DVIAxc *******************************
DVXC_W : const double = 0.018;	
DVXC_E : const double = 0.03;	
DVXC_S : const double = 0.093;	
DVXCNON_S : const double = 0.5;	
DVXC_VXC : const double = 0.093;	
DVXC_MXC : const double = 0.087;	
DVXC_DVXC : const double = 0.093;	
DVXC_SRM : const double = 0.098;	
DVXC_FORB1 : const double = 3;	
DVXC_FORB2 : const double = 4;	
NONOPCMETAL_DVXC_E : const double = 0.3;	

//***** DVIAxd *******************************
DVXD_W : const double = 0.018;	
DVXD_E : const double = 0.05;	
DVXD_S : const double = 0.128;	
DVXDNON_S : const double = 0.5;	
DVXD_VXD : const double = 0.128;	
DVXD_MXD : const double = 0.12;	
DVXD_DVXD : const double = 0.128;	
NONOPCMETAL_DVXD_E : const double = 0.39;	
DVXD_FORB1 : const double = 1.8;	
DVXD_FORB2 : const double = 2.8;	

//***** DVIAya *******************************
DVYA_W : const double = 0.09;	
DVYA_E : const double = 0.09;	
DVYA_S : const double = 0.334;	
DVYA_VYA : const double = 1.8;	
DVYA_MYA : const double = 1.8;	
DVYA_DVYA : const double = 0.334;	
DVYA_DVYA_O : const double = 0.3;
//***** DVIAyb_O *******************************
DVYB_O_W : const double = 0.038;	
DVYB_O_S : const double = 0.096;	

//***** DVIAy_O *******************************
DVY_O_W : const double = 0.038;	
DVY_O_S : const double = 0.096;	

//***** DVIAyy_O *******************************
DVYY_O_W : const double = 0.062;	
DVYY_O_S : const double = 0.118;	

//***** DVIAy *******************************
DVY_W : const double = 0.09;	
DVY_E : const double = 0.09;	
DVY_S : const double = 0.334;	
DVY_VY : const double = 1.8;	
DVY_MY : const double = 1.8;	
DVY_DVY : const double = 0.334;	
DVY_RHTNB : const double = 0.35;	

//***** DVIAyy                  *******************************
DVYY_W : const double = 0.106;	
DVYY_EYY : const double = 0.09;	
DVYY_EY : const double = 0.09;	
DVYY_S : const double = 0.18;	
DVYY_VYY : const double = 0.18;	
DVYY_MYY : const double = 0.18;	
DVYY_DVYY : const double = 0.18;	

//***** DVIAyx                  *******************************
DVYX_W : const double = 0.166;	
DVYX_EYX : const double = 0.09;	
DVYX_S : const double = 0.25;	
DVYX_VYX : const double = 0.25;	
DVYX_MYX : const double = 0.25;	
DVYX_DVYX : const double = 0.25;	

//***** BTCD *******************************************************************
BTCD_S : const double = 400;	// not confirmed
BTCD_CHIP : const double = 5;	
BTCD_ICOVL : const double = 15;	
BTCD_CSRDMY : const double = 15;	
BTCD_IND : const double = INDDMY_BUFFER_RANGE;
BTCD_MOMDMY : const double = 2;
BTCD_LOGO : const double = 4;
BTCD_SR : const double = 5;
BTCD_M : const double = 1.5;
BTCD_D : const double = 0.21;
BTCD_DX1 : const double = 0.1;
BTCD_DX1B : const double = 0.4;
BTCD_DX2 : const double = 0.1;
BTCD_DX2B : const double = 0.21;
BTCD_DX3 : const double = 0.21;
BTCD_DY1 : const double = 0.21;
BTCD_SRM : const double = 2;
BTCD_SRAMDMY : const double = 2;
BTCD_CM0 : const double = 0.05;	
BTCD_RHTN : const double = 1.5;
BTCD_RHTNB : const double = 1.5;
BTCD_STD : const double = 2;	

//***** Wrapper ****************************************************************
WRAPPER_RANGEX1 : const double = 1.5;
WRAPPER_RANGEX3 : const double = 2;
WRAPPER_RANGEY1 : const double = 1;
WRAPPER_RANGE2 : const double = 1;
LONG_METAL_L : const double = 1;	//

FILLSTACK_20T_S : const double = 0.082;

CHIP_SHRINK_VALUEX1 : const double = 0.5;	
CHIP_SHRINK_VALUEY1 : const double = 0.3;	
CHIP_SHRINK_VALUEX2 : const double = 0.8;	
CHIP_SHRINK_VALUEX3 : const double = 0.8;	
CHIP_SHRINK_VALUEY2 : const double = 0.5;	

SHDMIM_BPC : const double = 2;	
SHDMIM_TPC : const double = 2;	
SHDMIM_RV : const double = 1.4;	
SHDMIM_CU_RV : const double = 1.4;	
SHDMIM_CB : const double = 1.4;	
SHDMIM_CBD : const double = 1.4;	
SHDMIM_CU_RDL : const double = 0.8;	
SHDMIM_PRBOUNDARY : const double = 1;	
SHDMIM_DMIMEXCL : const double = 1;	
SHDMIM_INDDMY : const double = 5;	
SHDMIM_LOGO : const double = 1;	
SHDMIM_SERLRING : const double = 0;	
SHDMIM_KOZ : const double = 1;
SHDMIM_BPVT : const double = 1.1;
SHDMIM_BPVB : const double = 1.1;
#pragma PXL encrypted begin
[^6"1G@KHQGO9U4""F7@M7)G3:QF4GC#021-W'(SU-M%_5+<$'\EP?6GYNH08(R8>!?F>7Q@
L0D7\+UE$ONQK_':ZPIGU(>O>N*]-BYJ6%-Z@%<8OTA$=<> W8M!HZ)=Q*?=K;M8DEX7'>>M
;8IR\R/ZL,QMR</-Q[ZPS?[)^=1>9VYG''?YQ08>ZQSC#3#%OEK<ZQ(_[\.^K0E, EMWQ:NM
Z]R(>+BO;V7K!/V8C0^HQ;($'$]O/O9PM L<VF,W8F!RE[7:'?4PO]8TX <=A;TGMSIP0'^%
#pragma PXL encrypted end

//******************************************************************************
//      ALGORITHM
//******************************************************************************

#ifdef FULL_CHIP
CHIP_SHRINK_VALUE : const double = 0.8;	
#else
CHIP_SHRINK_VALUE : const double = 0.7;	
#endif


//***** derived layer **********************************************************
INDDMY_BUFFER = size( INDDMY, clip_acute = TRUNCATE, distance = INDDMY_BUFFER_RANGE );

#ifdef FULL_CHIP 
#ifdef WITH_SEALRING 
   CSR66_3485 = copy( gEMPTY, ancestry = true ); 
#else
   CSR66_3485 = internal1( CHIP_snps, < 66.3485, extension = RADIAL, intersecting = {  }, intersection_angle = == 90, look_thru = NOT_ADJACENT, orientation = { }, extension_look_past = POINT_TO_POINT ); 
#endif
#else
   CSR66_3485 = copy( gEMPTY, ancestry = true ); 
#endif


DM0EXCL_FINAL  = DM0EXCL not UNDM0EXCL;
BEOLBLK_FINAL  = BEOLBLK  not UNBEOLBLK;

DM1EXCL_FINAL  = DM1EXCL not UNDM1EXCL;
BEOLBLK_FINAL  = BEOLBLK  not UNBEOLBLK;

DM2EXCL_FINAL  = DM2EXCL not UNDM2EXCL;
BEOLBLK_FINAL  = BEOLBLK  not UNBEOLBLK;

DM3EXCL_FINAL  = DM3EXCL not UNDM3EXCL;
BEOLBLK_FINAL  = BEOLBLK  not UNBEOLBLK;

DM4EXCL_FINAL  = DM4EXCL not UNDM4EXCL;
BEOLBLK_FINAL  = BEOLBLK  not UNBEOLBLK;

DM5EXCL_FINAL  = DM5EXCL not UNDM5EXCL;
BEOLBLK_FINAL  = BEOLBLK  not UNBEOLBLK;

DM6EXCL_FINAL  = DM6EXCL not UNDM6EXCL;
BEOLBLK_FINAL  = BEOLBLK  not UNBEOLBLK;

DM7EXCL_FINAL  = DM7EXCL not UNDM7EXCL;
BEOLBLK_FINAL  = BEOLBLK  not UNBEOLBLK;

DM8EXCL_FINAL  = DM8EXCL not UNDM8EXCL;
BEOLBLK_FINAL  = BEOLBLK  not UNBEOLBLK;

DM9EXCL_FINAL  = DM9EXCL not UNDM9EXCL;
BEOLBLK_FINAL  = BEOLBLK  not UNBEOLBLK;

DM10EXCL_FINAL  = DM10EXCL not UNDM10EXCL;
BEOLBLK_FINAL  = BEOLBLK  not UNBEOLBLK;

DM11EXCL_FINAL  = DM11EXCL not UNDM11EXCL;
BEOLBLK_FINAL  = BEOLBLK  not UNBEOLBLK;

DM12EXCL_FINAL  = DM12EXCL not UNDM12EXCL;
BEOLBLK_FINAL  = BEOLBLK  not UNBEOLBLK;

DM13EXCL_FINAL  = DM13EXCL not UNDM13EXCL;
BEOLBLK_FINAL  = BEOLBLK  not UNBEOLBLK;

DM14EXCL_FINAL  = DM14EXCL not UNDM14EXCL;
BEOLBLK_FINAL  = BEOLBLK  not UNBEOLBLK;

DM15EXCL_FINAL  = DM15EXCL not UNDM15EXCL;
BEOLBLK_FINAL  = BEOLBLK  not UNBEOLBLK;

DM16EXCL_FINAL  = DM16EXCL not UNDM16EXCL;
BEOLBLK_FINAL  = BEOLBLK  not UNBEOLBLK;

DM17EXCL_FINAL  = DM17EXCL not UNDM17EXCL;
BEOLBLK_FINAL  = BEOLBLK  not UNBEOLBLK;

DM18EXCL_FINAL  = DM18EXCL not UNDM18EXCL;
BEOLBLK_FINAL  = BEOLBLK  not UNBEOLBLK;

DM19EXCL_FINAL  = DM19EXCL not UNDM19EXCL;
BEOLBLK_FINAL  = BEOLBLK  not UNBEOLBLK;

SRM_IN_PRE = size( SRM, clip_acute = TRUNCATE, distance = - DMX1_SRM_IN ); 
SRM_IN = SRM not SRM_IN_PRE; 
SRAM_IN_PRE = size( SRAMDMY, clip_acute = TRUNCATE, distance = - DMX1_SRM_IN ); 
SRAM_IN = SRAMDMY not SRM_IN_PRE; 

FLOATING_M2_JUMP = M2_MAIN_CA inside M2_JUMP; 

CHIP_NOT_BEOL = not_angle_edge( ( CHIP_snps not BEOLBLK_FINAL ), { 0, 90 } ); 
CHIP_45D = edge_size( extend_edge( CHIP_NOT_BEOL, start = 0.4, end = 0.4 ), inside = 0.4 ) and CHIP_snps; 
M0FORBIDDEN_CHIP = not_interacting( edge_size( angle_edge( CHIP_BOUNDARY, == 0 ), inside = DM0O_CHIPR ), CHIP_45D ) or edge_size( angle_edge( CHIP_BOUNDARY, == 90 ), inside = DM0O_CHIPE ); 

MX1FORBIDDEN_CHIPMH = edge_size( angle_edge( CHIP_BOUNDARY, == 0 ), inside = DMX1O_CHIPR ) or edge_size( angle_edge( CHIP_BOUNDARY, == 90 ), inside = DMX1O_CHIPE ); 
MX1FORBIDDEN_CHIPMV = edge_size( angle_edge( CHIP_BOUNDARY, == 0 ), inside = DMX1O_CHIPE ) or edge_size( angle_edge( CHIP_BOUNDARY, == 90 ), inside = DMX1O_CHIPR ); 
MX2FORBIDDEN_CHIPMH = edge_size( angle_edge( CHIP_BOUNDARY, == 0 ), inside = DMX2O_CHIPR ) or edge_size( angle_edge( CHIP_BOUNDARY, == 90 ), inside = DMX2O_CHIPE ); 
MX2FORBIDDEN_CHIPMV = edge_size( angle_edge( CHIP_BOUNDARY, == 0 ), inside = DMX2O_CHIPE ) or edge_size( angle_edge( CHIP_BOUNDARY, == 90 ), inside = DMX2O_CHIPR ); 
CHIP_NS = not_angle_edge( CHIP_snps, { 0, 90 } ); 
CHIP_45DEGREE = edge_size( extend_edge( CHIP_NS, start = 0.4, end = 0.4 ), inside = 0.4 ) and CHIP_snps; 


CHIP_BOUND_EDGE = angle_edge( CHIP_snps, == 0 ) or_edge angle_edge( CHIP_snps, == 90 ); 
CHIP_BOUNDX = edge_size( CHIP_BOUND_EDGE, inside = 1 ); 
CHIP_BOUND_REG = CHIP_45DEGREE or CHIP_BOUNDX; 













VIA0_HVN_096V = VIA0I and M1_HVN_096V; 
VIA0_HVN_132V = VIA0I and M1_HVN_132V; 
VIA0_HVN_165V = VIA0I and M1_HVN_165V; 
VIA0_HVN_180V = VIA0I and M1_HVN_180V; 
VIA0_HVN_198V = VIA0I and M1_HVN_198V; 
VIA0_HVN_275V = VIA0I and M1_HVN_275V; 
VIA0_HVN_5V = VIA0I and M1_HVN_5V; 

VIA1_HVN_096V = VIA1I and M2_HVN_096V; 
VIA1_HVN_132V = VIA1I and M2_HVN_132V; 
VIA1_HVN_165V = VIA1I and M2_HVN_165V; 
VIA1_HVN_180V = VIA1I and M2_HVN_180V; 
VIA1_HVN_198V = VIA1I and M2_HVN_198V; 
VIA1_HVN_275V = VIA1I and M2_HVN_275V; 
VIA1_HVN_5V = VIA1I and M2_HVN_5V; 

VIA2_HVN_096V = VIA2I and M3_HVN_096V; 
VIA2_HVN_132V = VIA2I and M3_HVN_132V; 
VIA2_HVN_165V = VIA2I and M3_HVN_165V; 
VIA2_HVN_180V = VIA2I and M3_HVN_180V; 
VIA2_HVN_198V = VIA2I and M3_HVN_198V; 
VIA2_HVN_275V = VIA2I and M3_HVN_275V; 
VIA2_HVN_5V = VIA2I and M3_HVN_5V; 

VIA3_HVN_096V = VIA3I and M4_HVN_096V; 
VIA3_HVN_132V = VIA3I and M4_HVN_132V; 
VIA3_HVN_165V = VIA3I and M4_HVN_165V; 
VIA3_HVN_180V = VIA3I and M4_HVN_180V; 
VIA3_HVN_198V = VIA3I and M4_HVN_198V; 
VIA3_HVN_275V = VIA3I and M4_HVN_275V; 
VIA3_HVN_5V = VIA3I and M4_HVN_5V; 

VIA4_HVN_096V = VIA4I and M5_HVN_096V; 
VIA4_HVN_132V = VIA4I and M5_HVN_132V; 
VIA4_HVN_165V = VIA4I and M5_HVN_165V; 
VIA4_HVN_180V = VIA4I and M5_HVN_180V; 
VIA4_HVN_198V = VIA4I and M5_HVN_198V; 
VIA4_HVN_275V = VIA4I and M5_HVN_275V; 
VIA4_HVN_5V = VIA4I and M5_HVN_5V; 

VIA5_HVN_096V = VIA5I and M6_HVN_096V; 
VIA5_HVN_132V = VIA5I and M6_HVN_132V; 
VIA5_HVN_165V = VIA5I and M6_HVN_165V; 
VIA5_HVN_180V = VIA5I and M6_HVN_180V; 
VIA5_HVN_198V = VIA5I and M6_HVN_198V; 
VIA5_HVN_275V = VIA5I and M6_HVN_275V; 
VIA5_HVN_5V = VIA5I and M6_HVN_5V; 

VIA6_HVN_096V = VIA6I and M7_HVN_096V; 
VIA6_HVN_132V = VIA6I and M7_HVN_132V; 
VIA6_HVN_165V = VIA6I and M7_HVN_165V; 
VIA6_HVN_180V = VIA6I and M7_HVN_180V; 
VIA6_HVN_198V = VIA6I and M7_HVN_198V; 
VIA6_HVN_275V = VIA6I and M7_HVN_275V; 
VIA6_HVN_5V = VIA6I and M7_HVN_5V; 

VIA7_HVN_096V = VIA7I and M8_HVN_096V; 
VIA7_HVN_132V = VIA7I and M8_HVN_132V; 
VIA7_HVN_165V = VIA7I and M8_HVN_165V; 
VIA7_HVN_180V = VIA7I and M8_HVN_180V; 
VIA7_HVN_198V = VIA7I and M8_HVN_198V; 
VIA7_HVN_275V = VIA7I and M8_HVN_275V; 
VIA7_HVN_5V = VIA7I and M8_HVN_5V; 

VIA8_HVN_096V = VIA8I and M9_HVN_096V; 
VIA8_HVN_132V = VIA8I and M9_HVN_132V; 
VIA8_HVN_165V = VIA8I and M9_HVN_165V; 
VIA8_HVN_180V = VIA8I and M9_HVN_180V; 
VIA8_HVN_198V = VIA8I and M9_HVN_198V; 
VIA8_HVN_275V = VIA8I and M9_HVN_275V; 
VIA8_HVN_5V = VIA8I and M9_HVN_5V; 

VIA9_HVN_096V = VIA9I and M10_HVN_096V; 
VIA9_HVN_132V = VIA9I and M10_HVN_132V; 
VIA9_HVN_165V = VIA9I and M10_HVN_165V; 
VIA9_HVN_180V = VIA9I and M10_HVN_180V; 
VIA9_HVN_198V = VIA9I and M10_HVN_198V; 
VIA9_HVN_275V = VIA9I and M10_HVN_275V; 
VIA9_HVN_5V = VIA9I and M10_HVN_5V; 

VIA10_HVN_096V = VIA10I and M11_HVN_096V; 
VIA10_HVN_132V = VIA10I and M11_HVN_132V; 
VIA10_HVN_165V = VIA10I and M11_HVN_165V; 
VIA10_HVN_180V = VIA10I and M11_HVN_180V; 
VIA10_HVN_198V = VIA10I and M11_HVN_198V; 
VIA10_HVN_275V = VIA10I and M11_HVN_275V; 
VIA10_HVN_5V = VIA10I and M11_HVN_5V; 

VIA11_HVN_096V = VIA11I and M12_HVN_096V; 
VIA11_HVN_132V = VIA11I and M12_HVN_132V; 
VIA11_HVN_165V = VIA11I and M12_HVN_165V; 
VIA11_HVN_180V = VIA11I and M12_HVN_180V; 
VIA11_HVN_198V = VIA11I and M12_HVN_198V; 
VIA11_HVN_275V = VIA11I and M12_HVN_275V; 
VIA11_HVN_5V = VIA11I and M12_HVN_5V; 

VIA12_HVN_096V = VIA12I and M13_HVN_096V; 
VIA12_HVN_132V = VIA12I and M13_HVN_132V; 
VIA12_HVN_165V = VIA12I and M13_HVN_165V; 
VIA12_HVN_180V = VIA12I and M13_HVN_180V; 
VIA12_HVN_198V = VIA12I and M13_HVN_198V; 
VIA12_HVN_275V = VIA12I and M13_HVN_275V; 
VIA12_HVN_5V = VIA12I and M13_HVN_5V; 

VIA13_HVN_096V = VIA13I and M14_HVN_096V; 
VIA13_HVN_132V = VIA13I and M14_HVN_132V; 
VIA13_HVN_165V = VIA13I and M14_HVN_165V; 
VIA13_HVN_180V = VIA13I and M14_HVN_180V; 
VIA13_HVN_198V = VIA13I and M14_HVN_198V; 
VIA13_HVN_275V = VIA13I and M14_HVN_275V; 
VIA13_HVN_5V = VIA13I and M14_HVN_5V; 

VIA14_HVN_096V = VIA14I and M15_HVN_096V; 
VIA14_HVN_132V = VIA14I and M15_HVN_132V; 
VIA14_HVN_165V = VIA14I and M15_HVN_165V; 
VIA14_HVN_180V = VIA14I and M15_HVN_180V; 
VIA14_HVN_198V = VIA14I and M15_HVN_198V; 
VIA14_HVN_275V = VIA14I and M15_HVN_275V; 
VIA14_HVN_5V = VIA14I and M15_HVN_5V; 

VIA15_HVN_096V = VIA15I and M16_HVN_096V; 
VIA15_HVN_132V = VIA15I and M16_HVN_132V; 
VIA15_HVN_165V = VIA15I and M16_HVN_165V; 
VIA15_HVN_180V = VIA15I and M16_HVN_180V; 
VIA15_HVN_198V = VIA15I and M16_HVN_198V; 
VIA15_HVN_275V = VIA15I and M16_HVN_275V; 
VIA15_HVN_5V = VIA15I and M16_HVN_5V; 

VIA16_HVN_096V = VIA16I and M17_HVN_096V; 
VIA16_HVN_132V = VIA16I and M17_HVN_132V; 
VIA16_HVN_165V = VIA16I and M17_HVN_165V; 
VIA16_HVN_180V = VIA16I and M17_HVN_180V; 
VIA16_HVN_198V = VIA16I and M17_HVN_198V; 
VIA16_HVN_275V = VIA16I and M17_HVN_275V; 
VIA16_HVN_5V = VIA16I and M17_HVN_5V; 

VIA17_HVN_096V = VIA17I and M18_HVN_096V; 
VIA17_HVN_132V = VIA17I and M18_HVN_132V; 
VIA17_HVN_165V = VIA17I and M18_HVN_165V; 
VIA17_HVN_180V = VIA17I and M18_HVN_180V; 
VIA17_HVN_198V = VIA17I and M18_HVN_198V; 
VIA17_HVN_275V = VIA17I and M18_HVN_275V; 
VIA17_HVN_5V = VIA17I and M18_HVN_5V; 

VIA18_HVN_096V = VIA18I and M19_HVN_096V; 
VIA18_HVN_132V = VIA18I and M19_HVN_132V; 
VIA18_HVN_165V = VIA18I and M19_HVN_165V; 
VIA18_HVN_180V = VIA18I and M19_HVN_180V; 
VIA18_HVN_198V = VIA18I and M19_HVN_198V; 
VIA18_HVN_275V = VIA18I and M19_HVN_275V; 
VIA18_HVN_5V = VIA18I and M19_HVN_5V; 





M0_LT285 = wide( M0_MAIN, < 0.0285, angled = TRUNCATE ); 
M0_LT40 = wide( M0_MAIN, < 0.04, angled = TRUNCATE ); 

#ifdef VERTICAL_M0
M0_EDGE_END = angle_edge( M0_MAIN, == 0 ); 
M0CA_EDGE_END = angle_edge( M0_MAIN_CA, == 0 ); 
M0CB_EDGE_END = angle_edge( M0_MAIN_CB, == 0 ); 
DM0_EDGE_END = angle_edge( DM0, == 0 ); 

#else
M0_EDGE_END = angle_edge( M0_MAIN, == 90 ); 
M0CA_EDGE_END = angle_edge( M0_MAIN_CA, == 90 ); 
M0CB_EDGE_END = angle_edge( M0_MAIN_CB, == 90 ); 
DM0_EDGE_END = angle_edge( DM0, == 90 ); 

#endif

   M0CA_LE = M0_MAIN_CA not M0_LT40;
   M0CB_LE = M0_MAIN_CB not M0_LT40;


macroLAYER_18 = angle_edge( M0_MAIN, == 45 ); 
macroLAYER_35 = extend_edge( macroLAYER_18, start = DMX1_MX45, end = DMX1_MX45 );
macroLAYER_17 = edge_size( macroLAYER_35, outside = DMX1_MX45 );
macroLAYER_16 = size( macroLAYER_17, clip_acute = TRUNCATE, distance = GRID ); 
M0_45 = M0_MAIN or macroLAYER_16; 

M0_HOLE = donut_holes( M0_MAIN, area = < MX1HOLE, holes = INNER, outer_boundary_point_touch = CLOSED_OUTER_BOUNDARY ); 

M0_LT165 = wide( M0_MAIN, < 0.0165, angled = TRUNCATE ); 


macroLAYER_25 = length_edge( M0_EDGE_END, [ 0.0405, 0.16 ) ); 
macroLAYER_24 = edge_size( macroLAYER_25, inside = 0.001, outside = 0.001 );
M0_LT160 = interacting( M0_MAIN, macroLAYER_24 ); 



macroLAYER_23 = length_edge( M0_EDGE_END, >= 0.16 ); 
macroLAYER_22 = edge_size( macroLAYER_23, inside = 0.001, outside = 0.001 );
M0_GE160 = interacting( M0_MAIN, macroLAYER_22 ); 


macroLAYER_25 = length_edge( M0_EDGE_END, [ 0.0285, 0.0405 ) ); 
macroLAYER_24 = edge_size( macroLAYER_25, inside = 0.001, outside = 0.001 );
M0_LT405 = interacting( M0_MAIN, macroLAYER_24 ); 


M0CA_LT165 = wide( M0_MAIN_CA, < 0.0165, angled = TRUNCATE ); 

M0CA_LT285 = wide( M0_MAIN_CA, < 0.0285, angled = TRUNCATE ); 
macroLAYER_25 = length_edge( M0CA_EDGE_END, [ 0.0285, 0.0405 ) ); 
macroLAYER_24 = edge_size( macroLAYER_25, inside = 0.001, outside = 0.001 );
M0CA_LT405 = interacting( M0_MAIN_CA, macroLAYER_24 ); 


macroLAYER_25 = length_edge( M0CA_EDGE_END, [ 0.0405, 0.16 ) ); 
macroLAYER_24 = edge_size( macroLAYER_25, inside = 0.001, outside = 0.001 );
M0CA_LT160 = interacting( M0_MAIN_CA, macroLAYER_24 ); 



macroLAYER_23 = length_edge( M0CA_EDGE_END, >= 0.16 ); 
macroLAYER_22 = edge_size( macroLAYER_23, inside = 0.001, outside = 0.001 );
M0CA_GE160 = interacting( M0_MAIN_CA, macroLAYER_22 ); 


M0CB_LT165 = wide( M0_MAIN_CB, < 0.0165, angled = TRUNCATE ); 

M0CB_LT285 = wide( M0_MAIN_CB, < 0.0285, angled = TRUNCATE ); 
macroLAYER_25 = length_edge( M0CB_EDGE_END, [ 0.0285, 0.0405 ) ); 
macroLAYER_24 = edge_size( macroLAYER_25, inside = 0.001, outside = 0.001 );
M0CB_LT405 = interacting( M0_MAIN_CB, macroLAYER_24 ); 



macroLAYER_25 = length_edge( M0CB_EDGE_END, [ 0.0405, 0.16 ) ); 
macroLAYER_24 = edge_size( macroLAYER_25, inside = 0.001, outside = 0.001 );
M0CB_LT160 = interacting( M0_MAIN_CB, macroLAYER_24 ); 



macroLAYER_23 = length_edge( M0CB_EDGE_END, >= 0.16 ); 
macroLAYER_22 = edge_size( macroLAYER_23, inside = 0.001, outside = 0.001 );
M0CB_GE160 = interacting( M0_MAIN_CB, macroLAYER_22 ); 



macroLAYER_23 = length_edge( DM0_EDGE_END, >= 0.091 ); 
macroLAYER_22 = edge_size( macroLAYER_23, inside = 0.001, outside = 0.001 );
DM0_GE91 = interacting( DM0, macroLAYER_22 ); 



#ifdef DMY_Boundary_Control
   BEOLBLK_FINAL_NOM0 = not_interacting( BEOLBLK_FINAL, ( ALL_M0 and size( BEOLBLK_FINAL, clip_acute = TRUNCATE, distance = - 0.09 ) ) ); 
   DM0EXCL_FINAL_NOM0 = not_interacting( DM0EXCL_FINAL, ( ALL_M0 and size( DM0EXCL_FINAL, clip_acute = TRUNCATE, distance = - 0.09 ) ) ); 
#else
   BEOLBLK_FINAL_NOM0 = BEOLBLK_FINAL or size( gEMPTY, clip_acute = TRUNCATE, distance = - 0.10 ); 
   DM0EXCL_FINAL_NOM0 = DM0EXCL_FINAL or gEMPTY; 
#endif




M1_LT285 = wide( M1_MAIN, < 0.0285, angled = TRUNCATE ); 
M1_LT40 = wide( M1_MAIN, < 0.04, angled = TRUNCATE ); 

#ifdef VERTICAL_M1 
   M1_EDGE_END = angle_edge( M1_MAIN, == 0 ); 
   M1_LE = angle_edge( ( M1_MAIN not M1_LT40 ), == 0 ); 
   DM1_EDGE_END = angle_edge( DM1, == 0 ); 
#else
   M1_EDGE_END = angle_edge( M1_MAIN, == 90 ); 
   M1_LE = angle_edge( ( M1_MAIN not M1_LT40 ), == 90 ); 
   DM1_EDGE_END = angle_edge( DM1, == 90 ); 
#endif

macroLAYER_18 = angle_edge( M1_MAIN, == 45 ); 
macroLAYER_35 = extend_edge( macroLAYER_18, start = DMX1_MX45, end = DMX1_MX45 );
macroLAYER_17 = edge_size( macroLAYER_35, outside = DMX1_MX45 );
macroLAYER_16 = size( macroLAYER_17, clip_acute = TRUNCATE, distance = GRID ); 
M1_45 = M1_MAIN or macroLAYER_16; 

M1_HOLE = donut_holes( M1_MAIN, area = < MX1HOLE, holes = INNER, outer_boundary_point_touch = CLOSED_OUTER_BOUNDARY ); 


macroLAYER_25 = length_edge( M1_EDGE_END, [ 0.0285, 0.0405 ) ); 
macroLAYER_24 = edge_size( macroLAYER_25, inside = 0.001, outside = 0.001 );
M1_LT405 = interacting( M1_MAIN, macroLAYER_24 ); 



macroLAYER_25 = length_edge( M1_EDGE_END, [ 0.0405, 0.16 ) ); 
macroLAYER_24 = edge_size( macroLAYER_25, inside = 0.001, outside = 0.001 );
M1_LT160 = interacting( M1_MAIN, macroLAYER_24 ); 



macroLAYER_23 = length_edge( M1_EDGE_END, >= 0.16 ); 
macroLAYER_22 = edge_size( macroLAYER_23, inside = 0.001, outside = 0.001 );
M1_GE160 = interacting( M1_MAIN, macroLAYER_22 ); 



macroLAYER_23 = length_edge( DM1_EDGE_END, >= 0.091 ); 
macroLAYER_22 = edge_size( macroLAYER_23, inside = 0.001, outside = 0.001 );
DM1_GE91 = interacting( DM1, macroLAYER_22 ); 


M1_096V_LE = M1_HVN_096V ; 
M1_096V_OE = M1_HVN_096V ; 
M1_198V_LE = M1_HVN_198V ; 
M1_198V_OE = M1_HVN_198V ; 

#ifdef DMY_Boundary_Control 
   BEOLBLK_FINAL_NOM1 = not_interacting( BEOLBLK_FINAL, ( ALL_M1 and size( BEOLBLK_FINAL, clip_acute = TRUNCATE, distance = - 0.09 ) ) ); 
   DM1EXCL_FINAL_NOM1 = not_interacting( DM1EXCL_FINAL, ( ALL_M1 and size( DM1EXCL_FINAL, clip_acute = TRUNCATE, distance = - 0.09 ) ) ); 
#else
   BEOLBLK_FINAL_NOM1 = BEOLBLK_FINAL or size( gEMPTY, clip_acute = TRUNCATE, distance = - 0.11 ); 
   DM1EXCL_FINAL_NOM1 = DM1EXCL_FINAL or gEMPTY; 
#endif




//  OPC DVIA_O
SQ_VIA0 = rectangles( VIA0, orientation = ORTHOGONAL, sides = { == 0.02, == 0.02 } ); 





M2_LT285 = wide( M2_MAIN, < 0.0285, angled = TRUNCATE ); 
M2_LT40 = wide( M2_MAIN, < 0.04, angled = TRUNCATE ); 

#ifdef VERTICAL_M2
M2_EDGE_END = angle_edge( M2_MAIN, == 0 ); 
M2CA_EDGE_END = angle_edge( M2_MAIN_CA, == 0 ); 
M2CB_EDGE_END = angle_edge( M2_MAIN_CB, == 0 ); 
DM2_EDGE_END = angle_edge( DM2, == 0 ); 

#else
M2_EDGE_END = angle_edge( M2_MAIN, == 90 ); 
M2CA_EDGE_END = angle_edge( M2_MAIN_CA, == 90 ); 
M2CB_EDGE_END = angle_edge( M2_MAIN_CB, == 90 ); 
DM2_EDGE_END = angle_edge( DM2, == 90 ); 

#endif

   M2CA_LE = M2_MAIN_CA not M2_LT40;
   M2CB_LE = M2_MAIN_CB not M2_LT40;


macroLAYER_18 = angle_edge( M2_MAIN, == 45 ); 
macroLAYER_35 = extend_edge( macroLAYER_18, start = DMX1_MX45, end = DMX1_MX45 );
macroLAYER_17 = edge_size( macroLAYER_35, outside = DMX1_MX45 );
macroLAYER_16 = size( macroLAYER_17, clip_acute = TRUNCATE, distance = GRID ); 
M2_45 = M2_MAIN or macroLAYER_16; 

M2_HOLE = donut_holes( M2_MAIN, area = < MX1HOLE, holes = INNER, outer_boundary_point_touch = CLOSED_OUTER_BOUNDARY ); 


macroLAYER_25 = length_edge( M2_EDGE_END, [ 0.0405, 0.16 ) ); 
macroLAYER_24 = edge_size( macroLAYER_25, inside = 0.001, outside = 0.001 );
M2_LT160 = interacting( M2_MAIN, macroLAYER_24 ); 



macroLAYER_23 = length_edge( M2_EDGE_END, >= 0.16 ); 
macroLAYER_22 = edge_size( macroLAYER_23, inside = 0.001, outside = 0.001 );
M2_GE160 = interacting( M2_MAIN, macroLAYER_22 ); 


macroLAYER_25 = length_edge( M2_EDGE_END, [ 0.0285, 0.0405 ) ); 
macroLAYER_24 = edge_size( macroLAYER_25, inside = 0.001, outside = 0.001 );
M2_LT405 = interacting( M2_MAIN, macroLAYER_24 ); 


M2CA_LT285 = wide( M2_MAIN_CA, < 0.0285, angled = TRUNCATE ); 
macroLAYER_25 = length_edge( M2CA_EDGE_END, [ 0.0285, 0.0405 ) ); 
macroLAYER_24 = edge_size( macroLAYER_25, inside = 0.001, outside = 0.001 );
M2CA_LT405 = interacting( M2_MAIN_CA, macroLAYER_24 ); 


macroLAYER_25 = length_edge( M2CA_EDGE_END, [ 0.0405, 0.16 ) ); 
macroLAYER_24 = edge_size( macroLAYER_25, inside = 0.001, outside = 0.001 );
M2CA_LT160 = interacting( M2_MAIN_CA, macroLAYER_24 ); 



macroLAYER_23 = length_edge( M2CA_EDGE_END, >= 0.16 ); 
macroLAYER_22 = edge_size( macroLAYER_23, inside = 0.001, outside = 0.001 );
M2CA_GE160 = interacting( M2_MAIN_CA, macroLAYER_22 ); 


M2CB_LT285 = wide( M2_MAIN_CB, < 0.0285, angled = TRUNCATE ); 
macroLAYER_25 = length_edge( M2CB_EDGE_END, [ 0.0285, 0.0405 ) ); 
macroLAYER_24 = edge_size( macroLAYER_25, inside = 0.001, outside = 0.001 );
M2CB_LT405 = interacting( M2_MAIN_CB, macroLAYER_24 ); 



macroLAYER_25 = length_edge( M2CB_EDGE_END, [ 0.0405, 0.16 ) ); 
macroLAYER_24 = edge_size( macroLAYER_25, inside = 0.001, outside = 0.001 );
M2CB_LT160 = interacting( M2_MAIN_CB, macroLAYER_24 ); 



macroLAYER_23 = length_edge( M2CB_EDGE_END, >= 0.16 ); 
macroLAYER_22 = edge_size( macroLAYER_23, inside = 0.001, outside = 0.001 );
M2CB_GE160 = interacting( M2_MAIN_CB, macroLAYER_22 ); 



macroLAYER_23 = length_edge( DM2_EDGE_END, >= 0.091 ); 
macroLAYER_22 = edge_size( macroLAYER_23, inside = 0.001, outside = 0.001 );
DM2_GE91 = interacting( DM2, macroLAYER_22 ); 



#ifdef DMY_Boundary_Control
   BEOLBLK_FINAL_NOM2 = not_interacting( BEOLBLK_FINAL, ( ALL_M2 and size( BEOLBLK_FINAL, clip_acute = TRUNCATE, distance = - 0.09 ) ) ); 
   DM2EXCL_FINAL_NOM2 = not_interacting( DM2EXCL_FINAL, ( ALL_M2 and size( DM2EXCL_FINAL, clip_acute = TRUNCATE, distance = - 0.09 ) ) ); 
#else
   BEOLBLK_FINAL_NOM2 = BEOLBLK_FINAL or size( gEMPTY, clip_acute = TRUNCATE, distance = - 0.12 ); 
   DM2EXCL_FINAL_NOM2 = DM2EXCL_FINAL or gEMPTY; 
#endif
//  OPC DVIA_O
SQ_VIA1 = rectangles( VIA1, orientation = ORTHOGONAL, sides = { == 0.02, == 0.02 } ); 



#ifdef VERTICAL_M3
M3_EDGE_END = angle_edge( M3_MAIN, == 0 ); 
   M3_MAIN_LE = M3_MAIN;
DM3_EDGE_END = angle_edge( DM3, == 0 ); 

#ifdef FULL_CHIP
M3_BOUNDARY_INSIDE2 = edge_size( angle_edge( CHIP_BOUNDARY, == 90 ), inside = 0.5 ); 
#else
M3_BOUNDARY_INSIDE2 = edge_size( angle_edge( PRBOUNDARY, == 90 ), inside = 0.5 ); 
#endif
M3_BLK_OUTSIDE = edge_size( angle_edge( ( DM3EXCL_FINAL or BEOLBLK_FINAL ), == 90 ), outside = 0.5 ); 

#else
M3_EDGE_END = angle_edge( M3_MAIN, == 90 ); 
   M3_MAIN_LE = M3_MAIN;
DM3_EDGE_END = angle_edge( DM3, == 90 ); 

#ifdef FULL_CHIP
M3_BOUNDARY_INSIDE2 = edge_size( angle_edge( CHIP_BOUNDARY, == 0 ), inside = 0.5 ); 
#else
M3_BOUNDARY_INSIDE2 = edge_size( angle_edge( PRBOUNDARY, == 0 ), inside = 0.5 ); 
#endif
M3_BLK_OUTSIDE = edge_size( angle_edge( ( DM3EXCL_FINAL or BEOLBLK_FINAL ), == 0 ), outside = 0.5 ); 

#endif

M3_096V_LE = M3_HVN_096V ; 
M3_096V_OE = M3_HVN_096V ; 
M3_198V_LE = M3_HVN_198V ; 
M3_198V_OE = M3_HVN_198V ; 


M3_HVN_096V_H = angle_edge( M3_HVN_096V, == 0 ); 
M3_HVN_096V_V = angle_edge( M3_HVN_096V, == 90 ); 
M3_HVN_198V_H = angle_edge( M3_HVN_198V, == 0 ); 
M3_HVN_198V_V = angle_edge( M3_HVN_198V, == 90 ); 

M3_HVN_096VP = not_interacting( M3_HVN_096V, ( M3_BOUNDARY_INSIDE2 or M3_BLK_OUTSIDE ) ); 
M3_HVN_132VP = not_interacting( M3_HVN_132V, ( M3_BOUNDARY_INSIDE2 or M3_BLK_OUTSIDE ) ); 
M3_HVN_165VP = not_interacting( M3_HVN_165V, ( M3_BOUNDARY_INSIDE2 or M3_BLK_OUTSIDE ) ); 
M3_HVN_198VP = not_interacting( M3_HVN_198V, ( M3_BOUNDARY_INSIDE2 or M3_BLK_OUTSIDE ) ); 
M3_HVN_275VP = not_interacting( M3_HVN_275V, ( M3_BOUNDARY_INSIDE2 or M3_BLK_OUTSIDE ) ); 

VIA2_HVN_096VP = not_interacting( VIA2_HVN_096V, ( M3_BOUNDARY_INSIDE2 or M3_BLK_OUTSIDE ) ); 
VIA2_HVN_132VP = not_interacting( VIA2_HVN_132V, ( M3_BOUNDARY_INSIDE2 or M3_BLK_OUTSIDE ) ); 
VIA2_HVN_165VP = not_interacting( VIA2_HVN_165V, ( M3_BOUNDARY_INSIDE2 or M3_BLK_OUTSIDE ) ); 
VIA2_HVN_198VP = not_interacting( VIA2_HVN_198V, ( M3_BOUNDARY_INSIDE2 or M3_BLK_OUTSIDE ) ); 
VIA2_HVN_275VP = not_interacting( VIA2_HVN_275V, ( M3_BOUNDARY_INSIDE2 or M3_BLK_OUTSIDE ) ); 

VIA3_HVN_096VPT = not_interacting( VIA3_HVN_096V, ( M3_BOUNDARY_INSIDE2 or M3_BLK_OUTSIDE ) ); 
VIA3_HVN_132VPT = not_interacting( VIA3_HVN_132V, ( M3_BOUNDARY_INSIDE2 or M3_BLK_OUTSIDE ) ); 
VIA3_HVN_165VPT = not_interacting( VIA3_HVN_165V, ( M3_BOUNDARY_INSIDE2 or M3_BLK_OUTSIDE ) ); 
VIA3_HVN_198VPT = not_interacting( VIA3_HVN_198V, ( M3_BOUNDARY_INSIDE2 or M3_BLK_OUTSIDE ) ); 
VIA3_HVN_275VPT = not_interacting( VIA3_HVN_275V, ( M3_BOUNDARY_INSIDE2 or M3_BLK_OUTSIDE ) ); 
M3_GE100 = interacting( M3_MAIN, edge_size( length_edge( M3_EDGE_END, >= 0.1 ), inside = 0.001, outside = 0.001 ) ); 

macroLAYER_23 = length_edge( DM3_EDGE_END, >= 0.091 ); 
macroLAYER_22 = edge_size( macroLAYER_23, inside = 0.001, outside = 0.001 );
DM3_GE91 = interacting( DM3, macroLAYER_22 ); 



macroLAYER_18 = angle_edge( M3_MAIN, == 45 ); 
macroLAYER_35 = extend_edge( macroLAYER_18, start = 0.251, end = 0.251 );
macroLAYER_17 = edge_size( macroLAYER_35, outside = 0.251 );
macroLAYER_16 = size( macroLAYER_17, clip_acute = TRUNCATE, distance = GRID ); 
M3_45 = M3_MAIN or macroLAYER_16; 

M3_HOLE = donut_holes( M3_MAIN, area = < MX1HOLE, holes = INNER, outer_boundary_point_touch = CLOSED_OUTER_BOUNDARY ); 
M3_LT22 = wide( M3_MAIN, < 0.022, angled = TRUNCATE ); 
M3_GE22 = M3_MAIN not M3_LT22; 

CHIP_BLOCK_M3 = size( ( DM3EXCL_FINAL or BEOLBLK_FINAL ), clip_acute = TRUNCATE, distance = 1 ); 
CHIP_SMALL_M3 = external2( ( CHIP_BOUND_REG or CHIP_BLOCK_M3 ), CHIP_BLOCK_M3, < 0.35, edge_containment = OUTSIDE, extension = NONE, intersecting = {  }, look_thru = NOT_ADJACENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
CHIP_BOUND_REG_M3 = or_list( { CHIP_BOUND_REG, CHIP_BLOCK_M3, CHIP_SMALL_M3 } ); 


M3DX = M3_MAIN_H or DM3_O_H; 
M3DY = M3_MAIN_V or DM3_O_V; 

M3DX_GROUP_W48_PRE_1_20 = error_merge_list( { internal1_error( angle_edge( M3DX, == 00  ), == 0.048, direction = VERTICAL , extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M3DX_GROUP_W48_PRE_2_20 = error_merge_list( { internal1_error( angle_edge( BLK_M3, == 00  ), == 0.049, direction = VERTICAL , extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M3DX_GROUP_W48_PRE_20 = shrink( grow( interacting( M3DX_GROUP_W48_PRE_1_20, M3DX_GROUP_W48_PRE_2_20 ), north = 0.019, south = 0.019 ), north = 0.019, south = 0.019 ); 
M3DX_GROUP_W48_20 = M3DX_GROUP_W48_PRE_20 not error_merge_list( { internal1_error( angle_edge( M3DX_GROUP_W48_PRE_20, == 00  ), == 0.048, direction = VERTICAL , extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 

M3DY_GROUP_W48_PRE_1_20 = error_merge_list( { internal1_error( angle_edge( M3DY, == 90  ), == 0.048, direction = HORIZONTAL , extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M3DY_GROUP_W48_PRE_2_20 = error_merge_list( { internal1_error( angle_edge( BLK_M3, == 90  ), == 0.049, direction = HORIZONTAL , extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M3DY_GROUP_W48_PRE_20 = shrink( grow( interacting( M3DY_GROUP_W48_PRE_1_20, M3DY_GROUP_W48_PRE_2_20 ), east = 0.019, west = 0.019 ), east = 0.019, west = 0.019 ); 
M3DY_GROUP_W48_20 = M3DY_GROUP_W48_PRE_20 not error_merge_list( { internal1_error( angle_edge( M3DY_GROUP_W48_PRE_20, == 90  ), == 0.048, direction = HORIZONTAL , extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 

M3_GROUP_W48_20 = M3DX_GROUP_W48_20 or M3DY_GROUP_W48_20; 



//  OPC DVIA_O
SQ_VIA2 = rectangles( VIA2, orientation = ORTHOGONAL, sides = { == 0.02, == 0.02 } ); 



#ifdef VERTICAL_M4
M4_EDGE_END = angle_edge( M4_MAIN, == 0 ); 
   M4_MAIN_LE = M4_MAIN;
DM4_EDGE_END = angle_edge( DM4, == 0 ); 

#ifdef FULL_CHIP
M4_BOUNDARY_INSIDE2 = edge_size( angle_edge( CHIP_BOUNDARY, == 90 ), inside = 0.5 ); 
#else
M4_BOUNDARY_INSIDE2 = edge_size( angle_edge( PRBOUNDARY, == 90 ), inside = 0.5 ); 
#endif
M4_BLK_OUTSIDE = edge_size( angle_edge( ( DM4EXCL_FINAL or BEOLBLK_FINAL ), == 90 ), outside = 0.5 ); 

#else
M4_EDGE_END = angle_edge( M4_MAIN, == 90 ); 
   M4_MAIN_LE = M4_MAIN;
DM4_EDGE_END = angle_edge( DM4, == 90 ); 

#ifdef FULL_CHIP
M4_BOUNDARY_INSIDE2 = edge_size( angle_edge( CHIP_BOUNDARY, == 0 ), inside = 0.5 ); 
#else
M4_BOUNDARY_INSIDE2 = edge_size( angle_edge( PRBOUNDARY, == 0 ), inside = 0.5 ); 
#endif
M4_BLK_OUTSIDE = edge_size( angle_edge( ( DM4EXCL_FINAL or BEOLBLK_FINAL ), == 0 ), outside = 0.5 ); 

#endif

M4_096V_LE = M4_HVN_096V ; 
M4_096V_OE = M4_HVN_096V ; 
M4_198V_LE = M4_HVN_198V ; 
M4_198V_OE = M4_HVN_198V ; 


M4_HVN_096V_H = angle_edge( M4_HVN_096V, == 0 ); 
M4_HVN_096V_V = angle_edge( M4_HVN_096V, == 90 ); 
M4_HVN_198V_H = angle_edge( M4_HVN_198V, == 0 ); 
M4_HVN_198V_V = angle_edge( M4_HVN_198V, == 90 ); 

M4_HVN_096VP = not_interacting( M4_HVN_096V, ( M4_BOUNDARY_INSIDE2 or M4_BLK_OUTSIDE ) ); 
M4_HVN_132VP = not_interacting( M4_HVN_132V, ( M4_BOUNDARY_INSIDE2 or M4_BLK_OUTSIDE ) ); 
M4_HVN_165VP = not_interacting( M4_HVN_165V, ( M4_BOUNDARY_INSIDE2 or M4_BLK_OUTSIDE ) ); 
M4_HVN_198VP = not_interacting( M4_HVN_198V, ( M4_BOUNDARY_INSIDE2 or M4_BLK_OUTSIDE ) ); 
M4_HVN_275VP = not_interacting( M4_HVN_275V, ( M4_BOUNDARY_INSIDE2 or M4_BLK_OUTSIDE ) ); 

VIA3_HVN_096VP = not_interacting( VIA3_HVN_096V, ( M4_BOUNDARY_INSIDE2 or M4_BLK_OUTSIDE ) ); 
VIA3_HVN_132VP = not_interacting( VIA3_HVN_132V, ( M4_BOUNDARY_INSIDE2 or M4_BLK_OUTSIDE ) ); 
VIA3_HVN_165VP = not_interacting( VIA3_HVN_165V, ( M4_BOUNDARY_INSIDE2 or M4_BLK_OUTSIDE ) ); 
VIA3_HVN_198VP = not_interacting( VIA3_HVN_198V, ( M4_BOUNDARY_INSIDE2 or M4_BLK_OUTSIDE ) ); 
VIA3_HVN_275VP = not_interacting( VIA3_HVN_275V, ( M4_BOUNDARY_INSIDE2 or M4_BLK_OUTSIDE ) ); 

VIA4_HVN_096VPT = not_interacting( VIA4_HVN_096V, ( M4_BOUNDARY_INSIDE2 or M4_BLK_OUTSIDE ) ); 
VIA4_HVN_132VPT = not_interacting( VIA4_HVN_132V, ( M4_BOUNDARY_INSIDE2 or M4_BLK_OUTSIDE ) ); 
VIA4_HVN_165VPT = not_interacting( VIA4_HVN_165V, ( M4_BOUNDARY_INSIDE2 or M4_BLK_OUTSIDE ) ); 
VIA4_HVN_198VPT = not_interacting( VIA4_HVN_198V, ( M4_BOUNDARY_INSIDE2 or M4_BLK_OUTSIDE ) ); 
VIA4_HVN_275VPT = not_interacting( VIA4_HVN_275V, ( M4_BOUNDARY_INSIDE2 or M4_BLK_OUTSIDE ) ); 
M4_GE100 = interacting( M4_MAIN, edge_size( length_edge( M4_EDGE_END, >= 0.1 ), inside = 0.001, outside = 0.001 ) ); 

macroLAYER_23 = length_edge( DM4_EDGE_END, >= 0.091 ); 
macroLAYER_22 = edge_size( macroLAYER_23, inside = 0.001, outside = 0.001 );
DM4_GE91 = interacting( DM4, macroLAYER_22 ); 



macroLAYER_18 = angle_edge( M4_MAIN, == 45 ); 
macroLAYER_35 = extend_edge( macroLAYER_18, start = 0.251, end = 0.251 );
macroLAYER_17 = edge_size( macroLAYER_35, outside = 0.251 );
macroLAYER_16 = size( macroLAYER_17, clip_acute = TRUNCATE, distance = GRID ); 
M4_45 = M4_MAIN or macroLAYER_16; 

M4_HOLE = donut_holes( M4_MAIN, area = < MX1HOLE, holes = INNER, outer_boundary_point_touch = CLOSED_OUTER_BOUNDARY ); 
M4_LT22 = wide( M4_MAIN, < 0.022, angled = TRUNCATE ); 
M4_GE22 = M4_MAIN not M4_LT22; 

CHIP_BLOCK_M4 = size( ( DM4EXCL_FINAL or BEOLBLK_FINAL ), clip_acute = TRUNCATE, distance = 1 ); 
CHIP_SMALL_M4 = external2( ( CHIP_BOUND_REG or CHIP_BLOCK_M4 ), CHIP_BLOCK_M4, < 0.35, edge_containment = OUTSIDE, extension = NONE, intersecting = {  }, look_thru = NOT_ADJACENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
CHIP_BOUND_REG_M4 = or_list( { CHIP_BOUND_REG, CHIP_BLOCK_M4, CHIP_SMALL_M4 } ); 




//  OPC DVIA_O
SQ_VIA3 = rectangles( VIA3, orientation = ORTHOGONAL, sides = { == 0.02, == 0.02 } ); 

VIA3_18 = rectangles( VIA3, orientation = ORTHOGONAL, sides = { == 0.018, == 0.018 } ); 
BIG_VIA3 = VIA3 not VIA3_18; 
SLOT_VIA3 = rectangles( VIA3, orientation = ORTHOGONAL, sides = { == 0.018, == 0.034 } ); 




M5_HOLE = donut_holes( M5, area = < MX3HOLE, holes = INNER, outer_boundary_point_touch = CLOSED_OUTER_BOUNDARY ); 
M5_MAIN_EDGEH = angle_edge( M5_MAIN, == 0 ); 
M5_MAIN_EDGEV = angle_edge( M5_MAIN, == 90 ); 

macroLAYER_18 = angle_edge( M5_MAIN, == 45 ); 
macroLAYER_35 = extend_edge( macroLAYER_18, start = DMX3_MX45, end = DMX3_MX45 );
macroLAYER_17 = edge_size( macroLAYER_35, outside = DMX3_MX45 );
macroLAYER_16 = size( macroLAYER_17, clip_acute = TRUNCATE, distance = GRID ); 
M5_45 = M5_MAIN or macroLAYER_16; 


M5_LT245 = wide( M5_MAIN, < 0.0245, angled = TRUNCATE ); 
M5_LT60 = not( wide( M5_MAIN, >= 0.0245, angled = TRUNCATE ), wide( M5_MAIN, >= 0.06, angled = TRUNCATE ) ); 

#ifdef VERTICAL_M5
M5_EDGE_END = angle_edge( ( M5_MAIN not ( M5_LT245 or M5_LT60 ) ), == 0 ); 
M5CA_EDGE_END = angle_edge( ( M5_MAIN_CA not ( M5_LT245 or M5_LT60 ) ), == 0 ); 
M5CB_EDGE_END = angle_edge( ( M5_MAIN_CB not ( M5_LT245 or M5_LT60 ) ), == 0 ); 
#else
M5_EDGE_END = angle_edge( ( M5_MAIN not ( M5_LT245 or M5_LT60 ) ), == 90 ); 
M5CA_EDGE_END = angle_edge( ( M5_MAIN_CA not ( M5_LT245 or M5_LT60 ) ), == 90 ); 
M5CB_EDGE_END = angle_edge( ( M5_MAIN_CB not ( M5_LT245 or M5_LT60 ) ), == 90 ); 
#endif
   M5_MAIN_LE = M5_MAIN;



macroLAYER_25 = length_edge( M5_EDGE_END, [ 0.06, 0.10 ) ); 
macroLAYER_24 = edge_size( macroLAYER_25, inside = 0.001, outside = 0.001 );
M5_LT100 = interacting( M5_MAIN, macroLAYER_24 ); 



macroLAYER_25 = length_edge( M5_EDGE_END, [ 0.10, 0.14 ) ); 
macroLAYER_24 = edge_size( macroLAYER_25, inside = 0.001, outside = 0.001 );
M5_LT140 = interacting( M5_MAIN, macroLAYER_24 ); 



macroLAYER_25 = length_edge( M5_EDGE_END, [ 0.14, 0.18 ) ); 
macroLAYER_24 = edge_size( macroLAYER_25, inside = 0.001, outside = 0.001 );
M5_LT180 = interacting( M5_MAIN, macroLAYER_24 ); 



macroLAYER_25 = length_edge( M5_EDGE_END, [ 0.18, 0.26 ) ); 
macroLAYER_24 = edge_size( macroLAYER_25, inside = 0.001, outside = 0.001 );
M5_LT260 = interacting( M5_MAIN, macroLAYER_24 ); 



macroLAYER_23 = length_edge( M5_EDGE_END, >= 0.26 ); 
macroLAYER_22 = edge_size( macroLAYER_23, inside = 0.001, outside = 0.001 );
M5_GE260 = interacting( M5_MAIN, macroLAYER_22 ); 


M5CA_LT245 = wide( M5_MAIN_CA, < 0.0245, forty_five = INTERNAL ); 
gdLAYER_73 = wide( M5_MAIN_CA, >= 0.0245, forty_five = INTERNAL ); 
gdLAYER_74 = wide( M5_MAIN_CA, >= 0.06, forty_five = INTERNAL ); 
M5CA_LT60 = not( gdLAYER_73, gdLAYER_74 ); 

macroLAYER_25 = length_edge( M5CA_EDGE_END, [ 0.06, 0.10 ) ); 
macroLAYER_24 = edge_size( macroLAYER_25, inside = 0.001, outside = 0.001 );
M5CA_LT100 = interacting( M5_MAIN_CA, macroLAYER_24 ); 



macroLAYER_25 = length_edge( M5CA_EDGE_END, [ 0.10, 0.14 ) ); 
macroLAYER_24 = edge_size( macroLAYER_25, inside = 0.001, outside = 0.001 );
M5CA_LT140 = interacting( M5_MAIN_CA, macroLAYER_24 ); 



macroLAYER_25 = length_edge( M5CA_EDGE_END, [ 0.14, 0.18 ) ); 
macroLAYER_24 = edge_size( macroLAYER_25, inside = 0.001, outside = 0.001 );
M5CA_LT180 = interacting( M5_MAIN_CA, macroLAYER_24 ); 



macroLAYER_25 = length_edge( M5CA_EDGE_END, [ 0.18, 0.26 ) ); 
macroLAYER_24 = edge_size( macroLAYER_25, inside = 0.001, outside = 0.001 );
M5CA_LT260 = interacting( M5_MAIN_CA, macroLAYER_24 ); 


M5CB_LT245 = wide( M5_MAIN_CB, < 0.0245, forty_five = INTERNAL ); 
gdLAYER_75 = wide( M5_MAIN_CB, >= 0.0245, forty_five = INTERNAL ); 
gdLAYER_76 = wide( M5_MAIN_CB, >= 0.06, forty_five = INTERNAL ); 
M5CB_LT60 = not( gdLAYER_75, gdLAYER_76 ); 

macroLAYER_25 = length_edge( M5CB_EDGE_END, [ 0.06, 0.10 ) ); 
macroLAYER_24 = edge_size( macroLAYER_25, inside = 0.001, outside = 0.001 );
M5CB_LT100 = interacting( M5_MAIN_CB, macroLAYER_24 ); 



macroLAYER_25 = length_edge( M5CB_EDGE_END, [ 0.10, 0.14 ) ); 
macroLAYER_24 = edge_size( macroLAYER_25, inside = 0.001, outside = 0.001 );
M5CB_LT140 = interacting( M5_MAIN_CB, macroLAYER_24 ); 



macroLAYER_25 = length_edge( M5CB_EDGE_END, [ 0.14, 0.18 ) ); 
macroLAYER_24 = edge_size( macroLAYER_25, inside = 0.001, outside = 0.001 );
M5CB_LT180 = interacting( M5_MAIN_CB, macroLAYER_24 ); 



macroLAYER_25 = length_edge( M5CB_EDGE_END, [ 0.18, 0.26 ) ); 
macroLAYER_24 = edge_size( macroLAYER_25, inside = 0.001, outside = 0.001 );
M5CB_LT260 = interacting( M5_MAIN_CB, macroLAYER_24 ); 


DM5_O_S = wide( DM5_O, < 0.06, forty_five = INTERNAL ); 
DM5_O_B = wide( DM5_O, >= 0.06, forty_five = INTERNAL ); 
M5_180_OW = wide( M5_MAIN, >= 0.18, forty_five = INTERNAL );    /* DMn.S.2.6 */ 
M5_260_OW = wide( M5_MAIN, >= 0.26, forty_five = INTERNAL );    /* DMn.S.2.7 */ 

#ifdef VERTICAL_M5
M5_S42_LENGTH = angle_edge( length_edge( M5_MAIN, == 0.06 ), == 90 ); 
M5_260_BIG = length_edge( angle_edge( M5_GE260, == 0 ), >= 1 ); 
M5_260_SIZE = grow( grow( grow( grow( M5_GE260, north = 0.13 ), west = 0.26 ), south = 0.13 ), east = 0.26 ); 

#else
M5_S42_LENGTH = angle_edge( length_edge( M5_MAIN, == 0.06 ), == 0 ); 
M5_260_BIG = length_edge( angle_edge( M5_GE260, == 90 ), >= 1 ); 
M5_260_SIZE = grow( grow( grow( grow( M5_GE260, north = 0.26 ), west = 0.13 ), south = 0.26 ), east = 0.13 ); 

#endif
M5_S42 = edge_size( extend_edge( M5_S42_LENGTH, start = 0.040, end = 0.040 ), outside = 0.128 );    /* Mx3.S.4.2 width = 0.06 , DMn.S.2.4 */ 


//  OPC DVIA_O
SQ_VIA4 = rectangles( VIA4, orientation = ORTHOGONAL, sides = { == 0.02, == 0.02 } ); 

SLOT_VIA4 = rectangles( VIA4, orientation = ORTHOGONAL, sides = { == 0.018, == 0.034 } ); 
BIG_VIA4 = rectangles( VIA4, orientation = ORTHOGONAL, sides = { == 0.02, == 0.02 } ); 




M6_HOLE = donut_holes( M6, area = < MY1HOLE, holes = INNER, outer_boundary_point_touch = CLOSED_OUTER_BOUNDARY ); 
M6_GT76 = wide( M6, > MY1W1, angled = TRUNCATE ); 
M6_GT114 = wide( M6, > MY1W2, angled = TRUNCATE ); 
M6_GT152 = wide( M6, > MY1W3, angled = TRUNCATE ); 
M6_GT180 = wide( M6, > MY1W4, angled = TRUNCATE ); 
M6_GT240 = wide( M6, > MY1W5, angled = TRUNCATE ); 
M6_GT280 = wide( M6, > MY1W6, angled = TRUNCATE ); 
M6_GT500 = wide( M6, > MY1W7, angled = TRUNCATE ); 
M6_GT1350 = wide( M6, > MY1W8, angled = TRUNCATE ); 

macroLAYER_18 = angle_edge( M6, == 45 ); 
macroLAYER_35 = extend_edge( macroLAYER_18, start = 0.41, end = 0.41 );
macroLAYER_17 = edge_size( macroLAYER_35, outside = DMY1_MY145 );
macroLAYER_16 = size( macroLAYER_17, clip_acute = TRUNCATE, distance = GRID ); 
M6_45 = M6 or macroLAYER_16; 

M6_38 = wide( M6, == MY138, angled = TRUNCATE );    /* My1.S.27 */ 
M6_40 = wide( M6, == MY140, angled = TRUNCATE );    /* My1.S.27.1 */ 
M6_60 = wide( M6, == MY160, angled = TRUNCATE ); 
M6_80 = wide( M6, == 0.08, angled = TRUNCATE ); 
M6_120 = wide( M6, == 0.12, angled = TRUNCATE ); 

DM6_GT1350 = wide( DM6, > 1.35, angled = TRUNCATE );    /* DMn.S.3.1 */ 

#ifdef VERTICAL_M6
S22_M6_EDGE_45 = angle_edge( M6, == 45 ); 
S22_M6_E1 = adjacent_edge( M6, angle1 = == 270, angle2 = == 270, length = < 0.114 ); 
S22_M6_E2 = length_edge( M6, <= 0.038 ); 
S22_M6_A1 = polygon_extents( not_touching( external1( M6, <= GRID, extension = RADIAL, intersecting = {  }, intersection_angle = == 90, look_thru = NOT_ADJACENT, orientation = { } ), S22_M6_EDGE_45, == 2 ) ); 
S22_M6_A1Y = interacting( S22_M6_A1, M6 ); 
S22_M6_AY = not_interacting( S22_M6_A1Y, edge_size( ( S22_M6_E1 or_edge S22_M6_E2 ), outside = GRID ) ); 
S22_M6_AY_EDGE = S22_M6_AY coincident_edge M6; 
S22_M6_AY_EDGE_V = angle_edge( S22_M6_AY_EDGE, == 90 ); 
S22_M6_AY_REGION_1 = edge_size( S22_M6_AY_EDGE_V, inside = 0.114 ); 
S22_M6_AY_EDGE_H = angle_edge( ( S22_M6_AY_REGION_1 touching_edge M6 ), == 0 ); 
S22_M6_REGION = edge_size( S22_M6_AY_EDGE_H, inside = 0.200 );    /* 0.114x0.200 */ 

#else
S22_M6_EDGE_45 = angle_edge( M6, == 45 ); 
S22_M6_E1 = adjacent_edge( M6, angle1 = == 270, angle2 = == 270, length = < 0.114 ); 
S22_M6_E2 = length_edge( M6, <= 0.038 ); 
S22_M6_A1 = polygon_extents( not_touching( external1( M6, <= GRID, extension = RADIAL, intersecting = {  }, intersection_angle = == 90, look_thru = NOT_ADJACENT, orientation = { } ), S22_M6_EDGE_45, == 2 ) ); 
S22_M6_A1X = interacting( S22_M6_A1, M6 ); 
S22_M6_AX = not_interacting( S22_M6_A1X, edge_size( ( S22_M6_E1 or_edge S22_M6_E2 ), outside = GRID ) ); 
S22_M6_AX_EDGE = S22_M6_AX coincident_edge M6; 
S22_M6_AX_EDGE_H = angle_edge( S22_M6_AX_EDGE, == 0 ); 
S22_M6_AX_REGION_1 = edge_size( S22_M6_AX_EDGE_H, inside = 0.114 ); 
S22_M6_AX_EDGE_V = angle_edge( ( S22_M6_AX_REGION_1 touching_edge M6 ), == 90 ); 
S22_M6_REGION = edge_size( S22_M6_AX_EDGE_V, inside = 0.200 );    /* 0.114x0.200 */ 

#endif
R7_VIA5_ENC1 = VIA5 touching_edge enclose_edge( VIA5, M6, < 0.01, edge_containment = INSIDE_TO_OUTSIDE, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, output_layer = LAYER1, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
R7_VIA5_ENC2 = internal2_edge( R7_VIA5_ENC1, VIA5, <= 0.05, edge_containment = INSIDE, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, membership = SAME_POLYGON, output_layer = LAYER2, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
R7_VIA5_EP_PRE1 = ( VIA5 touching_edge R7_VIA5_ENC1 ) or_edge ( VIA5 touching_edge R7_VIA5_ENC2 ); 
R7_VIA5_EP_PRE2 = enclose_edge( R7_VIA5_EP_PRE1, M5, < 0.05, edge_containment = INSIDE_TO_OUTSIDE, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, output_layer = LAYER1, projection = { IN, ON }, orientation = { PARALLEL }); 
R7_VIA5_EP = VIA5 touching R7_VIA5_EP_PRE2; 
R7_VIA5_CHK_REGION = edge_size( extend_edge( ( R7_VIA5_EP touching_edge R7_VIA5_EP_PRE1 ), start = 0.300, end = 0.300 ), outside = 0.085 ); 


R15_VIA6_ENC1 = VIA6 touching_edge enclose_edge( VIA6, M6, < 0.001, edge_containment = INSIDE_TO_OUTSIDE, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, output_layer = LAYER1, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
R15_VIA6_ENC2 = internal2_edge( R15_VIA6_ENC1, VIA6, <= 0.1, edge_containment = INSIDE, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, membership = SAME_POLYGON, output_layer = LAYER2, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
R15_VIA6_EP_PRE1 = ( VIA6 touching_edge R15_VIA6_ENC1 ) or_edge ( VIA6 touching_edge R15_VIA6_ENC2 ); 
R15_VIA6_EP_PRE2 = enclose_edge( R15_VIA6_EP_PRE1, M7, < 0.065, edge_containment = INSIDE_TO_OUTSIDE, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, output_layer = LAYER1, projection = { IN, ON }, orientation = { PARALLEL } ); 
R15_VIA6_EP = VIA6 touching R15_VIA6_EP_PRE2; 
R15_VIA6_CHK_REGION = edge_size( extend_edge( ( R15_VIA6_EP touching_edge R15_VIA6_EP_PRE1 ), start = 0.300, end = 0.300 ), outside = 0.076 ); 



M6_PG_31_H_PRE1 = error_merge_list( { internal1_error( angle_edge( M6_MAIN_H, == 0 ), == 0.058, direction = VERTICAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M6_PG_31_H_PRE2 = angle_edge( M6_PG_31_H_PRE1, == 0 ); 
M6_PG_31_H = M6_PG_31_H_PRE1 touching external1_edge( M6_PG_31_H_PRE2, == 0.054, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
M6_PG_31_V_PRE1 = error_merge_list( { internal1_error( angle_edge( M6_MAIN_V, == 90 ), == 0.058, direction = HORIZONTAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M6_PG_31_V_PRE2 = angle_edge( M6_PG_31_V_PRE1, == 90 ); 
M6_PG_31_V = M6_PG_31_V_PRE1 touching external1_edge( M6_PG_31_V_PRE2, == 0.054, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
M6_PG_31 = M6_PG_31_H or M6_PG_31_V; 

 
M6_PG_32_H_PRE1 = error_merge_list( { internal1_error( angle_edge( M6_MAIN_H, == 0 ), == 0.076, direction = VERTICAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M6_PG_32_H_PRE2 = angle_edge( M6_PG_32_H_PRE1, == 0 ); 
M6_PG_32_H_PRE3 = error_merge_list( { internal1_error( angle_edge( M6_MAIN_H, == 0 ), == 0.038, direction = VERTICAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M6_PG_32_H_PRE4 = angle_edge( M6_PG_32_H_PRE3, == 0 ); 
M6_PG_32_H = M6_PG_32_H_PRE1 touching external2_edge( M6_PG_32_H_PRE2, M6_PG_32_H_PRE4, == 0.053, edge_containment = OUTSIDE, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, output_layer = LAYER1, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
M6_PG_32_V_PRE1 = error_merge_list( { internal1_error( angle_edge( M6_MAIN_V, == 90 ), == 0.076, direction = HORIZONTAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M6_PG_32_V_PRE2 = angle_edge( M6_PG_32_V_PRE1, == 90 ); 
M6_PG_32_V_PRE3 = error_merge_list( { internal1_error( angle_edge( M6_MAIN_V, == 90 ), == 0.038, direction = HORIZONTAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M6_PG_32_V_PRE4 = angle_edge( M6_PG_32_V_PRE3, == 90 ); 
M6_PG_32_V = M6_PG_32_V_PRE1 touching external2_edge( M6_PG_32_V_PRE2, M6_PG_32_V_PRE4, == 0.053, edge_containment = OUTSIDE, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, output_layer = LAYER1, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
M6_PG_32 = M6_PG_32_H or M6_PG_32_V; 

 
M6_PG_33_H_PRE1 = error_merge_list( { internal1_error( angle_edge( M6_MAIN_H, == 0 ), == 0.038, direction = VERTICAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M6_PG_33_H_PRE2 = angle_edge( M6_PG_33_H_PRE1, == 0 ); 
M6_PG_33_H_PRE3 = error_merge_list( { internal1_error( angle_edge( M6_MAIN_H, == 0 ), == 0.076, direction = VERTICAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M6_PG_33_H_PRE4 = angle_edge( M6_PG_33_H_PRE3, == 0 ); 
M6_PG_33_H = M6_PG_33_H_PRE1 touching external2_edge( M6_PG_33_H_PRE2, M6_PG_33_H_PRE4, == 0.053, edge_containment = OUTSIDE, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, output_layer = LAYER1, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
M6_PG_33_V_PRE1 = error_merge_list( { internal1_error( angle_edge( M6_MAIN_V, == 90 ), == 0.038, direction = HORIZONTAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M6_PG_33_V_PRE2 = angle_edge( M6_PG_33_V_PRE1, == 90 ); 
M6_PG_33_V_PRE3 = error_merge_list( { internal1_error( angle_edge( M6_MAIN_V, == 90 ), == 0.076, direction = HORIZONTAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M6_PG_33_V_PRE4 = angle_edge( M6_PG_33_V_PRE3, == 90 ); 
M6_PG_33_V = M6_PG_33_V_PRE1 touching external2_edge( M6_PG_33_V_PRE2, M6_PG_33_V_PRE4, == 0.053, edge_containment = OUTSIDE, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, output_layer = LAYER1, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
M6_PG_33 = M6_PG_33_H or M6_PG_33_V; 

 
M6_PG_34_H_PRE1 = error_merge_list( { internal1_error( angle_edge( M6_MAIN_H, == 0 ), == 0.076, direction = VERTICAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M6_PG_34_H_PRE2 = angle_edge( M6_PG_34_H_PRE1, == 0 ); 
M6_PG_34_H = M6_PG_34_H_PRE1 touching external1_edge( M6_PG_34_H_PRE2, == 0.074, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
M6_PG_34_V_PRE1 = error_merge_list( { internal1_error( angle_edge( M6_MAIN_V, == 90 ), == 0.076, direction = HORIZONTAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M6_PG_34_V_PRE2 = angle_edge( M6_PG_34_V_PRE1, == 90 ); 
M6_PG_34_V = M6_PG_34_V_PRE1 touching external1_edge( M6_PG_34_V_PRE2, == 0.074, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
M6_PG_34 = M6_PG_34_H or M6_PG_34_V; 

 
M6_PG_35_H_PRE1 = error_merge_list( { internal1_error( angle_edge( M6_MAIN_H, == 0 ), == 0.058, direction = VERTICAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M6_PG_35_H_PRE2 = angle_edge( M6_PG_35_H_PRE1, == 0 ); 
M6_PG_35_H_PRE3 = error_merge_list( { internal1_error( angle_edge( M6_MAIN_H, == 0 ), == 0.038, direction = VERTICAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M6_PG_35_H_PRE4 = angle_edge( M6_PG_35_H_PRE3, == 0 ); 
M6_PG_35_H = M6_PG_35_H_PRE1 touching external2_edge( M6_PG_35_H_PRE2, M6_PG_35_H_PRE4, == 0.053, edge_containment = OUTSIDE, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, output_layer = LAYER1, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
M6_PG_35_V_PRE1 = error_merge_list( { internal1_error( angle_edge( M6_MAIN_V, == 90 ), == 0.058, direction = HORIZONTAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M6_PG_35_V_PRE2 = angle_edge( M6_PG_35_V_PRE1, == 90 ); 
M6_PG_35_V_PRE3 = error_merge_list( { internal1_error( angle_edge( M6_MAIN_V, == 90 ), == 0.038, direction = HORIZONTAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M6_PG_35_V_PRE4 = angle_edge( M6_PG_35_V_PRE3, == 90 ); 
M6_PG_35_V = M6_PG_35_V_PRE1 touching external2_edge( M6_PG_35_V_PRE2, M6_PG_35_V_PRE4, == 0.053, edge_containment = OUTSIDE, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, output_layer = LAYER1, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
M6_PG_35 = M6_PG_35_H or M6_PG_35_V; 

 
M6_PG_36_H_PRE1 = error_merge_list( { internal1_error( angle_edge( M6_MAIN_H, == 0 ), == 0.038, direction = VERTICAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M6_PG_36_H_PRE2 = angle_edge( M6_PG_36_H_PRE1, == 0 ); 
M6_PG_36_H_PRE3 = error_merge_list( { internal1_error( angle_edge( M6_MAIN_H, == 0 ), == 0.058, direction = VERTICAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M6_PG_36_H_PRE4 = angle_edge( M6_PG_36_H_PRE3, == 0 ); 
M6_PG_36_H = M6_PG_36_H_PRE1 touching external2_edge( M6_PG_36_H_PRE2, M6_PG_36_H_PRE4, == 0.053, edge_containment = OUTSIDE, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, output_layer = LAYER1, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
M6_PG_36_V_PRE1 = error_merge_list( { internal1_error( angle_edge( M6_MAIN_V, == 90 ), == 0.038, direction = HORIZONTAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M6_PG_36_V_PRE2 = angle_edge( M6_PG_36_V_PRE1, == 90 ); 
M6_PG_36_V_PRE3 = error_merge_list( { internal1_error( angle_edge( M6_MAIN_V, == 90 ), == 0.058, direction = HORIZONTAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M6_PG_36_V_PRE4 = angle_edge( M6_PG_36_V_PRE3, == 90 ); 
M6_PG_36_V = M6_PG_36_V_PRE1 touching external2_edge( M6_PG_36_V_PRE2, M6_PG_36_V_PRE4, == 0.053, edge_containment = OUTSIDE, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, output_layer = LAYER1, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
M6_PG_36 = M6_PG_36_H or M6_PG_36_V; 

 
M6_PG_37_H_PRE1 = error_merge_list( { internal1_error( angle_edge( M6_MAIN_H, == 0 ), == 0.058, direction = VERTICAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M6_PG_37_H_PRE2 = angle_edge( M6_PG_37_H_PRE1, == 0 ); 
M6_PG_37_H_PRE3 = error_merge_list( { internal1_error( angle_edge( M6_MAIN_H, == 0 ), == 0.076, direction = VERTICAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M6_PG_37_H_PRE4 = angle_edge( M6_PG_37_H_PRE3, == 0 ); 
M6_PG_37_H = M6_PG_37_H_PRE1 touching external2_edge( M6_PG_37_H_PRE2, M6_PG_37_H_PRE4, == 0.053, edge_containment = OUTSIDE, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, output_layer = LAYER1, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
M6_PG_37_V_PRE1 = error_merge_list( { internal1_error( angle_edge( M6_MAIN_V, == 90 ), == 0.058, direction = HORIZONTAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M6_PG_37_V_PRE2 = angle_edge( M6_PG_37_V_PRE1, == 90 ); 
M6_PG_37_V_PRE3 = error_merge_list( { internal1_error( angle_edge( M6_MAIN_V, == 90 ), == 0.076, direction = HORIZONTAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M6_PG_37_V_PRE4 = angle_edge( M6_PG_37_V_PRE3, == 90 ); 
M6_PG_37_V = M6_PG_37_V_PRE1 touching external2_edge( M6_PG_37_V_PRE2, M6_PG_37_V_PRE4, == 0.053, edge_containment = OUTSIDE, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, output_layer = LAYER1, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
M6_PG_37 = M6_PG_37_H or M6_PG_37_V; 

 
M6_PG_38_H_PRE1 = error_merge_list( { internal1_error( angle_edge( M6_MAIN_H, == 0 ), == 0.076, direction = VERTICAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M6_PG_38_H_PRE2 = angle_edge( M6_PG_38_H_PRE1, == 0 ); 
M6_PG_38_H_PRE3 = error_merge_list( { internal1_error( angle_edge( M6_MAIN_H, == 0 ), == 0.058, direction = VERTICAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M6_PG_38_H_PRE4 = angle_edge( M6_PG_38_H_PRE3, == 0 ); 
M6_PG_38_H = M6_PG_38_H_PRE1 touching external2_edge( M6_PG_38_H_PRE2, M6_PG_38_H_PRE4, == 0.053, edge_containment = OUTSIDE, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, output_layer = LAYER1, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
M6_PG_38_V_PRE1 = error_merge_list( { internal1_error( angle_edge( M6_MAIN_V, == 90 ), == 0.076, direction = HORIZONTAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M6_PG_38_V_PRE2 = angle_edge( M6_PG_38_V_PRE1, == 90 ); 
M6_PG_38_V_PRE3 = error_merge_list( { internal1_error( angle_edge( M6_MAIN_V, == 90 ), == 0.058, direction = HORIZONTAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M6_PG_38_V_PRE4 = angle_edge( M6_PG_38_V_PRE3, == 90 ); 
M6_PG_38_V = M6_PG_38_V_PRE1 touching external2_edge( M6_PG_38_V_PRE2, M6_PG_38_V_PRE4, == 0.053, edge_containment = OUTSIDE, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, output_layer = LAYER1, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
M6_PG_38 = M6_PG_38_H or M6_PG_38_V; 

 
M6_PG_ALL = or_list( { M6_PG_31, M6_PG_32, M6_PG_33, M6_PG_34, M6_PG_35, M6_PG_36, M6_PG_37, M6_PG_38 } ); 



#ifdef VERTICAL_M6
GRP_M6_Y0 = shrink( grow( ( M6_38 or M6_40 ), east = 0.020, west = 0.020 ), east = 0.020, west = 0.020 ); 
GRP_M6_Y1 = shrink( GRP_M6_Y0, east = 0.140, west = 0.140 ); 
GRP_M6_Y2 = grow( shrink( GRP_M6_Y1, north = 0.050, south = 0.050 ), north = 0.050, south = 0.050 ); 
GRP_M6_Y = interacting( ( M6_38 or M6_40 ), GRP_M6_Y2 ); 
ERR_VIA_M6_Y = enclose_edge( ( VIA5 inside grow( GRP_M6_Y2, north = 0.100, south = 0.100 ) ), GRP_M6_Y, < 0.05, edge_containment = INSIDE_TO_OUTSIDE, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, output_layer = LAYER2 ); 
GRP_M6_END_Y = adjacent_edge( GRP_M6_Y, angle1 = == 90, angle2 = == 90, length = <= 0.04 ); 
S164_M6_REGION = edge_size( extend_edge( ( ERR_VIA_M6_Y touching_edge GRP_M6_END_Y ), start = 0.038, end = 0.038 ), outside = 0.135 ); 

#else
GRP_M6_X0 = shrink( grow( ( M6_38 or M6_40 ), north = 0.020, south = 0.020 ), north = 0.020, south = 0.020 ); 
GRP_M6_X1 = shrink( GRP_M6_X0, north = 0.140, south = 0.140 ); 
GRP_M6_X2 = grow( shrink( GRP_M6_X1, east = 0.050, west = 0.050 ), east = 0.050, west = 0.050 ); 
GRP_M6_X = interacting( ( M6_38 or M6_40 ), GRP_M6_X2 ); 
ERR_VIA_M6_X = enclose_edge( ( VIA5 inside grow( GRP_M6_X2, east = 0.100, west = 0.100 ) ), GRP_M6_X, < 0.05, edge_containment = INSIDE_TO_OUTSIDE, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, output_layer = LAYER2 ); 
GRP_M6_END_X = adjacent_edge( GRP_M6_X, angle1 = == 90, angle2 = == 90, length = <= 0.04 ); 
S164_M6_REGION = edge_size( extend_edge( ( ERR_VIA_M6_X touching_edge GRP_M6_END_X ), start = 0.038, end = 0.038 ), outside = 0.135 ); 

#endif

//  OPC DVIA_O
SQ_VIA5 = rectangles( VIA5, orientation = ORTHOGONAL, sides = { == 0.02, == 0.02 } ); 




M7_HOLE = donut_holes( M7, area = < MY1HOLE, holes = INNER, outer_boundary_point_touch = CLOSED_OUTER_BOUNDARY ); 
M7_GT76 = wide( M7, > MY1W1, angled = TRUNCATE ); 
M7_GT114 = wide( M7, > MY1W2, angled = TRUNCATE ); 
M7_GT152 = wide( M7, > MY1W3, angled = TRUNCATE ); 
M7_GT180 = wide( M7, > MY1W4, angled = TRUNCATE ); 
M7_GT240 = wide( M7, > MY1W5, angled = TRUNCATE ); 
M7_GT280 = wide( M7, > MY1W6, angled = TRUNCATE ); 
M7_GT500 = wide( M7, > MY1W7, angled = TRUNCATE ); 
M7_GT1350 = wide( M7, > MY1W8, angled = TRUNCATE ); 

macroLAYER_18 = angle_edge( M7, == 45 ); 
macroLAYER_35 = extend_edge( macroLAYER_18, start = 0.41, end = 0.41 );
macroLAYER_17 = edge_size( macroLAYER_35, outside = DMY1_MY145 );
macroLAYER_16 = size( macroLAYER_17, clip_acute = TRUNCATE, distance = GRID ); 
M7_45 = M7 or macroLAYER_16; 

M7_38 = wide( M7, == MY138, angled = TRUNCATE );    /* My1.S.27 */ 
M7_40 = wide( M7, == MY140, angled = TRUNCATE );    /* My1.S.27.1 */ 
M7_60 = wide( M7, == MY160, angled = TRUNCATE ); 
M7_80 = wide( M7, == 0.08, angled = TRUNCATE ); 
M7_120 = wide( M7, == 0.12, angled = TRUNCATE ); 

DM7_GT1350 = wide( DM7, > 1.35, angled = TRUNCATE );    /* DMn.S.3.1 */ 

#ifdef VERTICAL_M7
S22_M7_EDGE_45 = angle_edge( M7, == 45 ); 
S22_M7_E1 = adjacent_edge( M7, angle1 = == 270, angle2 = == 270, length = < 0.114 ); 
S22_M7_E2 = length_edge( M7, <= 0.038 ); 
S22_M7_A1 = polygon_extents( not_touching( external1( M7, <= GRID, extension = RADIAL, intersecting = {  }, intersection_angle = == 90, look_thru = NOT_ADJACENT, orientation = { } ), S22_M7_EDGE_45, == 2 ) ); 
S22_M7_A1Y = interacting( S22_M7_A1, M7 ); 
S22_M7_AY = not_interacting( S22_M7_A1Y, edge_size( ( S22_M7_E1 or_edge S22_M7_E2 ), outside = GRID ) ); 
S22_M7_AY_EDGE = S22_M7_AY coincident_edge M7; 
S22_M7_AY_EDGE_V = angle_edge( S22_M7_AY_EDGE, == 90 ); 
S22_M7_AY_REGION_1 = edge_size( S22_M7_AY_EDGE_V, inside = 0.114 ); 
S22_M7_AY_EDGE_H = angle_edge( ( S22_M7_AY_REGION_1 touching_edge M7 ), == 0 ); 
S22_M7_REGION = edge_size( S22_M7_AY_EDGE_H, inside = 0.200 );    /* 0.114x0.200 */ 

#else
S22_M7_EDGE_45 = angle_edge( M7, == 45 ); 
S22_M7_E1 = adjacent_edge( M7, angle1 = == 270, angle2 = == 270, length = < 0.114 ); 
S22_M7_E2 = length_edge( M7, <= 0.038 ); 
S22_M7_A1 = polygon_extents( not_touching( external1( M7, <= GRID, extension = RADIAL, intersecting = {  }, intersection_angle = == 90, look_thru = NOT_ADJACENT, orientation = { } ), S22_M7_EDGE_45, == 2 ) ); 
S22_M7_A1X = interacting( S22_M7_A1, M7 ); 
S22_M7_AX = not_interacting( S22_M7_A1X, edge_size( ( S22_M7_E1 or_edge S22_M7_E2 ), outside = GRID ) ); 
S22_M7_AX_EDGE = S22_M7_AX coincident_edge M7; 
S22_M7_AX_EDGE_H = angle_edge( S22_M7_AX_EDGE, == 0 ); 
S22_M7_AX_REGION_1 = edge_size( S22_M7_AX_EDGE_H, inside = 0.114 ); 
S22_M7_AX_EDGE_V = angle_edge( ( S22_M7_AX_REGION_1 touching_edge M7 ), == 90 ); 
S22_M7_REGION = edge_size( S22_M7_AX_EDGE_V, inside = 0.200 );    /* 0.114x0.200 */ 

#endif
R7_VIA6_ENC1 = VIA6 touching_edge enclose_edge( VIA6, M7, < 0.001, edge_containment = INSIDE_TO_OUTSIDE, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, output_layer = LAYER1, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
R7_VIA6_ENC2 = internal2_edge( R7_VIA6_ENC1, VIA6, <= 0.1, edge_containment = INSIDE, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, membership = SAME_POLYGON, output_layer = LAYER2, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
R7_VIA6_EP_PRE1 = ( VIA6 touching_edge R7_VIA6_ENC1 ) or_edge ( VIA6 touching_edge R7_VIA6_ENC2 ); 
R7_VIA6_EP_PRE2 = enclose_edge( R7_VIA6_EP_PRE1, M6, < 0.065, edge_containment = INSIDE_TO_OUTSIDE, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, output_layer = LAYER1, projection = { IN, ON }, orientation = { PARALLEL } ); 
R7_VIA6_EP = VIA6 touching R7_VIA6_EP_PRE2; 
R7_VIA6_CHK_REGION = edge_size( extend_edge( ( R7_VIA6_EP touching_edge R7_VIA6_EP_PRE1 ), start = 0.300, end = 0.300 ), outside = 0.076 ); 


R15_VIA7_ENC1 = VIA7 touching_edge enclose_edge( VIA7, M7, < 0.001, edge_containment = INSIDE_TO_OUTSIDE, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, output_layer = LAYER1, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
R15_VIA7_ENC2 = internal2_edge( R15_VIA7_ENC1, VIA7, <= 0.1, edge_containment = INSIDE, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, membership = SAME_POLYGON, output_layer = LAYER2, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
R15_VIA7_EP_PRE1 = ( VIA7 touching_edge R15_VIA7_ENC1 ) or_edge ( VIA7 touching_edge R15_VIA7_ENC2 ); 
R15_VIA7_EP_PRE2 = enclose_edge( R15_VIA7_EP_PRE1, M8, < 0.065, edge_containment = INSIDE_TO_OUTSIDE, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, output_layer = LAYER1, projection = { IN, ON }, orientation = { PARALLEL } ); 
R15_VIA7_EP = VIA7 touching R15_VIA7_EP_PRE2; 
R15_VIA7_CHK_REGION = edge_size( extend_edge( ( R15_VIA7_EP touching_edge R15_VIA7_EP_PRE1 ), start = 0.300, end = 0.300 ), outside = 0.076 ); 



M7_PG_31_H_PRE1 = error_merge_list( { internal1_error( angle_edge( M7_MAIN_H, == 0 ), == 0.058, direction = VERTICAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M7_PG_31_H_PRE2 = angle_edge( M7_PG_31_H_PRE1, == 0 ); 
M7_PG_31_H = M7_PG_31_H_PRE1 touching external1_edge( M7_PG_31_H_PRE2, == 0.054, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
M7_PG_31_V_PRE1 = error_merge_list( { internal1_error( angle_edge( M7_MAIN_V, == 90 ), == 0.058, direction = HORIZONTAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M7_PG_31_V_PRE2 = angle_edge( M7_PG_31_V_PRE1, == 90 ); 
M7_PG_31_V = M7_PG_31_V_PRE1 touching external1_edge( M7_PG_31_V_PRE2, == 0.054, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
M7_PG_31 = M7_PG_31_H or M7_PG_31_V; 

 
M7_PG_32_H_PRE1 = error_merge_list( { internal1_error( angle_edge( M7_MAIN_H, == 0 ), == 0.076, direction = VERTICAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M7_PG_32_H_PRE2 = angle_edge( M7_PG_32_H_PRE1, == 0 ); 
M7_PG_32_H_PRE3 = error_merge_list( { internal1_error( angle_edge( M7_MAIN_H, == 0 ), == 0.038, direction = VERTICAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M7_PG_32_H_PRE4 = angle_edge( M7_PG_32_H_PRE3, == 0 ); 
M7_PG_32_H = M7_PG_32_H_PRE1 touching external2_edge( M7_PG_32_H_PRE2, M7_PG_32_H_PRE4, == 0.053, edge_containment = OUTSIDE, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, output_layer = LAYER1, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
M7_PG_32_V_PRE1 = error_merge_list( { internal1_error( angle_edge( M7_MAIN_V, == 90 ), == 0.076, direction = HORIZONTAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M7_PG_32_V_PRE2 = angle_edge( M7_PG_32_V_PRE1, == 90 ); 
M7_PG_32_V_PRE3 = error_merge_list( { internal1_error( angle_edge( M7_MAIN_V, == 90 ), == 0.038, direction = HORIZONTAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M7_PG_32_V_PRE4 = angle_edge( M7_PG_32_V_PRE3, == 90 ); 
M7_PG_32_V = M7_PG_32_V_PRE1 touching external2_edge( M7_PG_32_V_PRE2, M7_PG_32_V_PRE4, == 0.053, edge_containment = OUTSIDE, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, output_layer = LAYER1, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
M7_PG_32 = M7_PG_32_H or M7_PG_32_V; 

 
M7_PG_33_H_PRE1 = error_merge_list( { internal1_error( angle_edge( M7_MAIN_H, == 0 ), == 0.038, direction = VERTICAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M7_PG_33_H_PRE2 = angle_edge( M7_PG_33_H_PRE1, == 0 ); 
M7_PG_33_H_PRE3 = error_merge_list( { internal1_error( angle_edge( M7_MAIN_H, == 0 ), == 0.076, direction = VERTICAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M7_PG_33_H_PRE4 = angle_edge( M7_PG_33_H_PRE3, == 0 ); 
M7_PG_33_H = M7_PG_33_H_PRE1 touching external2_edge( M7_PG_33_H_PRE2, M7_PG_33_H_PRE4, == 0.053, edge_containment = OUTSIDE, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, output_layer = LAYER1, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
M7_PG_33_V_PRE1 = error_merge_list( { internal1_error( angle_edge( M7_MAIN_V, == 90 ), == 0.038, direction = HORIZONTAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M7_PG_33_V_PRE2 = angle_edge( M7_PG_33_V_PRE1, == 90 ); 
M7_PG_33_V_PRE3 = error_merge_list( { internal1_error( angle_edge( M7_MAIN_V, == 90 ), == 0.076, direction = HORIZONTAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M7_PG_33_V_PRE4 = angle_edge( M7_PG_33_V_PRE3, == 90 ); 
M7_PG_33_V = M7_PG_33_V_PRE1 touching external2_edge( M7_PG_33_V_PRE2, M7_PG_33_V_PRE4, == 0.053, edge_containment = OUTSIDE, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, output_layer = LAYER1, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
M7_PG_33 = M7_PG_33_H or M7_PG_33_V; 

 
M7_PG_34_H_PRE1 = error_merge_list( { internal1_error( angle_edge( M7_MAIN_H, == 0 ), == 0.076, direction = VERTICAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M7_PG_34_H_PRE2 = angle_edge( M7_PG_34_H_PRE1, == 0 ); 
M7_PG_34_H = M7_PG_34_H_PRE1 touching external1_edge( M7_PG_34_H_PRE2, == 0.074, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
M7_PG_34_V_PRE1 = error_merge_list( { internal1_error( angle_edge( M7_MAIN_V, == 90 ), == 0.076, direction = HORIZONTAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M7_PG_34_V_PRE2 = angle_edge( M7_PG_34_V_PRE1, == 90 ); 
M7_PG_34_V = M7_PG_34_V_PRE1 touching external1_edge( M7_PG_34_V_PRE2, == 0.074, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
M7_PG_34 = M7_PG_34_H or M7_PG_34_V; 

 
M7_PG_35_H_PRE1 = error_merge_list( { internal1_error( angle_edge( M7_MAIN_H, == 0 ), == 0.058, direction = VERTICAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M7_PG_35_H_PRE2 = angle_edge( M7_PG_35_H_PRE1, == 0 ); 
M7_PG_35_H_PRE3 = error_merge_list( { internal1_error( angle_edge( M7_MAIN_H, == 0 ), == 0.038, direction = VERTICAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M7_PG_35_H_PRE4 = angle_edge( M7_PG_35_H_PRE3, == 0 ); 
M7_PG_35_H = M7_PG_35_H_PRE1 touching external2_edge( M7_PG_35_H_PRE2, M7_PG_35_H_PRE4, == 0.053, edge_containment = OUTSIDE, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, output_layer = LAYER1, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
M7_PG_35_V_PRE1 = error_merge_list( { internal1_error( angle_edge( M7_MAIN_V, == 90 ), == 0.058, direction = HORIZONTAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M7_PG_35_V_PRE2 = angle_edge( M7_PG_35_V_PRE1, == 90 ); 
M7_PG_35_V_PRE3 = error_merge_list( { internal1_error( angle_edge( M7_MAIN_V, == 90 ), == 0.038, direction = HORIZONTAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M7_PG_35_V_PRE4 = angle_edge( M7_PG_35_V_PRE3, == 90 ); 
M7_PG_35_V = M7_PG_35_V_PRE1 touching external2_edge( M7_PG_35_V_PRE2, M7_PG_35_V_PRE4, == 0.053, edge_containment = OUTSIDE, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, output_layer = LAYER1, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
M7_PG_35 = M7_PG_35_H or M7_PG_35_V; 

 
M7_PG_36_H_PRE1 = error_merge_list( { internal1_error( angle_edge( M7_MAIN_H, == 0 ), == 0.038, direction = VERTICAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M7_PG_36_H_PRE2 = angle_edge( M7_PG_36_H_PRE1, == 0 ); 
M7_PG_36_H_PRE3 = error_merge_list( { internal1_error( angle_edge( M7_MAIN_H, == 0 ), == 0.058, direction = VERTICAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M7_PG_36_H_PRE4 = angle_edge( M7_PG_36_H_PRE3, == 0 ); 
M7_PG_36_H = M7_PG_36_H_PRE1 touching external2_edge( M7_PG_36_H_PRE2, M7_PG_36_H_PRE4, == 0.053, edge_containment = OUTSIDE, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, output_layer = LAYER1, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
M7_PG_36_V_PRE1 = error_merge_list( { internal1_error( angle_edge( M7_MAIN_V, == 90 ), == 0.038, direction = HORIZONTAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M7_PG_36_V_PRE2 = angle_edge( M7_PG_36_V_PRE1, == 90 ); 
M7_PG_36_V_PRE3 = error_merge_list( { internal1_error( angle_edge( M7_MAIN_V, == 90 ), == 0.058, direction = HORIZONTAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M7_PG_36_V_PRE4 = angle_edge( M7_PG_36_V_PRE3, == 90 ); 
M7_PG_36_V = M7_PG_36_V_PRE1 touching external2_edge( M7_PG_36_V_PRE2, M7_PG_36_V_PRE4, == 0.053, edge_containment = OUTSIDE, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, output_layer = LAYER1, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
M7_PG_36 = M7_PG_36_H or M7_PG_36_V; 

 
M7_PG_37_H_PRE1 = error_merge_list( { internal1_error( angle_edge( M7_MAIN_H, == 0 ), == 0.058, direction = VERTICAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M7_PG_37_H_PRE2 = angle_edge( M7_PG_37_H_PRE1, == 0 ); 
M7_PG_37_H_PRE3 = error_merge_list( { internal1_error( angle_edge( M7_MAIN_H, == 0 ), == 0.076, direction = VERTICAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M7_PG_37_H_PRE4 = angle_edge( M7_PG_37_H_PRE3, == 0 ); 
M7_PG_37_H = M7_PG_37_H_PRE1 touching external2_edge( M7_PG_37_H_PRE2, M7_PG_37_H_PRE4, == 0.053, edge_containment = OUTSIDE, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, output_layer = LAYER1, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
M7_PG_37_V_PRE1 = error_merge_list( { internal1_error( angle_edge( M7_MAIN_V, == 90 ), == 0.058, direction = HORIZONTAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M7_PG_37_V_PRE2 = angle_edge( M7_PG_37_V_PRE1, == 90 ); 
M7_PG_37_V_PRE3 = error_merge_list( { internal1_error( angle_edge( M7_MAIN_V, == 90 ), == 0.076, direction = HORIZONTAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M7_PG_37_V_PRE4 = angle_edge( M7_PG_37_V_PRE3, == 90 ); 
M7_PG_37_V = M7_PG_37_V_PRE1 touching external2_edge( M7_PG_37_V_PRE2, M7_PG_37_V_PRE4, == 0.053, edge_containment = OUTSIDE, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, output_layer = LAYER1, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
M7_PG_37 = M7_PG_37_H or M7_PG_37_V; 

 
M7_PG_38_H_PRE1 = error_merge_list( { internal1_error( angle_edge( M7_MAIN_H, == 0 ), == 0.076, direction = VERTICAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M7_PG_38_H_PRE2 = angle_edge( M7_PG_38_H_PRE1, == 0 ); 
M7_PG_38_H_PRE3 = error_merge_list( { internal1_error( angle_edge( M7_MAIN_H, == 0 ), == 0.058, direction = VERTICAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M7_PG_38_H_PRE4 = angle_edge( M7_PG_38_H_PRE3, == 0 ); 
M7_PG_38_H = M7_PG_38_H_PRE1 touching external2_edge( M7_PG_38_H_PRE2, M7_PG_38_H_PRE4, == 0.053, edge_containment = OUTSIDE, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, output_layer = LAYER1, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
M7_PG_38_V_PRE1 = error_merge_list( { internal1_error( angle_edge( M7_MAIN_V, == 90 ), == 0.076, direction = HORIZONTAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M7_PG_38_V_PRE2 = angle_edge( M7_PG_38_V_PRE1, == 90 ); 
M7_PG_38_V_PRE3 = error_merge_list( { internal1_error( angle_edge( M7_MAIN_V, == 90 ), == 0.058, direction = HORIZONTAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M7_PG_38_V_PRE4 = angle_edge( M7_PG_38_V_PRE3, == 90 ); 
M7_PG_38_V = M7_PG_38_V_PRE1 touching external2_edge( M7_PG_38_V_PRE2, M7_PG_38_V_PRE4, == 0.053, edge_containment = OUTSIDE, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, output_layer = LAYER1, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
M7_PG_38 = M7_PG_38_H or M7_PG_38_V; 

 
M7_PG_ALL = or_list( { M7_PG_31, M7_PG_32, M7_PG_33, M7_PG_34, M7_PG_35, M7_PG_36, M7_PG_37, M7_PG_38 } ); 



//  OPC DVIA_O
SQ_VIA6 = rectangles( VIA6, orientation = ORTHOGONAL, sides = { == 0.02, == 0.02 } ); 

VIA6_40 = rectangles( VIA6, orientation = ORTHOGONAL, sides = { == 0.04, == 0.04 } ); 




M8_HOLE = donut_holes( M8, area = < MY1HOLE, holes = INNER, outer_boundary_point_touch = CLOSED_OUTER_BOUNDARY ); 
M8_GT76 = wide( M8, > MY1W1, angled = TRUNCATE ); 
M8_GT114 = wide( M8, > MY1W2, angled = TRUNCATE ); 
M8_GT152 = wide( M8, > MY1W3, angled = TRUNCATE ); 
M8_GT180 = wide( M8, > MY1W4, angled = TRUNCATE ); 
M8_GT240 = wide( M8, > MY1W5, angled = TRUNCATE ); 
M8_GT280 = wide( M8, > MY1W6, angled = TRUNCATE ); 
M8_GT500 = wide( M8, > MY1W7, angled = TRUNCATE ); 
M8_GT1350 = wide( M8, > MY1W8, angled = TRUNCATE ); 

macroLAYER_18 = angle_edge( M8, == 45 ); 
macroLAYER_35 = extend_edge( macroLAYER_18, start = 0.41, end = 0.41 );
macroLAYER_17 = edge_size( macroLAYER_35, outside = DMY1_MY145 );
macroLAYER_16 = size( macroLAYER_17, clip_acute = TRUNCATE, distance = GRID ); 
M8_45 = M8 or macroLAYER_16; 

M8_38 = wide( M8, == MY138, angled = TRUNCATE );    /* My1.S.27 */ 
M8_40 = wide( M8, == MY140, angled = TRUNCATE );    /* My1.S.27.1 */ 
M8_60 = wide( M8, == MY160, angled = TRUNCATE ); 
M8_80 = wide( M8, == 0.08, angled = TRUNCATE ); 
M8_120 = wide( M8, == 0.12, angled = TRUNCATE ); 

DM8_GT1350 = wide( DM8, > 1.35, angled = TRUNCATE );    /* DMn.S.3.1 */ 

#ifdef VERTICAL_M8
S22_M8_EDGE_45 = angle_edge( M8, == 45 ); 
S22_M8_E1 = adjacent_edge( M8, angle1 = == 270, angle2 = == 270, length = < 0.114 ); 
S22_M8_E2 = length_edge( M8, <= 0.038 ); 
S22_M8_A1 = polygon_extents( not_touching( external1( M8, <= GRID, extension = RADIAL, intersecting = {  }, intersection_angle = == 90, look_thru = NOT_ADJACENT, orientation = { } ), S22_M8_EDGE_45, == 2 ) ); 
S22_M8_A1Y = interacting( S22_M8_A1, M8 ); 
S22_M8_AY = not_interacting( S22_M8_A1Y, edge_size( ( S22_M8_E1 or_edge S22_M8_E2 ), outside = GRID ) ); 
S22_M8_AY_EDGE = S22_M8_AY coincident_edge M8; 
S22_M8_AY_EDGE_V = angle_edge( S22_M8_AY_EDGE, == 90 ); 
S22_M8_AY_REGION_1 = edge_size( S22_M8_AY_EDGE_V, inside = 0.114 ); 
S22_M8_AY_EDGE_H = angle_edge( ( S22_M8_AY_REGION_1 touching_edge M8 ), == 0 ); 
S22_M8_REGION = edge_size( S22_M8_AY_EDGE_H, inside = 0.200 );    /* 0.114x0.200 */ 

#else
S22_M8_EDGE_45 = angle_edge( M8, == 45 ); 
S22_M8_E1 = adjacent_edge( M8, angle1 = == 270, angle2 = == 270, length = < 0.114 ); 
S22_M8_E2 = length_edge( M8, <= 0.038 ); 
S22_M8_A1 = polygon_extents( not_touching( external1( M8, <= GRID, extension = RADIAL, intersecting = {  }, intersection_angle = == 90, look_thru = NOT_ADJACENT, orientation = { } ), S22_M8_EDGE_45, == 2 ) ); 
S22_M8_A1X = interacting( S22_M8_A1, M8 ); 
S22_M8_AX = not_interacting( S22_M8_A1X, edge_size( ( S22_M8_E1 or_edge S22_M8_E2 ), outside = GRID ) ); 
S22_M8_AX_EDGE = S22_M8_AX coincident_edge M8; 
S22_M8_AX_EDGE_H = angle_edge( S22_M8_AX_EDGE, == 0 ); 
S22_M8_AX_REGION_1 = edge_size( S22_M8_AX_EDGE_H, inside = 0.114 ); 
S22_M8_AX_EDGE_V = angle_edge( ( S22_M8_AX_REGION_1 touching_edge M8 ), == 90 ); 
S22_M8_REGION = edge_size( S22_M8_AX_EDGE_V, inside = 0.200 );    /* 0.114x0.200 */ 

#endif
R7_VIA7_ENC1 = VIA7 touching_edge enclose_edge( VIA7, M8, < 0.001, edge_containment = INSIDE_TO_OUTSIDE, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, output_layer = LAYER1, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
R7_VIA7_ENC2 = internal2_edge( R7_VIA7_ENC1, VIA7, <= 0.1, edge_containment = INSIDE, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, membership = SAME_POLYGON, output_layer = LAYER2, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
R7_VIA7_EP_PRE1 = ( VIA7 touching_edge R7_VIA7_ENC1 ) or_edge ( VIA7 touching_edge R7_VIA7_ENC2 ); 
R7_VIA7_EP_PRE2 = enclose_edge( R7_VIA7_EP_PRE1, M7, < 0.065, edge_containment = INSIDE_TO_OUTSIDE, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, output_layer = LAYER1, projection = { IN, ON }, orientation = { PARALLEL } ); 
R7_VIA7_EP = VIA7 touching R7_VIA7_EP_PRE2; 
R7_VIA7_CHK_REGION = edge_size( extend_edge( ( R7_VIA7_EP touching_edge R7_VIA7_EP_PRE1 ), start = 0.300, end = 0.300 ), outside = 0.076 ); 


R15_VIA8_ENC1 = VIA8 touching_edge enclose_edge( VIA8, M8, < 0.001, edge_containment = INSIDE_TO_OUTSIDE, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, output_layer = LAYER1, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
R15_VIA8_ENC2 = internal2_edge( R15_VIA8_ENC1, VIA8, <= 0.1, edge_containment = INSIDE, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, membership = SAME_POLYGON, output_layer = LAYER2, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
R15_VIA8_EP_PRE1 = ( VIA8 touching_edge R15_VIA8_ENC1 ) or_edge ( VIA8 touching_edge R15_VIA8_ENC2 ); 
R15_VIA8_EP_PRE2 = enclose_edge( R15_VIA8_EP_PRE1, M9, < 0.065, edge_containment = INSIDE_TO_OUTSIDE, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, output_layer = LAYER1, projection = { IN, ON }, orientation = { PARALLEL } ); 
R15_VIA8_EP = VIA8 touching R15_VIA8_EP_PRE2; 
R15_VIA8_CHK_REGION = edge_size( extend_edge( ( R15_VIA8_EP touching_edge R15_VIA8_EP_PRE1 ), start = 0.300, end = 0.300 ), outside = 0.076 ); 



M8_PG_31_H_PRE1 = error_merge_list( { internal1_error( angle_edge( M8_MAIN_H, == 0 ), == 0.058, direction = VERTICAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M8_PG_31_H_PRE2 = angle_edge( M8_PG_31_H_PRE1, == 0 ); 
M8_PG_31_H = M8_PG_31_H_PRE1 touching external1_edge( M8_PG_31_H_PRE2, == 0.054, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
M8_PG_31_V_PRE1 = error_merge_list( { internal1_error( angle_edge( M8_MAIN_V, == 90 ), == 0.058, direction = HORIZONTAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M8_PG_31_V_PRE2 = angle_edge( M8_PG_31_V_PRE1, == 90 ); 
M8_PG_31_V = M8_PG_31_V_PRE1 touching external1_edge( M8_PG_31_V_PRE2, == 0.054, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
M8_PG_31 = M8_PG_31_H or M8_PG_31_V; 

 
M8_PG_32_H_PRE1 = error_merge_list( { internal1_error( angle_edge( M8_MAIN_H, == 0 ), == 0.076, direction = VERTICAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M8_PG_32_H_PRE2 = angle_edge( M8_PG_32_H_PRE1, == 0 ); 
M8_PG_32_H_PRE3 = error_merge_list( { internal1_error( angle_edge( M8_MAIN_H, == 0 ), == 0.038, direction = VERTICAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M8_PG_32_H_PRE4 = angle_edge( M8_PG_32_H_PRE3, == 0 ); 
M8_PG_32_H = M8_PG_32_H_PRE1 touching external2_edge( M8_PG_32_H_PRE2, M8_PG_32_H_PRE4, == 0.053, edge_containment = OUTSIDE, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, output_layer = LAYER1, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
M8_PG_32_V_PRE1 = error_merge_list( { internal1_error( angle_edge( M8_MAIN_V, == 90 ), == 0.076, direction = HORIZONTAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M8_PG_32_V_PRE2 = angle_edge( M8_PG_32_V_PRE1, == 90 ); 
M8_PG_32_V_PRE3 = error_merge_list( { internal1_error( angle_edge( M8_MAIN_V, == 90 ), == 0.038, direction = HORIZONTAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M8_PG_32_V_PRE4 = angle_edge( M8_PG_32_V_PRE3, == 90 ); 
M8_PG_32_V = M8_PG_32_V_PRE1 touching external2_edge( M8_PG_32_V_PRE2, M8_PG_32_V_PRE4, == 0.053, edge_containment = OUTSIDE, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, output_layer = LAYER1, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
M8_PG_32 = M8_PG_32_H or M8_PG_32_V; 

 
M8_PG_33_H_PRE1 = error_merge_list( { internal1_error( angle_edge( M8_MAIN_H, == 0 ), == 0.038, direction = VERTICAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M8_PG_33_H_PRE2 = angle_edge( M8_PG_33_H_PRE1, == 0 ); 
M8_PG_33_H_PRE3 = error_merge_list( { internal1_error( angle_edge( M8_MAIN_H, == 0 ), == 0.076, direction = VERTICAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M8_PG_33_H_PRE4 = angle_edge( M8_PG_33_H_PRE3, == 0 ); 
M8_PG_33_H = M8_PG_33_H_PRE1 touching external2_edge( M8_PG_33_H_PRE2, M8_PG_33_H_PRE4, == 0.053, edge_containment = OUTSIDE, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, output_layer = LAYER1, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
M8_PG_33_V_PRE1 = error_merge_list( { internal1_error( angle_edge( M8_MAIN_V, == 90 ), == 0.038, direction = HORIZONTAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M8_PG_33_V_PRE2 = angle_edge( M8_PG_33_V_PRE1, == 90 ); 
M8_PG_33_V_PRE3 = error_merge_list( { internal1_error( angle_edge( M8_MAIN_V, == 90 ), == 0.076, direction = HORIZONTAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M8_PG_33_V_PRE4 = angle_edge( M8_PG_33_V_PRE3, == 90 ); 
M8_PG_33_V = M8_PG_33_V_PRE1 touching external2_edge( M8_PG_33_V_PRE2, M8_PG_33_V_PRE4, == 0.053, edge_containment = OUTSIDE, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, output_layer = LAYER1, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
M8_PG_33 = M8_PG_33_H or M8_PG_33_V; 

 
M8_PG_34_H_PRE1 = error_merge_list( { internal1_error( angle_edge( M8_MAIN_H, == 0 ), == 0.076, direction = VERTICAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M8_PG_34_H_PRE2 = angle_edge( M8_PG_34_H_PRE1, == 0 ); 
M8_PG_34_H = M8_PG_34_H_PRE1 touching external1_edge( M8_PG_34_H_PRE2, == 0.074, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
M8_PG_34_V_PRE1 = error_merge_list( { internal1_error( angle_edge( M8_MAIN_V, == 90 ), == 0.076, direction = HORIZONTAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M8_PG_34_V_PRE2 = angle_edge( M8_PG_34_V_PRE1, == 90 ); 
M8_PG_34_V = M8_PG_34_V_PRE1 touching external1_edge( M8_PG_34_V_PRE2, == 0.074, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
M8_PG_34 = M8_PG_34_H or M8_PG_34_V; 

 
M8_PG_35_H_PRE1 = error_merge_list( { internal1_error( angle_edge( M8_MAIN_H, == 0 ), == 0.058, direction = VERTICAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M8_PG_35_H_PRE2 = angle_edge( M8_PG_35_H_PRE1, == 0 ); 
M8_PG_35_H_PRE3 = error_merge_list( { internal1_error( angle_edge( M8_MAIN_H, == 0 ), == 0.038, direction = VERTICAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M8_PG_35_H_PRE4 = angle_edge( M8_PG_35_H_PRE3, == 0 ); 
M8_PG_35_H = M8_PG_35_H_PRE1 touching external2_edge( M8_PG_35_H_PRE2, M8_PG_35_H_PRE4, == 0.053, edge_containment = OUTSIDE, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, output_layer = LAYER1, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
M8_PG_35_V_PRE1 = error_merge_list( { internal1_error( angle_edge( M8_MAIN_V, == 90 ), == 0.058, direction = HORIZONTAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M8_PG_35_V_PRE2 = angle_edge( M8_PG_35_V_PRE1, == 90 ); 
M8_PG_35_V_PRE3 = error_merge_list( { internal1_error( angle_edge( M8_MAIN_V, == 90 ), == 0.038, direction = HORIZONTAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M8_PG_35_V_PRE4 = angle_edge( M8_PG_35_V_PRE3, == 90 ); 
M8_PG_35_V = M8_PG_35_V_PRE1 touching external2_edge( M8_PG_35_V_PRE2, M8_PG_35_V_PRE4, == 0.053, edge_containment = OUTSIDE, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, output_layer = LAYER1, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
M8_PG_35 = M8_PG_35_H or M8_PG_35_V; 

 
M8_PG_36_H_PRE1 = error_merge_list( { internal1_error( angle_edge( M8_MAIN_H, == 0 ), == 0.038, direction = VERTICAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M8_PG_36_H_PRE2 = angle_edge( M8_PG_36_H_PRE1, == 0 ); 
M8_PG_36_H_PRE3 = error_merge_list( { internal1_error( angle_edge( M8_MAIN_H, == 0 ), == 0.058, direction = VERTICAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M8_PG_36_H_PRE4 = angle_edge( M8_PG_36_H_PRE3, == 0 ); 
M8_PG_36_H = M8_PG_36_H_PRE1 touching external2_edge( M8_PG_36_H_PRE2, M8_PG_36_H_PRE4, == 0.053, edge_containment = OUTSIDE, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, output_layer = LAYER1, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
M8_PG_36_V_PRE1 = error_merge_list( { internal1_error( angle_edge( M8_MAIN_V, == 90 ), == 0.038, direction = HORIZONTAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M8_PG_36_V_PRE2 = angle_edge( M8_PG_36_V_PRE1, == 90 ); 
M8_PG_36_V_PRE3 = error_merge_list( { internal1_error( angle_edge( M8_MAIN_V, == 90 ), == 0.058, direction = HORIZONTAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M8_PG_36_V_PRE4 = angle_edge( M8_PG_36_V_PRE3, == 90 ); 
M8_PG_36_V = M8_PG_36_V_PRE1 touching external2_edge( M8_PG_36_V_PRE2, M8_PG_36_V_PRE4, == 0.053, edge_containment = OUTSIDE, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, output_layer = LAYER1, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
M8_PG_36 = M8_PG_36_H or M8_PG_36_V; 

 
M8_PG_37_H_PRE1 = error_merge_list( { internal1_error( angle_edge( M8_MAIN_H, == 0 ), == 0.058, direction = VERTICAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M8_PG_37_H_PRE2 = angle_edge( M8_PG_37_H_PRE1, == 0 ); 
M8_PG_37_H_PRE3 = error_merge_list( { internal1_error( angle_edge( M8_MAIN_H, == 0 ), == 0.076, direction = VERTICAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M8_PG_37_H_PRE4 = angle_edge( M8_PG_37_H_PRE3, == 0 ); 
M8_PG_37_H = M8_PG_37_H_PRE1 touching external2_edge( M8_PG_37_H_PRE2, M8_PG_37_H_PRE4, == 0.053, edge_containment = OUTSIDE, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, output_layer = LAYER1, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
M8_PG_37_V_PRE1 = error_merge_list( { internal1_error( angle_edge( M8_MAIN_V, == 90 ), == 0.058, direction = HORIZONTAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M8_PG_37_V_PRE2 = angle_edge( M8_PG_37_V_PRE1, == 90 ); 
M8_PG_37_V_PRE3 = error_merge_list( { internal1_error( angle_edge( M8_MAIN_V, == 90 ), == 0.076, direction = HORIZONTAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M8_PG_37_V_PRE4 = angle_edge( M8_PG_37_V_PRE3, == 90 ); 
M8_PG_37_V = M8_PG_37_V_PRE1 touching external2_edge( M8_PG_37_V_PRE2, M8_PG_37_V_PRE4, == 0.053, edge_containment = OUTSIDE, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, output_layer = LAYER1, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
M8_PG_37 = M8_PG_37_H or M8_PG_37_V; 

 
M8_PG_38_H_PRE1 = error_merge_list( { internal1_error( angle_edge( M8_MAIN_H, == 0 ), == 0.076, direction = VERTICAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M8_PG_38_H_PRE2 = angle_edge( M8_PG_38_H_PRE1, == 0 ); 
M8_PG_38_H_PRE3 = error_merge_list( { internal1_error( angle_edge( M8_MAIN_H, == 0 ), == 0.058, direction = VERTICAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M8_PG_38_H_PRE4 = angle_edge( M8_PG_38_H_PRE3, == 0 ); 
M8_PG_38_H = M8_PG_38_H_PRE1 touching external2_edge( M8_PG_38_H_PRE2, M8_PG_38_H_PRE4, == 0.053, edge_containment = OUTSIDE, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, output_layer = LAYER1, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
M8_PG_38_V_PRE1 = error_merge_list( { internal1_error( angle_edge( M8_MAIN_V, == 90 ), == 0.076, direction = HORIZONTAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M8_PG_38_V_PRE2 = angle_edge( M8_PG_38_V_PRE1, == 90 ); 
M8_PG_38_V_PRE3 = error_merge_list( { internal1_error( angle_edge( M8_MAIN_V, == 90 ), == 0.058, direction = HORIZONTAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M8_PG_38_V_PRE4 = angle_edge( M8_PG_38_V_PRE3, == 90 ); 
M8_PG_38_V = M8_PG_38_V_PRE1 touching external2_edge( M8_PG_38_V_PRE2, M8_PG_38_V_PRE4, == 0.053, edge_containment = OUTSIDE, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, output_layer = LAYER1, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
M8_PG_38 = M8_PG_38_H or M8_PG_38_V; 

 
M8_PG_ALL = or_list( { M8_PG_31, M8_PG_32, M8_PG_33, M8_PG_34, M8_PG_35, M8_PG_36, M8_PG_37, M8_PG_38 } ); 



//  OPC DVIA_O
SQ_VIA7 = rectangles( VIA7, orientation = ORTHOGONAL, sides = { == 0.02, == 0.02 } ); 

VIA7_40 = rectangles( VIA7, orientation = ORTHOGONAL, sides = { == 0.04, == 0.04 } ); 




M9_HOLE = donut_holes( M9, area = < MY1HOLE, holes = INNER, outer_boundary_point_touch = CLOSED_OUTER_BOUNDARY ); 
M9_GT76 = wide( M9, > MY1W1, angled = TRUNCATE ); 
M9_GT114 = wide( M9, > MY1W2, angled = TRUNCATE ); 
M9_GT152 = wide( M9, > MY1W3, angled = TRUNCATE ); 
M9_GT180 = wide( M9, > MY1W4, angled = TRUNCATE ); 
M9_GT240 = wide( M9, > MY1W5, angled = TRUNCATE ); 
M9_GT280 = wide( M9, > MY1W6, angled = TRUNCATE ); 
M9_GT500 = wide( M9, > MY1W7, angled = TRUNCATE ); 
M9_GT1350 = wide( M9, > MY1W8, angled = TRUNCATE ); 

macroLAYER_18 = angle_edge( M9, == 45 ); 
macroLAYER_35 = extend_edge( macroLAYER_18, start = 0.41, end = 0.41 );
macroLAYER_17 = edge_size( macroLAYER_35, outside = DMY1_MY145 );
macroLAYER_16 = size( macroLAYER_17, clip_acute = TRUNCATE, distance = GRID ); 
M9_45 = M9 or macroLAYER_16; 

M9_38 = wide( M9, == MY138, angled = TRUNCATE );    /* My1.S.27 */ 
M9_40 = wide( M9, == MY140, angled = TRUNCATE );    /* My1.S.27.1 */ 
M9_60 = wide( M9, == MY160, angled = TRUNCATE ); 
M9_80 = wide( M9, == 0.08, angled = TRUNCATE ); 
M9_120 = wide( M9, == 0.12, angled = TRUNCATE ); 

DM9_GT1350 = wide( DM9, > 1.35, angled = TRUNCATE );    /* DMn.S.3.1 */ 

#ifdef VERTICAL_M9
S22_M9_EDGE_45 = angle_edge( M9, == 45 ); 
S22_M9_E1 = adjacent_edge( M9, angle1 = == 270, angle2 = == 270, length = < 0.114 ); 
S22_M9_E2 = length_edge( M9, <= 0.038 ); 
S22_M9_A1 = polygon_extents( not_touching( external1( M9, <= GRID, extension = RADIAL, intersecting = {  }, intersection_angle = == 90, look_thru = NOT_ADJACENT, orientation = { } ), S22_M9_EDGE_45, == 2 ) ); 
S22_M9_A1Y = interacting( S22_M9_A1, M9 ); 
S22_M9_AY = not_interacting( S22_M9_A1Y, edge_size( ( S22_M9_E1 or_edge S22_M9_E2 ), outside = GRID ) ); 
S22_M9_AY_EDGE = S22_M9_AY coincident_edge M9; 
S22_M9_AY_EDGE_V = angle_edge( S22_M9_AY_EDGE, == 90 ); 
S22_M9_AY_REGION_1 = edge_size( S22_M9_AY_EDGE_V, inside = 0.114 ); 
S22_M9_AY_EDGE_H = angle_edge( ( S22_M9_AY_REGION_1 touching_edge M9 ), == 0 ); 
S22_M9_REGION = edge_size( S22_M9_AY_EDGE_H, inside = 0.200 );    /* 0.114x0.200 */ 

#else
S22_M9_EDGE_45 = angle_edge( M9, == 45 ); 
S22_M9_E1 = adjacent_edge( M9, angle1 = == 270, angle2 = == 270, length = < 0.114 ); 
S22_M9_E2 = length_edge( M9, <= 0.038 ); 
S22_M9_A1 = polygon_extents( not_touching( external1( M9, <= GRID, extension = RADIAL, intersecting = {  }, intersection_angle = == 90, look_thru = NOT_ADJACENT, orientation = { } ), S22_M9_EDGE_45, == 2 ) ); 
S22_M9_A1X = interacting( S22_M9_A1, M9 ); 
S22_M9_AX = not_interacting( S22_M9_A1X, edge_size( ( S22_M9_E1 or_edge S22_M9_E2 ), outside = GRID ) ); 
S22_M9_AX_EDGE = S22_M9_AX coincident_edge M9; 
S22_M9_AX_EDGE_H = angle_edge( S22_M9_AX_EDGE, == 0 ); 
S22_M9_AX_REGION_1 = edge_size( S22_M9_AX_EDGE_H, inside = 0.114 ); 
S22_M9_AX_EDGE_V = angle_edge( ( S22_M9_AX_REGION_1 touching_edge M9 ), == 90 ); 
S22_M9_REGION = edge_size( S22_M9_AX_EDGE_V, inside = 0.200 );    /* 0.114x0.200 */ 

#endif
R7_VIA8_ENC1 = VIA8 touching_edge enclose_edge( VIA8, M9, < 0.001, edge_containment = INSIDE_TO_OUTSIDE, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, output_layer = LAYER1, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
R7_VIA8_ENC2 = internal2_edge( R7_VIA8_ENC1, VIA8, <= 0.1, edge_containment = INSIDE, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, membership = SAME_POLYGON, output_layer = LAYER2, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
R7_VIA8_EP_PRE1 = ( VIA8 touching_edge R7_VIA8_ENC1 ) or_edge ( VIA8 touching_edge R7_VIA8_ENC2 ); 
R7_VIA8_EP_PRE2 = enclose_edge( R7_VIA8_EP_PRE1, M8, < 0.065, edge_containment = INSIDE_TO_OUTSIDE, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, output_layer = LAYER1, projection = { IN, ON }, orientation = { PARALLEL } ); 
R7_VIA8_EP = VIA8 touching R7_VIA8_EP_PRE2; 
R7_VIA8_CHK_REGION = edge_size( extend_edge( ( R7_VIA8_EP touching_edge R7_VIA8_EP_PRE1 ), start = 0.300, end = 0.300 ), outside = 0.076 ); 


R15_VIA9_ENC1 = VIA9 touching_edge enclose_edge( VIA9, M9, < 0.001, edge_containment = INSIDE_TO_OUTSIDE, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, output_layer = LAYER1, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
R15_VIA9_ENC2 = internal2_edge( R15_VIA9_ENC1, VIA9, <= 0.1, edge_containment = INSIDE, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, membership = SAME_POLYGON, output_layer = LAYER2, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
R15_VIA9_EP_PRE1 = ( VIA9 touching_edge R15_VIA9_ENC1 ) or_edge ( VIA9 touching_edge R15_VIA9_ENC2 ); 
R15_VIA9_EP_PRE2 = enclose_edge( R15_VIA9_EP_PRE1, M10, < 0.065, edge_containment = INSIDE_TO_OUTSIDE, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, output_layer = LAYER1, projection = { IN, ON }, orientation = { PARALLEL } ); 
R15_VIA9_EP = VIA9 touching R15_VIA9_EP_PRE2; 
R15_VIA9_CHK_REGION = edge_size( extend_edge( ( R15_VIA9_EP touching_edge R15_VIA9_EP_PRE1 ), start = 0.300, end = 0.300 ), outside = 0.076 ); 



M9_PG_31_H_PRE1 = error_merge_list( { internal1_error( angle_edge( M9_MAIN_H, == 0 ), == 0.058, direction = VERTICAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M9_PG_31_H_PRE2 = angle_edge( M9_PG_31_H_PRE1, == 0 ); 
M9_PG_31_H = M9_PG_31_H_PRE1 touching external1_edge( M9_PG_31_H_PRE2, == 0.054, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
M9_PG_31_V_PRE1 = error_merge_list( { internal1_error( angle_edge( M9_MAIN_V, == 90 ), == 0.058, direction = HORIZONTAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M9_PG_31_V_PRE2 = angle_edge( M9_PG_31_V_PRE1, == 90 ); 
M9_PG_31_V = M9_PG_31_V_PRE1 touching external1_edge( M9_PG_31_V_PRE2, == 0.054, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
M9_PG_31 = M9_PG_31_H or M9_PG_31_V; 

 
M9_PG_32_H_PRE1 = error_merge_list( { internal1_error( angle_edge( M9_MAIN_H, == 0 ), == 0.076, direction = VERTICAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M9_PG_32_H_PRE2 = angle_edge( M9_PG_32_H_PRE1, == 0 ); 
M9_PG_32_H_PRE3 = error_merge_list( { internal1_error( angle_edge( M9_MAIN_H, == 0 ), == 0.038, direction = VERTICAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M9_PG_32_H_PRE4 = angle_edge( M9_PG_32_H_PRE3, == 0 ); 
M9_PG_32_H = M9_PG_32_H_PRE1 touching external2_edge( M9_PG_32_H_PRE2, M9_PG_32_H_PRE4, == 0.053, edge_containment = OUTSIDE, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, output_layer = LAYER1, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
M9_PG_32_V_PRE1 = error_merge_list( { internal1_error( angle_edge( M9_MAIN_V, == 90 ), == 0.076, direction = HORIZONTAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M9_PG_32_V_PRE2 = angle_edge( M9_PG_32_V_PRE1, == 90 ); 
M9_PG_32_V_PRE3 = error_merge_list( { internal1_error( angle_edge( M9_MAIN_V, == 90 ), == 0.038, direction = HORIZONTAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M9_PG_32_V_PRE4 = angle_edge( M9_PG_32_V_PRE3, == 90 ); 
M9_PG_32_V = M9_PG_32_V_PRE1 touching external2_edge( M9_PG_32_V_PRE2, M9_PG_32_V_PRE4, == 0.053, edge_containment = OUTSIDE, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, output_layer = LAYER1, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
M9_PG_32 = M9_PG_32_H or M9_PG_32_V; 

 
M9_PG_33_H_PRE1 = error_merge_list( { internal1_error( angle_edge( M9_MAIN_H, == 0 ), == 0.038, direction = VERTICAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M9_PG_33_H_PRE2 = angle_edge( M9_PG_33_H_PRE1, == 0 ); 
M9_PG_33_H_PRE3 = error_merge_list( { internal1_error( angle_edge( M9_MAIN_H, == 0 ), == 0.076, direction = VERTICAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M9_PG_33_H_PRE4 = angle_edge( M9_PG_33_H_PRE3, == 0 ); 
M9_PG_33_H = M9_PG_33_H_PRE1 touching external2_edge( M9_PG_33_H_PRE2, M9_PG_33_H_PRE4, == 0.053, edge_containment = OUTSIDE, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, output_layer = LAYER1, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
M9_PG_33_V_PRE1 = error_merge_list( { internal1_error( angle_edge( M9_MAIN_V, == 90 ), == 0.038, direction = HORIZONTAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M9_PG_33_V_PRE2 = angle_edge( M9_PG_33_V_PRE1, == 90 ); 
M9_PG_33_V_PRE3 = error_merge_list( { internal1_error( angle_edge( M9_MAIN_V, == 90 ), == 0.076, direction = HORIZONTAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M9_PG_33_V_PRE4 = angle_edge( M9_PG_33_V_PRE3, == 90 ); 
M9_PG_33_V = M9_PG_33_V_PRE1 touching external2_edge( M9_PG_33_V_PRE2, M9_PG_33_V_PRE4, == 0.053, edge_containment = OUTSIDE, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, output_layer = LAYER1, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
M9_PG_33 = M9_PG_33_H or M9_PG_33_V; 

 
M9_PG_34_H_PRE1 = error_merge_list( { internal1_error( angle_edge( M9_MAIN_H, == 0 ), == 0.076, direction = VERTICAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M9_PG_34_H_PRE2 = angle_edge( M9_PG_34_H_PRE1, == 0 ); 
M9_PG_34_H = M9_PG_34_H_PRE1 touching external1_edge( M9_PG_34_H_PRE2, == 0.074, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
M9_PG_34_V_PRE1 = error_merge_list( { internal1_error( angle_edge( M9_MAIN_V, == 90 ), == 0.076, direction = HORIZONTAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M9_PG_34_V_PRE2 = angle_edge( M9_PG_34_V_PRE1, == 90 ); 
M9_PG_34_V = M9_PG_34_V_PRE1 touching external1_edge( M9_PG_34_V_PRE2, == 0.074, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
M9_PG_34 = M9_PG_34_H or M9_PG_34_V; 

 
M9_PG_35_H_PRE1 = error_merge_list( { internal1_error( angle_edge( M9_MAIN_H, == 0 ), == 0.058, direction = VERTICAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M9_PG_35_H_PRE2 = angle_edge( M9_PG_35_H_PRE1, == 0 ); 
M9_PG_35_H_PRE3 = error_merge_list( { internal1_error( angle_edge( M9_MAIN_H, == 0 ), == 0.038, direction = VERTICAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M9_PG_35_H_PRE4 = angle_edge( M9_PG_35_H_PRE3, == 0 ); 
M9_PG_35_H = M9_PG_35_H_PRE1 touching external2_edge( M9_PG_35_H_PRE2, M9_PG_35_H_PRE4, == 0.053, edge_containment = OUTSIDE, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, output_layer = LAYER1, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
M9_PG_35_V_PRE1 = error_merge_list( { internal1_error( angle_edge( M9_MAIN_V, == 90 ), == 0.058, direction = HORIZONTAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M9_PG_35_V_PRE2 = angle_edge( M9_PG_35_V_PRE1, == 90 ); 
M9_PG_35_V_PRE3 = error_merge_list( { internal1_error( angle_edge( M9_MAIN_V, == 90 ), == 0.038, direction = HORIZONTAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M9_PG_35_V_PRE4 = angle_edge( M9_PG_35_V_PRE3, == 90 ); 
M9_PG_35_V = M9_PG_35_V_PRE1 touching external2_edge( M9_PG_35_V_PRE2, M9_PG_35_V_PRE4, == 0.053, edge_containment = OUTSIDE, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, output_layer = LAYER1, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
M9_PG_35 = M9_PG_35_H or M9_PG_35_V; 

 
M9_PG_36_H_PRE1 = error_merge_list( { internal1_error( angle_edge( M9_MAIN_H, == 0 ), == 0.038, direction = VERTICAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M9_PG_36_H_PRE2 = angle_edge( M9_PG_36_H_PRE1, == 0 ); 
M9_PG_36_H_PRE3 = error_merge_list( { internal1_error( angle_edge( M9_MAIN_H, == 0 ), == 0.058, direction = VERTICAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M9_PG_36_H_PRE4 = angle_edge( M9_PG_36_H_PRE3, == 0 ); 
M9_PG_36_H = M9_PG_36_H_PRE1 touching external2_edge( M9_PG_36_H_PRE2, M9_PG_36_H_PRE4, == 0.053, edge_containment = OUTSIDE, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, output_layer = LAYER1, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
M9_PG_36_V_PRE1 = error_merge_list( { internal1_error( angle_edge( M9_MAIN_V, == 90 ), == 0.038, direction = HORIZONTAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M9_PG_36_V_PRE2 = angle_edge( M9_PG_36_V_PRE1, == 90 ); 
M9_PG_36_V_PRE3 = error_merge_list( { internal1_error( angle_edge( M9_MAIN_V, == 90 ), == 0.058, direction = HORIZONTAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M9_PG_36_V_PRE4 = angle_edge( M9_PG_36_V_PRE3, == 90 ); 
M9_PG_36_V = M9_PG_36_V_PRE1 touching external2_edge( M9_PG_36_V_PRE2, M9_PG_36_V_PRE4, == 0.053, edge_containment = OUTSIDE, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, output_layer = LAYER1, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
M9_PG_36 = M9_PG_36_H or M9_PG_36_V; 

 
M9_PG_37_H_PRE1 = error_merge_list( { internal1_error( angle_edge( M9_MAIN_H, == 0 ), == 0.058, direction = VERTICAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M9_PG_37_H_PRE2 = angle_edge( M9_PG_37_H_PRE1, == 0 ); 
M9_PG_37_H_PRE3 = error_merge_list( { internal1_error( angle_edge( M9_MAIN_H, == 0 ), == 0.076, direction = VERTICAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M9_PG_37_H_PRE4 = angle_edge( M9_PG_37_H_PRE3, == 0 ); 
M9_PG_37_H = M9_PG_37_H_PRE1 touching external2_edge( M9_PG_37_H_PRE2, M9_PG_37_H_PRE4, == 0.053, edge_containment = OUTSIDE, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, output_layer = LAYER1, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
M9_PG_37_V_PRE1 = error_merge_list( { internal1_error( angle_edge( M9_MAIN_V, == 90 ), == 0.058, direction = HORIZONTAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M9_PG_37_V_PRE2 = angle_edge( M9_PG_37_V_PRE1, == 90 ); 
M9_PG_37_V_PRE3 = error_merge_list( { internal1_error( angle_edge( M9_MAIN_V, == 90 ), == 0.076, direction = HORIZONTAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M9_PG_37_V_PRE4 = angle_edge( M9_PG_37_V_PRE3, == 90 ); 
M9_PG_37_V = M9_PG_37_V_PRE1 touching external2_edge( M9_PG_37_V_PRE2, M9_PG_37_V_PRE4, == 0.053, edge_containment = OUTSIDE, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, output_layer = LAYER1, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
M9_PG_37 = M9_PG_37_H or M9_PG_37_V; 

 
M9_PG_38_H_PRE1 = error_merge_list( { internal1_error( angle_edge( M9_MAIN_H, == 0 ), == 0.076, direction = VERTICAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M9_PG_38_H_PRE2 = angle_edge( M9_PG_38_H_PRE1, == 0 ); 
M9_PG_38_H_PRE3 = error_merge_list( { internal1_error( angle_edge( M9_MAIN_H, == 0 ), == 0.058, direction = VERTICAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M9_PG_38_H_PRE4 = angle_edge( M9_PG_38_H_PRE3, == 0 ); 
M9_PG_38_H = M9_PG_38_H_PRE1 touching external2_edge( M9_PG_38_H_PRE2, M9_PG_38_H_PRE4, == 0.053, edge_containment = OUTSIDE, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, output_layer = LAYER1, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
M9_PG_38_V_PRE1 = error_merge_list( { internal1_error( angle_edge( M9_MAIN_V, == 90 ), == 0.076, direction = HORIZONTAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M9_PG_38_V_PRE2 = angle_edge( M9_PG_38_V_PRE1, == 90 ); 
M9_PG_38_V_PRE3 = error_merge_list( { internal1_error( angle_edge( M9_MAIN_V, == 90 ), == 0.058, direction = HORIZONTAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M9_PG_38_V_PRE4 = angle_edge( M9_PG_38_V_PRE3, == 90 ); 
M9_PG_38_V = M9_PG_38_V_PRE1 touching external2_edge( M9_PG_38_V_PRE2, M9_PG_38_V_PRE4, == 0.053, edge_containment = OUTSIDE, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, output_layer = LAYER1, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
M9_PG_38 = M9_PG_38_H or M9_PG_38_V; 

 
M9_PG_ALL = or_list( { M9_PG_31, M9_PG_32, M9_PG_33, M9_PG_34, M9_PG_35, M9_PG_36, M9_PG_37, M9_PG_38 } ); 



//  OPC DVIA_O
SQ_VIA8 = rectangles( VIA8, orientation = ORTHOGONAL, sides = { == 0.02, == 0.02 } ); 

VIA8_40 = rectangles( VIA8, orientation = ORTHOGONAL, sides = { == 0.04, == 0.04 } ); 




M10_HOLE = donut_holes( M10, area = < MY1HOLE, holes = INNER, outer_boundary_point_touch = CLOSED_OUTER_BOUNDARY ); 
M10_GT76 = wide( M10, > MY1W1, angled = TRUNCATE ); 
M10_GT114 = wide( M10, > MY1W2, angled = TRUNCATE ); 
M10_GT152 = wide( M10, > MY1W3, angled = TRUNCATE ); 
M10_GT180 = wide( M10, > MY1W4, angled = TRUNCATE ); 
M10_GT240 = wide( M10, > MY1W5, angled = TRUNCATE ); 
M10_GT280 = wide( M10, > MY1W6, angled = TRUNCATE ); 
M10_GT500 = wide( M10, > MY1W7, angled = TRUNCATE ); 
M10_GT1350 = wide( M10, > MY1W8, angled = TRUNCATE ); 

macroLAYER_18 = angle_edge( M10, == 45 ); 
macroLAYER_35 = extend_edge( macroLAYER_18, start = 0.41, end = 0.41 );
macroLAYER_17 = edge_size( macroLAYER_35, outside = DMY1_MY145 );
macroLAYER_16 = size( macroLAYER_17, clip_acute = TRUNCATE, distance = GRID ); 
M10_45 = M10 or macroLAYER_16; 

M10_38 = wide( M10, == MY138, angled = TRUNCATE );    /* My1.S.27 */ 
M10_40 = wide( M10, == MY140, angled = TRUNCATE );    /* My1.S.27.1 */ 
M10_60 = wide( M10, == MY160, angled = TRUNCATE ); 
M10_80 = wide( M10, == 0.08, angled = TRUNCATE ); 
M10_120 = wide( M10, == 0.12, angled = TRUNCATE ); 

DM10_GT1350 = wide( DM10, > 1.35, angled = TRUNCATE );    /* DMn.S.3.1 */ 

#ifdef VERTICAL_M10
S22_M10_EDGE_45 = angle_edge( M10, == 45 ); 
S22_M10_E1 = adjacent_edge( M10, angle1 = == 270, angle2 = == 270, length = < 0.114 ); 
S22_M10_E2 = length_edge( M10, <= 0.038 ); 
S22_M10_A1 = polygon_extents( not_touching( external1( M10, <= GRID, extension = RADIAL, intersecting = {  }, intersection_angle = == 90, look_thru = NOT_ADJACENT, orientation = { } ), S22_M10_EDGE_45, == 2 ) ); 
S22_M10_A1Y = interacting( S22_M10_A1, M10 ); 
S22_M10_AY = not_interacting( S22_M10_A1Y, edge_size( ( S22_M10_E1 or_edge S22_M10_E2 ), outside = GRID ) ); 
S22_M10_AY_EDGE = S22_M10_AY coincident_edge M10; 
S22_M10_AY_EDGE_V = angle_edge( S22_M10_AY_EDGE, == 90 ); 
S22_M10_AY_REGION_1 = edge_size( S22_M10_AY_EDGE_V, inside = 0.114 ); 
S22_M10_AY_EDGE_H = angle_edge( ( S22_M10_AY_REGION_1 touching_edge M10 ), == 0 ); 
S22_M10_REGION = edge_size( S22_M10_AY_EDGE_H, inside = 0.200 );    /* 0.114x0.200 */ 

#else
S22_M10_EDGE_45 = angle_edge( M10, == 45 ); 
S22_M10_E1 = adjacent_edge( M10, angle1 = == 270, angle2 = == 270, length = < 0.114 ); 
S22_M10_E2 = length_edge( M10, <= 0.038 ); 
S22_M10_A1 = polygon_extents( not_touching( external1( M10, <= GRID, extension = RADIAL, intersecting = {  }, intersection_angle = == 90, look_thru = NOT_ADJACENT, orientation = { } ), S22_M10_EDGE_45, == 2 ) ); 
S22_M10_A1X = interacting( S22_M10_A1, M10 ); 
S22_M10_AX = not_interacting( S22_M10_A1X, edge_size( ( S22_M10_E1 or_edge S22_M10_E2 ), outside = GRID ) ); 
S22_M10_AX_EDGE = S22_M10_AX coincident_edge M10; 
S22_M10_AX_EDGE_H = angle_edge( S22_M10_AX_EDGE, == 0 ); 
S22_M10_AX_REGION_1 = edge_size( S22_M10_AX_EDGE_H, inside = 0.114 ); 
S22_M10_AX_EDGE_V = angle_edge( ( S22_M10_AX_REGION_1 touching_edge M10 ), == 90 ); 
S22_M10_REGION = edge_size( S22_M10_AX_EDGE_V, inside = 0.200 );    /* 0.114x0.200 */ 

#endif
R7_VIA9_ENC1 = VIA9 touching_edge enclose_edge( VIA9, M10, < 0.001, edge_containment = INSIDE_TO_OUTSIDE, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, output_layer = LAYER1, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
R7_VIA9_ENC2 = internal2_edge( R7_VIA9_ENC1, VIA9, <= 0.1, edge_containment = INSIDE, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, membership = SAME_POLYGON, output_layer = LAYER2, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
R7_VIA9_EP_PRE1 = ( VIA9 touching_edge R7_VIA9_ENC1 ) or_edge ( VIA9 touching_edge R7_VIA9_ENC2 ); 
R7_VIA9_EP_PRE2 = enclose_edge( R7_VIA9_EP_PRE1, M9, < 0.065, edge_containment = INSIDE_TO_OUTSIDE, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, output_layer = LAYER1, projection = { IN, ON }, orientation = { PARALLEL } ); 
R7_VIA9_EP = VIA9 touching R7_VIA9_EP_PRE2; 
R7_VIA9_CHK_REGION = edge_size( extend_edge( ( R7_VIA9_EP touching_edge R7_VIA9_EP_PRE1 ), start = 0.300, end = 0.300 ), outside = 0.076 ); 


R15_VIA10_ENC1 = VIA10 touching_edge enclose_edge( VIA10, M10, < 0.001, edge_containment = INSIDE_TO_OUTSIDE, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, output_layer = LAYER1, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
R15_VIA10_ENC2 = internal2_edge( R15_VIA10_ENC1, VIA10, <= 0.1, edge_containment = INSIDE, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, membership = SAME_POLYGON, output_layer = LAYER2, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
R15_VIA10_EP_PRE1 = ( VIA10 touching_edge R15_VIA10_ENC1 ) or_edge ( VIA10 touching_edge R15_VIA10_ENC2 ); 
R15_VIA10_EP_PRE2 = enclose_edge( R15_VIA10_EP_PRE1, M11, < 0.065, edge_containment = INSIDE_TO_OUTSIDE, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, output_layer = LAYER1, projection = { IN, ON }, orientation = { PARALLEL } ); 
R15_VIA10_EP = VIA10 touching R15_VIA10_EP_PRE2; 
R15_VIA10_CHK_REGION = edge_size( extend_edge( ( R15_VIA10_EP touching_edge R15_VIA10_EP_PRE1 ), start = 0.300, end = 0.300 ), outside = 0.076 ); 



M10_PG_31_H_PRE1 = error_merge_list( { internal1_error( angle_edge( M10_MAIN_H, == 0 ), == 0.058, direction = VERTICAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M10_PG_31_H_PRE2 = angle_edge( M10_PG_31_H_PRE1, == 0 ); 
M10_PG_31_H = M10_PG_31_H_PRE1 touching external1_edge( M10_PG_31_H_PRE2, == 0.054, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
M10_PG_31_V_PRE1 = error_merge_list( { internal1_error( angle_edge( M10_MAIN_V, == 90 ), == 0.058, direction = HORIZONTAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M10_PG_31_V_PRE2 = angle_edge( M10_PG_31_V_PRE1, == 90 ); 
M10_PG_31_V = M10_PG_31_V_PRE1 touching external1_edge( M10_PG_31_V_PRE2, == 0.054, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
M10_PG_31 = M10_PG_31_H or M10_PG_31_V; 

 
M10_PG_32_H_PRE1 = error_merge_list( { internal1_error( angle_edge( M10_MAIN_H, == 0 ), == 0.076, direction = VERTICAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M10_PG_32_H_PRE2 = angle_edge( M10_PG_32_H_PRE1, == 0 ); 
M10_PG_32_H_PRE3 = error_merge_list( { internal1_error( angle_edge( M10_MAIN_H, == 0 ), == 0.038, direction = VERTICAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M10_PG_32_H_PRE4 = angle_edge( M10_PG_32_H_PRE3, == 0 ); 
M10_PG_32_H = M10_PG_32_H_PRE1 touching external2_edge( M10_PG_32_H_PRE2, M10_PG_32_H_PRE4, == 0.053, edge_containment = OUTSIDE, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, output_layer = LAYER1, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
M10_PG_32_V_PRE1 = error_merge_list( { internal1_error( angle_edge( M10_MAIN_V, == 90 ), == 0.076, direction = HORIZONTAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M10_PG_32_V_PRE2 = angle_edge( M10_PG_32_V_PRE1, == 90 ); 
M10_PG_32_V_PRE3 = error_merge_list( { internal1_error( angle_edge( M10_MAIN_V, == 90 ), == 0.038, direction = HORIZONTAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M10_PG_32_V_PRE4 = angle_edge( M10_PG_32_V_PRE3, == 90 ); 
M10_PG_32_V = M10_PG_32_V_PRE1 touching external2_edge( M10_PG_32_V_PRE2, M10_PG_32_V_PRE4, == 0.053, edge_containment = OUTSIDE, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, output_layer = LAYER1, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
M10_PG_32 = M10_PG_32_H or M10_PG_32_V; 

 
M10_PG_33_H_PRE1 = error_merge_list( { internal1_error( angle_edge( M10_MAIN_H, == 0 ), == 0.038, direction = VERTICAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M10_PG_33_H_PRE2 = angle_edge( M10_PG_33_H_PRE1, == 0 ); 
M10_PG_33_H_PRE3 = error_merge_list( { internal1_error( angle_edge( M10_MAIN_H, == 0 ), == 0.076, direction = VERTICAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M10_PG_33_H_PRE4 = angle_edge( M10_PG_33_H_PRE3, == 0 ); 
M10_PG_33_H = M10_PG_33_H_PRE1 touching external2_edge( M10_PG_33_H_PRE2, M10_PG_33_H_PRE4, == 0.053, edge_containment = OUTSIDE, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, output_layer = LAYER1, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
M10_PG_33_V_PRE1 = error_merge_list( { internal1_error( angle_edge( M10_MAIN_V, == 90 ), == 0.038, direction = HORIZONTAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M10_PG_33_V_PRE2 = angle_edge( M10_PG_33_V_PRE1, == 90 ); 
M10_PG_33_V_PRE3 = error_merge_list( { internal1_error( angle_edge( M10_MAIN_V, == 90 ), == 0.076, direction = HORIZONTAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M10_PG_33_V_PRE4 = angle_edge( M10_PG_33_V_PRE3, == 90 ); 
M10_PG_33_V = M10_PG_33_V_PRE1 touching external2_edge( M10_PG_33_V_PRE2, M10_PG_33_V_PRE4, == 0.053, edge_containment = OUTSIDE, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, output_layer = LAYER1, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
M10_PG_33 = M10_PG_33_H or M10_PG_33_V; 

 
M10_PG_34_H_PRE1 = error_merge_list( { internal1_error( angle_edge( M10_MAIN_H, == 0 ), == 0.076, direction = VERTICAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M10_PG_34_H_PRE2 = angle_edge( M10_PG_34_H_PRE1, == 0 ); 
M10_PG_34_H = M10_PG_34_H_PRE1 touching external1_edge( M10_PG_34_H_PRE2, == 0.074, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
M10_PG_34_V_PRE1 = error_merge_list( { internal1_error( angle_edge( M10_MAIN_V, == 90 ), == 0.076, direction = HORIZONTAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M10_PG_34_V_PRE2 = angle_edge( M10_PG_34_V_PRE1, == 90 ); 
M10_PG_34_V = M10_PG_34_V_PRE1 touching external1_edge( M10_PG_34_V_PRE2, == 0.074, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
M10_PG_34 = M10_PG_34_H or M10_PG_34_V; 

 
M10_PG_35_H_PRE1 = error_merge_list( { internal1_error( angle_edge( M10_MAIN_H, == 0 ), == 0.058, direction = VERTICAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M10_PG_35_H_PRE2 = angle_edge( M10_PG_35_H_PRE1, == 0 ); 
M10_PG_35_H_PRE3 = error_merge_list( { internal1_error( angle_edge( M10_MAIN_H, == 0 ), == 0.038, direction = VERTICAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M10_PG_35_H_PRE4 = angle_edge( M10_PG_35_H_PRE3, == 0 ); 
M10_PG_35_H = M10_PG_35_H_PRE1 touching external2_edge( M10_PG_35_H_PRE2, M10_PG_35_H_PRE4, == 0.053, edge_containment = OUTSIDE, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, output_layer = LAYER1, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
M10_PG_35_V_PRE1 = error_merge_list( { internal1_error( angle_edge( M10_MAIN_V, == 90 ), == 0.058, direction = HORIZONTAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M10_PG_35_V_PRE2 = angle_edge( M10_PG_35_V_PRE1, == 90 ); 
M10_PG_35_V_PRE3 = error_merge_list( { internal1_error( angle_edge( M10_MAIN_V, == 90 ), == 0.038, direction = HORIZONTAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M10_PG_35_V_PRE4 = angle_edge( M10_PG_35_V_PRE3, == 90 ); 
M10_PG_35_V = M10_PG_35_V_PRE1 touching external2_edge( M10_PG_35_V_PRE2, M10_PG_35_V_PRE4, == 0.053, edge_containment = OUTSIDE, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, output_layer = LAYER1, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
M10_PG_35 = M10_PG_35_H or M10_PG_35_V; 

 
M10_PG_36_H_PRE1 = error_merge_list( { internal1_error( angle_edge( M10_MAIN_H, == 0 ), == 0.038, direction = VERTICAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M10_PG_36_H_PRE2 = angle_edge( M10_PG_36_H_PRE1, == 0 ); 
M10_PG_36_H_PRE3 = error_merge_list( { internal1_error( angle_edge( M10_MAIN_H, == 0 ), == 0.058, direction = VERTICAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M10_PG_36_H_PRE4 = angle_edge( M10_PG_36_H_PRE3, == 0 ); 
M10_PG_36_H = M10_PG_36_H_PRE1 touching external2_edge( M10_PG_36_H_PRE2, M10_PG_36_H_PRE4, == 0.053, edge_containment = OUTSIDE, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, output_layer = LAYER1, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
M10_PG_36_V_PRE1 = error_merge_list( { internal1_error( angle_edge( M10_MAIN_V, == 90 ), == 0.038, direction = HORIZONTAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M10_PG_36_V_PRE2 = angle_edge( M10_PG_36_V_PRE1, == 90 ); 
M10_PG_36_V_PRE3 = error_merge_list( { internal1_error( angle_edge( M10_MAIN_V, == 90 ), == 0.058, direction = HORIZONTAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M10_PG_36_V_PRE4 = angle_edge( M10_PG_36_V_PRE3, == 90 ); 
M10_PG_36_V = M10_PG_36_V_PRE1 touching external2_edge( M10_PG_36_V_PRE2, M10_PG_36_V_PRE4, == 0.053, edge_containment = OUTSIDE, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, output_layer = LAYER1, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
M10_PG_36 = M10_PG_36_H or M10_PG_36_V; 

 
M10_PG_37_H_PRE1 = error_merge_list( { internal1_error( angle_edge( M10_MAIN_H, == 0 ), == 0.058, direction = VERTICAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M10_PG_37_H_PRE2 = angle_edge( M10_PG_37_H_PRE1, == 0 ); 
M10_PG_37_H_PRE3 = error_merge_list( { internal1_error( angle_edge( M10_MAIN_H, == 0 ), == 0.076, direction = VERTICAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M10_PG_37_H_PRE4 = angle_edge( M10_PG_37_H_PRE3, == 0 ); 
M10_PG_37_H = M10_PG_37_H_PRE1 touching external2_edge( M10_PG_37_H_PRE2, M10_PG_37_H_PRE4, == 0.053, edge_containment = OUTSIDE, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, output_layer = LAYER1, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
M10_PG_37_V_PRE1 = error_merge_list( { internal1_error( angle_edge( M10_MAIN_V, == 90 ), == 0.058, direction = HORIZONTAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M10_PG_37_V_PRE2 = angle_edge( M10_PG_37_V_PRE1, == 90 ); 
M10_PG_37_V_PRE3 = error_merge_list( { internal1_error( angle_edge( M10_MAIN_V, == 90 ), == 0.076, direction = HORIZONTAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M10_PG_37_V_PRE4 = angle_edge( M10_PG_37_V_PRE3, == 90 ); 
M10_PG_37_V = M10_PG_37_V_PRE1 touching external2_edge( M10_PG_37_V_PRE2, M10_PG_37_V_PRE4, == 0.053, edge_containment = OUTSIDE, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, output_layer = LAYER1, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
M10_PG_37 = M10_PG_37_H or M10_PG_37_V; 

 
M10_PG_38_H_PRE1 = error_merge_list( { internal1_error( angle_edge( M10_MAIN_H, == 0 ), == 0.076, direction = VERTICAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M10_PG_38_H_PRE2 = angle_edge( M10_PG_38_H_PRE1, == 0 ); 
M10_PG_38_H_PRE3 = error_merge_list( { internal1_error( angle_edge( M10_MAIN_H, == 0 ), == 0.058, direction = VERTICAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M10_PG_38_H_PRE4 = angle_edge( M10_PG_38_H_PRE3, == 0 ); 
M10_PG_38_H = M10_PG_38_H_PRE1 touching external2_edge( M10_PG_38_H_PRE2, M10_PG_38_H_PRE4, == 0.053, edge_containment = OUTSIDE, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, output_layer = LAYER1, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
M10_PG_38_V_PRE1 = error_merge_list( { internal1_error( angle_edge( M10_MAIN_V, == 90 ), == 0.076, direction = HORIZONTAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M10_PG_38_V_PRE2 = angle_edge( M10_PG_38_V_PRE1, == 90 ); 
M10_PG_38_V_PRE3 = error_merge_list( { internal1_error( angle_edge( M10_MAIN_V, == 90 ), == 0.058, direction = HORIZONTAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M10_PG_38_V_PRE4 = angle_edge( M10_PG_38_V_PRE3, == 90 ); 
M10_PG_38_V = M10_PG_38_V_PRE1 touching external2_edge( M10_PG_38_V_PRE2, M10_PG_38_V_PRE4, == 0.053, edge_containment = OUTSIDE, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, output_layer = LAYER1, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
M10_PG_38 = M10_PG_38_H or M10_PG_38_V; 

 
M10_PG_ALL = or_list( { M10_PG_31, M10_PG_32, M10_PG_33, M10_PG_34, M10_PG_35, M10_PG_36, M10_PG_37, M10_PG_38 } ); 



//  OPC DVIA_O
SQ_VIA9 = rectangles( VIA9, orientation = ORTHOGONAL, sides = { == 0.02, == 0.02 } ); 

VIA9_40 = rectangles( VIA9, orientation = ORTHOGONAL, sides = { == 0.04, == 0.04 } ); 




M11_HOLE = donut_holes( M11, area = < MY1HOLE, holes = INNER, outer_boundary_point_touch = CLOSED_OUTER_BOUNDARY ); 
M11_GT76 = wide( M11, > MY1W1, angled = TRUNCATE ); 
M11_GT114 = wide( M11, > MY1W2, angled = TRUNCATE ); 
M11_GT152 = wide( M11, > MY1W3, angled = TRUNCATE ); 
M11_GT180 = wide( M11, > MY1W4, angled = TRUNCATE ); 
M11_GT240 = wide( M11, > MY1W5, angled = TRUNCATE ); 
M11_GT280 = wide( M11, > MY1W6, angled = TRUNCATE ); 
M11_GT500 = wide( M11, > MY1W7, angled = TRUNCATE ); 
M11_GT1350 = wide( M11, > MY1W8, angled = TRUNCATE ); 

macroLAYER_18 = angle_edge( M11, == 45 ); 
macroLAYER_35 = extend_edge( macroLAYER_18, start = 0.41, end = 0.41 );
macroLAYER_17 = edge_size( macroLAYER_35, outside = DMY1_MY145 );
macroLAYER_16 = size( macroLAYER_17, clip_acute = TRUNCATE, distance = GRID ); 
M11_45 = M11 or macroLAYER_16; 

M11_38 = wide( M11, == MY138, angled = TRUNCATE );    /* My1.S.27 */ 
M11_40 = wide( M11, == MY140, angled = TRUNCATE );    /* My1.S.27.1 */ 
M11_60 = wide( M11, == MY160, angled = TRUNCATE ); 
M11_80 = wide( M11, == 0.08, angled = TRUNCATE ); 
M11_120 = wide( M11, == 0.12, angled = TRUNCATE ); 

DM11_GT1350 = wide( DM11, > 1.35, angled = TRUNCATE );    /* DMn.S.3.1 */ 

#ifdef VERTICAL_M11
S22_M11_EDGE_45 = angle_edge( M11, == 45 ); 
S22_M11_E1 = adjacent_edge( M11, angle1 = == 270, angle2 = == 270, length = < 0.114 ); 
S22_M11_E2 = length_edge( M11, <= 0.038 ); 
S22_M11_A1 = polygon_extents( not_touching( external1( M11, <= GRID, extension = RADIAL, intersecting = {  }, intersection_angle = == 90, look_thru = NOT_ADJACENT, orientation = { } ), S22_M11_EDGE_45, == 2 ) ); 
S22_M11_A1Y = interacting( S22_M11_A1, M11 ); 
S22_M11_AY = not_interacting( S22_M11_A1Y, edge_size( ( S22_M11_E1 or_edge S22_M11_E2 ), outside = GRID ) ); 
S22_M11_AY_EDGE = S22_M11_AY coincident_edge M11; 
S22_M11_AY_EDGE_V = angle_edge( S22_M11_AY_EDGE, == 90 ); 
S22_M11_AY_REGION_1 = edge_size( S22_M11_AY_EDGE_V, inside = 0.114 ); 
S22_M11_AY_EDGE_H = angle_edge( ( S22_M11_AY_REGION_1 touching_edge M11 ), == 0 ); 
S22_M11_REGION = edge_size( S22_M11_AY_EDGE_H, inside = 0.200 );    /* 0.114x0.200 */ 

#else
S22_M11_EDGE_45 = angle_edge( M11, == 45 ); 
S22_M11_E1 = adjacent_edge( M11, angle1 = == 270, angle2 = == 270, length = < 0.114 ); 
S22_M11_E2 = length_edge( M11, <= 0.038 ); 
S22_M11_A1 = polygon_extents( not_touching( external1( M11, <= GRID, extension = RADIAL, intersecting = {  }, intersection_angle = == 90, look_thru = NOT_ADJACENT, orientation = { } ), S22_M11_EDGE_45, == 2 ) ); 
S22_M11_A1X = interacting( S22_M11_A1, M11 ); 
S22_M11_AX = not_interacting( S22_M11_A1X, edge_size( ( S22_M11_E1 or_edge S22_M11_E2 ), outside = GRID ) ); 
S22_M11_AX_EDGE = S22_M11_AX coincident_edge M11; 
S22_M11_AX_EDGE_H = angle_edge( S22_M11_AX_EDGE, == 0 ); 
S22_M11_AX_REGION_1 = edge_size( S22_M11_AX_EDGE_H, inside = 0.114 ); 
S22_M11_AX_EDGE_V = angle_edge( ( S22_M11_AX_REGION_1 touching_edge M11 ), == 90 ); 
S22_M11_REGION = edge_size( S22_M11_AX_EDGE_V, inside = 0.200 );    /* 0.114x0.200 */ 

#endif
R7_VIA10_ENC1 = VIA10 touching_edge enclose_edge( VIA10, M11, < 0.001, edge_containment = INSIDE_TO_OUTSIDE, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, output_layer = LAYER1, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
R7_VIA10_ENC2 = internal2_edge( R7_VIA10_ENC1, VIA10, <= 0.1, edge_containment = INSIDE, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, membership = SAME_POLYGON, output_layer = LAYER2, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
R7_VIA10_EP_PRE1 = ( VIA10 touching_edge R7_VIA10_ENC1 ) or_edge ( VIA10 touching_edge R7_VIA10_ENC2 ); 
R7_VIA10_EP_PRE2 = enclose_edge( R7_VIA10_EP_PRE1, M10, < 0.065, edge_containment = INSIDE_TO_OUTSIDE, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, output_layer = LAYER1, projection = { IN, ON }, orientation = { PARALLEL } ); 
R7_VIA10_EP = VIA10 touching R7_VIA10_EP_PRE2; 
R7_VIA10_CHK_REGION = edge_size( extend_edge( ( R7_VIA10_EP touching_edge R7_VIA10_EP_PRE1 ), start = 0.300, end = 0.300 ), outside = 0.076 ); 


R15_VIA11_ENC1 = VIA11 touching_edge enclose_edge( VIA11, M11, < 0.001, edge_containment = INSIDE_TO_OUTSIDE, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, output_layer = LAYER1, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
R15_VIA11_ENC2 = internal2_edge( R15_VIA11_ENC1, VIA11, <= 0.1, edge_containment = INSIDE, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, membership = SAME_POLYGON, output_layer = LAYER2, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
R15_VIA11_EP_PRE1 = ( VIA11 touching_edge R15_VIA11_ENC1 ) or_edge ( VIA11 touching_edge R15_VIA11_ENC2 ); 
R15_VIA11_EP_PRE2 = enclose_edge( R15_VIA11_EP_PRE1, M12, < 0.065, edge_containment = INSIDE_TO_OUTSIDE, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, output_layer = LAYER1, projection = { IN, ON }, orientation = { PARALLEL } ); 
R15_VIA11_EP = VIA11 touching R15_VIA11_EP_PRE2; 
R15_VIA11_CHK_REGION = edge_size( extend_edge( ( R15_VIA11_EP touching_edge R15_VIA11_EP_PRE1 ), start = 0.300, end = 0.300 ), outside = 0.076 ); 



M11_PG_31_H_PRE1 = error_merge_list( { internal1_error( angle_edge( M11_MAIN_H, == 0 ), == 0.058, direction = VERTICAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M11_PG_31_H_PRE2 = angle_edge( M11_PG_31_H_PRE1, == 0 ); 
M11_PG_31_H = M11_PG_31_H_PRE1 touching external1_edge( M11_PG_31_H_PRE2, == 0.054, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
M11_PG_31_V_PRE1 = error_merge_list( { internal1_error( angle_edge( M11_MAIN_V, == 90 ), == 0.058, direction = HORIZONTAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M11_PG_31_V_PRE2 = angle_edge( M11_PG_31_V_PRE1, == 90 ); 
M11_PG_31_V = M11_PG_31_V_PRE1 touching external1_edge( M11_PG_31_V_PRE2, == 0.054, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
M11_PG_31 = M11_PG_31_H or M11_PG_31_V; 

 
M11_PG_32_H_PRE1 = error_merge_list( { internal1_error( angle_edge( M11_MAIN_H, == 0 ), == 0.076, direction = VERTICAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M11_PG_32_H_PRE2 = angle_edge( M11_PG_32_H_PRE1, == 0 ); 
M11_PG_32_H_PRE3 = error_merge_list( { internal1_error( angle_edge( M11_MAIN_H, == 0 ), == 0.038, direction = VERTICAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M11_PG_32_H_PRE4 = angle_edge( M11_PG_32_H_PRE3, == 0 ); 
M11_PG_32_H = M11_PG_32_H_PRE1 touching external2_edge( M11_PG_32_H_PRE2, M11_PG_32_H_PRE4, == 0.053, edge_containment = OUTSIDE, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, output_layer = LAYER1, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
M11_PG_32_V_PRE1 = error_merge_list( { internal1_error( angle_edge( M11_MAIN_V, == 90 ), == 0.076, direction = HORIZONTAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M11_PG_32_V_PRE2 = angle_edge( M11_PG_32_V_PRE1, == 90 ); 
M11_PG_32_V_PRE3 = error_merge_list( { internal1_error( angle_edge( M11_MAIN_V, == 90 ), == 0.038, direction = HORIZONTAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M11_PG_32_V_PRE4 = angle_edge( M11_PG_32_V_PRE3, == 90 ); 
M11_PG_32_V = M11_PG_32_V_PRE1 touching external2_edge( M11_PG_32_V_PRE2, M11_PG_32_V_PRE4, == 0.053, edge_containment = OUTSIDE, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, output_layer = LAYER1, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
M11_PG_32 = M11_PG_32_H or M11_PG_32_V; 

 
M11_PG_33_H_PRE1 = error_merge_list( { internal1_error( angle_edge( M11_MAIN_H, == 0 ), == 0.038, direction = VERTICAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M11_PG_33_H_PRE2 = angle_edge( M11_PG_33_H_PRE1, == 0 ); 
M11_PG_33_H_PRE3 = error_merge_list( { internal1_error( angle_edge( M11_MAIN_H, == 0 ), == 0.076, direction = VERTICAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M11_PG_33_H_PRE4 = angle_edge( M11_PG_33_H_PRE3, == 0 ); 
M11_PG_33_H = M11_PG_33_H_PRE1 touching external2_edge( M11_PG_33_H_PRE2, M11_PG_33_H_PRE4, == 0.053, edge_containment = OUTSIDE, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, output_layer = LAYER1, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
M11_PG_33_V_PRE1 = error_merge_list( { internal1_error( angle_edge( M11_MAIN_V, == 90 ), == 0.038, direction = HORIZONTAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M11_PG_33_V_PRE2 = angle_edge( M11_PG_33_V_PRE1, == 90 ); 
M11_PG_33_V_PRE3 = error_merge_list( { internal1_error( angle_edge( M11_MAIN_V, == 90 ), == 0.076, direction = HORIZONTAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M11_PG_33_V_PRE4 = angle_edge( M11_PG_33_V_PRE3, == 90 ); 
M11_PG_33_V = M11_PG_33_V_PRE1 touching external2_edge( M11_PG_33_V_PRE2, M11_PG_33_V_PRE4, == 0.053, edge_containment = OUTSIDE, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, output_layer = LAYER1, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
M11_PG_33 = M11_PG_33_H or M11_PG_33_V; 

 
M11_PG_34_H_PRE1 = error_merge_list( { internal1_error( angle_edge( M11_MAIN_H, == 0 ), == 0.076, direction = VERTICAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M11_PG_34_H_PRE2 = angle_edge( M11_PG_34_H_PRE1, == 0 ); 
M11_PG_34_H = M11_PG_34_H_PRE1 touching external1_edge( M11_PG_34_H_PRE2, == 0.074, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
M11_PG_34_V_PRE1 = error_merge_list( { internal1_error( angle_edge( M11_MAIN_V, == 90 ), == 0.076, direction = HORIZONTAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M11_PG_34_V_PRE2 = angle_edge( M11_PG_34_V_PRE1, == 90 ); 
M11_PG_34_V = M11_PG_34_V_PRE1 touching external1_edge( M11_PG_34_V_PRE2, == 0.074, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
M11_PG_34 = M11_PG_34_H or M11_PG_34_V; 

 
M11_PG_35_H_PRE1 = error_merge_list( { internal1_error( angle_edge( M11_MAIN_H, == 0 ), == 0.058, direction = VERTICAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M11_PG_35_H_PRE2 = angle_edge( M11_PG_35_H_PRE1, == 0 ); 
M11_PG_35_H_PRE3 = error_merge_list( { internal1_error( angle_edge( M11_MAIN_H, == 0 ), == 0.038, direction = VERTICAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M11_PG_35_H_PRE4 = angle_edge( M11_PG_35_H_PRE3, == 0 ); 
M11_PG_35_H = M11_PG_35_H_PRE1 touching external2_edge( M11_PG_35_H_PRE2, M11_PG_35_H_PRE4, == 0.053, edge_containment = OUTSIDE, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, output_layer = LAYER1, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
M11_PG_35_V_PRE1 = error_merge_list( { internal1_error( angle_edge( M11_MAIN_V, == 90 ), == 0.058, direction = HORIZONTAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M11_PG_35_V_PRE2 = angle_edge( M11_PG_35_V_PRE1, == 90 ); 
M11_PG_35_V_PRE3 = error_merge_list( { internal1_error( angle_edge( M11_MAIN_V, == 90 ), == 0.038, direction = HORIZONTAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M11_PG_35_V_PRE4 = angle_edge( M11_PG_35_V_PRE3, == 90 ); 
M11_PG_35_V = M11_PG_35_V_PRE1 touching external2_edge( M11_PG_35_V_PRE2, M11_PG_35_V_PRE4, == 0.053, edge_containment = OUTSIDE, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, output_layer = LAYER1, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
M11_PG_35 = M11_PG_35_H or M11_PG_35_V; 

 
M11_PG_36_H_PRE1 = error_merge_list( { internal1_error( angle_edge( M11_MAIN_H, == 0 ), == 0.038, direction = VERTICAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M11_PG_36_H_PRE2 = angle_edge( M11_PG_36_H_PRE1, == 0 ); 
M11_PG_36_H_PRE3 = error_merge_list( { internal1_error( angle_edge( M11_MAIN_H, == 0 ), == 0.058, direction = VERTICAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M11_PG_36_H_PRE4 = angle_edge( M11_PG_36_H_PRE3, == 0 ); 
M11_PG_36_H = M11_PG_36_H_PRE1 touching external2_edge( M11_PG_36_H_PRE2, M11_PG_36_H_PRE4, == 0.053, edge_containment = OUTSIDE, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, output_layer = LAYER1, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
M11_PG_36_V_PRE1 = error_merge_list( { internal1_error( angle_edge( M11_MAIN_V, == 90 ), == 0.038, direction = HORIZONTAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M11_PG_36_V_PRE2 = angle_edge( M11_PG_36_V_PRE1, == 90 ); 
M11_PG_36_V_PRE3 = error_merge_list( { internal1_error( angle_edge( M11_MAIN_V, == 90 ), == 0.058, direction = HORIZONTAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M11_PG_36_V_PRE4 = angle_edge( M11_PG_36_V_PRE3, == 90 ); 
M11_PG_36_V = M11_PG_36_V_PRE1 touching external2_edge( M11_PG_36_V_PRE2, M11_PG_36_V_PRE4, == 0.053, edge_containment = OUTSIDE, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, output_layer = LAYER1, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
M11_PG_36 = M11_PG_36_H or M11_PG_36_V; 

 
M11_PG_37_H_PRE1 = error_merge_list( { internal1_error( angle_edge( M11_MAIN_H, == 0 ), == 0.058, direction = VERTICAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M11_PG_37_H_PRE2 = angle_edge( M11_PG_37_H_PRE1, == 0 ); 
M11_PG_37_H_PRE3 = error_merge_list( { internal1_error( angle_edge( M11_MAIN_H, == 0 ), == 0.076, direction = VERTICAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M11_PG_37_H_PRE4 = angle_edge( M11_PG_37_H_PRE3, == 0 ); 
M11_PG_37_H = M11_PG_37_H_PRE1 touching external2_edge( M11_PG_37_H_PRE2, M11_PG_37_H_PRE4, == 0.053, edge_containment = OUTSIDE, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, output_layer = LAYER1, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
M11_PG_37_V_PRE1 = error_merge_list( { internal1_error( angle_edge( M11_MAIN_V, == 90 ), == 0.058, direction = HORIZONTAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M11_PG_37_V_PRE2 = angle_edge( M11_PG_37_V_PRE1, == 90 ); 
M11_PG_37_V_PRE3 = error_merge_list( { internal1_error( angle_edge( M11_MAIN_V, == 90 ), == 0.076, direction = HORIZONTAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M11_PG_37_V_PRE4 = angle_edge( M11_PG_37_V_PRE3, == 90 ); 
M11_PG_37_V = M11_PG_37_V_PRE1 touching external2_edge( M11_PG_37_V_PRE2, M11_PG_37_V_PRE4, == 0.053, edge_containment = OUTSIDE, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, output_layer = LAYER1, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
M11_PG_37 = M11_PG_37_H or M11_PG_37_V; 

 
M11_PG_38_H_PRE1 = error_merge_list( { internal1_error( angle_edge( M11_MAIN_H, == 0 ), == 0.076, direction = VERTICAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M11_PG_38_H_PRE2 = angle_edge( M11_PG_38_H_PRE1, == 0 ); 
M11_PG_38_H_PRE3 = error_merge_list( { internal1_error( angle_edge( M11_MAIN_H, == 0 ), == 0.058, direction = VERTICAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M11_PG_38_H_PRE4 = angle_edge( M11_PG_38_H_PRE3, == 0 ); 
M11_PG_38_H = M11_PG_38_H_PRE1 touching external2_edge( M11_PG_38_H_PRE2, M11_PG_38_H_PRE4, == 0.053, edge_containment = OUTSIDE, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, output_layer = LAYER1, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
M11_PG_38_V_PRE1 = error_merge_list( { internal1_error( angle_edge( M11_MAIN_V, == 90 ), == 0.076, direction = HORIZONTAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M11_PG_38_V_PRE2 = angle_edge( M11_PG_38_V_PRE1, == 90 ); 
M11_PG_38_V_PRE3 = error_merge_list( { internal1_error( angle_edge( M11_MAIN_V, == 90 ), == 0.058, direction = HORIZONTAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M11_PG_38_V_PRE4 = angle_edge( M11_PG_38_V_PRE3, == 90 ); 
M11_PG_38_V = M11_PG_38_V_PRE1 touching external2_edge( M11_PG_38_V_PRE2, M11_PG_38_V_PRE4, == 0.053, edge_containment = OUTSIDE, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, output_layer = LAYER1, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
M11_PG_38 = M11_PG_38_H or M11_PG_38_V; 

 
M11_PG_ALL = or_list( { M11_PG_31, M11_PG_32, M11_PG_33, M11_PG_34, M11_PG_35, M11_PG_36, M11_PG_37, M11_PG_38 } ); 



//  OPC DVIA_O
SQ_VIA10 = rectangles( VIA10, orientation = ORTHOGONAL, sides = { == 0.02, == 0.02 } ); 

VIA10_40 = rectangles( VIA10, orientation = ORTHOGONAL, sides = { == 0.04, == 0.04 } ); 




M12_HOLE = donut_holes( M12, area = < MY1HOLE, holes = INNER, outer_boundary_point_touch = CLOSED_OUTER_BOUNDARY ); 
M12_GT76 = wide( M12, > MY1W1, angled = TRUNCATE ); 
M12_GT114 = wide( M12, > MY1W2, angled = TRUNCATE ); 
M12_GT152 = wide( M12, > MY1W3, angled = TRUNCATE ); 
M12_GT180 = wide( M12, > MY1W4, angled = TRUNCATE ); 
M12_GT240 = wide( M12, > MY1W5, angled = TRUNCATE ); 
M12_GT280 = wide( M12, > MY1W6, angled = TRUNCATE ); 
M12_GT500 = wide( M12, > MY1W7, angled = TRUNCATE ); 
M12_GT1350 = wide( M12, > MY1W8, angled = TRUNCATE ); 

macroLAYER_18 = angle_edge( M12, == 45 ); 
macroLAYER_35 = extend_edge( macroLAYER_18, start = 0.41, end = 0.41 );
macroLAYER_17 = edge_size( macroLAYER_35, outside = DMY1_MY145 );
macroLAYER_16 = size( macroLAYER_17, clip_acute = TRUNCATE, distance = GRID ); 
M12_45 = M12 or macroLAYER_16; 

M12_38 = wide( M12, == MY138, angled = TRUNCATE );    /* My1.S.27 */ 
M12_40 = wide( M12, == MY140, angled = TRUNCATE );    /* My1.S.27.1 */ 
M12_60 = wide( M12, == MY160, angled = TRUNCATE ); 
M12_80 = wide( M12, == 0.08, angled = TRUNCATE ); 
M12_120 = wide( M12, == 0.12, angled = TRUNCATE ); 

DM12_GT1350 = wide( DM12, > 1.35, angled = TRUNCATE );    /* DMn.S.3.1 */ 

#ifdef VERTICAL_M12
S22_M12_EDGE_45 = angle_edge( M12, == 45 ); 
S22_M12_E1 = adjacent_edge( M12, angle1 = == 270, angle2 = == 270, length = < 0.114 ); 
S22_M12_E2 = length_edge( M12, <= 0.038 ); 
S22_M12_A1 = polygon_extents( not_touching( external1( M12, <= GRID, extension = RADIAL, intersecting = {  }, intersection_angle = == 90, look_thru = NOT_ADJACENT, orientation = { } ), S22_M12_EDGE_45, == 2 ) ); 
S22_M12_A1Y = interacting( S22_M12_A1, M12 ); 
S22_M12_AY = not_interacting( S22_M12_A1Y, edge_size( ( S22_M12_E1 or_edge S22_M12_E2 ), outside = GRID ) ); 
S22_M12_AY_EDGE = S22_M12_AY coincident_edge M12; 
S22_M12_AY_EDGE_V = angle_edge( S22_M12_AY_EDGE, == 90 ); 
S22_M12_AY_REGION_1 = edge_size( S22_M12_AY_EDGE_V, inside = 0.114 ); 
S22_M12_AY_EDGE_H = angle_edge( ( S22_M12_AY_REGION_1 touching_edge M12 ), == 0 ); 
S22_M12_REGION = edge_size( S22_M12_AY_EDGE_H, inside = 0.200 );    /* 0.114x0.200 */ 

#else
S22_M12_EDGE_45 = angle_edge( M12, == 45 ); 
S22_M12_E1 = adjacent_edge( M12, angle1 = == 270, angle2 = == 270, length = < 0.114 ); 
S22_M12_E2 = length_edge( M12, <= 0.038 ); 
S22_M12_A1 = polygon_extents( not_touching( external1( M12, <= GRID, extension = RADIAL, intersecting = {  }, intersection_angle = == 90, look_thru = NOT_ADJACENT, orientation = { } ), S22_M12_EDGE_45, == 2 ) ); 
S22_M12_A1X = interacting( S22_M12_A1, M12 ); 
S22_M12_AX = not_interacting( S22_M12_A1X, edge_size( ( S22_M12_E1 or_edge S22_M12_E2 ), outside = GRID ) ); 
S22_M12_AX_EDGE = S22_M12_AX coincident_edge M12; 
S22_M12_AX_EDGE_H = angle_edge( S22_M12_AX_EDGE, == 0 ); 
S22_M12_AX_REGION_1 = edge_size( S22_M12_AX_EDGE_H, inside = 0.114 ); 
S22_M12_AX_EDGE_V = angle_edge( ( S22_M12_AX_REGION_1 touching_edge M12 ), == 90 ); 
S22_M12_REGION = edge_size( S22_M12_AX_EDGE_V, inside = 0.200 );    /* 0.114x0.200 */ 

#endif
R7_VIA11_ENC1 = VIA11 touching_edge enclose_edge( VIA11, M12, < 0.001, edge_containment = INSIDE_TO_OUTSIDE, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, output_layer = LAYER1, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
R7_VIA11_ENC2 = internal2_edge( R7_VIA11_ENC1, VIA11, <= 0.1, edge_containment = INSIDE, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, membership = SAME_POLYGON, output_layer = LAYER2, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
R7_VIA11_EP_PRE1 = ( VIA11 touching_edge R7_VIA11_ENC1 ) or_edge ( VIA11 touching_edge R7_VIA11_ENC2 ); 
R7_VIA11_EP_PRE2 = enclose_edge( R7_VIA11_EP_PRE1, M11, < 0.065, edge_containment = INSIDE_TO_OUTSIDE, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, output_layer = LAYER1, projection = { IN, ON }, orientation = { PARALLEL } ); 
R7_VIA11_EP = VIA11 touching R7_VIA11_EP_PRE2; 
R7_VIA11_CHK_REGION = edge_size( extend_edge( ( R7_VIA11_EP touching_edge R7_VIA11_EP_PRE1 ), start = 0.300, end = 0.300 ), outside = 0.076 ); 


R15_VIA12_ENC1 = VIA12 touching_edge enclose_edge( VIA12, M12, < 0.001, edge_containment = INSIDE_TO_OUTSIDE, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, output_layer = LAYER1, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
R15_VIA12_ENC2 = internal2_edge( R15_VIA12_ENC1, VIA12, <= 0.1, edge_containment = INSIDE, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, membership = SAME_POLYGON, output_layer = LAYER2, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
R15_VIA12_EP_PRE1 = ( VIA12 touching_edge R15_VIA12_ENC1 ) or_edge ( VIA12 touching_edge R15_VIA12_ENC2 ); 
R15_VIA12_EP_PRE2 = enclose_edge( R15_VIA12_EP_PRE1, M13, < 0.065, edge_containment = INSIDE_TO_OUTSIDE, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, output_layer = LAYER1, projection = { IN, ON }, orientation = { PARALLEL } ); 
R15_VIA12_EP = VIA12 touching R15_VIA12_EP_PRE2; 
R15_VIA12_CHK_REGION = edge_size( extend_edge( ( R15_VIA12_EP touching_edge R15_VIA12_EP_PRE1 ), start = 0.300, end = 0.300 ), outside = 0.076 ); 



M12_PG_31_H_PRE1 = error_merge_list( { internal1_error( angle_edge( M12_MAIN_H, == 0 ), == 0.058, direction = VERTICAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M12_PG_31_H_PRE2 = angle_edge( M12_PG_31_H_PRE1, == 0 ); 
M12_PG_31_H = M12_PG_31_H_PRE1 touching external1_edge( M12_PG_31_H_PRE2, == 0.054, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
M12_PG_31_V_PRE1 = error_merge_list( { internal1_error( angle_edge( M12_MAIN_V, == 90 ), == 0.058, direction = HORIZONTAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M12_PG_31_V_PRE2 = angle_edge( M12_PG_31_V_PRE1, == 90 ); 
M12_PG_31_V = M12_PG_31_V_PRE1 touching external1_edge( M12_PG_31_V_PRE2, == 0.054, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
M12_PG_31 = M12_PG_31_H or M12_PG_31_V; 

 
M12_PG_32_H_PRE1 = error_merge_list( { internal1_error( angle_edge( M12_MAIN_H, == 0 ), == 0.076, direction = VERTICAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M12_PG_32_H_PRE2 = angle_edge( M12_PG_32_H_PRE1, == 0 ); 
M12_PG_32_H_PRE3 = error_merge_list( { internal1_error( angle_edge( M12_MAIN_H, == 0 ), == 0.038, direction = VERTICAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M12_PG_32_H_PRE4 = angle_edge( M12_PG_32_H_PRE3, == 0 ); 
M12_PG_32_H = M12_PG_32_H_PRE1 touching external2_edge( M12_PG_32_H_PRE2, M12_PG_32_H_PRE4, == 0.053, edge_containment = OUTSIDE, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, output_layer = LAYER1, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
M12_PG_32_V_PRE1 = error_merge_list( { internal1_error( angle_edge( M12_MAIN_V, == 90 ), == 0.076, direction = HORIZONTAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M12_PG_32_V_PRE2 = angle_edge( M12_PG_32_V_PRE1, == 90 ); 
M12_PG_32_V_PRE3 = error_merge_list( { internal1_error( angle_edge( M12_MAIN_V, == 90 ), == 0.038, direction = HORIZONTAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M12_PG_32_V_PRE4 = angle_edge( M12_PG_32_V_PRE3, == 90 ); 
M12_PG_32_V = M12_PG_32_V_PRE1 touching external2_edge( M12_PG_32_V_PRE2, M12_PG_32_V_PRE4, == 0.053, edge_containment = OUTSIDE, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, output_layer = LAYER1, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
M12_PG_32 = M12_PG_32_H or M12_PG_32_V; 

 
M12_PG_33_H_PRE1 = error_merge_list( { internal1_error( angle_edge( M12_MAIN_H, == 0 ), == 0.038, direction = VERTICAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M12_PG_33_H_PRE2 = angle_edge( M12_PG_33_H_PRE1, == 0 ); 
M12_PG_33_H_PRE3 = error_merge_list( { internal1_error( angle_edge( M12_MAIN_H, == 0 ), == 0.076, direction = VERTICAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M12_PG_33_H_PRE4 = angle_edge( M12_PG_33_H_PRE3, == 0 ); 
M12_PG_33_H = M12_PG_33_H_PRE1 touching external2_edge( M12_PG_33_H_PRE2, M12_PG_33_H_PRE4, == 0.053, edge_containment = OUTSIDE, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, output_layer = LAYER1, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
M12_PG_33_V_PRE1 = error_merge_list( { internal1_error( angle_edge( M12_MAIN_V, == 90 ), == 0.038, direction = HORIZONTAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M12_PG_33_V_PRE2 = angle_edge( M12_PG_33_V_PRE1, == 90 ); 
M12_PG_33_V_PRE3 = error_merge_list( { internal1_error( angle_edge( M12_MAIN_V, == 90 ), == 0.076, direction = HORIZONTAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M12_PG_33_V_PRE4 = angle_edge( M12_PG_33_V_PRE3, == 90 ); 
M12_PG_33_V = M12_PG_33_V_PRE1 touching external2_edge( M12_PG_33_V_PRE2, M12_PG_33_V_PRE4, == 0.053, edge_containment = OUTSIDE, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, output_layer = LAYER1, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
M12_PG_33 = M12_PG_33_H or M12_PG_33_V; 

 
M12_PG_34_H_PRE1 = error_merge_list( { internal1_error( angle_edge( M12_MAIN_H, == 0 ), == 0.076, direction = VERTICAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M12_PG_34_H_PRE2 = angle_edge( M12_PG_34_H_PRE1, == 0 ); 
M12_PG_34_H = M12_PG_34_H_PRE1 touching external1_edge( M12_PG_34_H_PRE2, == 0.074, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
M12_PG_34_V_PRE1 = error_merge_list( { internal1_error( angle_edge( M12_MAIN_V, == 90 ), == 0.076, direction = HORIZONTAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M12_PG_34_V_PRE2 = angle_edge( M12_PG_34_V_PRE1, == 90 ); 
M12_PG_34_V = M12_PG_34_V_PRE1 touching external1_edge( M12_PG_34_V_PRE2, == 0.074, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
M12_PG_34 = M12_PG_34_H or M12_PG_34_V; 

 
M12_PG_35_H_PRE1 = error_merge_list( { internal1_error( angle_edge( M12_MAIN_H, == 0 ), == 0.058, direction = VERTICAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M12_PG_35_H_PRE2 = angle_edge( M12_PG_35_H_PRE1, == 0 ); 
M12_PG_35_H_PRE3 = error_merge_list( { internal1_error( angle_edge( M12_MAIN_H, == 0 ), == 0.038, direction = VERTICAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M12_PG_35_H_PRE4 = angle_edge( M12_PG_35_H_PRE3, == 0 ); 
M12_PG_35_H = M12_PG_35_H_PRE1 touching external2_edge( M12_PG_35_H_PRE2, M12_PG_35_H_PRE4, == 0.053, edge_containment = OUTSIDE, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, output_layer = LAYER1, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
M12_PG_35_V_PRE1 = error_merge_list( { internal1_error( angle_edge( M12_MAIN_V, == 90 ), == 0.058, direction = HORIZONTAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M12_PG_35_V_PRE2 = angle_edge( M12_PG_35_V_PRE1, == 90 ); 
M12_PG_35_V_PRE3 = error_merge_list( { internal1_error( angle_edge( M12_MAIN_V, == 90 ), == 0.038, direction = HORIZONTAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M12_PG_35_V_PRE4 = angle_edge( M12_PG_35_V_PRE3, == 90 ); 
M12_PG_35_V = M12_PG_35_V_PRE1 touching external2_edge( M12_PG_35_V_PRE2, M12_PG_35_V_PRE4, == 0.053, edge_containment = OUTSIDE, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, output_layer = LAYER1, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
M12_PG_35 = M12_PG_35_H or M12_PG_35_V; 

 
M12_PG_36_H_PRE1 = error_merge_list( { internal1_error( angle_edge( M12_MAIN_H, == 0 ), == 0.038, direction = VERTICAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M12_PG_36_H_PRE2 = angle_edge( M12_PG_36_H_PRE1, == 0 ); 
M12_PG_36_H_PRE3 = error_merge_list( { internal1_error( angle_edge( M12_MAIN_H, == 0 ), == 0.058, direction = VERTICAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M12_PG_36_H_PRE4 = angle_edge( M12_PG_36_H_PRE3, == 0 ); 
M12_PG_36_H = M12_PG_36_H_PRE1 touching external2_edge( M12_PG_36_H_PRE2, M12_PG_36_H_PRE4, == 0.053, edge_containment = OUTSIDE, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, output_layer = LAYER1, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
M12_PG_36_V_PRE1 = error_merge_list( { internal1_error( angle_edge( M12_MAIN_V, == 90 ), == 0.038, direction = HORIZONTAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M12_PG_36_V_PRE2 = angle_edge( M12_PG_36_V_PRE1, == 90 ); 
M12_PG_36_V_PRE3 = error_merge_list( { internal1_error( angle_edge( M12_MAIN_V, == 90 ), == 0.058, direction = HORIZONTAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M12_PG_36_V_PRE4 = angle_edge( M12_PG_36_V_PRE3, == 90 ); 
M12_PG_36_V = M12_PG_36_V_PRE1 touching external2_edge( M12_PG_36_V_PRE2, M12_PG_36_V_PRE4, == 0.053, edge_containment = OUTSIDE, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, output_layer = LAYER1, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
M12_PG_36 = M12_PG_36_H or M12_PG_36_V; 

 
M12_PG_37_H_PRE1 = error_merge_list( { internal1_error( angle_edge( M12_MAIN_H, == 0 ), == 0.058, direction = VERTICAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M12_PG_37_H_PRE2 = angle_edge( M12_PG_37_H_PRE1, == 0 ); 
M12_PG_37_H_PRE3 = error_merge_list( { internal1_error( angle_edge( M12_MAIN_H, == 0 ), == 0.076, direction = VERTICAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M12_PG_37_H_PRE4 = angle_edge( M12_PG_37_H_PRE3, == 0 ); 
M12_PG_37_H = M12_PG_37_H_PRE1 touching external2_edge( M12_PG_37_H_PRE2, M12_PG_37_H_PRE4, == 0.053, edge_containment = OUTSIDE, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, output_layer = LAYER1, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
M12_PG_37_V_PRE1 = error_merge_list( { internal1_error( angle_edge( M12_MAIN_V, == 90 ), == 0.058, direction = HORIZONTAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M12_PG_37_V_PRE2 = angle_edge( M12_PG_37_V_PRE1, == 90 ); 
M12_PG_37_V_PRE3 = error_merge_list( { internal1_error( angle_edge( M12_MAIN_V, == 90 ), == 0.076, direction = HORIZONTAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M12_PG_37_V_PRE4 = angle_edge( M12_PG_37_V_PRE3, == 90 ); 
M12_PG_37_V = M12_PG_37_V_PRE1 touching external2_edge( M12_PG_37_V_PRE2, M12_PG_37_V_PRE4, == 0.053, edge_containment = OUTSIDE, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, output_layer = LAYER1, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
M12_PG_37 = M12_PG_37_H or M12_PG_37_V; 

 
M12_PG_38_H_PRE1 = error_merge_list( { internal1_error( angle_edge( M12_MAIN_H, == 0 ), == 0.076, direction = VERTICAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M12_PG_38_H_PRE2 = angle_edge( M12_PG_38_H_PRE1, == 0 ); 
M12_PG_38_H_PRE3 = error_merge_list( { internal1_error( angle_edge( M12_MAIN_H, == 0 ), == 0.058, direction = VERTICAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M12_PG_38_H_PRE4 = angle_edge( M12_PG_38_H_PRE3, == 0 ); 
M12_PG_38_H = M12_PG_38_H_PRE1 touching external2_edge( M12_PG_38_H_PRE2, M12_PG_38_H_PRE4, == 0.053, edge_containment = OUTSIDE, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, output_layer = LAYER1, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
M12_PG_38_V_PRE1 = error_merge_list( { internal1_error( angle_edge( M12_MAIN_V, == 90 ), == 0.076, direction = HORIZONTAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M12_PG_38_V_PRE2 = angle_edge( M12_PG_38_V_PRE1, == 90 ); 
M12_PG_38_V_PRE3 = error_merge_list( { internal1_error( angle_edge( M12_MAIN_V, == 90 ), == 0.058, direction = HORIZONTAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M12_PG_38_V_PRE4 = angle_edge( M12_PG_38_V_PRE3, == 90 ); 
M12_PG_38_V = M12_PG_38_V_PRE1 touching external2_edge( M12_PG_38_V_PRE2, M12_PG_38_V_PRE4, == 0.053, edge_containment = OUTSIDE, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, output_layer = LAYER1, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
M12_PG_38 = M12_PG_38_H or M12_PG_38_V; 

 
M12_PG_ALL = or_list( { M12_PG_31, M12_PG_32, M12_PG_33, M12_PG_34, M12_PG_35, M12_PG_36, M12_PG_37, M12_PG_38 } ); 



//  OPC DVIA_O
SQ_VIA11 = rectangles( VIA11, orientation = ORTHOGONAL, sides = { == 0.02, == 0.02 } ); 

VIA11_40 = rectangles( VIA11, orientation = ORTHOGONAL, sides = { == 0.04, == 0.04 } ); 




M13_HOLE = donut_holes( M13, area = < MY1HOLE, holes = INNER, outer_boundary_point_touch = CLOSED_OUTER_BOUNDARY ); 
M13_GT76 = wide( M13, > MY1W1, angled = TRUNCATE ); 
M13_GT114 = wide( M13, > MY1W2, angled = TRUNCATE ); 
M13_GT152 = wide( M13, > MY1W3, angled = TRUNCATE ); 
M13_GT180 = wide( M13, > MY1W4, angled = TRUNCATE ); 
M13_GT240 = wide( M13, > MY1W5, angled = TRUNCATE ); 
M13_GT280 = wide( M13, > MY1W6, angled = TRUNCATE ); 
M13_GT500 = wide( M13, > MY1W7, angled = TRUNCATE ); 
M13_GT1350 = wide( M13, > MY1W8, angled = TRUNCATE ); 

macroLAYER_18 = angle_edge( M13, == 45 ); 
macroLAYER_35 = extend_edge( macroLAYER_18, start = 0.41, end = 0.41 );
macroLAYER_17 = edge_size( macroLAYER_35, outside = DMY1_MY145 );
macroLAYER_16 = size( macroLAYER_17, clip_acute = TRUNCATE, distance = GRID ); 
M13_45 = M13 or macroLAYER_16; 

M13_38 = wide( M13, == MY138, angled = TRUNCATE );    /* My1.S.27 */ 
M13_40 = wide( M13, == MY140, angled = TRUNCATE );    /* My1.S.27.1 */ 
M13_60 = wide( M13, == MY160, angled = TRUNCATE ); 
M13_80 = wide( M13, == 0.08, angled = TRUNCATE ); 
M13_120 = wide( M13, == 0.12, angled = TRUNCATE ); 

DM13_GT1350 = wide( DM13, > 1.35, angled = TRUNCATE );    /* DMn.S.3.1 */ 

#ifdef VERTICAL_M13
S22_M13_EDGE_45 = angle_edge( M13, == 45 ); 
S22_M13_E1 = adjacent_edge( M13, angle1 = == 270, angle2 = == 270, length = < 0.114 ); 
S22_M13_E2 = length_edge( M13, <= 0.038 ); 
S22_M13_A1 = polygon_extents( not_touching( external1( M13, <= GRID, extension = RADIAL, intersecting = {  }, intersection_angle = == 90, look_thru = NOT_ADJACENT, orientation = { } ), S22_M13_EDGE_45, == 2 ) ); 
S22_M13_A1Y = interacting( S22_M13_A1, M13 ); 
S22_M13_AY = not_interacting( S22_M13_A1Y, edge_size( ( S22_M13_E1 or_edge S22_M13_E2 ), outside = GRID ) ); 
S22_M13_AY_EDGE = S22_M13_AY coincident_edge M13; 
S22_M13_AY_EDGE_V = angle_edge( S22_M13_AY_EDGE, == 90 ); 
S22_M13_AY_REGION_1 = edge_size( S22_M13_AY_EDGE_V, inside = 0.114 ); 
S22_M13_AY_EDGE_H = angle_edge( ( S22_M13_AY_REGION_1 touching_edge M13 ), == 0 ); 
S22_M13_REGION = edge_size( S22_M13_AY_EDGE_H, inside = 0.200 );    /* 0.114x0.200 */ 

#else
S22_M13_EDGE_45 = angle_edge( M13, == 45 ); 
S22_M13_E1 = adjacent_edge( M13, angle1 = == 270, angle2 = == 270, length = < 0.114 ); 
S22_M13_E2 = length_edge( M13, <= 0.038 ); 
S22_M13_A1 = polygon_extents( not_touching( external1( M13, <= GRID, extension = RADIAL, intersecting = {  }, intersection_angle = == 90, look_thru = NOT_ADJACENT, orientation = { } ), S22_M13_EDGE_45, == 2 ) ); 
S22_M13_A1X = interacting( S22_M13_A1, M13 ); 
S22_M13_AX = not_interacting( S22_M13_A1X, edge_size( ( S22_M13_E1 or_edge S22_M13_E2 ), outside = GRID ) ); 
S22_M13_AX_EDGE = S22_M13_AX coincident_edge M13; 
S22_M13_AX_EDGE_H = angle_edge( S22_M13_AX_EDGE, == 0 ); 
S22_M13_AX_REGION_1 = edge_size( S22_M13_AX_EDGE_H, inside = 0.114 ); 
S22_M13_AX_EDGE_V = angle_edge( ( S22_M13_AX_REGION_1 touching_edge M13 ), == 90 ); 
S22_M13_REGION = edge_size( S22_M13_AX_EDGE_V, inside = 0.200 );    /* 0.114x0.200 */ 

#endif
R7_VIA12_ENC1 = VIA12 touching_edge enclose_edge( VIA12, M13, < 0.001, edge_containment = INSIDE_TO_OUTSIDE, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, output_layer = LAYER1, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
R7_VIA12_ENC2 = internal2_edge( R7_VIA12_ENC1, VIA12, <= 0.1, edge_containment = INSIDE, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, membership = SAME_POLYGON, output_layer = LAYER2, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
R7_VIA12_EP_PRE1 = ( VIA12 touching_edge R7_VIA12_ENC1 ) or_edge ( VIA12 touching_edge R7_VIA12_ENC2 ); 
R7_VIA12_EP_PRE2 = enclose_edge( R7_VIA12_EP_PRE1, M12, < 0.065, edge_containment = INSIDE_TO_OUTSIDE, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, output_layer = LAYER1, projection = { IN, ON }, orientation = { PARALLEL } ); 
R7_VIA12_EP = VIA12 touching R7_VIA12_EP_PRE2; 
R7_VIA12_CHK_REGION = edge_size( extend_edge( ( R7_VIA12_EP touching_edge R7_VIA12_EP_PRE1 ), start = 0.300, end = 0.300 ), outside = 0.076 ); 




M13_PG_31_H_PRE1 = error_merge_list( { internal1_error( angle_edge( M13_MAIN_H, == 0 ), == 0.058, direction = VERTICAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M13_PG_31_H_PRE2 = angle_edge( M13_PG_31_H_PRE1, == 0 ); 
M13_PG_31_H = M13_PG_31_H_PRE1 touching external1_edge( M13_PG_31_H_PRE2, == 0.054, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
M13_PG_31_V_PRE1 = error_merge_list( { internal1_error( angle_edge( M13_MAIN_V, == 90 ), == 0.058, direction = HORIZONTAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M13_PG_31_V_PRE2 = angle_edge( M13_PG_31_V_PRE1, == 90 ); 
M13_PG_31_V = M13_PG_31_V_PRE1 touching external1_edge( M13_PG_31_V_PRE2, == 0.054, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
M13_PG_31 = M13_PG_31_H or M13_PG_31_V; 

 
M13_PG_32_H_PRE1 = error_merge_list( { internal1_error( angle_edge( M13_MAIN_H, == 0 ), == 0.076, direction = VERTICAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M13_PG_32_H_PRE2 = angle_edge( M13_PG_32_H_PRE1, == 0 ); 
M13_PG_32_H_PRE3 = error_merge_list( { internal1_error( angle_edge( M13_MAIN_H, == 0 ), == 0.038, direction = VERTICAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M13_PG_32_H_PRE4 = angle_edge( M13_PG_32_H_PRE3, == 0 ); 
M13_PG_32_H = M13_PG_32_H_PRE1 touching external2_edge( M13_PG_32_H_PRE2, M13_PG_32_H_PRE4, == 0.053, edge_containment = OUTSIDE, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, output_layer = LAYER1, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
M13_PG_32_V_PRE1 = error_merge_list( { internal1_error( angle_edge( M13_MAIN_V, == 90 ), == 0.076, direction = HORIZONTAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M13_PG_32_V_PRE2 = angle_edge( M13_PG_32_V_PRE1, == 90 ); 
M13_PG_32_V_PRE3 = error_merge_list( { internal1_error( angle_edge( M13_MAIN_V, == 90 ), == 0.038, direction = HORIZONTAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M13_PG_32_V_PRE4 = angle_edge( M13_PG_32_V_PRE3, == 90 ); 
M13_PG_32_V = M13_PG_32_V_PRE1 touching external2_edge( M13_PG_32_V_PRE2, M13_PG_32_V_PRE4, == 0.053, edge_containment = OUTSIDE, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, output_layer = LAYER1, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
M13_PG_32 = M13_PG_32_H or M13_PG_32_V; 

 
M13_PG_33_H_PRE1 = error_merge_list( { internal1_error( angle_edge( M13_MAIN_H, == 0 ), == 0.038, direction = VERTICAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M13_PG_33_H_PRE2 = angle_edge( M13_PG_33_H_PRE1, == 0 ); 
M13_PG_33_H_PRE3 = error_merge_list( { internal1_error( angle_edge( M13_MAIN_H, == 0 ), == 0.076, direction = VERTICAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M13_PG_33_H_PRE4 = angle_edge( M13_PG_33_H_PRE3, == 0 ); 
M13_PG_33_H = M13_PG_33_H_PRE1 touching external2_edge( M13_PG_33_H_PRE2, M13_PG_33_H_PRE4, == 0.053, edge_containment = OUTSIDE, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, output_layer = LAYER1, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
M13_PG_33_V_PRE1 = error_merge_list( { internal1_error( angle_edge( M13_MAIN_V, == 90 ), == 0.038, direction = HORIZONTAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M13_PG_33_V_PRE2 = angle_edge( M13_PG_33_V_PRE1, == 90 ); 
M13_PG_33_V_PRE3 = error_merge_list( { internal1_error( angle_edge( M13_MAIN_V, == 90 ), == 0.076, direction = HORIZONTAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M13_PG_33_V_PRE4 = angle_edge( M13_PG_33_V_PRE3, == 90 ); 
M13_PG_33_V = M13_PG_33_V_PRE1 touching external2_edge( M13_PG_33_V_PRE2, M13_PG_33_V_PRE4, == 0.053, edge_containment = OUTSIDE, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, output_layer = LAYER1, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
M13_PG_33 = M13_PG_33_H or M13_PG_33_V; 

 
M13_PG_34_H_PRE1 = error_merge_list( { internal1_error( angle_edge( M13_MAIN_H, == 0 ), == 0.076, direction = VERTICAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M13_PG_34_H_PRE2 = angle_edge( M13_PG_34_H_PRE1, == 0 ); 
M13_PG_34_H = M13_PG_34_H_PRE1 touching external1_edge( M13_PG_34_H_PRE2, == 0.074, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
M13_PG_34_V_PRE1 = error_merge_list( { internal1_error( angle_edge( M13_MAIN_V, == 90 ), == 0.076, direction = HORIZONTAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M13_PG_34_V_PRE2 = angle_edge( M13_PG_34_V_PRE1, == 90 ); 
M13_PG_34_V = M13_PG_34_V_PRE1 touching external1_edge( M13_PG_34_V_PRE2, == 0.074, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
M13_PG_34 = M13_PG_34_H or M13_PG_34_V; 

 
M13_PG_35_H_PRE1 = error_merge_list( { internal1_error( angle_edge( M13_MAIN_H, == 0 ), == 0.058, direction = VERTICAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M13_PG_35_H_PRE2 = angle_edge( M13_PG_35_H_PRE1, == 0 ); 
M13_PG_35_H_PRE3 = error_merge_list( { internal1_error( angle_edge( M13_MAIN_H, == 0 ), == 0.038, direction = VERTICAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M13_PG_35_H_PRE4 = angle_edge( M13_PG_35_H_PRE3, == 0 ); 
M13_PG_35_H = M13_PG_35_H_PRE1 touching external2_edge( M13_PG_35_H_PRE2, M13_PG_35_H_PRE4, == 0.053, edge_containment = OUTSIDE, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, output_layer = LAYER1, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
M13_PG_35_V_PRE1 = error_merge_list( { internal1_error( angle_edge( M13_MAIN_V, == 90 ), == 0.058, direction = HORIZONTAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M13_PG_35_V_PRE2 = angle_edge( M13_PG_35_V_PRE1, == 90 ); 
M13_PG_35_V_PRE3 = error_merge_list( { internal1_error( angle_edge( M13_MAIN_V, == 90 ), == 0.038, direction = HORIZONTAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M13_PG_35_V_PRE4 = angle_edge( M13_PG_35_V_PRE3, == 90 ); 
M13_PG_35_V = M13_PG_35_V_PRE1 touching external2_edge( M13_PG_35_V_PRE2, M13_PG_35_V_PRE4, == 0.053, edge_containment = OUTSIDE, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, output_layer = LAYER1, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
M13_PG_35 = M13_PG_35_H or M13_PG_35_V; 

 
M13_PG_36_H_PRE1 = error_merge_list( { internal1_error( angle_edge( M13_MAIN_H, == 0 ), == 0.038, direction = VERTICAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M13_PG_36_H_PRE2 = angle_edge( M13_PG_36_H_PRE1, == 0 ); 
M13_PG_36_H_PRE3 = error_merge_list( { internal1_error( angle_edge( M13_MAIN_H, == 0 ), == 0.058, direction = VERTICAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M13_PG_36_H_PRE4 = angle_edge( M13_PG_36_H_PRE3, == 0 ); 
M13_PG_36_H = M13_PG_36_H_PRE1 touching external2_edge( M13_PG_36_H_PRE2, M13_PG_36_H_PRE4, == 0.053, edge_containment = OUTSIDE, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, output_layer = LAYER1, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
M13_PG_36_V_PRE1 = error_merge_list( { internal1_error( angle_edge( M13_MAIN_V, == 90 ), == 0.038, direction = HORIZONTAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M13_PG_36_V_PRE2 = angle_edge( M13_PG_36_V_PRE1, == 90 ); 
M13_PG_36_V_PRE3 = error_merge_list( { internal1_error( angle_edge( M13_MAIN_V, == 90 ), == 0.058, direction = HORIZONTAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M13_PG_36_V_PRE4 = angle_edge( M13_PG_36_V_PRE3, == 90 ); 
M13_PG_36_V = M13_PG_36_V_PRE1 touching external2_edge( M13_PG_36_V_PRE2, M13_PG_36_V_PRE4, == 0.053, edge_containment = OUTSIDE, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, output_layer = LAYER1, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
M13_PG_36 = M13_PG_36_H or M13_PG_36_V; 

 
M13_PG_37_H_PRE1 = error_merge_list( { internal1_error( angle_edge( M13_MAIN_H, == 0 ), == 0.058, direction = VERTICAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M13_PG_37_H_PRE2 = angle_edge( M13_PG_37_H_PRE1, == 0 ); 
M13_PG_37_H_PRE3 = error_merge_list( { internal1_error( angle_edge( M13_MAIN_H, == 0 ), == 0.076, direction = VERTICAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M13_PG_37_H_PRE4 = angle_edge( M13_PG_37_H_PRE3, == 0 ); 
M13_PG_37_H = M13_PG_37_H_PRE1 touching external2_edge( M13_PG_37_H_PRE2, M13_PG_37_H_PRE4, == 0.053, edge_containment = OUTSIDE, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, output_layer = LAYER1, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
M13_PG_37_V_PRE1 = error_merge_list( { internal1_error( angle_edge( M13_MAIN_V, == 90 ), == 0.058, direction = HORIZONTAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M13_PG_37_V_PRE2 = angle_edge( M13_PG_37_V_PRE1, == 90 ); 
M13_PG_37_V_PRE3 = error_merge_list( { internal1_error( angle_edge( M13_MAIN_V, == 90 ), == 0.076, direction = HORIZONTAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M13_PG_37_V_PRE4 = angle_edge( M13_PG_37_V_PRE3, == 90 ); 
M13_PG_37_V = M13_PG_37_V_PRE1 touching external2_edge( M13_PG_37_V_PRE2, M13_PG_37_V_PRE4, == 0.053, edge_containment = OUTSIDE, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, output_layer = LAYER1, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
M13_PG_37 = M13_PG_37_H or M13_PG_37_V; 

 
M13_PG_38_H_PRE1 = error_merge_list( { internal1_error( angle_edge( M13_MAIN_H, == 0 ), == 0.076, direction = VERTICAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M13_PG_38_H_PRE2 = angle_edge( M13_PG_38_H_PRE1, == 0 ); 
M13_PG_38_H_PRE3 = error_merge_list( { internal1_error( angle_edge( M13_MAIN_H, == 0 ), == 0.058, direction = VERTICAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M13_PG_38_H_PRE4 = angle_edge( M13_PG_38_H_PRE3, == 0 ); 
M13_PG_38_H = M13_PG_38_H_PRE1 touching external2_edge( M13_PG_38_H_PRE2, M13_PG_38_H_PRE4, == 0.053, edge_containment = OUTSIDE, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, output_layer = LAYER1, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
M13_PG_38_V_PRE1 = error_merge_list( { internal1_error( angle_edge( M13_MAIN_V, == 90 ), == 0.076, direction = HORIZONTAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M13_PG_38_V_PRE2 = angle_edge( M13_PG_38_V_PRE1, == 90 ); 
M13_PG_38_V_PRE3 = error_merge_list( { internal1_error( angle_edge( M13_MAIN_V, == 90 ), == 0.058, direction = HORIZONTAL, extension = NONE, extension_look_past = POINT_TO_POINT ) } ); 
M13_PG_38_V_PRE4 = angle_edge( M13_PG_38_V_PRE3, == 90 ); 
M13_PG_38_V = M13_PG_38_V_PRE1 touching external2_edge( M13_PG_38_V_PRE2, M13_PG_38_V_PRE4, == 0.053, edge_containment = OUTSIDE, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, output_layer = LAYER1, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
M13_PG_38 = M13_PG_38_H or M13_PG_38_V; 

 
M13_PG_ALL = or_list( { M13_PG_31, M13_PG_32, M13_PG_33, M13_PG_34, M13_PG_35, M13_PG_36, M13_PG_37, M13_PG_38 } ); 



//  OPC DVIA_O
SQ_VIA12 = rectangles( VIA12, orientation = ORTHOGONAL, sides = { == 0.02, == 0.02 } ); 

VIA12_40 = rectangles( VIA12, orientation = ORTHOGONAL, sides = { == 0.04, == 0.04 } ); 



ALL_M14_GT1350 = wide( ALL_M14, > MYYW, angled = TRUNCATE ); 
ALL_M14_GT4050 = wide( ALL_M14, > MYYWB, angled = TRUNCATE ); 
M14_HOLE = donut_holes( M14, area = < MYYHOLE, holes = INNER, outer_boundary_point_touch = CLOSED_OUTER_BOUNDARY ); 

DM14_O_W62 = wide( DM14_O, >= 0.062, angled = TRUNCATE ); 
DM14_O_W90 = wide( DM14_O, >= 0.09, angled = TRUNCATE ); 

//  OPC DVIA_O
SQ_VIA13 = rectangles( VIA13, orientation = ORTHOGONAL, sides = { == 0.02, == 0.02 } ); 



ALL_M15_GT1350 = wide( ALL_M15, > MYYW, angled = TRUNCATE ); 
ALL_M15_GT4050 = wide( ALL_M15, > MYYWB, angled = TRUNCATE ); 
M15_HOLE = donut_holes( M15, area = < MYYHOLE, holes = INNER, outer_boundary_point_touch = CLOSED_OUTER_BOUNDARY ); 

DM15_O_W62 = wide( DM15_O, >= 0.062, angled = TRUNCATE ); 
DM15_O_W90 = wide( DM15_O, >= 0.09, angled = TRUNCATE ); 

//  OPC DVIA_O
SQ_VIA14 = rectangles( VIA14, orientation = ORTHOGONAL, sides = { == 0.02, == 0.02 } ); 



M16_HOLE = donut_holes( M16, area = < MYXHOLE, holes = INNER, outer_boundary_point_touch = CLOSED_OUTER_BOUNDARY ); 
ALL_M16_GT1350 = wide( ALL_M16, > MYXW, angled = TRUNCATE ); 
ALL_M16_GT4050 = wide( ALL_M16, > MYXWB, angled = TRUNCATE ); 

//  OPC DVIA_O
SQ_VIA15 = rectangles( VIA15, orientation = ORTHOGONAL, sides = { == 0.02, == 0.02 } ); 



M17_HOLE = donut_holes( M17, area = < MYXHOLE, holes = INNER, outer_boundary_point_touch = CLOSED_OUTER_BOUNDARY ); 
ALL_M17_GT1350 = wide( ALL_M17, > MYXW, angled = TRUNCATE ); 
ALL_M17_GT4050 = wide( ALL_M17, > MYXWB, angled = TRUNCATE ); 

//  OPC DVIA_O
SQ_VIA16 = rectangles( VIA16, orientation = ORTHOGONAL, sides = { == 0.02, == 0.02 } ); 



M18_HOLE = donut_holes( M18, area = < MRHOLE, holes = INNER, outer_boundary_point_touch = CLOSED_OUTER_BOUNDARY ); 
ALL_M18_GT1350 = wide( ALL_M18, > MRW, angled = TRUNCATE ); 
ALL_M18_GT4050 = wide( ALL_M18, > MRWB, angled = TRUNCATE ); 

//  OPC DVIA_O
SQ_VIA17 = rectangles( VIA17, orientation = ORTHOGONAL, sides = { == 0.02, == 0.02 } ); 



M19_HOLE = donut_holes( M19, area = < MRHOLE, holes = INNER, outer_boundary_point_touch = CLOSED_OUTER_BOUNDARY ); 
ALL_M19_GT1350 = wide( ALL_M19, > MRW, angled = TRUNCATE ); 
ALL_M19_GT4050 = wide( ALL_M19, > MRWB, angled = TRUNCATE ); 

//  OPC DVIA_O
SQ_VIA18 = rectangles( VIA18, orientation = ORTHOGONAL, sides = { == 0.02, == 0.02 } ); 





VIAMINUS = or_list( { VDR, VG, VD } ); 
VIAMINUS_HVN_096V = VIAMINUS and M0_HVN_096V; 
VIAMINUS_HVN_132V = VIAMINUS and M0_HVN_132V; 
VIAMINUS_HVN_165V = VIAMINUS and M0_HVN_165V; 
VIAMINUS_HVN_180V = VIAMINUS and M0_HVN_180V; 
VIAMINUS_HVN_198V = VIAMINUS and M0_HVN_198V; 
VIAMINUS_HVN_275V = VIAMINUS and M0_HVN_275V; 
VIAMINUS_HVN_5V = VIAMINUS and M0_HVN_5V; 


// DUMMY SPEC : chip_spaceX1
CHIP_FILLREGION_X1 = over_size( unified_fill_region( 
    {{ CHIP_snps, min_space = 0, context = INTERIOR }}, //for 3pty check workzone difference
    { type = SIGNAL_EXTENT }
), 0.008 );
//=================================================================

// DUMMY SPEC : chip_spaceX2
CHIP_FILLREGION_X2 = over_size( unified_fill_region(
    {{ CHIP_snps, min_space = 0, context = INTERIOR }}, //for 3pty check workzone difference
    { type = SIGNAL_EXTENT }
), 0.008 );
//=================================================================

// DUMMY SPEC : chip_spaceX3
CHIP_FILLREGION_X3 = over_size( unified_fill_region(
    {{ CHIP_snps, min_space = 0, context = INTERIOR }}, //for 3pty check workzone difference
    { type = SIGNAL_EXTENT }
), 0.008 );
//=================================================================




#ifdef ANTPrevention
RINGWIDTH_ORI : const double = 1.5;	
RINGWIDTH : const double = RINGWIDTH_ORI/2;	// user value
RINGVAR : const double = 40;	


SHAPE_IN: list of coordinate_l = {
    { { RINGWIDTH, RINGWIDTH }, { ( RINGVAR - RINGWIDTH ), RINGWIDTH }, { ( RINGVAR - RINGWIDTH ), ( RINGVAR - RINGWIDTH ) }, { RINGWIDTH, ( RINGVAR - RINGWIDTH ) } }
};

SHAPE_OUT: list of coordinate_l = {
    { { 0.0000, 0.0000},  { RINGVAR, 0.0000},  { RINGVAR, RINGVAR },  {0.0000, RINGVAR } }
};

LAYER_SHAPE_IN : polygon_layer_s = { 
    layer_spec = {
        output_layer_key = "OUTPUT_IN"
    },
    polygons = SHAPE_IN 
};

LAYER_SHAPE_OUT : polygon_layer_s = { 
    layer_spec = {
        output_layer_key = "OUTPUT_OUT"
    },
    polygons = SHAPE_OUT
};

CHIP_SIZE = size( CHIP_snps, clip_acute = TRUNCATE, distance = RINGVAR * 2 );
 
PATTERN_SHAPE_RING : uf_fill_pattern_s = { 
     polygon_fill = {
            insertion = {
                iterations = 5,
                shift_factor = 4,
                starting_point = CENTER,
            },
            pattern_spec = {
                space_x = 0,
                space_y = 0,
                stagger_x = 0,
                stagger_y = -3
            },
            layers = {
                LAYER_SHAPE_IN,
                LAYER_SHAPE_OUT,
            },
            cell_prefix = "RINGFORB",
            hierarchical_fill = true
    },
    type = UF_POLYGON
};

SPEC_RING = unified_fill(
    extents_output = {
        {
            output_layer_key = "OUTPUT_CM1_EXTENT"
        },
    },
    fill_boundary = {
        layer = CHIP_SIZE, 
        type = LAYER 
    },
    fill_patterns = {
        PATTERN_SHAPE_RING,
    },
    boundary = ALIGN,
    grid = vGRID
);

RING_IN_C     = SPEC_RING["OUTPUT_IN"][0];
RING_OUT_C    = SPEC_RING["OUTPUT_OUT"][0];
RING_IN_E     = SPEC_RING["OUTPUT_IN"][0];

FORBIDDEN_RING = CHIP_SIZE not RING_IN_E; 

#endif

//***** BTCD *******************************************************************

SHAPE_BTCD_BOUNDARY : list of coordinate_l = { 
    { { 0.0000, 0.0000 }, { 5.4720, 0.0000 }, { 5.4720, 7.3840 }, { 0.0000, 7.3840 } }
};


#ifdef FILL_M0_BTCD
#ifdef FILL_VIA0_BTCD
#ifdef FILL_M1_BTCD
#define FILL_M0_VIA0_M1_BTCD
#endif
#endif
#endif

#ifdef FILL_M1_BTCD
#ifdef FILL_VIA1_BTCD
#ifdef FILL_M2_BTCD
#define FILL_M1_VIA1_M2_BTCD
#endif
#endif
#endif

#ifdef FILL_M2_BTCD
#ifdef FILL_VIA2_BTCD
#ifdef FILL_M3_BTCD
#define FILL_M2_VIA2_M3_BTCD
#endif
#endif
#endif

#ifdef FILL_M3_BTCD
#ifdef FILL_VIA3_BTCD
#ifdef FILL_M4_BTCD
#define FILL_M3_VIA3_M4_BTCD
#endif
#endif
#endif

#ifdef FILL_M4_BTCD
#ifdef FILL_VIA4_BTCD
#ifdef FILL_M5_BTCD
#define FILL_M4_VIA4_M5_BTCD
#endif
#endif
#endif

#ifdef FILL_M5_BTCD
#ifdef FILL_VIA5_BTCD
#ifdef FILL_M6_BTCD
#define FILL_M5_VIA5_M6_BTCD
#endif
#endif
#endif

#ifdef FILL_M6_BTCD
#ifdef FILL_VIA6_BTCD
#ifdef FILL_M7_BTCD
#define FILL_M6_VIA6_M7_BTCD
#endif
#endif
#endif

#ifdef FILL_M7_BTCD
#ifdef FILL_VIA7_BTCD
#ifdef FILL_M8_BTCD
#define FILL_M7_VIA7_M8_BTCD
#endif
#endif
#endif

#ifdef FILL_M8_BTCD
#ifdef FILL_VIA8_BTCD
#ifdef FILL_M9_BTCD
#define FILL_M8_VIA8_M9_BTCD
#endif
#endif
#endif

#ifdef FILL_M9_BTCD
#ifdef FILL_VIA9_BTCD
#ifdef FILL_M10_BTCD
#define FILL_M9_VIA9_M10_BTCD
#endif
#endif
#endif

#ifdef FILL_M10_BTCD
#ifdef FILL_VIA10_BTCD
#ifdef FILL_M11_BTCD
#define FILL_M10_VIA10_M11_BTCD
#endif
#endif
#endif

#ifdef FILL_M11_BTCD
#ifdef FILL_VIA11_BTCD
#ifdef FILL_M12_BTCD
#define FILL_M11_VIA11_M12_BTCD
#endif
#endif
#endif

#ifdef FILL_M12_BTCD
#ifdef FILL_VIA12_BTCD
#ifdef FILL_M13_BTCD
#define FILL_M12_VIA12_M13_BTCD
#endif
#endif
#endif









#ifdef FILL_M0_VIA0_M1_BTCD
// DUMMY SPEC : BTCD_M0_V0_M1
FSS_SPEC_BTCD_M0_V0_M1 : list of fill_to_signal_spacing_s = {






    { CHIP_snps, min_space = DMX1_CHIP, context = INTERIOR }, // for 0/1/xa/xb/xc
    { BEOLBLK_FINAL, min_space = DMX1B_MX }, // for 0/1/xa/xb/xc
    { DM0EXCL_FINAL, min_space = DMX1B_MX },
    { M0_MAIN, min_space = DMX1B_MX },
    { DV0EXCL, min_space = DV_DVXEXCL },



    { CHIP_snps, min_space = DMX1_CHIP, context = INTERIOR }, // for 0/1/xa/xb/xc
    { BEOLBLK_FINAL, min_space = DMX1B_MX }, // for 0/1/xa/xb/xc
    { DM1EXCL_FINAL, min_space = DMX1B_MX },
    { M1_MAIN, min_space = DMX1B_MX },

#ifdef FULL_CHIP
               { CHIP_BOUNDARY, min_space = 5, context = INTERIOR },
#else
               { PRBOUNDARY, min_space = 5, context = INTERIOR },
#endif
               { ICOVL_SINGLE, min_space = BTCD_ICOVL },
               { INDDMY, min_space = BTCD_IND },
               { MOMDMY_0, min_space = BTCD_MOMDMY },
               { MOMDMY_1, min_space = BTCD_MOMDMY },
               { LOGO, min_space = BTCD_LOGO },
	           { SRM, min_space = BTCD_SRM },
               { SRAMDMY, min_space = BTCD_SRAMDMY },
               { TCDDMY_M0, min_space = BTCD_SR },
               { TCDDMY_V0, min_space = BTCD_SR },
               { TCDDMY_M1, min_space = BTCD_SR },
               { VIA0I, min_space = BTCD_M },
               { DM0, min_space = BTCD_D },
               { DM0_O, min_space = BTCD_D },
               { DVIA0, min_space = BTCD_D },
               { DVIA0_O, min_space = BTCD_D },
               { DM1, min_space = BTCD_D },
               { DM1_O, min_space = BTCD_D },
               { ALL_STD_20, min_space = BTCD_STD },
               { RH_TN, min_space = BTCD_RHTN },
               { RH_TNB, min_space = BTCD_RHTNB },
};
//========================================================

PATTERN_SPEC_BTCD_M0_V0_M1 = get_single_polygon_pattern (
    cell_prefix = "TCDM0V0M1PHANTOM",
    step_x = BTCD_S,
    step_y = BTCD_S,
    FSS = FSS_SPEC_BTCD_M0_V0_M1,
    repeat = 2,
    shift = 2,
    starting_point = CENTER
);


LAYER_OUTPUT_BTCD_M0_V0_M1_TCDDMY_M0 : polygon_layer_s = {
    layer_spec= {
        output_layer_key = "OUTPUT_BTCD_M0_V0_M1_TCDDMY_M0",
    },
    polygons = SHAPE_BTCD_BOUNDARY,
};
LAYER_OUTPUT_BTCD_M0_V0_M1_TCDDMY_V0 : polygon_layer_s = {
    layer_spec= {
        output_layer_key = "OUTPUT_BTCD_M0_V0_M1_TCDDMY_V0",
    },
    polygons = SHAPE_BTCD_BOUNDARY,
};
LAYER_OUTPUT_BTCD_M0_V0_M1_TCDDMY_M1  : polygon_layer_s = {
    layer_spec= {
        output_layer_key = "OUTPUT_BTCD_M0_V0_M1_TCDDMY_M1",
    },
    polygons = SHAPE_BTCD_BOUNDARY,
};

PATTERN_SPEC_BTCD_M0_V0_M1.polygon_fill.layers = {
    LAYER_OUTPUT_BTCD_M0_V0_M1_TCDDMY_M0,
    LAYER_OUTPUT_BTCD_M0_V0_M1_TCDDMY_V0,
    LAYER_OUTPUT_BTCD_M0_V0_M1_TCDDMY_M1 ,
};

//***** spec *******************************************************************
SPEC_BTCD_M0_V0_M1 = unified_fill(
	fill_patterns = {
        PATTERN_SPEC_BTCD_M0_V0_M1
    },
	fill_boundary = {
	    layer = CHIP_snps,
	    type = LAYER,
	},
    extents_output = {
        {
            output_layer_key = "SPEC_BTCD_M0_V0_M1_TCDDMY_M0_EXTENT",
        }
    },
    boundary = ALIGN,
	grid = vGRID
);




//***** fill *******************************************************************
BTCD_M0_V0_M1_TCDDMY_M0_C = SPEC_BTCD_M0_V0_M1["OUTPUT_BTCD_M0_V0_M1_TCDDMY_M0"][0];
BTCD_M0_V0_M1_TCDDMY_V0_C = SPEC_BTCD_M0_V0_M1["OUTPUT_BTCD_M0_V0_M1_TCDDMY_V0"][0];
BTCD_M0_V0_M1_TCDDMY_M1_C  = SPEC_BTCD_M0_V0_M1["OUTPUT_BTCD_M0_V0_M1_TCDDMY_M1"][0];
BTCD_M0_V0_M1_E            = SPEC_BTCD_M0_V0_M1["SPEC_BTCD_M0_V0_M1_TCDDMY_M0_EXTENT"][0];
#endif
//===================================================================================

#ifdef FILL_M1_VIA1_M2_BTCD
// DUMMY SPEC : BTCD_M1_V1_M2
FSS_SPEC_BTCD_M1_V1_M2 : list of fill_to_signal_spacing_s = {






    { CHIP_snps, min_space = DMX1_CHIP, context = INTERIOR }, // for 0/1/xa/xb/xc
    { BEOLBLK_FINAL, min_space = DMX1B_MX }, // for 0/1/xa/xb/xc
    { DM1EXCL_FINAL, min_space = DMX1B_MX },
    { M1_MAIN, min_space = DMX1B_MX },
    { DV1EXCL, min_space = DV_DVXEXCL },



    { CHIP_snps, min_space = DMX1_CHIP, context = INTERIOR }, // for 0/1/xa/xb/xc
    { BEOLBLK_FINAL, min_space = DMX1B_MX }, // for 0/1/xa/xb/xc
    { DM2EXCL_FINAL, min_space = DMX1B_MX },
    { M2_MAIN, min_space = DMX1B_MX },

#ifdef FULL_CHIP
               { CHIP_BOUNDARY, min_space = 5, context = INTERIOR },
#else
               { PRBOUNDARY, min_space = 5, context = INTERIOR },
#endif
               { ICOVL_SINGLE, min_space = BTCD_ICOVL },
               { INDDMY, min_space = BTCD_IND },
               { MOMDMY_1, min_space = BTCD_MOMDMY },
               { MOMDMY_2, min_space = BTCD_MOMDMY },
               { LOGO, min_space = BTCD_LOGO },
	           { SRM, min_space = BTCD_SRM },
               { SRAMDMY, min_space = BTCD_SRAMDMY },
               { TCDDMY_M1, min_space = BTCD_SR },
               { TCDDMY_V1, min_space = BTCD_SR },
               { TCDDMY_M2, min_space = BTCD_SR },
               { VIA1I, min_space = BTCD_M },
               { DM1, min_space = BTCD_D },
               { DM1_O, min_space = BTCD_D },
               { DVIA1, min_space = BTCD_D },
               { DVIA1_O, min_space = BTCD_D },
               { DM2, min_space = BTCD_D },
               { DM2_O, min_space = BTCD_D },
               { ALL_STD_20, min_space = BTCD_STD },
               { RH_TN, min_space = BTCD_RHTN },
               { RH_TNB, min_space = BTCD_RHTNB },
#ifdef FILL_M0_VIA0_M1_BTCD
               { BTCD_M0_V0_M1_E, min_space = BTCD_SR },
#endif
};
//========================================================

PATTERN_SPEC_BTCD_M1_V1_M2 = get_single_polygon_pattern (
    cell_prefix = "TCDM1V1M2PHANTOM",
    step_x = BTCD_S,
    step_y = BTCD_S,
    FSS = FSS_SPEC_BTCD_M1_V1_M2,
    repeat = 2,
    shift = 2,
    starting_point = CENTER
);


LAYER_OUTPUT_BTCD_M1_V1_M2_TCDDMY_M1 : polygon_layer_s = {
    layer_spec= {
        output_layer_key = "OUTPUT_BTCD_M1_V1_M2_TCDDMY_M1",
    },
    polygons = SHAPE_BTCD_BOUNDARY,
};
LAYER_OUTPUT_BTCD_M1_V1_M2_TCDDMY_V1 : polygon_layer_s = {
    layer_spec= {
        output_layer_key = "OUTPUT_BTCD_M1_V1_M2_TCDDMY_V1",
    },
    polygons = SHAPE_BTCD_BOUNDARY,
};
LAYER_OUTPUT_BTCD_M1_V1_M2_TCDDMY_M2  : polygon_layer_s = {
    layer_spec= {
        output_layer_key = "OUTPUT_BTCD_M1_V1_M2_TCDDMY_M2",
    },
    polygons = SHAPE_BTCD_BOUNDARY,
};

PATTERN_SPEC_BTCD_M1_V1_M2.polygon_fill.layers = {
    LAYER_OUTPUT_BTCD_M1_V1_M2_TCDDMY_M1,
    LAYER_OUTPUT_BTCD_M1_V1_M2_TCDDMY_V1,
    LAYER_OUTPUT_BTCD_M1_V1_M2_TCDDMY_M2 ,
};

//***** spec *******************************************************************
SPEC_BTCD_M1_V1_M2 = unified_fill(
	fill_patterns = {
        PATTERN_SPEC_BTCD_M1_V1_M2
    },
	fill_boundary = {
	    layer = CHIP_snps,
	    type = LAYER,
	},
    extents_output = {
        {
            output_layer_key = "SPEC_BTCD_M1_V1_M2_TCDDMY_M1_EXTENT",
        }
    },
    boundary = ALIGN,
	grid = vGRID
);




//***** fill *******************************************************************
BTCD_M1_V1_M2_TCDDMY_M1_C = SPEC_BTCD_M1_V1_M2["OUTPUT_BTCD_M1_V1_M2_TCDDMY_M1"][0];
BTCD_M1_V1_M2_TCDDMY_V1_C = SPEC_BTCD_M1_V1_M2["OUTPUT_BTCD_M1_V1_M2_TCDDMY_V1"][0];
BTCD_M1_V1_M2_TCDDMY_M2_C  = SPEC_BTCD_M1_V1_M2["OUTPUT_BTCD_M1_V1_M2_TCDDMY_M2"][0];
BTCD_M1_V1_M2_E            = SPEC_BTCD_M1_V1_M2["SPEC_BTCD_M1_V1_M2_TCDDMY_M1_EXTENT"][0];
#endif
//===================================================================================

#ifdef FILL_M2_VIA2_M3_BTCD
// DUMMY SPEC : BTCD_M2_V2_M3
FSS_SPEC_BTCD_M2_V2_M3 : list of fill_to_signal_spacing_s = {






    { CHIP_snps, min_space = DMX1_CHIP, context = INTERIOR }, // for 0/1/xa/xb/xc
    { BEOLBLK_FINAL, min_space = DMX1B_MX }, // for 0/1/xa/xb/xc
    { DM2EXCL_FINAL, min_space = DMX1B_MX },
    { M2_MAIN, min_space = DMX1B_MX },
    { DV2EXCL, min_space = DV_DVXEXCL },



    { CHIP_snps, min_space = DMX2_CHIP, context = INTERIOR }, // for 0/1/xa/xb/xc
    { BEOLBLK_FINAL, min_space = DMX2B_MX }, // for 0/1/xa/xb/xc
    { DM3EXCL_FINAL, min_space = DMX2B_MX },
    { M3_MAIN, min_space = DMX2B_MX },

#ifdef FULL_CHIP
               { CHIP_BOUNDARY, min_space = 5, context = INTERIOR },
#else
               { PRBOUNDARY, min_space = 5, context = INTERIOR },
#endif
               { ICOVL_SINGLE, min_space = BTCD_ICOVL },
               { INDDMY, min_space = BTCD_IND },
               { MOMDMY_2, min_space = BTCD_MOMDMY },
               { MOMDMY_3, min_space = BTCD_MOMDMY },
               { LOGO, min_space = BTCD_LOGO },
	           { SRM, min_space = BTCD_SRM },
               { SRAMDMY, min_space = BTCD_SRAMDMY },
               { TCDDMY_M2, min_space = BTCD_SR },
               { TCDDMY_V2, min_space = BTCD_SR },
               { TCDDMY_M3, min_space = BTCD_SR },
               { VIA2I, min_space = BTCD_M },
               { DM2, min_space = BTCD_D },
               { DM2_O, min_space = BTCD_D },
               { DVIA2, min_space = BTCD_D },
               { DVIA2_O, min_space = BTCD_D },
               { DM3, min_space = BTCD_D },
               { DM3_O, min_space = BTCD_D },
               { ALL_STD_20, min_space = BTCD_STD },
               { RH_TN, min_space = BTCD_RHTN },
               { RH_TNB, min_space = BTCD_RHTNB },
#ifdef FILL_M1_VIA1_M2_BTCD
               { BTCD_M1_V1_M2_E, min_space = BTCD_SR },
#endif
};
//========================================================

PATTERN_SPEC_BTCD_M2_V2_M3 = get_single_polygon_pattern (
    cell_prefix = "TCDM2V2M3PHANTOM",
    step_x = BTCD_S,
    step_y = BTCD_S,
    FSS = FSS_SPEC_BTCD_M2_V2_M3,
    repeat = 2,
    shift = 2,
    starting_point = CENTER
);


LAYER_OUTPUT_BTCD_M2_V2_M3_TCDDMY_M2 : polygon_layer_s = {
    layer_spec= {
        output_layer_key = "OUTPUT_BTCD_M2_V2_M3_TCDDMY_M2",
    },
    polygons = SHAPE_BTCD_BOUNDARY,
};
LAYER_OUTPUT_BTCD_M2_V2_M3_TCDDMY_V2 : polygon_layer_s = {
    layer_spec= {
        output_layer_key = "OUTPUT_BTCD_M2_V2_M3_TCDDMY_V2",
    },
    polygons = SHAPE_BTCD_BOUNDARY,
};
LAYER_OUTPUT_BTCD_M2_V2_M3_TCDDMY_M3  : polygon_layer_s = {
    layer_spec= {
        output_layer_key = "OUTPUT_BTCD_M2_V2_M3_TCDDMY_M3",
    },
    polygons = SHAPE_BTCD_BOUNDARY,
};

PATTERN_SPEC_BTCD_M2_V2_M3.polygon_fill.layers = {
    LAYER_OUTPUT_BTCD_M2_V2_M3_TCDDMY_M2,
    LAYER_OUTPUT_BTCD_M2_V2_M3_TCDDMY_V2,
    LAYER_OUTPUT_BTCD_M2_V2_M3_TCDDMY_M3 ,
};

//***** spec *******************************************************************
SPEC_BTCD_M2_V2_M3 = unified_fill(
	fill_patterns = {
        PATTERN_SPEC_BTCD_M2_V2_M3
    },
	fill_boundary = {
	    layer = CHIP_snps,
	    type = LAYER,
	},
    extents_output = {
        {
            output_layer_key = "SPEC_BTCD_M2_V2_M3_TCDDMY_M2_EXTENT",
        }
    },
    boundary = ALIGN,
	grid = vGRID
);




//***** fill *******************************************************************
BTCD_M2_V2_M3_TCDDMY_M2_C = SPEC_BTCD_M2_V2_M3["OUTPUT_BTCD_M2_V2_M3_TCDDMY_M2"][0];
BTCD_M2_V2_M3_TCDDMY_V2_C = SPEC_BTCD_M2_V2_M3["OUTPUT_BTCD_M2_V2_M3_TCDDMY_V2"][0];
BTCD_M2_V2_M3_TCDDMY_M3_C  = SPEC_BTCD_M2_V2_M3["OUTPUT_BTCD_M2_V2_M3_TCDDMY_M3"][0];
BTCD_M2_V2_M3_E            = SPEC_BTCD_M2_V2_M3["SPEC_BTCD_M2_V2_M3_TCDDMY_M2_EXTENT"][0];
#endif
//===================================================================================

#ifdef FILL_M3_VIA3_M4_BTCD
// DUMMY SPEC : BTCD_M3_V3_M4
FSS_SPEC_BTCD_M3_V3_M4 : list of fill_to_signal_spacing_s = {






    { CHIP_snps, min_space = DMX2_CHIP, context = INTERIOR }, // for 0/1/xa/xb/xc
    { BEOLBLK_FINAL, min_space = DMX2B_MX }, // for 0/1/xa/xb/xc
    { DM3EXCL_FINAL, min_space = DMX2B_MX },
    { M3_MAIN, min_space = DMX2B_MX },
    { DV3EXCL, min_space = DV_DVXEXCL },



    { CHIP_snps, min_space = DMX2_CHIP, context = INTERIOR }, // for 0/1/xa/xb/xc
    { BEOLBLK_FINAL, min_space = DMX2B_MX }, // for 0/1/xa/xb/xc
    { DM4EXCL_FINAL, min_space = DMX2B_MX },
    { M4_MAIN, min_space = DMX2B_MX },

#ifdef FULL_CHIP
               { CHIP_BOUNDARY, min_space = 5, context = INTERIOR },
#else
               { PRBOUNDARY, min_space = 5, context = INTERIOR },
#endif
               { ICOVL_SINGLE, min_space = BTCD_ICOVL },
               { INDDMY, min_space = BTCD_IND },
               { MOMDMY_3, min_space = BTCD_MOMDMY },
               { MOMDMY_4, min_space = BTCD_MOMDMY },
               { LOGO, min_space = BTCD_LOGO },
	           { SRM, min_space = BTCD_SRM },
               { SRAMDMY, min_space = BTCD_SRAMDMY },
               { TCDDMY_M3, min_space = BTCD_SR },
               { TCDDMY_V3, min_space = BTCD_SR },
               { TCDDMY_M4, min_space = BTCD_SR },
               { VIA3I, min_space = BTCD_M },
               { DM3, min_space = BTCD_D },
               { DM3_O, min_space = BTCD_D },
               { DVIA3, min_space = BTCD_D },
               { DVIA3_O, min_space = BTCD_D },
               { DM4, min_space = BTCD_D },
               { DM4_O, min_space = BTCD_D },
               { ALL_STD_20, min_space = BTCD_STD },
               { RH_TN, min_space = BTCD_RHTN },
               { RH_TNB, min_space = BTCD_RHTNB },
#ifdef FILL_M2_VIA2_M3_BTCD
               { BTCD_M2_V2_M3_E, min_space = BTCD_SR },
#endif
};
//========================================================

PATTERN_SPEC_BTCD_M3_V3_M4 = get_single_polygon_pattern (
    cell_prefix = "TCDM3V3M4PHANTOM",
    step_x = BTCD_S,
    step_y = BTCD_S,
    FSS = FSS_SPEC_BTCD_M3_V3_M4,
    repeat = 2,
    shift = 2,
    starting_point = CENTER
);


LAYER_OUTPUT_BTCD_M3_V3_M4_TCDDMY_M3 : polygon_layer_s = {
    layer_spec= {
        output_layer_key = "OUTPUT_BTCD_M3_V3_M4_TCDDMY_M3",
    },
    polygons = SHAPE_BTCD_BOUNDARY,
};
LAYER_OUTPUT_BTCD_M3_V3_M4_TCDDMY_V3 : polygon_layer_s = {
    layer_spec= {
        output_layer_key = "OUTPUT_BTCD_M3_V3_M4_TCDDMY_V3",
    },
    polygons = SHAPE_BTCD_BOUNDARY,
};
LAYER_OUTPUT_BTCD_M3_V3_M4_TCDDMY_M4  : polygon_layer_s = {
    layer_spec= {
        output_layer_key = "OUTPUT_BTCD_M3_V3_M4_TCDDMY_M4",
    },
    polygons = SHAPE_BTCD_BOUNDARY,
};

PATTERN_SPEC_BTCD_M3_V3_M4.polygon_fill.layers = {
    LAYER_OUTPUT_BTCD_M3_V3_M4_TCDDMY_M3,
    LAYER_OUTPUT_BTCD_M3_V3_M4_TCDDMY_V3,
    LAYER_OUTPUT_BTCD_M3_V3_M4_TCDDMY_M4 ,
};

//***** spec *******************************************************************
SPEC_BTCD_M3_V3_M4 = unified_fill(
	fill_patterns = {
        PATTERN_SPEC_BTCD_M3_V3_M4
    },
	fill_boundary = {
	    layer = CHIP_snps,
	    type = LAYER,
	},
    extents_output = {
        {
            output_layer_key = "SPEC_BTCD_M3_V3_M4_TCDDMY_M3_EXTENT",
        }
    },
    boundary = ALIGN,
	grid = vGRID
);




//***** fill *******************************************************************
BTCD_M3_V3_M4_TCDDMY_M3_C = SPEC_BTCD_M3_V3_M4["OUTPUT_BTCD_M3_V3_M4_TCDDMY_M3"][0];
BTCD_M3_V3_M4_TCDDMY_V3_C = SPEC_BTCD_M3_V3_M4["OUTPUT_BTCD_M3_V3_M4_TCDDMY_V3"][0];
BTCD_M3_V3_M4_TCDDMY_M4_C  = SPEC_BTCD_M3_V3_M4["OUTPUT_BTCD_M3_V3_M4_TCDDMY_M4"][0];
BTCD_M3_V3_M4_E            = SPEC_BTCD_M3_V3_M4["SPEC_BTCD_M3_V3_M4_TCDDMY_M3_EXTENT"][0];
#endif
//===================================================================================

#ifdef FILL_M4_VIA4_M5_BTCD
// DUMMY SPEC : BTCD_M4_V4_M5
FSS_SPEC_BTCD_M4_V4_M5 : list of fill_to_signal_spacing_s = {






    { CHIP_snps, min_space = DMX2_CHIP, context = INTERIOR }, // for 0/1/xa/xb/xc
    { BEOLBLK_FINAL, min_space = DMX2B_MX }, // for 0/1/xa/xb/xc
    { DM4EXCL_FINAL, min_space = DMX2B_MX },
    { M4_MAIN, min_space = DMX2B_MX },
    { DV4EXCL, min_space = DV_DVXEXCL },



    { CHIP_snps, min_space = DMX3B_CHIP, context = INTERIOR }, // for xd
    { BEOLBLK_FINAL, min_space = DMX3B_MX }, // for xd
    { DM5EXCL_FINAL, min_space = DMX3B_MX },
    { M5_MAIN, min_space = DMX3B_MX },
    { DM5_O, min_space = 0.26 },
    { DM5, min_space = 0.26 },

#ifdef FULL_CHIP
               { CHIP_BOUNDARY, min_space = 5, context = INTERIOR },
#else
               { PRBOUNDARY, min_space = 5, context = INTERIOR },
#endif
               { ICOVL_SINGLE, min_space = BTCD_ICOVL },
               { INDDMY, min_space = BTCD_IND },
               { MOMDMY_4, min_space = BTCD_MOMDMY },
               { MOMDMY_5, min_space = BTCD_MOMDMY },
               { LOGO, min_space = BTCD_LOGO },
	           { SRM, min_space = BTCD_SRM },
               { SRAMDMY, min_space = BTCD_SRAMDMY },
               { TCDDMY_M4, min_space = BTCD_SR },
               { TCDDMY_V4, min_space = BTCD_SR },
               { TCDDMY_M5, min_space = BTCD_SR },
               { VIA4I, min_space = BTCD_M },
               { DM4, min_space = BTCD_D },
               { DM4_O, min_space = BTCD_D },
               { DVIA4, min_space = BTCD_D },
               { DVIA4_O, min_space = BTCD_D },
               { ALL_STD_20, min_space = BTCD_STD },
               { RH_TN, min_space = BTCD_RHTN },
               { RH_TNB, min_space = BTCD_RHTNB },
#ifdef FILL_M3_VIA3_M4_BTCD
               { BTCD_M3_V3_M4_E, min_space = BTCD_SR },
#endif
};
//========================================================

PATTERN_SPEC_BTCD_M4_V4_M5 = get_single_polygon_pattern (
    cell_prefix = "TCDM4V4M5PHANTOM",
    step_x = BTCD_S,
    step_y = BTCD_S,
    FSS = FSS_SPEC_BTCD_M4_V4_M5,
    repeat = 2,
    shift = 2,
    starting_point = CENTER
);


LAYER_OUTPUT_BTCD_M4_V4_M5_TCDDMY_M4 : polygon_layer_s = {
    layer_spec= {
        output_layer_key = "OUTPUT_BTCD_M4_V4_M5_TCDDMY_M4",
    },
    polygons = SHAPE_BTCD_BOUNDARY,
};
LAYER_OUTPUT_BTCD_M4_V4_M5_TCDDMY_V4 : polygon_layer_s = {
    layer_spec= {
        output_layer_key = "OUTPUT_BTCD_M4_V4_M5_TCDDMY_V4",
    },
    polygons = SHAPE_BTCD_BOUNDARY,
};
LAYER_OUTPUT_BTCD_M4_V4_M5_TCDDMY_M5  : polygon_layer_s = {
    layer_spec= {
        output_layer_key = "OUTPUT_BTCD_M4_V4_M5_TCDDMY_M5",
    },
    polygons = SHAPE_BTCD_BOUNDARY,
};

PATTERN_SPEC_BTCD_M4_V4_M5.polygon_fill.layers = {
    LAYER_OUTPUT_BTCD_M4_V4_M5_TCDDMY_M4,
    LAYER_OUTPUT_BTCD_M4_V4_M5_TCDDMY_V4,
    LAYER_OUTPUT_BTCD_M4_V4_M5_TCDDMY_M5 ,
};

//***** spec *******************************************************************
SPEC_BTCD_M4_V4_M5 = unified_fill(
	fill_patterns = {
        PATTERN_SPEC_BTCD_M4_V4_M5
    },
	fill_boundary = {
	    layer = CHIP_snps,
	    type = LAYER,
	},
    extents_output = {
        {
            output_layer_key = "SPEC_BTCD_M4_V4_M5_TCDDMY_M4_EXTENT",
        }
    },
    boundary = ALIGN,
	grid = vGRID
);




//***** fill *******************************************************************
BTCD_M4_V4_M5_TCDDMY_M4_C = SPEC_BTCD_M4_V4_M5["OUTPUT_BTCD_M4_V4_M5_TCDDMY_M4"][0];
BTCD_M4_V4_M5_TCDDMY_V4_C = SPEC_BTCD_M4_V4_M5["OUTPUT_BTCD_M4_V4_M5_TCDDMY_V4"][0];
BTCD_M4_V4_M5_TCDDMY_M5_C  = SPEC_BTCD_M4_V4_M5["OUTPUT_BTCD_M4_V4_M5_TCDDMY_M5"][0];
BTCD_M4_V4_M5_E            = SPEC_BTCD_M4_V4_M5["SPEC_BTCD_M4_V4_M5_TCDDMY_M4_EXTENT"][0];
#endif
//===================================================================================

#ifdef FILL_M5_VIA5_M6_BTCD
// DUMMY SPEC : BTCD_M5_V5_M6
FSS_SPEC_BTCD_M5_V5_M6 : list of fill_to_signal_spacing_s = {






    { CHIP_snps, min_space = DMX3B_CHIP, context = INTERIOR }, // for xd
    { BEOLBLK_FINAL, min_space = DMX3B_MX }, // for xd
    { DM5EXCL_FINAL, min_space = DMX3B_MX },
    { M5_MAIN, min_space = DMX3B_MX },
    { DM5_O, min_space = 0.26 },
    { DM5, min_space = 0.26 },
    { DV5EXCL, min_space = DV_DVXEXCL },



    { CHIP_snps, min_space = DMY1B_CHIP, context = INTERIOR }, // for ya/yb/y
	{ BEOLBLK_FINAL, min_space = DMY1B_MY1 }, // for ya/yb/y
    { DM6EXCL_FINAL, min_space = DMY1B_MY1 },
    { M6_MAIN, min_space = DMY1B_MY1 },
    { DM6_O, min_space = 0.26 },
    { DM6, min_space = 0.26 },
    { DM6_GT1350, min_space = 0.45 },

#ifdef FULL_CHIP
               { CHIP_BOUNDARY, min_space = 5, context = INTERIOR },
#else
               { PRBOUNDARY, min_space = 5, context = INTERIOR },
#endif
               { ICOVL_SINGLE, min_space = BTCD_ICOVL },
               { INDDMY, min_space = BTCD_IND },
               { MOMDMY_5, min_space = BTCD_MOMDMY },
               { MOMDMY_6, min_space = BTCD_MOMDMY },
               { LOGO, min_space = BTCD_LOGO },
	           { SRM, min_space = BTCD_SRM },
               { SRAMDMY, min_space = BTCD_SRAMDMY },
               { TCDDMY_M5, min_space = BTCD_SR },
               { TCDDMY_V5, min_space = BTCD_SR },
               { TCDDMY_M6, min_space = BTCD_SR },
               { VIA5I, min_space = BTCD_M },
               { DVIA5, min_space = BTCD_D },
               { DVIA5_O, min_space = BTCD_D },
               { ALL_STD_20, min_space = BTCD_STD },
               { RH_TN, min_space = BTCD_RHTN },
               { RH_TNB, min_space = BTCD_RHTNB },
#ifdef FILL_M4_VIA4_M5_BTCD
               { BTCD_M4_V4_M5_E, min_space = BTCD_SR },
#endif
};
//========================================================

PATTERN_SPEC_BTCD_M5_V5_M6 = get_single_polygon_pattern (
    cell_prefix = "TCDM5V5M6PHANTOM",
    step_x = BTCD_S,
    step_y = BTCD_S,
    FSS = FSS_SPEC_BTCD_M5_V5_M6,
    repeat = 2,
    shift = 2,
    starting_point = CENTER
);


LAYER_OUTPUT_BTCD_M5_V5_M6_TCDDMY_M5 : polygon_layer_s = {
    layer_spec= {
        output_layer_key = "OUTPUT_BTCD_M5_V5_M6_TCDDMY_M5",
    },
    polygons = SHAPE_BTCD_BOUNDARY,
};
LAYER_OUTPUT_BTCD_M5_V5_M6_TCDDMY_V5 : polygon_layer_s = {
    layer_spec= {
        output_layer_key = "OUTPUT_BTCD_M5_V5_M6_TCDDMY_V5",
    },
    polygons = SHAPE_BTCD_BOUNDARY,
};
LAYER_OUTPUT_BTCD_M5_V5_M6_TCDDMY_M6  : polygon_layer_s = {
    layer_spec= {
        output_layer_key = "OUTPUT_BTCD_M5_V5_M6_TCDDMY_M6",
    },
    polygons = SHAPE_BTCD_BOUNDARY,
};

PATTERN_SPEC_BTCD_M5_V5_M6.polygon_fill.layers = {
    LAYER_OUTPUT_BTCD_M5_V5_M6_TCDDMY_M5,
    LAYER_OUTPUT_BTCD_M5_V5_M6_TCDDMY_V5,
    LAYER_OUTPUT_BTCD_M5_V5_M6_TCDDMY_M6 ,
};

//***** spec *******************************************************************
SPEC_BTCD_M5_V5_M6 = unified_fill(
	fill_patterns = {
        PATTERN_SPEC_BTCD_M5_V5_M6
    },
	fill_boundary = {
	    layer = CHIP_snps,
	    type = LAYER,
	},
    extents_output = {
        {
            output_layer_key = "SPEC_BTCD_M5_V5_M6_TCDDMY_M5_EXTENT",
        }
    },
    boundary = ALIGN,
	grid = vGRID
);




//***** fill *******************************************************************
BTCD_M5_V5_M6_TCDDMY_M5_C = SPEC_BTCD_M5_V5_M6["OUTPUT_BTCD_M5_V5_M6_TCDDMY_M5"][0];
BTCD_M5_V5_M6_TCDDMY_V5_C = SPEC_BTCD_M5_V5_M6["OUTPUT_BTCD_M5_V5_M6_TCDDMY_V5"][0];
BTCD_M5_V5_M6_TCDDMY_M6_C  = SPEC_BTCD_M5_V5_M6["OUTPUT_BTCD_M5_V5_M6_TCDDMY_M6"][0];
BTCD_M5_V5_M6_E            = SPEC_BTCD_M5_V5_M6["SPEC_BTCD_M5_V5_M6_TCDDMY_M5_EXTENT"][0];
#endif
//===================================================================================

#ifdef FILL_M6_VIA6_M7_BTCD
// DUMMY SPEC : BTCD_M6_V6_M7
FSS_SPEC_BTCD_M6_V6_M7 : list of fill_to_signal_spacing_s = {






    { CHIP_snps, min_space = DMY1B_CHIP, context = INTERIOR }, // for ya/yb/y
	{ BEOLBLK_FINAL, min_space = DMY1B_MY1 }, // for ya/yb/y
    { DM6EXCL_FINAL, min_space = DMY1B_MY1 },
    { M6_MAIN, min_space = DMY1B_MY1 },
    { DM6_O, min_space = 0.26 },
    { DM6, min_space = 0.26 },
    { DM6_GT1350, min_space = 0.45 },
    { DV6EXCL, min_space = DV_DVXEXCL },



    { CHIP_snps, min_space = DMY1B_CHIP, context = INTERIOR }, // for ya/yb/y
	{ BEOLBLK_FINAL, min_space = DMY1B_MY1 }, // for ya/yb/y
    { DM7EXCL_FINAL, min_space = DMY1B_MY1 },
    { M7_MAIN, min_space = DMY1B_MY1 },
    { DM7_O, min_space = 0.26 },
    { DM7, min_space = 0.26 },
    { DM7_GT1350, min_space = 0.45 },

#ifdef FULL_CHIP
               { CHIP_BOUNDARY, min_space = 5, context = INTERIOR },
#else
               { PRBOUNDARY, min_space = 5, context = INTERIOR },
#endif
               { ICOVL_SINGLE, min_space = BTCD_ICOVL },
               { INDDMY, min_space = BTCD_IND },
               { MOMDMY_6, min_space = BTCD_MOMDMY },
               { MOMDMY_7, min_space = BTCD_MOMDMY },
               { LOGO, min_space = BTCD_LOGO },
	           { SRM, min_space = BTCD_SRM },
               { SRAMDMY, min_space = BTCD_SRAMDMY },
               { TCDDMY_M6, min_space = BTCD_SR },
               { TCDDMY_V6, min_space = BTCD_SR },
               { TCDDMY_M7, min_space = BTCD_SR },
               { VIA6I, min_space = BTCD_M },
               { DVIA6, min_space = BTCD_D },
               { DVIA6_O, min_space = BTCD_D },
               { ALL_STD_20, min_space = BTCD_STD },
               { RH_TN, min_space = BTCD_RHTN },
               { RH_TNB, min_space = BTCD_RHTNB },
#ifdef FILL_M5_VIA5_M6_BTCD
               { BTCD_M5_V5_M6_E, min_space = BTCD_SR },
#endif
};
//========================================================

PATTERN_SPEC_BTCD_M6_V6_M7 = get_single_polygon_pattern (
    cell_prefix = "TCDM6V6M7PHANTOM",
    step_x = BTCD_S,
    step_y = BTCD_S,
    FSS = FSS_SPEC_BTCD_M6_V6_M7,
    repeat = 2,
    shift = 2,
    starting_point = CENTER
);


LAYER_OUTPUT_BTCD_M6_V6_M7_TCDDMY_M6 : polygon_layer_s = {
    layer_spec= {
        output_layer_key = "OUTPUT_BTCD_M6_V6_M7_TCDDMY_M6",
    },
    polygons = SHAPE_BTCD_BOUNDARY,
};
LAYER_OUTPUT_BTCD_M6_V6_M7_TCDDMY_V6 : polygon_layer_s = {
    layer_spec= {
        output_layer_key = "OUTPUT_BTCD_M6_V6_M7_TCDDMY_V6",
    },
    polygons = SHAPE_BTCD_BOUNDARY,
};
LAYER_OUTPUT_BTCD_M6_V6_M7_TCDDMY_M7  : polygon_layer_s = {
    layer_spec= {
        output_layer_key = "OUTPUT_BTCD_M6_V6_M7_TCDDMY_M7",
    },
    polygons = SHAPE_BTCD_BOUNDARY,
};

PATTERN_SPEC_BTCD_M6_V6_M7.polygon_fill.layers = {
    LAYER_OUTPUT_BTCD_M6_V6_M7_TCDDMY_M6,
    LAYER_OUTPUT_BTCD_M6_V6_M7_TCDDMY_V6,
    LAYER_OUTPUT_BTCD_M6_V6_M7_TCDDMY_M7 ,
};

//***** spec *******************************************************************
SPEC_BTCD_M6_V6_M7 = unified_fill(
	fill_patterns = {
        PATTERN_SPEC_BTCD_M6_V6_M7
    },
	fill_boundary = {
	    layer = CHIP_snps,
	    type = LAYER,
	},
    extents_output = {
        {
            output_layer_key = "SPEC_BTCD_M6_V6_M7_TCDDMY_M6_EXTENT",
        }
    },
    boundary = ALIGN,
	grid = vGRID
);




//***** fill *******************************************************************
BTCD_M6_V6_M7_TCDDMY_M6_C = SPEC_BTCD_M6_V6_M7["OUTPUT_BTCD_M6_V6_M7_TCDDMY_M6"][0];
BTCD_M6_V6_M7_TCDDMY_V6_C = SPEC_BTCD_M6_V6_M7["OUTPUT_BTCD_M6_V6_M7_TCDDMY_V6"][0];
BTCD_M6_V6_M7_TCDDMY_M7_C  = SPEC_BTCD_M6_V6_M7["OUTPUT_BTCD_M6_V6_M7_TCDDMY_M7"][0];
BTCD_M6_V6_M7_E            = SPEC_BTCD_M6_V6_M7["SPEC_BTCD_M6_V6_M7_TCDDMY_M6_EXTENT"][0];
#endif
//===================================================================================

#ifdef FILL_M7_VIA7_M8_BTCD
// DUMMY SPEC : BTCD_M7_V7_M8
FSS_SPEC_BTCD_M7_V7_M8 : list of fill_to_signal_spacing_s = {






    { CHIP_snps, min_space = DMY1B_CHIP, context = INTERIOR }, // for ya/yb/y
	{ BEOLBLK_FINAL, min_space = DMY1B_MY1 }, // for ya/yb/y
    { DM7EXCL_FINAL, min_space = DMY1B_MY1 },
    { M7_MAIN, min_space = DMY1B_MY1 },
    { DM7_O, min_space = 0.26 },
    { DM7, min_space = 0.26 },
    { DM7_GT1350, min_space = 0.45 },
    { DV7EXCL, min_space = DV_DVXEXCL },



    { CHIP_snps, min_space = DMY1B_CHIP, context = INTERIOR }, // for ya/yb/y
	{ BEOLBLK_FINAL, min_space = DMY1B_MY1 }, // for ya/yb/y
    { DM8EXCL_FINAL, min_space = DMY1B_MY1 },
    { M8_MAIN, min_space = DMY1B_MY1 },
    { DM8_O, min_space = 0.26 },
    { DM8, min_space = 0.26 },
    { DM8_GT1350, min_space = 0.45 },

#ifdef FULL_CHIP
               { CHIP_BOUNDARY, min_space = 5, context = INTERIOR },
#else
               { PRBOUNDARY, min_space = 5, context = INTERIOR },
#endif
               { ICOVL_SINGLE, min_space = BTCD_ICOVL },
               { INDDMY, min_space = BTCD_IND },
               { MOMDMY_7, min_space = BTCD_MOMDMY },
               { MOMDMY_8, min_space = BTCD_MOMDMY },
               { LOGO, min_space = BTCD_LOGO },
	           { SRM, min_space = BTCD_SRM },
               { SRAMDMY, min_space = BTCD_SRAMDMY },
               { TCDDMY_M7, min_space = BTCD_SR },
               { TCDDMY_V7, min_space = BTCD_SR },
               { TCDDMY_M8, min_space = BTCD_SR },
               { VIA7I, min_space = BTCD_M },
               { DVIA7, min_space = BTCD_D },
               { DVIA7_O, min_space = BTCD_D },
               { ALL_STD_20, min_space = BTCD_STD },
               { RH_TN, min_space = BTCD_RHTN },
               { RH_TNB, min_space = BTCD_RHTNB },
#ifdef FILL_M6_VIA6_M7_BTCD
               { BTCD_M6_V6_M7_E, min_space = BTCD_SR },
#endif
};
//========================================================

PATTERN_SPEC_BTCD_M7_V7_M8 = get_single_polygon_pattern (
    cell_prefix = "TCDM7V7M8PHANTOM",
    step_x = BTCD_S,
    step_y = BTCD_S,
    FSS = FSS_SPEC_BTCD_M7_V7_M8,
    repeat = 2,
    shift = 2,
    starting_point = CENTER
);


LAYER_OUTPUT_BTCD_M7_V7_M8_TCDDMY_M7 : polygon_layer_s = {
    layer_spec= {
        output_layer_key = "OUTPUT_BTCD_M7_V7_M8_TCDDMY_M7",
    },
    polygons = SHAPE_BTCD_BOUNDARY,
};
LAYER_OUTPUT_BTCD_M7_V7_M8_TCDDMY_V7 : polygon_layer_s = {
    layer_spec= {
        output_layer_key = "OUTPUT_BTCD_M7_V7_M8_TCDDMY_V7",
    },
    polygons = SHAPE_BTCD_BOUNDARY,
};
LAYER_OUTPUT_BTCD_M7_V7_M8_TCDDMY_M8  : polygon_layer_s = {
    layer_spec= {
        output_layer_key = "OUTPUT_BTCD_M7_V7_M8_TCDDMY_M8",
    },
    polygons = SHAPE_BTCD_BOUNDARY,
};

PATTERN_SPEC_BTCD_M7_V7_M8.polygon_fill.layers = {
    LAYER_OUTPUT_BTCD_M7_V7_M8_TCDDMY_M7,
    LAYER_OUTPUT_BTCD_M7_V7_M8_TCDDMY_V7,
    LAYER_OUTPUT_BTCD_M7_V7_M8_TCDDMY_M8 ,
};

//***** spec *******************************************************************
SPEC_BTCD_M7_V7_M8 = unified_fill(
	fill_patterns = {
        PATTERN_SPEC_BTCD_M7_V7_M8
    },
	fill_boundary = {
	    layer = CHIP_snps,
	    type = LAYER,
	},
    extents_output = {
        {
            output_layer_key = "SPEC_BTCD_M7_V7_M8_TCDDMY_M7_EXTENT",
        }
    },
    boundary = ALIGN,
	grid = vGRID
);




//***** fill *******************************************************************
BTCD_M7_V7_M8_TCDDMY_M7_C = SPEC_BTCD_M7_V7_M8["OUTPUT_BTCD_M7_V7_M8_TCDDMY_M7"][0];
BTCD_M7_V7_M8_TCDDMY_V7_C = SPEC_BTCD_M7_V7_M8["OUTPUT_BTCD_M7_V7_M8_TCDDMY_V7"][0];
BTCD_M7_V7_M8_TCDDMY_M8_C  = SPEC_BTCD_M7_V7_M8["OUTPUT_BTCD_M7_V7_M8_TCDDMY_M8"][0];
BTCD_M7_V7_M8_E            = SPEC_BTCD_M7_V7_M8["SPEC_BTCD_M7_V7_M8_TCDDMY_M7_EXTENT"][0];
#endif
//===================================================================================

#ifdef FILL_M8_VIA8_M9_BTCD
// DUMMY SPEC : BTCD_M8_V8_M9
FSS_SPEC_BTCD_M8_V8_M9 : list of fill_to_signal_spacing_s = {






    { CHIP_snps, min_space = DMY1B_CHIP, context = INTERIOR }, // for ya/yb/y
	{ BEOLBLK_FINAL, min_space = DMY1B_MY1 }, // for ya/yb/y
    { DM8EXCL_FINAL, min_space = DMY1B_MY1 },
    { M8_MAIN, min_space = DMY1B_MY1 },
    { DM8_O, min_space = 0.26 },
    { DM8, min_space = 0.26 },
    { DM8_GT1350, min_space = 0.45 },
    { DV8EXCL, min_space = DV_DVXEXCL },



    { CHIP_snps, min_space = DMY1B_CHIP, context = INTERIOR }, // for ya/yb/y
	{ BEOLBLK_FINAL, min_space = DMY1B_MY1 }, // for ya/yb/y
    { DM9EXCL_FINAL, min_space = DMY1B_MY1 },
    { M9_MAIN, min_space = DMY1B_MY1 },
    { DM9_O, min_space = 0.26 },
    { DM9, min_space = 0.26 },
    { DM9_GT1350, min_space = 0.45 },

#ifdef FULL_CHIP
               { CHIP_BOUNDARY, min_space = 5, context = INTERIOR },
#else
               { PRBOUNDARY, min_space = 5, context = INTERIOR },
#endif
               { ICOVL_SINGLE, min_space = BTCD_ICOVL },
               { INDDMY, min_space = BTCD_IND },
               { MOMDMY_8, min_space = BTCD_MOMDMY },
               { MOMDMY_9, min_space = BTCD_MOMDMY },
               { LOGO, min_space = BTCD_LOGO },
	           { SRM, min_space = BTCD_SRM },
               { SRAMDMY, min_space = BTCD_SRAMDMY },
               { TCDDMY_M8, min_space = BTCD_SR },
               { TCDDMY_V8, min_space = BTCD_SR },
               { TCDDMY_M9, min_space = BTCD_SR },
               { VIA8I, min_space = BTCD_M },
               { DVIA8, min_space = BTCD_D },
               { DVIA8_O, min_space = BTCD_D },
               { ALL_STD_20, min_space = BTCD_STD },
               { RH_TN, min_space = BTCD_RHTN },
               { RH_TNB, min_space = BTCD_RHTNB },
#ifdef FILL_M7_VIA7_M8_BTCD
               { BTCD_M7_V7_M8_E, min_space = BTCD_SR },
#endif
};
//========================================================

PATTERN_SPEC_BTCD_M8_V8_M9 = get_single_polygon_pattern (
    cell_prefix = "TCDM8V8M9PHANTOM",
    step_x = BTCD_S,
    step_y = BTCD_S,
    FSS = FSS_SPEC_BTCD_M8_V8_M9,
    repeat = 2,
    shift = 2,
    starting_point = CENTER
);


LAYER_OUTPUT_BTCD_M8_V8_M9_TCDDMY_M8 : polygon_layer_s = {
    layer_spec= {
        output_layer_key = "OUTPUT_BTCD_M8_V8_M9_TCDDMY_M8",
    },
    polygons = SHAPE_BTCD_BOUNDARY,
};
LAYER_OUTPUT_BTCD_M8_V8_M9_TCDDMY_V8 : polygon_layer_s = {
    layer_spec= {
        output_layer_key = "OUTPUT_BTCD_M8_V8_M9_TCDDMY_V8",
    },
    polygons = SHAPE_BTCD_BOUNDARY,
};
LAYER_OUTPUT_BTCD_M8_V8_M9_TCDDMY_M9  : polygon_layer_s = {
    layer_spec= {
        output_layer_key = "OUTPUT_BTCD_M8_V8_M9_TCDDMY_M9",
    },
    polygons = SHAPE_BTCD_BOUNDARY,
};

PATTERN_SPEC_BTCD_M8_V8_M9.polygon_fill.layers = {
    LAYER_OUTPUT_BTCD_M8_V8_M9_TCDDMY_M8,
    LAYER_OUTPUT_BTCD_M8_V8_M9_TCDDMY_V8,
    LAYER_OUTPUT_BTCD_M8_V8_M9_TCDDMY_M9 ,
};

//***** spec *******************************************************************
SPEC_BTCD_M8_V8_M9 = unified_fill(
	fill_patterns = {
        PATTERN_SPEC_BTCD_M8_V8_M9
    },
	fill_boundary = {
	    layer = CHIP_snps,
	    type = LAYER,
	},
    extents_output = {
        {
            output_layer_key = "SPEC_BTCD_M8_V8_M9_TCDDMY_M8_EXTENT",
        }
    },
    boundary = ALIGN,
	grid = vGRID
);




//***** fill *******************************************************************
BTCD_M8_V8_M9_TCDDMY_M8_C = SPEC_BTCD_M8_V8_M9["OUTPUT_BTCD_M8_V8_M9_TCDDMY_M8"][0];
BTCD_M8_V8_M9_TCDDMY_V8_C = SPEC_BTCD_M8_V8_M9["OUTPUT_BTCD_M8_V8_M9_TCDDMY_V8"][0];
BTCD_M8_V8_M9_TCDDMY_M9_C  = SPEC_BTCD_M8_V8_M9["OUTPUT_BTCD_M8_V8_M9_TCDDMY_M9"][0];
BTCD_M8_V8_M9_E            = SPEC_BTCD_M8_V8_M9["SPEC_BTCD_M8_V8_M9_TCDDMY_M8_EXTENT"][0];
#endif
//===================================================================================

#ifdef FILL_M9_VIA9_M10_BTCD
// DUMMY SPEC : BTCD_M9_V9_M10
FSS_SPEC_BTCD_M9_V9_M10 : list of fill_to_signal_spacing_s = {






    { CHIP_snps, min_space = DMY1B_CHIP, context = INTERIOR }, // for ya/yb/y
	{ BEOLBLK_FINAL, min_space = DMY1B_MY1 }, // for ya/yb/y
    { DM9EXCL_FINAL, min_space = DMY1B_MY1 },
    { M9_MAIN, min_space = DMY1B_MY1 },
    { DM9_O, min_space = 0.26 },
    { DM9, min_space = 0.26 },
    { DM9_GT1350, min_space = 0.45 },
    { DV9EXCL, min_space = DV_DVXEXCL },



    { CHIP_snps, min_space = DMY1B_CHIP, context = INTERIOR }, // for ya/yb/y
	{ BEOLBLK_FINAL, min_space = DMY1B_MY1 }, // for ya/yb/y
    { DM10EXCL_FINAL, min_space = DMY1B_MY1 },
    { M10_MAIN, min_space = DMY1B_MY1 },
    { DM10_O, min_space = 0.26 },
    { DM10, min_space = 0.26 },
    { DM10_GT1350, min_space = 0.45 },

#ifdef FULL_CHIP
               { CHIP_BOUNDARY, min_space = 5, context = INTERIOR },
#else
               { PRBOUNDARY, min_space = 5, context = INTERIOR },
#endif
               { ICOVL_SINGLE, min_space = BTCD_ICOVL },
               { INDDMY, min_space = BTCD_IND },
               { MOMDMY_9, min_space = BTCD_MOMDMY },
               { MOMDMY_10, min_space = BTCD_MOMDMY },
               { LOGO, min_space = BTCD_LOGO },
	           { SRM, min_space = BTCD_SRM },
               { SRAMDMY, min_space = BTCD_SRAMDMY },
               { TCDDMY_M9, min_space = BTCD_SR },
               { TCDDMY_V9, min_space = BTCD_SR },
               { TCDDMY_M10, min_space = BTCD_SR },
               { VIA9I, min_space = BTCD_M },
               { DVIA9, min_space = BTCD_D },
               { DVIA9_O, min_space = BTCD_D },
               { ALL_STD_20, min_space = BTCD_STD },
               { RH_TN, min_space = BTCD_RHTN },
               { RH_TNB, min_space = BTCD_RHTNB },
#ifdef FILL_M8_VIA8_M9_BTCD
               { BTCD_M8_V8_M9_E, min_space = BTCD_SR },
#endif
};
//========================================================

PATTERN_SPEC_BTCD_M9_V9_M10 = get_single_polygon_pattern (
    cell_prefix = "TCDM9V9M10PHANTOM",
    step_x = BTCD_S,
    step_y = BTCD_S,
    FSS = FSS_SPEC_BTCD_M9_V9_M10,
    repeat = 2,
    shift = 2,
    starting_point = CENTER
);


LAYER_OUTPUT_BTCD_M9_V9_M10_TCDDMY_M9 : polygon_layer_s = {
    layer_spec= {
        output_layer_key = "OUTPUT_BTCD_M9_V9_M10_TCDDMY_M9",
    },
    polygons = SHAPE_BTCD_BOUNDARY,
};
LAYER_OUTPUT_BTCD_M9_V9_M10_TCDDMY_V9 : polygon_layer_s = {
    layer_spec= {
        output_layer_key = "OUTPUT_BTCD_M9_V9_M10_TCDDMY_V9",
    },
    polygons = SHAPE_BTCD_BOUNDARY,
};
LAYER_OUTPUT_BTCD_M9_V9_M10_TCDDMY_M10  : polygon_layer_s = {
    layer_spec= {
        output_layer_key = "OUTPUT_BTCD_M9_V9_M10_TCDDMY_M10",
    },
    polygons = SHAPE_BTCD_BOUNDARY,
};

PATTERN_SPEC_BTCD_M9_V9_M10.polygon_fill.layers = {
    LAYER_OUTPUT_BTCD_M9_V9_M10_TCDDMY_M9,
    LAYER_OUTPUT_BTCD_M9_V9_M10_TCDDMY_V9,
    LAYER_OUTPUT_BTCD_M9_V9_M10_TCDDMY_M10 ,
};

//***** spec *******************************************************************
SPEC_BTCD_M9_V9_M10 = unified_fill(
	fill_patterns = {
        PATTERN_SPEC_BTCD_M9_V9_M10
    },
	fill_boundary = {
	    layer = CHIP_snps,
	    type = LAYER,
	},
    extents_output = {
        {
            output_layer_key = "SPEC_BTCD_M9_V9_M10_TCDDMY_M9_EXTENT",
        }
    },
    boundary = ALIGN,
	grid = vGRID
);




//***** fill *******************************************************************
BTCD_M9_V9_M10_TCDDMY_M9_C = SPEC_BTCD_M9_V9_M10["OUTPUT_BTCD_M9_V9_M10_TCDDMY_M9"][0];
BTCD_M9_V9_M10_TCDDMY_V9_C = SPEC_BTCD_M9_V9_M10["OUTPUT_BTCD_M9_V9_M10_TCDDMY_V9"][0];
BTCD_M9_V9_M10_TCDDMY_M10_C  = SPEC_BTCD_M9_V9_M10["OUTPUT_BTCD_M9_V9_M10_TCDDMY_M10"][0];
BTCD_M9_V9_M10_E            = SPEC_BTCD_M9_V9_M10["SPEC_BTCD_M9_V9_M10_TCDDMY_M9_EXTENT"][0];
#endif
//===================================================================================

#ifdef FILL_M10_VIA10_M11_BTCD
// DUMMY SPEC : BTCD_M10_V10_M11
FSS_SPEC_BTCD_M10_V10_M11 : list of fill_to_signal_spacing_s = {






    { CHIP_snps, min_space = DMY1B_CHIP, context = INTERIOR }, // for ya/yb/y
	{ BEOLBLK_FINAL, min_space = DMY1B_MY1 }, // for ya/yb/y
    { DM10EXCL_FINAL, min_space = DMY1B_MY1 },
    { M10_MAIN, min_space = DMY1B_MY1 },
    { DM10_O, min_space = 0.26 },
    { DM10, min_space = 0.26 },
    { DM10_GT1350, min_space = 0.45 },
    { DV10EXCL, min_space = DV_DVXEXCL },



    { CHIP_snps, min_space = DMY1B_CHIP, context = INTERIOR }, // for ya/yb/y
	{ BEOLBLK_FINAL, min_space = DMY1B_MY1 }, // for ya/yb/y
    { DM11EXCL_FINAL, min_space = DMY1B_MY1 },
    { M11_MAIN, min_space = DMY1B_MY1 },
    { DM11_O, min_space = 0.26 },
    { DM11, min_space = 0.26 },
    { DM11_GT1350, min_space = 0.45 },

#ifdef FULL_CHIP
               { CHIP_BOUNDARY, min_space = 5, context = INTERIOR },
#else
               { PRBOUNDARY, min_space = 5, context = INTERIOR },
#endif
               { ICOVL_SINGLE, min_space = BTCD_ICOVL },
               { INDDMY, min_space = BTCD_IND },
               { MOMDMY_10, min_space = BTCD_MOMDMY },
               { MOMDMY_11, min_space = BTCD_MOMDMY },
               { LOGO, min_space = BTCD_LOGO },
	           { SRM, min_space = BTCD_SRM },
               { SRAMDMY, min_space = BTCD_SRAMDMY },
               { TCDDMY_M10, min_space = BTCD_SR },
               { TCDDMY_V10, min_space = BTCD_SR },
               { TCDDMY_M11, min_space = BTCD_SR },
               { VIA10I, min_space = BTCD_M },
               { DVIA10, min_space = BTCD_D },
               { DVIA10_O, min_space = BTCD_D },
               { ALL_STD_20, min_space = BTCD_STD },
               { RH_TN, min_space = BTCD_RHTN },
               { RH_TNB, min_space = BTCD_RHTNB },
#ifdef FILL_M9_VIA9_M10_BTCD
               { BTCD_M9_V9_M10_E, min_space = BTCD_SR },
#endif
};
//========================================================

PATTERN_SPEC_BTCD_M10_V10_M11 = get_single_polygon_pattern (
    cell_prefix = "TCDM10V10M11PHANTOM",
    step_x = BTCD_S,
    step_y = BTCD_S,
    FSS = FSS_SPEC_BTCD_M10_V10_M11,
    repeat = 2,
    shift = 2,
    starting_point = CENTER
);


LAYER_OUTPUT_BTCD_M10_V10_M11_TCDDMY_M10 : polygon_layer_s = {
    layer_spec= {
        output_layer_key = "OUTPUT_BTCD_M10_V10_M11_TCDDMY_M10",
    },
    polygons = SHAPE_BTCD_BOUNDARY,
};
LAYER_OUTPUT_BTCD_M10_V10_M11_TCDDMY_V10 : polygon_layer_s = {
    layer_spec= {
        output_layer_key = "OUTPUT_BTCD_M10_V10_M11_TCDDMY_V10",
    },
    polygons = SHAPE_BTCD_BOUNDARY,
};
LAYER_OUTPUT_BTCD_M10_V10_M11_TCDDMY_M11  : polygon_layer_s = {
    layer_spec= {
        output_layer_key = "OUTPUT_BTCD_M10_V10_M11_TCDDMY_M11",
    },
    polygons = SHAPE_BTCD_BOUNDARY,
};

PATTERN_SPEC_BTCD_M10_V10_M11.polygon_fill.layers = {
    LAYER_OUTPUT_BTCD_M10_V10_M11_TCDDMY_M10,
    LAYER_OUTPUT_BTCD_M10_V10_M11_TCDDMY_V10,
    LAYER_OUTPUT_BTCD_M10_V10_M11_TCDDMY_M11 ,
};

//***** spec *******************************************************************
SPEC_BTCD_M10_V10_M11 = unified_fill(
	fill_patterns = {
        PATTERN_SPEC_BTCD_M10_V10_M11
    },
	fill_boundary = {
	    layer = CHIP_snps,
	    type = LAYER,
	},
    extents_output = {
        {
            output_layer_key = "SPEC_BTCD_M10_V10_M11_TCDDMY_M10_EXTENT",
        }
    },
    boundary = ALIGN,
	grid = vGRID
);




//***** fill *******************************************************************
BTCD_M10_V10_M11_TCDDMY_M10_C = SPEC_BTCD_M10_V10_M11["OUTPUT_BTCD_M10_V10_M11_TCDDMY_M10"][0];
BTCD_M10_V10_M11_TCDDMY_V10_C = SPEC_BTCD_M10_V10_M11["OUTPUT_BTCD_M10_V10_M11_TCDDMY_V10"][0];
BTCD_M10_V10_M11_TCDDMY_M11_C  = SPEC_BTCD_M10_V10_M11["OUTPUT_BTCD_M10_V10_M11_TCDDMY_M11"][0];
BTCD_M10_V10_M11_E            = SPEC_BTCD_M10_V10_M11["SPEC_BTCD_M10_V10_M11_TCDDMY_M10_EXTENT"][0];
#endif
//===================================================================================

#ifdef FILL_M11_VIA11_M12_BTCD
// DUMMY SPEC : BTCD_M11_V11_M12
FSS_SPEC_BTCD_M11_V11_M12 : list of fill_to_signal_spacing_s = {






    { CHIP_snps, min_space = DMY1B_CHIP, context = INTERIOR }, // for ya/yb/y
	{ BEOLBLK_FINAL, min_space = DMY1B_MY1 }, // for ya/yb/y
    { DM11EXCL_FINAL, min_space = DMY1B_MY1 },
    { M11_MAIN, min_space = DMY1B_MY1 },
    { DM11_O, min_space = 0.26 },
    { DM11, min_space = 0.26 },
    { DM11_GT1350, min_space = 0.45 },
    { DV11EXCL, min_space = DV_DVXEXCL },



    { CHIP_snps, min_space = DMY1B_CHIP, context = INTERIOR }, // for ya/yb/y
	{ BEOLBLK_FINAL, min_space = DMY1B_MY1 }, // for ya/yb/y
    { DM12EXCL_FINAL, min_space = DMY1B_MY1 },
    { M12_MAIN, min_space = DMY1B_MY1 },
    { DM12_O, min_space = 0.26 },
    { DM12, min_space = 0.26 },
    { DM12_GT1350, min_space = 0.45 },

#ifdef FULL_CHIP
               { CHIP_BOUNDARY, min_space = 5, context = INTERIOR },
#else
               { PRBOUNDARY, min_space = 5, context = INTERIOR },
#endif
               { ICOVL_SINGLE, min_space = BTCD_ICOVL },
               { INDDMY, min_space = BTCD_IND },
               { MOMDMY_11, min_space = BTCD_MOMDMY },
               { MOMDMY_12, min_space = BTCD_MOMDMY },
               { LOGO, min_space = BTCD_LOGO },
	           { SRM, min_space = BTCD_SRM },
               { SRAMDMY, min_space = BTCD_SRAMDMY },
               { TCDDMY_M11, min_space = BTCD_SR },
               { TCDDMY_V11, min_space = BTCD_SR },
               { TCDDMY_M12, min_space = BTCD_SR },
               { VIA11I, min_space = BTCD_M },
               { DVIA11, min_space = BTCD_D },
               { DVIA11_O, min_space = BTCD_D },
               { ALL_STD_20, min_space = BTCD_STD },
               { RH_TN, min_space = BTCD_RHTN },
               { RH_TNB, min_space = BTCD_RHTNB },
#ifdef FILL_M10_VIA10_M11_BTCD
               { BTCD_M10_V10_M11_E, min_space = BTCD_SR },
#endif
};
//========================================================

PATTERN_SPEC_BTCD_M11_V11_M12 = get_single_polygon_pattern (
    cell_prefix = "TCDM11V11M12PHANTOM",
    step_x = BTCD_S,
    step_y = BTCD_S,
    FSS = FSS_SPEC_BTCD_M11_V11_M12,
    repeat = 2,
    shift = 2,
    starting_point = CENTER
);


LAYER_OUTPUT_BTCD_M11_V11_M12_TCDDMY_M11 : polygon_layer_s = {
    layer_spec= {
        output_layer_key = "OUTPUT_BTCD_M11_V11_M12_TCDDMY_M11",
    },
    polygons = SHAPE_BTCD_BOUNDARY,
};
LAYER_OUTPUT_BTCD_M11_V11_M12_TCDDMY_V11 : polygon_layer_s = {
    layer_spec= {
        output_layer_key = "OUTPUT_BTCD_M11_V11_M12_TCDDMY_V11",
    },
    polygons = SHAPE_BTCD_BOUNDARY,
};
LAYER_OUTPUT_BTCD_M11_V11_M12_TCDDMY_M12  : polygon_layer_s = {
    layer_spec= {
        output_layer_key = "OUTPUT_BTCD_M11_V11_M12_TCDDMY_M12",
    },
    polygons = SHAPE_BTCD_BOUNDARY,
};

PATTERN_SPEC_BTCD_M11_V11_M12.polygon_fill.layers = {
    LAYER_OUTPUT_BTCD_M11_V11_M12_TCDDMY_M11,
    LAYER_OUTPUT_BTCD_M11_V11_M12_TCDDMY_V11,
    LAYER_OUTPUT_BTCD_M11_V11_M12_TCDDMY_M12 ,
};

//***** spec *******************************************************************
SPEC_BTCD_M11_V11_M12 = unified_fill(
	fill_patterns = {
        PATTERN_SPEC_BTCD_M11_V11_M12
    },
	fill_boundary = {
	    layer = CHIP_snps,
	    type = LAYER,
	},
    extents_output = {
        {
            output_layer_key = "SPEC_BTCD_M11_V11_M12_TCDDMY_M11_EXTENT",
        }
    },
    boundary = ALIGN,
	grid = vGRID
);




//***** fill *******************************************************************
BTCD_M11_V11_M12_TCDDMY_M11_C = SPEC_BTCD_M11_V11_M12["OUTPUT_BTCD_M11_V11_M12_TCDDMY_M11"][0];
BTCD_M11_V11_M12_TCDDMY_V11_C = SPEC_BTCD_M11_V11_M12["OUTPUT_BTCD_M11_V11_M12_TCDDMY_V11"][0];
BTCD_M11_V11_M12_TCDDMY_M12_C  = SPEC_BTCD_M11_V11_M12["OUTPUT_BTCD_M11_V11_M12_TCDDMY_M12"][0];
BTCD_M11_V11_M12_E            = SPEC_BTCD_M11_V11_M12["SPEC_BTCD_M11_V11_M12_TCDDMY_M11_EXTENT"][0];
#endif
//===================================================================================

#ifdef FILL_M12_VIA12_M13_BTCD
// DUMMY SPEC : BTCD_M12_V12_M13
FSS_SPEC_BTCD_M12_V12_M13 : list of fill_to_signal_spacing_s = {






    { CHIP_snps, min_space = DMY1B_CHIP, context = INTERIOR }, // for ya/yb/y
	{ BEOLBLK_FINAL, min_space = DMY1B_MY1 }, // for ya/yb/y
    { DM12EXCL_FINAL, min_space = DMY1B_MY1 },
    { M12_MAIN, min_space = DMY1B_MY1 },
    { DM12_O, min_space = 0.26 },
    { DM12, min_space = 0.26 },
    { DM12_GT1350, min_space = 0.45 },
    { DV12EXCL, min_space = DV_DVXEXCL },



    { CHIP_snps, min_space = DMY1B_CHIP, context = INTERIOR }, // for ya/yb/y
	{ BEOLBLK_FINAL, min_space = DMY1B_MY1 }, // for ya/yb/y
    { DM13EXCL_FINAL, min_space = DMY1B_MY1 },
    { M13_MAIN, min_space = DMY1B_MY1 },
    { DM13_O, min_space = 0.26 },
    { DM13, min_space = 0.26 },
    { DM13_GT1350, min_space = 0.45 },

#ifdef FULL_CHIP
               { CHIP_BOUNDARY, min_space = 5, context = INTERIOR },
#else
               { PRBOUNDARY, min_space = 5, context = INTERIOR },
#endif
               { ICOVL_SINGLE, min_space = BTCD_ICOVL },
               { INDDMY, min_space = BTCD_IND },
               { MOMDMY_12, min_space = BTCD_MOMDMY },
               { MOMDMY_13, min_space = BTCD_MOMDMY },
               { LOGO, min_space = BTCD_LOGO },
	           { SRM, min_space = BTCD_SRM },
               { SRAMDMY, min_space = BTCD_SRAMDMY },
               { TCDDMY_M12, min_space = BTCD_SR },
               { TCDDMY_V12, min_space = BTCD_SR },
               { TCDDMY_M13, min_space = BTCD_SR },
               { VIA12I, min_space = BTCD_M },
               { DVIA12, min_space = BTCD_D },
               { DVIA12_O, min_space = BTCD_D },
               { ALL_STD_20, min_space = BTCD_STD },
               { RH_TN, min_space = BTCD_RHTN },
               { RH_TNB, min_space = BTCD_RHTNB },
#ifdef FILL_M11_VIA11_M12_BTCD
               { BTCD_M11_V11_M12_E, min_space = BTCD_SR },
#endif
};
//========================================================

PATTERN_SPEC_BTCD_M12_V12_M13 = get_single_polygon_pattern (
    cell_prefix = "TCDM12V12M13PHANTOM",
    step_x = BTCD_S,
    step_y = BTCD_S,
    FSS = FSS_SPEC_BTCD_M12_V12_M13,
    repeat = 2,
    shift = 2,
    starting_point = CENTER
);


LAYER_OUTPUT_BTCD_M12_V12_M13_TCDDMY_M12 : polygon_layer_s = {
    layer_spec= {
        output_layer_key = "OUTPUT_BTCD_M12_V12_M13_TCDDMY_M12",
    },
    polygons = SHAPE_BTCD_BOUNDARY,
};
LAYER_OUTPUT_BTCD_M12_V12_M13_TCDDMY_V12 : polygon_layer_s = {
    layer_spec= {
        output_layer_key = "OUTPUT_BTCD_M12_V12_M13_TCDDMY_V12",
    },
    polygons = SHAPE_BTCD_BOUNDARY,
};
LAYER_OUTPUT_BTCD_M12_V12_M13_TCDDMY_M13  : polygon_layer_s = {
    layer_spec= {
        output_layer_key = "OUTPUT_BTCD_M12_V12_M13_TCDDMY_M13",
    },
    polygons = SHAPE_BTCD_BOUNDARY,
};

PATTERN_SPEC_BTCD_M12_V12_M13.polygon_fill.layers = {
    LAYER_OUTPUT_BTCD_M12_V12_M13_TCDDMY_M12,
    LAYER_OUTPUT_BTCD_M12_V12_M13_TCDDMY_V12,
    LAYER_OUTPUT_BTCD_M12_V12_M13_TCDDMY_M13 ,
};

//***** spec *******************************************************************
SPEC_BTCD_M12_V12_M13 = unified_fill(
	fill_patterns = {
        PATTERN_SPEC_BTCD_M12_V12_M13
    },
	fill_boundary = {
	    layer = CHIP_snps,
	    type = LAYER,
	},
    extents_output = {
        {
            output_layer_key = "SPEC_BTCD_M12_V12_M13_TCDDMY_M12_EXTENT",
        }
    },
    boundary = ALIGN,
	grid = vGRID
);




//***** fill *******************************************************************
BTCD_M12_V12_M13_TCDDMY_M12_C = SPEC_BTCD_M12_V12_M13["OUTPUT_BTCD_M12_V12_M13_TCDDMY_M12"][0];
BTCD_M12_V12_M13_TCDDMY_V12_C = SPEC_BTCD_M12_V12_M13["OUTPUT_BTCD_M12_V12_M13_TCDDMY_V12"][0];
BTCD_M12_V12_M13_TCDDMY_M13_C  = SPEC_BTCD_M12_V12_M13["OUTPUT_BTCD_M12_V12_M13_TCDDMY_M13"][0];
BTCD_M12_V12_M13_E            = SPEC_BTCD_M12_V12_M13["SPEC_BTCD_M12_V12_M13_TCDDMY_M12_EXTENT"][0];
#endif
//===================================================================================


















#ifdef FILL_M0_BTCD
#define FILL_M0_BTCD2
#endif

#ifdef FILL_M1_BTCD
#define FILL_M1_BTCD2
#endif

#ifdef FILL_M2_BTCD
#define FILL_M2_BTCD2
#endif

#ifdef FILL_M3_BTCD
#define FILL_M3_BTCD2
#endif

#ifdef FILL_M4_BTCD
#define FILL_M4_BTCD2
#endif

#ifdef FILL_M5_BTCD
#define FILL_M5_BTCD2
#endif

#ifdef FILL_M6_BTCD
#define FILL_M6_BTCD2
#endif

#ifdef FILL_M7_BTCD
#define FILL_M7_BTCD2
#endif

#ifdef FILL_M8_BTCD
#define FILL_M8_BTCD2
#endif

#ifdef FILL_M9_BTCD
#define FILL_M9_BTCD2
#endif

#ifdef FILL_M10_BTCD
#define FILL_M10_BTCD2
#endif

#ifdef FILL_M11_BTCD
#define FILL_M11_BTCD2
#endif

#ifdef FILL_M12_BTCD
#define FILL_M12_BTCD2
#endif

#ifdef FILL_M13_BTCD
#define FILL_M13_BTCD2
#endif









#ifdef FILL_M0_BTCD2
// DUMMY SPEC : BTCD_M0
FSS_SPEC_BTCD_M0 : list of fill_to_signal_spacing_s = {

#ifdef FULL_CHIP
               { CHIP_BOUNDARY, min_space = 5, context = INTERIOR },
#else
               { PRBOUNDARY, min_space = 5, context = INTERIOR },
#endif
               { CHIP_snps, min_space = DMX1_CHIP, context = INTERIOR }, // for 0/1/xa/xb/xc
               { BEOLBLK_FINAL, min_space = DMX1B_MX }, // for 0/1/xa/xb/xc
               { M0_MAIN, min_space = DMX1B_MX },
               { DM0EXCL_FINAL, min_space = DMX1B_MX },
               { ICOVL_SINGLE, min_space = BTCD_ICOVL },
               { INDDMY, min_space = BTCD_IND },
               { MOMDMY_0, min_space = BTCD_MOMDMY },
               { LOGO, min_space = BTCD_LOGO },
	 	       { SRM, min_space = BTCD_SRM },
               { SRAMDMY, min_space = BTCD_SRAMDMY },
               { TCDDMY_M0, min_space = BTCD_SR },
               { DM0, min_space = BTCD_D },
               { DM0_O, min_space = BTCD_D },
               { ALL_STD_20, min_space = BTCD_STD },
               { RH_TN, min_space = BTCD_RHTN },
               { RH_TNB, min_space = BTCD_RHTNB },
#ifdef FILL_M0_VIA0_M1_BTCD
               { BTCD_M0_V0_M1_E, min_space = BTCD_SR },
#endif

};
//========================================================
PATTERN_SPEC_BTCD_M0 = get_single_polygon_pattern(
    cell_prefix = "TCDM0PHANTOM",
    step_x = BTCD_S,
    step_y = BTCD_S,
    FSS = FSS_SPEC_BTCD_M0,
    repeat = 2,
    shift = 2,
    starting_point = CENTER
);

PATTERN_SPEC_BTCD_M0.polygon_fill.layers = {
    {
        layer_spec= {
            output_layer_key = "OUTPUT_BTCD_M0_TCDDMY_M0",
        },
        polygons = SHAPE_BTCD_BOUNDARY,
    }
};

SPEC_BTCD_M0 = unified_fill(
	fill_patterns = {
        PATTERN_SPEC_BTCD_M0
    },
	fill_boundary = {
	    layer = CHIP_snps,
	    type = LAYER,
	},
    extents_output = {
        {
            output_layer_key = "SPEC_BTCD_M0_EXTENT",
        }
    },
    boundary = ALIGN,
	grid = vGRID
);
//***** fill *******************************************************************
BTCD_M0_TCDDMY_M0_C = SPEC_BTCD_M0["OUTPUT_BTCD_M0_TCDDMY_M0"][0];
BTCD_M0_E           = SPEC_BTCD_M0["SPEC_BTCD_M0_EXTENT"][0];


#endif
//===================================================================================

#ifdef FILL_M1_BTCD2
// DUMMY SPEC : BTCD_M1
FSS_SPEC_BTCD_M1 : list of fill_to_signal_spacing_s = {

#ifdef FULL_CHIP
               { CHIP_BOUNDARY, min_space = 5, context = INTERIOR },
#else
               { PRBOUNDARY, min_space = 5, context = INTERIOR },
#endif
               { CHIP_snps, min_space = DMX1_CHIP, context = INTERIOR }, // for 0/1/xa/xb/xc
               { BEOLBLK_FINAL, min_space = DMX1B_MX }, // for 0/1/xa/xb/xc
               { M1_MAIN, min_space = DMX1B_MX },
               { DM1EXCL_FINAL, min_space = DMX1B_MX },
               { ICOVL_SINGLE, min_space = BTCD_ICOVL },
               { INDDMY, min_space = BTCD_IND },
               { MOMDMY_1, min_space = BTCD_MOMDMY },
               { LOGO, min_space = BTCD_LOGO },
	 	       { SRM, min_space = BTCD_SRM },
               { SRAMDMY, min_space = BTCD_SRAMDMY },
               { TCDDMY_M1, min_space = BTCD_SR },
               { DM1, min_space = BTCD_D },
               { DM1_O, min_space = BTCD_D },
               { ALL_STD_20, min_space = BTCD_STD },
               { RH_TN, min_space = BTCD_RHTN },
               { RH_TNB, min_space = BTCD_RHTNB },
#ifdef FILL_M0_VIA0_M1_BTCD
               { BTCD_M0_V0_M1_E, min_space = BTCD_SR },
#endif
#ifdef FILL_M1_VIA1_M2_BTCD
               { BTCD_M1_V1_M2_E, min_space = BTCD_SR },
#endif

};
//========================================================
PATTERN_SPEC_BTCD_M1 = get_single_polygon_pattern(
    cell_prefix = "TCDM1PHANTOM",
    step_x = BTCD_S,
    step_y = BTCD_S,
    FSS = FSS_SPEC_BTCD_M1,
    repeat = 2,
    shift = 2,
    starting_point = CENTER
);

PATTERN_SPEC_BTCD_M1.polygon_fill.layers = {
    {
        layer_spec= {
            output_layer_key = "OUTPUT_BTCD_M1_TCDDMY_M1",
        },
        polygons = SHAPE_BTCD_BOUNDARY,
    }
};

SPEC_BTCD_M1 = unified_fill(
	fill_patterns = {
        PATTERN_SPEC_BTCD_M1
    },
	fill_boundary = {
	    layer = CHIP_snps,
	    type = LAYER,
	},
    extents_output = {
        {
            output_layer_key = "SPEC_BTCD_M1_EXTENT",
        }
    },
    boundary = ALIGN,
	grid = vGRID
);
//***** fill *******************************************************************
BTCD_M1_TCDDMY_M1_C = SPEC_BTCD_M1["OUTPUT_BTCD_M1_TCDDMY_M1"][0];
BTCD_M1_E           = SPEC_BTCD_M1["SPEC_BTCD_M1_EXTENT"][0];


#endif
//===================================================================================

#ifdef FILL_M2_BTCD2
// DUMMY SPEC : BTCD_M2
FSS_SPEC_BTCD_M2 : list of fill_to_signal_spacing_s = {

#ifdef FULL_CHIP
               { CHIP_BOUNDARY, min_space = 5, context = INTERIOR },
#else
               { PRBOUNDARY, min_space = 5, context = INTERIOR },
#endif
               { CHIP_snps, min_space = DMX1_CHIP, context = INTERIOR }, // for 0/1/xa/xb/xc
               { BEOLBLK_FINAL, min_space = DMX1B_MX }, // for 0/1/xa/xb/xc
               { M2_MAIN, min_space = DMX1B_MX },
               { DM2EXCL_FINAL, min_space = DMX1B_MX },
               { ICOVL_SINGLE, min_space = BTCD_ICOVL },
               { INDDMY, min_space = BTCD_IND },
               { MOMDMY_2, min_space = BTCD_MOMDMY },
               { LOGO, min_space = BTCD_LOGO },
	 	       { SRM, min_space = BTCD_SRM },
               { SRAMDMY, min_space = BTCD_SRAMDMY },
               { TCDDMY_M2, min_space = BTCD_SR },
               { DM2, min_space = BTCD_D },
               { DM2_O, min_space = BTCD_D },
               { ALL_STD_20, min_space = BTCD_STD },
               { RH_TN, min_space = BTCD_RHTN },
               { RH_TNB, min_space = BTCD_RHTNB },
#ifdef FILL_M1_VIA1_M2_BTCD
               { BTCD_M1_V1_M2_E, min_space = BTCD_SR },
#endif
#ifdef FILL_M2_VIA2_M3_BTCD
               { BTCD_M2_V2_M3_E, min_space = BTCD_SR },
#endif

};
//========================================================
PATTERN_SPEC_BTCD_M2 = get_single_polygon_pattern(
    cell_prefix = "TCDM2PHANTOM",
    step_x = BTCD_S,
    step_y = BTCD_S,
    FSS = FSS_SPEC_BTCD_M2,
    repeat = 2,
    shift = 2,
    starting_point = CENTER
);

PATTERN_SPEC_BTCD_M2.polygon_fill.layers = {
    {
        layer_spec= {
            output_layer_key = "OUTPUT_BTCD_M2_TCDDMY_M2",
        },
        polygons = SHAPE_BTCD_BOUNDARY,
    }
};

SPEC_BTCD_M2 = unified_fill(
	fill_patterns = {
        PATTERN_SPEC_BTCD_M2
    },
	fill_boundary = {
	    layer = CHIP_snps,
	    type = LAYER,
	},
    extents_output = {
        {
            output_layer_key = "SPEC_BTCD_M2_EXTENT",
        }
    },
    boundary = ALIGN,
	grid = vGRID
);
//***** fill *******************************************************************
BTCD_M2_TCDDMY_M2_C = SPEC_BTCD_M2["OUTPUT_BTCD_M2_TCDDMY_M2"][0];
BTCD_M2_E           = SPEC_BTCD_M2["SPEC_BTCD_M2_EXTENT"][0];


#endif
//===================================================================================

#ifdef FILL_M3_BTCD2
// DUMMY SPEC : BTCD_M3
FSS_SPEC_BTCD_M3 : list of fill_to_signal_spacing_s = {

#ifdef FULL_CHIP
               { CHIP_BOUNDARY, min_space = 5, context = INTERIOR },
#else
               { PRBOUNDARY, min_space = 5, context = INTERIOR },
#endif
               { CHIP_snps, min_space = DMX2_CHIP, context = INTERIOR }, // for 0/1/x/xb/xc
               { BEOLBLK_FINAL, min_space = DMX2B_MX }, // for 0/1/x/xb/xc
               { DM3EXCL_FINAL, min_space = DMX2B_MX },
               { M3_MAIN, min_space = DMX2B_MX },
               { ICOVL_SINGLE, min_space = BTCD_ICOVL },
               { INDDMY, min_space = BTCD_IND },
               { MOMDMY_3, min_space = BTCD_MOMDMY },
               { LOGO, min_space = BTCD_LOGO },
	 	       { SRM, min_space = BTCD_SRM },
               { SRAMDMY, min_space = BTCD_SRAMDMY },
               { TCDDMY_M3, min_space = BTCD_SR },
               { DM3, min_space = BTCD_D },
               { DM3_O, min_space = BTCD_D },
               { ALL_STD_20, min_space = BTCD_STD },
               { RH_TN, min_space = BTCD_RHTN },
               { RH_TNB, min_space = BTCD_RHTNB },
#ifdef FILL_M2_VIA2_M3_BTCD
               { BTCD_M2_V2_M3_E, min_space = BTCD_SR },
#endif
#ifdef FILL_M3_VIA3_M4_BTCD
               { BTCD_M3_V3_M4_E, min_space = BTCD_SR },
#endif

};
//========================================================
PATTERN_SPEC_BTCD_M3 = get_single_polygon_pattern(
    cell_prefix = "TCDM3PHANTOM",
    step_x = BTCD_S,
    step_y = BTCD_S,
    FSS = FSS_SPEC_BTCD_M3,
    repeat = 2,
    shift = 2,
    starting_point = CENTER
);

PATTERN_SPEC_BTCD_M3.polygon_fill.layers = {
    {
        layer_spec= {
            output_layer_key = "OUTPUT_BTCD_M3_TCDDMY_M3",
        },
        polygons = SHAPE_BTCD_BOUNDARY,
    }
};

SPEC_BTCD_M3 = unified_fill(
	fill_patterns = {
        PATTERN_SPEC_BTCD_M3
    },
	fill_boundary = {
	    layer = CHIP_snps,
	    type = LAYER,
	},
    extents_output = {
        {
            output_layer_key = "SPEC_BTCD_M3_EXTENT",
        }
    },
    boundary = ALIGN,
	grid = vGRID
);
//***** fill *******************************************************************
BTCD_M3_TCDDMY_M3_C = SPEC_BTCD_M3["OUTPUT_BTCD_M3_TCDDMY_M3"][0];
BTCD_M3_E           = SPEC_BTCD_M3["SPEC_BTCD_M3_EXTENT"][0];


#endif
//===================================================================================

#ifdef FILL_M4_BTCD2
// DUMMY SPEC : BTCD_M4
FSS_SPEC_BTCD_M4 : list of fill_to_signal_spacing_s = {

#ifdef FULL_CHIP
               { CHIP_BOUNDARY, min_space = 5, context = INTERIOR },
#else
               { PRBOUNDARY, min_space = 5, context = INTERIOR },
#endif
               { CHIP_snps, min_space = DMX2_CHIP, context = INTERIOR }, // for 0/1/x/xb/xc
               { BEOLBLK_FINAL, min_space = DMX2B_MX }, // for 0/1/x/xb/xc
               { DM4EXCL_FINAL, min_space = DMX2B_MX },
               { M4_MAIN, min_space = DMX2B_MX },
               { ICOVL_SINGLE, min_space = BTCD_ICOVL },
               { INDDMY, min_space = BTCD_IND },
               { MOMDMY_4, min_space = BTCD_MOMDMY },
               { LOGO, min_space = BTCD_LOGO },
	 	       { SRM, min_space = BTCD_SRM },
               { SRAMDMY, min_space = BTCD_SRAMDMY },
               { TCDDMY_M4, min_space = BTCD_SR },
               { DM4, min_space = BTCD_D },
               { DM4_O, min_space = BTCD_D },
               { ALL_STD_20, min_space = BTCD_STD },
               { RH_TN, min_space = BTCD_RHTN },
               { RH_TNB, min_space = BTCD_RHTNB },
#ifdef FILL_M3_VIA3_M4_BTCD
               { BTCD_M3_V3_M4_E, min_space = BTCD_SR },
#endif
#ifdef FILL_M4_VIA4_M5_BTCD
               { BTCD_M4_V4_M5_E, min_space = BTCD_SR },
#endif

};
//========================================================
PATTERN_SPEC_BTCD_M4 = get_single_polygon_pattern(
    cell_prefix = "TCDM4PHANTOM",
    step_x = BTCD_S,
    step_y = BTCD_S,
    FSS = FSS_SPEC_BTCD_M4,
    repeat = 2,
    shift = 2,
    starting_point = CENTER
);

PATTERN_SPEC_BTCD_M4.polygon_fill.layers = {
    {
        layer_spec= {
            output_layer_key = "OUTPUT_BTCD_M4_TCDDMY_M4",
        },
        polygons = SHAPE_BTCD_BOUNDARY,
    }
};

SPEC_BTCD_M4 = unified_fill(
	fill_patterns = {
        PATTERN_SPEC_BTCD_M4
    },
	fill_boundary = {
	    layer = CHIP_snps,
	    type = LAYER,
	},
    extents_output = {
        {
            output_layer_key = "SPEC_BTCD_M4_EXTENT",
        }
    },
    boundary = ALIGN,
	grid = vGRID
);
//***** fill *******************************************************************
BTCD_M4_TCDDMY_M4_C = SPEC_BTCD_M4["OUTPUT_BTCD_M4_TCDDMY_M4"][0];
BTCD_M4_E           = SPEC_BTCD_M4["SPEC_BTCD_M4_EXTENT"][0];


#endif
//===================================================================================

#ifdef FILL_M5_BTCD2
// DUMMY SPEC : BTCD_M5
FSS_SPEC_BTCD_M5 : list of fill_to_signal_spacing_s = {

#ifdef FULL_CHIP
               { CHIP_BOUNDARY, min_space = 5, context = INTERIOR },
#else
               { PRBOUNDARY, min_space = 5, context = INTERIOR },
#endif
               { CHIP_snps, min_space = DMX3B_CHIP, context = INTERIOR }, // for xd
               { BEOLBLK_FINAL, min_space = DMX3B_MX }, // for xd
               { DM5EXCL_FINAL, min_space = DMX3B_MX },
               { M5_MAIN, min_space = DMX3B_MX },
               { DM5_O, min_space = 0.26 },
               { DM5, min_space = 0.26 },
               { ICOVL_SINGLE, min_space = BTCD_ICOVL },
               { INDDMY, min_space = BTCD_IND },
               { MOMDMY_5, min_space = BTCD_MOMDMY },
               { LOGO, min_space = BTCD_LOGO },
	 	       { SRM, min_space = BTCD_SRM },
               { SRAMDMY, min_space = BTCD_SRAMDMY },
               { TCDDMY_M5, min_space = BTCD_SR },
               { ALL_STD_20, min_space = BTCD_STD },
               { RH_TN, min_space = BTCD_RHTN },
               { RH_TNB, min_space = BTCD_RHTNB },
#ifdef FILL_M4_VIA4_M5_BTCD
               { BTCD_M4_V4_M5_E, min_space = BTCD_SR },
#endif
#ifdef FILL_M5_VIA5_M6_BTCD
               { BTCD_M5_V5_M6_E, min_space = BTCD_SR },
#endif

};
//========================================================
PATTERN_SPEC_BTCD_M5 = get_single_polygon_pattern(
    cell_prefix = "TCDM5PHANTOM",
    step_x = BTCD_S,
    step_y = BTCD_S,
    FSS = FSS_SPEC_BTCD_M5,
    repeat = 2,
    shift = 2,
    starting_point = CENTER
);

PATTERN_SPEC_BTCD_M5.polygon_fill.layers = {
    {
        layer_spec= {
            output_layer_key = "OUTPUT_BTCD_M5_TCDDMY_M5",
        },
        polygons = SHAPE_BTCD_BOUNDARY,
    }
};

SPEC_BTCD_M5 = unified_fill(
	fill_patterns = {
        PATTERN_SPEC_BTCD_M5
    },
	fill_boundary = {
	    layer = CHIP_snps,
	    type = LAYER,
	},
    extents_output = {
        {
            output_layer_key = "SPEC_BTCD_M5_EXTENT",
        }
    },
    boundary = ALIGN,
	grid = vGRID
);
//***** fill *******************************************************************
BTCD_M5_TCDDMY_M5_C = SPEC_BTCD_M5["OUTPUT_BTCD_M5_TCDDMY_M5"][0];
BTCD_M5_E           = SPEC_BTCD_M5["SPEC_BTCD_M5_EXTENT"][0];


#endif
//===================================================================================

#ifdef FILL_M6_BTCD2
// DUMMY SPEC : BTCD_M6
FSS_SPEC_BTCD_M6 : list of fill_to_signal_spacing_s = {

#ifdef FULL_CHIP
               { CHIP_BOUNDARY, min_space = 5, context = INTERIOR },
#else
               { PRBOUNDARY, min_space = 5, context = INTERIOR },
#endif
               { CHIP_snps, min_space = DMY1B_CHIP, context = INTERIOR }, // for ya/yb/y
               { BEOLBLK_FINAL, min_space = DMY1B_MY1 }, // for ya/yb/y
               { DM6EXCL_FINAL, min_space = DMY1B_MY1 },
               { M6_MAIN, min_space = DMY1B_MY1 },
               { DM6_O, min_space = 0.26 },
               { DM6, min_space = 0.26 },
               { DM6_GT1350, min_space = 0.45 },
               { ICOVL_SINGLE, min_space = BTCD_ICOVL },
               { INDDMY, min_space = BTCD_IND },
               { MOMDMY_6, min_space = BTCD_MOMDMY },
               { LOGO, min_space = BTCD_LOGO },
	 	       { SRM, min_space = BTCD_SRM },
               { SRAMDMY, min_space = BTCD_SRAMDMY },
               { TCDDMY_M6, min_space = BTCD_SR },
               { ALL_STD_20, min_space = BTCD_STD },
               { RH_TN, min_space = BTCD_RHTN },
               { RH_TNB, min_space = BTCD_RHTNB },
#ifdef FILL_M5_VIA5_M6_BTCD
               { BTCD_M5_V5_M6_E, min_space = BTCD_SR },
#endif
#ifdef FILL_M6_VIA6_M7_BTCD
               { BTCD_M6_V6_M7_E, min_space = BTCD_SR },
#endif

};
//========================================================
PATTERN_SPEC_BTCD_M6 = get_single_polygon_pattern(
    cell_prefix = "TCDM6PHANTOM",
    step_x = BTCD_S,
    step_y = BTCD_S,
    FSS = FSS_SPEC_BTCD_M6,
    repeat = 2,
    shift = 2,
    starting_point = CENTER
);

PATTERN_SPEC_BTCD_M6.polygon_fill.layers = {
    {
        layer_spec= {
            output_layer_key = "OUTPUT_BTCD_M6_TCDDMY_M6",
        },
        polygons = SHAPE_BTCD_BOUNDARY,
    }
};

SPEC_BTCD_M6 = unified_fill(
	fill_patterns = {
        PATTERN_SPEC_BTCD_M6
    },
	fill_boundary = {
	    layer = CHIP_snps,
	    type = LAYER,
	},
    extents_output = {
        {
            output_layer_key = "SPEC_BTCD_M6_EXTENT",
        }
    },
    boundary = ALIGN,
	grid = vGRID
);
//***** fill *******************************************************************
BTCD_M6_TCDDMY_M6_C = SPEC_BTCD_M6["OUTPUT_BTCD_M6_TCDDMY_M6"][0];
BTCD_M6_E           = SPEC_BTCD_M6["SPEC_BTCD_M6_EXTENT"][0];


#endif
//===================================================================================

#ifdef FILL_M7_BTCD2
// DUMMY SPEC : BTCD_M7
FSS_SPEC_BTCD_M7 : list of fill_to_signal_spacing_s = {

#ifdef FULL_CHIP
               { CHIP_BOUNDARY, min_space = 5, context = INTERIOR },
#else
               { PRBOUNDARY, min_space = 5, context = INTERIOR },
#endif
               { CHIP_snps, min_space = DMY1B_CHIP, context = INTERIOR }, // for ya/yb/y
               { BEOLBLK_FINAL, min_space = DMY1B_MY1 }, // for ya/yb/y
               { DM7EXCL_FINAL, min_space = DMY1B_MY1 },
               { M7_MAIN, min_space = DMY1B_MY1 },
               { DM7_O, min_space = 0.26 },
               { DM7, min_space = 0.26 },
               { DM7_GT1350, min_space = 0.45 },
               { ICOVL_SINGLE, min_space = BTCD_ICOVL },
               { INDDMY, min_space = BTCD_IND },
               { MOMDMY_7, min_space = BTCD_MOMDMY },
               { LOGO, min_space = BTCD_LOGO },
	 	       { SRM, min_space = BTCD_SRM },
               { SRAMDMY, min_space = BTCD_SRAMDMY },
               { TCDDMY_M7, min_space = BTCD_SR },
               { ALL_STD_20, min_space = BTCD_STD },
               { RH_TN, min_space = BTCD_RHTN },
               { RH_TNB, min_space = BTCD_RHTNB },
#ifdef FILL_M6_VIA6_M7_BTCD
               { BTCD_M6_V6_M7_E, min_space = BTCD_SR },
#endif
#ifdef FILL_M7_VIA7_M8_BTCD
               { BTCD_M7_V7_M8_E, min_space = BTCD_SR },
#endif

};
//========================================================
PATTERN_SPEC_BTCD_M7 = get_single_polygon_pattern(
    cell_prefix = "TCDM7PHANTOM",
    step_x = BTCD_S,
    step_y = BTCD_S,
    FSS = FSS_SPEC_BTCD_M7,
    repeat = 2,
    shift = 2,
    starting_point = CENTER
);

PATTERN_SPEC_BTCD_M7.polygon_fill.layers = {
    {
        layer_spec= {
            output_layer_key = "OUTPUT_BTCD_M7_TCDDMY_M7",
        },
        polygons = SHAPE_BTCD_BOUNDARY,
    }
};

SPEC_BTCD_M7 = unified_fill(
	fill_patterns = {
        PATTERN_SPEC_BTCD_M7
    },
	fill_boundary = {
	    layer = CHIP_snps,
	    type = LAYER,
	},
    extents_output = {
        {
            output_layer_key = "SPEC_BTCD_M7_EXTENT",
        }
    },
    boundary = ALIGN,
	grid = vGRID
);
//***** fill *******************************************************************
BTCD_M7_TCDDMY_M7_C = SPEC_BTCD_M7["OUTPUT_BTCD_M7_TCDDMY_M7"][0];
BTCD_M7_E           = SPEC_BTCD_M7["SPEC_BTCD_M7_EXTENT"][0];


#endif
//===================================================================================

#ifdef FILL_M8_BTCD2
// DUMMY SPEC : BTCD_M8
FSS_SPEC_BTCD_M8 : list of fill_to_signal_spacing_s = {

#ifdef FULL_CHIP
               { CHIP_BOUNDARY, min_space = 5, context = INTERIOR },
#else
               { PRBOUNDARY, min_space = 5, context = INTERIOR },
#endif
               { CHIP_snps, min_space = DMY1B_CHIP, context = INTERIOR }, // for ya/yb/y
               { BEOLBLK_FINAL, min_space = DMY1B_MY1 }, // for ya/yb/y
               { DM8EXCL_FINAL, min_space = DMY1B_MY1 },
               { M8_MAIN, min_space = DMY1B_MY1 },
               { DM8_O, min_space = 0.26 },
               { DM8, min_space = 0.26 },
               { DM8_GT1350, min_space = 0.45 },
               { ICOVL_SINGLE, min_space = BTCD_ICOVL },
               { INDDMY, min_space = BTCD_IND },
               { MOMDMY_8, min_space = BTCD_MOMDMY },
               { LOGO, min_space = BTCD_LOGO },
	 	       { SRM, min_space = BTCD_SRM },
               { SRAMDMY, min_space = BTCD_SRAMDMY },
               { TCDDMY_M8, min_space = BTCD_SR },
               { ALL_STD_20, min_space = BTCD_STD },
               { RH_TN, min_space = BTCD_RHTN },
               { RH_TNB, min_space = BTCD_RHTNB },
#ifdef FILL_M7_VIA7_M8_BTCD
               { BTCD_M7_V7_M8_E, min_space = BTCD_SR },
#endif
#ifdef FILL_M8_VIA8_M9_BTCD
               { BTCD_M8_V8_M9_E, min_space = BTCD_SR },
#endif

};
//========================================================
PATTERN_SPEC_BTCD_M8 = get_single_polygon_pattern(
    cell_prefix = "TCDM8PHANTOM",
    step_x = BTCD_S,
    step_y = BTCD_S,
    FSS = FSS_SPEC_BTCD_M8,
    repeat = 2,
    shift = 2,
    starting_point = CENTER
);

PATTERN_SPEC_BTCD_M8.polygon_fill.layers = {
    {
        layer_spec= {
            output_layer_key = "OUTPUT_BTCD_M8_TCDDMY_M8",
        },
        polygons = SHAPE_BTCD_BOUNDARY,
    }
};

SPEC_BTCD_M8 = unified_fill(
	fill_patterns = {
        PATTERN_SPEC_BTCD_M8
    },
	fill_boundary = {
	    layer = CHIP_snps,
	    type = LAYER,
	},
    extents_output = {
        {
            output_layer_key = "SPEC_BTCD_M8_EXTENT",
        }
    },
    boundary = ALIGN,
	grid = vGRID
);
//***** fill *******************************************************************
BTCD_M8_TCDDMY_M8_C = SPEC_BTCD_M8["OUTPUT_BTCD_M8_TCDDMY_M8"][0];
BTCD_M8_E           = SPEC_BTCD_M8["SPEC_BTCD_M8_EXTENT"][0];


#endif
//===================================================================================

#ifdef FILL_M9_BTCD2
// DUMMY SPEC : BTCD_M9
FSS_SPEC_BTCD_M9 : list of fill_to_signal_spacing_s = {

#ifdef FULL_CHIP
               { CHIP_BOUNDARY, min_space = 5, context = INTERIOR },
#else
               { PRBOUNDARY, min_space = 5, context = INTERIOR },
#endif
               { CHIP_snps, min_space = DMY1B_CHIP, context = INTERIOR }, // for ya/yb/y
               { BEOLBLK_FINAL, min_space = DMY1B_MY1 }, // for ya/yb/y
               { DM9EXCL_FINAL, min_space = DMY1B_MY1 },
               { M9_MAIN, min_space = DMY1B_MY1 },
               { DM9_O, min_space = 0.26 },
               { DM9, min_space = 0.26 },
               { DM9_GT1350, min_space = 0.45 },
               { ICOVL_SINGLE, min_space = BTCD_ICOVL },
               { INDDMY, min_space = BTCD_IND },
               { MOMDMY_9, min_space = BTCD_MOMDMY },
               { LOGO, min_space = BTCD_LOGO },
	 	       { SRM, min_space = BTCD_SRM },
               { SRAMDMY, min_space = BTCD_SRAMDMY },
               { TCDDMY_M9, min_space = BTCD_SR },
               { ALL_STD_20, min_space = BTCD_STD },
               { RH_TN, min_space = BTCD_RHTN },
               { RH_TNB, min_space = BTCD_RHTNB },
#ifdef FILL_M8_VIA8_M9_BTCD
               { BTCD_M8_V8_M9_E, min_space = BTCD_SR },
#endif
#ifdef FILL_M9_VIA9_M10_BTCD
               { BTCD_M9_V9_M10_E, min_space = BTCD_SR },
#endif

};
//========================================================
PATTERN_SPEC_BTCD_M9 = get_single_polygon_pattern(
    cell_prefix = "TCDM9PHANTOM",
    step_x = BTCD_S,
    step_y = BTCD_S,
    FSS = FSS_SPEC_BTCD_M9,
    repeat = 2,
    shift = 2,
    starting_point = CENTER
);

PATTERN_SPEC_BTCD_M9.polygon_fill.layers = {
    {
        layer_spec= {
            output_layer_key = "OUTPUT_BTCD_M9_TCDDMY_M9",
        },
        polygons = SHAPE_BTCD_BOUNDARY,
    }
};

SPEC_BTCD_M9 = unified_fill(
	fill_patterns = {
        PATTERN_SPEC_BTCD_M9
    },
	fill_boundary = {
	    layer = CHIP_snps,
	    type = LAYER,
	},
    extents_output = {
        {
            output_layer_key = "SPEC_BTCD_M9_EXTENT",
        }
    },
    boundary = ALIGN,
	grid = vGRID
);
//***** fill *******************************************************************
BTCD_M9_TCDDMY_M9_C = SPEC_BTCD_M9["OUTPUT_BTCD_M9_TCDDMY_M9"][0];
BTCD_M9_E           = SPEC_BTCD_M9["SPEC_BTCD_M9_EXTENT"][0];


#endif
//===================================================================================

#ifdef FILL_M10_BTCD2
// DUMMY SPEC : BTCD_M10
FSS_SPEC_BTCD_M10 : list of fill_to_signal_spacing_s = {

#ifdef FULL_CHIP
               { CHIP_BOUNDARY, min_space = 5, context = INTERIOR },
#else
               { PRBOUNDARY, min_space = 5, context = INTERIOR },
#endif
               { CHIP_snps, min_space = DMY1B_CHIP, context = INTERIOR }, // for ya/yb/y
               { BEOLBLK_FINAL, min_space = DMY1B_MY1 }, // for ya/yb/y
               { DM10EXCL_FINAL, min_space = DMY1B_MY1 },
               { M10_MAIN, min_space = DMY1B_MY1 },
               { DM10_O, min_space = 0.26 },
               { DM10, min_space = 0.26 },
               { DM10_GT1350, min_space = 0.45 },
               { ICOVL_SINGLE, min_space = BTCD_ICOVL },
               { INDDMY, min_space = BTCD_IND },
               { MOMDMY_10, min_space = BTCD_MOMDMY },
               { LOGO, min_space = BTCD_LOGO },
	 	       { SRM, min_space = BTCD_SRM },
               { SRAMDMY, min_space = BTCD_SRAMDMY },
               { TCDDMY_M10, min_space = BTCD_SR },
               { ALL_STD_20, min_space = BTCD_STD },
               { RH_TN, min_space = BTCD_RHTN },
               { RH_TNB, min_space = BTCD_RHTNB },
#ifdef FILL_M9_VIA9_M10_BTCD
               { BTCD_M9_V9_M10_E, min_space = BTCD_SR },
#endif
#ifdef FILL_M10_VIA10_M11_BTCD
               { BTCD_M10_V10_M11_E, min_space = BTCD_SR },
#endif

};
//========================================================
PATTERN_SPEC_BTCD_M10 = get_single_polygon_pattern(
    cell_prefix = "TCDM10PHANTOM",
    step_x = BTCD_S,
    step_y = BTCD_S,
    FSS = FSS_SPEC_BTCD_M10,
    repeat = 2,
    shift = 2,
    starting_point = CENTER
);

PATTERN_SPEC_BTCD_M10.polygon_fill.layers = {
    {
        layer_spec= {
            output_layer_key = "OUTPUT_BTCD_M10_TCDDMY_M10",
        },
        polygons = SHAPE_BTCD_BOUNDARY,
    }
};

SPEC_BTCD_M10 = unified_fill(
	fill_patterns = {
        PATTERN_SPEC_BTCD_M10
    },
	fill_boundary = {
	    layer = CHIP_snps,
	    type = LAYER,
	},
    extents_output = {
        {
            output_layer_key = "SPEC_BTCD_M10_EXTENT",
        }
    },
    boundary = ALIGN,
	grid = vGRID
);
//***** fill *******************************************************************
BTCD_M10_TCDDMY_M10_C = SPEC_BTCD_M10["OUTPUT_BTCD_M10_TCDDMY_M10"][0];
BTCD_M10_E           = SPEC_BTCD_M10["SPEC_BTCD_M10_EXTENT"][0];


#endif
//===================================================================================

#ifdef FILL_M11_BTCD2
// DUMMY SPEC : BTCD_M11
FSS_SPEC_BTCD_M11 : list of fill_to_signal_spacing_s = {

#ifdef FULL_CHIP
               { CHIP_BOUNDARY, min_space = 5, context = INTERIOR },
#else
               { PRBOUNDARY, min_space = 5, context = INTERIOR },
#endif
               { CHIP_snps, min_space = DMY1B_CHIP, context = INTERIOR }, // for ya/yb/y
               { BEOLBLK_FINAL, min_space = DMY1B_MY1 }, // for ya/yb/y
               { DM11EXCL_FINAL, min_space = DMY1B_MY1 },
               { M11_MAIN, min_space = DMY1B_MY1 },
               { DM11_O, min_space = 0.26 },
               { DM11, min_space = 0.26 },
               { DM11_GT1350, min_space = 0.45 },
               { ICOVL_SINGLE, min_space = BTCD_ICOVL },
               { INDDMY, min_space = BTCD_IND },
               { MOMDMY_11, min_space = BTCD_MOMDMY },
               { LOGO, min_space = BTCD_LOGO },
	 	       { SRM, min_space = BTCD_SRM },
               { SRAMDMY, min_space = BTCD_SRAMDMY },
               { TCDDMY_M11, min_space = BTCD_SR },
               { ALL_STD_20, min_space = BTCD_STD },
               { RH_TN, min_space = BTCD_RHTN },
               { RH_TNB, min_space = BTCD_RHTNB },
#ifdef FILL_M10_VIA10_M11_BTCD
               { BTCD_M10_V10_M11_E, min_space = BTCD_SR },
#endif
#ifdef FILL_M11_VIA11_M12_BTCD
               { BTCD_M11_V11_M12_E, min_space = BTCD_SR },
#endif

};
//========================================================
PATTERN_SPEC_BTCD_M11 = get_single_polygon_pattern(
    cell_prefix = "TCDM11PHANTOM",
    step_x = BTCD_S,
    step_y = BTCD_S,
    FSS = FSS_SPEC_BTCD_M11,
    repeat = 2,
    shift = 2,
    starting_point = CENTER
);

PATTERN_SPEC_BTCD_M11.polygon_fill.layers = {
    {
        layer_spec= {
            output_layer_key = "OUTPUT_BTCD_M11_TCDDMY_M11",
        },
        polygons = SHAPE_BTCD_BOUNDARY,
    }
};

SPEC_BTCD_M11 = unified_fill(
	fill_patterns = {
        PATTERN_SPEC_BTCD_M11
    },
	fill_boundary = {
	    layer = CHIP_snps,
	    type = LAYER,
	},
    extents_output = {
        {
            output_layer_key = "SPEC_BTCD_M11_EXTENT",
        }
    },
    boundary = ALIGN,
	grid = vGRID
);
//***** fill *******************************************************************
BTCD_M11_TCDDMY_M11_C = SPEC_BTCD_M11["OUTPUT_BTCD_M11_TCDDMY_M11"][0];
BTCD_M11_E           = SPEC_BTCD_M11["SPEC_BTCD_M11_EXTENT"][0];


#endif
//===================================================================================

#ifdef FILL_M12_BTCD2
// DUMMY SPEC : BTCD_M12
FSS_SPEC_BTCD_M12 : list of fill_to_signal_spacing_s = {

#ifdef FULL_CHIP
               { CHIP_BOUNDARY, min_space = 5, context = INTERIOR },
#else
               { PRBOUNDARY, min_space = 5, context = INTERIOR },
#endif
               { CHIP_snps, min_space = DMY1B_CHIP, context = INTERIOR }, // for ya/yb/y
               { BEOLBLK_FINAL, min_space = DMY1B_MY1 }, // for ya/yb/y
               { DM12EXCL_FINAL, min_space = DMY1B_MY1 },
               { M12_MAIN, min_space = DMY1B_MY1 },
               { DM12_O, min_space = 0.26 },
               { DM12, min_space = 0.26 },
               { DM12_GT1350, min_space = 0.45 },
               { ICOVL_SINGLE, min_space = BTCD_ICOVL },
               { INDDMY, min_space = BTCD_IND },
               { MOMDMY_12, min_space = BTCD_MOMDMY },
               { LOGO, min_space = BTCD_LOGO },
	 	       { SRM, min_space = BTCD_SRM },
               { SRAMDMY, min_space = BTCD_SRAMDMY },
               { TCDDMY_M12, min_space = BTCD_SR },
               { ALL_STD_20, min_space = BTCD_STD },
               { RH_TN, min_space = BTCD_RHTN },
               { RH_TNB, min_space = BTCD_RHTNB },
#ifdef FILL_M11_VIA11_M12_BTCD
               { BTCD_M11_V11_M12_E, min_space = BTCD_SR },
#endif
#ifdef FILL_M12_VIA12_M13_BTCD
               { BTCD_M12_V12_M13_E, min_space = BTCD_SR },
#endif

};
//========================================================
PATTERN_SPEC_BTCD_M12 = get_single_polygon_pattern(
    cell_prefix = "TCDM12PHANTOM",
    step_x = BTCD_S,
    step_y = BTCD_S,
    FSS = FSS_SPEC_BTCD_M12,
    repeat = 2,
    shift = 2,
    starting_point = CENTER
);

PATTERN_SPEC_BTCD_M12.polygon_fill.layers = {
    {
        layer_spec= {
            output_layer_key = "OUTPUT_BTCD_M12_TCDDMY_M12",
        },
        polygons = SHAPE_BTCD_BOUNDARY,
    }
};

SPEC_BTCD_M12 = unified_fill(
	fill_patterns = {
        PATTERN_SPEC_BTCD_M12
    },
	fill_boundary = {
	    layer = CHIP_snps,
	    type = LAYER,
	},
    extents_output = {
        {
            output_layer_key = "SPEC_BTCD_M12_EXTENT",
        }
    },
    boundary = ALIGN,
	grid = vGRID
);
//***** fill *******************************************************************
BTCD_M12_TCDDMY_M12_C = SPEC_BTCD_M12["OUTPUT_BTCD_M12_TCDDMY_M12"][0];
BTCD_M12_E           = SPEC_BTCD_M12["SPEC_BTCD_M12_EXTENT"][0];


#endif
//===================================================================================

#ifdef FILL_M13_BTCD2
// DUMMY SPEC : BTCD_M13
FSS_SPEC_BTCD_M13 : list of fill_to_signal_spacing_s = {

#ifdef FULL_CHIP
               { CHIP_BOUNDARY, min_space = 5, context = INTERIOR },
#else
               { PRBOUNDARY, min_space = 5, context = INTERIOR },
#endif
               { CHIP_snps, min_space = DMY1B_CHIP, context = INTERIOR }, // for ya/yb/y
               { BEOLBLK_FINAL, min_space = DMY1B_MY1 }, // for ya/yb/y
               { DM13EXCL_FINAL, min_space = DMY1B_MY1 },
               { M13_MAIN, min_space = DMY1B_MY1 },
               { DM13_O, min_space = 0.26 },
               { DM13, min_space = 0.26 },
               { DM13_GT1350, min_space = 0.45 },
               { ICOVL_SINGLE, min_space = BTCD_ICOVL },
               { INDDMY, min_space = BTCD_IND },
               { MOMDMY_13, min_space = BTCD_MOMDMY },
               { LOGO, min_space = BTCD_LOGO },
	 	       { SRM, min_space = BTCD_SRM },
               { SRAMDMY, min_space = BTCD_SRAMDMY },
               { TCDDMY_M13, min_space = BTCD_SR },
               { ALL_STD_20, min_space = BTCD_STD },
               { RH_TN, min_space = BTCD_RHTN },
               { RH_TNB, min_space = BTCD_RHTNB },
#ifdef FILL_M12_VIA12_M13_BTCD
               { BTCD_M12_V12_M13_E, min_space = BTCD_SR },
#endif

};
//========================================================
PATTERN_SPEC_BTCD_M13 = get_single_polygon_pattern(
    cell_prefix = "TCDM13PHANTOM",
    step_x = BTCD_S,
    step_y = BTCD_S,
    FSS = FSS_SPEC_BTCD_M13,
    repeat = 2,
    shift = 2,
    starting_point = CENTER
);

PATTERN_SPEC_BTCD_M13.polygon_fill.layers = {
    {
        layer_spec= {
            output_layer_key = "OUTPUT_BTCD_M13_TCDDMY_M13",
        },
        polygons = SHAPE_BTCD_BOUNDARY,
    }
};

SPEC_BTCD_M13 = unified_fill(
	fill_patterns = {
        PATTERN_SPEC_BTCD_M13
    },
	fill_boundary = {
	    layer = CHIP_snps,
	    type = LAYER,
	},
    extents_output = {
        {
            output_layer_key = "SPEC_BTCD_M13_EXTENT",
        }
    },
    boundary = ALIGN,
	grid = vGRID
);
//***** fill *******************************************************************
BTCD_M13_TCDDMY_M13_C = SPEC_BTCD_M13["OUTPUT_BTCD_M13_TCDDMY_M13"][0];
BTCD_M13_E           = SPEC_BTCD_M13["SPEC_BTCD_M13_EXTENT"][0];


#endif
//===================================================================================








MYCELL_H : list of coordinate_l = {
    { {0,0}, {DMY1OR_L, DMY1OR_W} }
};

MYCELL_V : list of coordinate_l = {
    { {0,0}, {DMY1OR_W, DMY1OR_L} }
};

MYCELL_HEXT : list of coordinate_l = {
    { {DMY1OR_L,0}, {(DMY1OR_L+DMY1OR_SY), DMY1OR_W} }
};

MYCELL_VEXT : list of coordinate_l = {
    { {0,DMY1OR_L}, {DMY1OR_W,(DMY1OR_L+DMY1OR_SY)} }
};




MYBCELL_H : list of coordinate_l = {
    { {0,0}, {DMY1B_L, DMY1B_W} }
};

MYBCELL_V : list of coordinate_l = {
    { {0,0}, {DMY1B_W, DMY1B_L} }
};

MYBCELL_HEXT : list of coordinate_l = {
    { {DMY1B_L,0}, {(DMY1B_L+DMY1B_SY), DMY1B_W} }
};

MYBCELL_VEXT : list of coordinate_l = {
    { {0,DMY1B_L}, {DMY1B_W,(DMY1B_L+DMY1B_SY)} }
};


dfm_property_func_w : function (void) returning void
{
    primary_data = df_get_current_data();
    elayer2_set = df_edge_layer(primary_data, "layer2");
    rlayer1_set = df_error_layer(primary_data, "");
    lengthL2 = df_edge_sum_length(elayer2_set);
    projection_lengthL1 = df_error_sum_projection_length(rlayer1_set);

    v1 = (lengthL2/2)-projection_lengthL1;

    if (double_constraint_contains(== 0.0, v1) && !(isinf(v1) || isnan(v1))) {
            df_save_data(primary_data);
    }
}

rect_func1 : function (void) returning void
{
    cur_polygon = fp_get_current_polygon();

    fp_generate_fill(cur_polygon, width = 5, height = 5, space_x = 10, space_y = 10, stagger_x = 2, stagger_y = 2);
}
BLK_REMOVE = fill_pattern( chip_extent(), rect_func1 ); 
















//***** Wrapper ****************************************************************




#ifdef FILL_DM0
#ifdef VERTICAL_M0
CHIP_SHRINK_M0 = shrink( CHIP_snps, north = CHIP_SHRINK_VALUEX1, south = CHIP_SHRINK_VALUEX1 );
SRM_FORBIDDEN_M0  = edge_size( angle_edge(SRM or SRAMDMY, == 0), outside = 0.4 );
#ifdef FULL_CHIP
M0_BOUNDARY_CLOSE  = edge_size( angle_edge(CHIP_BOUNDARY, == 90), outside = 0.014 );
M0_BOUNDARY_INSIDE = edge_size( angle_edge(CHIP_BOUNDARY, == 90), inside = CHIP_SHRINK_VALUEY1 );
#else
M0_BOUNDARY_CLOSE_PRE1 = edge_size( angle_edge( PRBOUNDARY, == 90 ), outside = 0.014 ); 
M0_BOUNDARY_CLOSE_PRE2 = shrink( M0_BOUNDARY_CLOSE_PRE1, north = 1, south = 1 ); 
M0_BOUNDARY_CLOSE_PRE3 = M0_BOUNDARY_CLOSE_PRE1 not M0_BOUNDARY_CLOSE_PRE2; 
M0_BOUNDARY_CLOSE_PRE4 = shrink( M0_BOUNDARY_CLOSE_PRE2, north = 0.1, south = 0.1 ); 
M0_BOUNDARY_CLOSE = M0_BOUNDARY_CLOSE_PRE3 or M0_BOUNDARY_CLOSE_PRE4; 
M0_BOUNDARY_INSIDE = edge_size( angle_edge( PRBOUNDARY, == 90 ), inside = CHIP_SHRINK_VALUEY1 ); 
#endif

#else
CHIP_SHRINK_M0 = shrink( CHIP_snps, east = CHIP_SHRINK_VALUEX1, west = CHIP_SHRINK_VALUEX1 );
SRM_FORBIDDEN_M0  = edge_size( angle_edge( SRM or SRAMDMY, == 90 ), outside = 0.4 );
#ifdef FULL_CHIP
M0_BOUNDARY_CLOSE  = edge_size( angle_edge(CHIP_BOUNDARY, == 0), outside = 0.014 );
M0_BOUNDARY_INSIDE = edge_size( angle_edge(CHIP_BOUNDARY, == 0), inside = CHIP_SHRINK_VALUEY1 );
#else
M0_BOUNDARY_CLOSE_PRE1  = edge_size(angle_edge( PRBOUNDARY, == 0), outside = 0.014 );
M0_BOUNDARY_CLOSE_PRE2  = shrink( M0_BOUNDARY_CLOSE_PRE1, west = 1, east = 1 );
M0_BOUNDARY_CLOSE_PRE3  = M0_BOUNDARY_CLOSE_PRE1 not M0_BOUNDARY_CLOSE_PRE2;
M0_BOUNDARY_CLOSE_PRE4  = shrink( M0_BOUNDARY_CLOSE_PRE2, west = 0.1, east = 0.1 );
M0_BOUNDARY_CLOSE  = or_list( { M0_BOUNDARY_CLOSE_PRE3, M0_BOUNDARY_CLOSE_PRE4 } );
M0_BOUNDARY_INSIDE = edge_size( angle_edge( PRBOUNDARY, == 0), inside = CHIP_SHRINK_VALUEY1 );
#endif

#endif

#ifdef FULL_CHIP
#ifdef WITH_SEALRING
REGION_WRAPPER_DM0 = ((CHIP_SHRINK_M0 not SRM_FORBIDDEN_M0) and (or_list( { (size( M0_MAIN, clip_acute = TRUNCATE, distance = WRAPPER_RANGEX1 )), (CHIP_snps not (size( CHIP_snps, clip_acute = TRUNCATE, distance = - WRAPPER_RANGEX1 ))), (size( (BEOLBLK_FINAL or DM0EXCL_FINAL), clip_acute = TRUNCATE, distance = WRAPPER_RANGEX1 )), M0_BOUNDARY_INSIDE } ))) or ((CHIP_snps not SRM_FORBIDDEN_M0) and M0_BOUNDARY_INSIDE); 
#else
REGION_WRAPPER_DM0 = (CHIP_SHRINK_M0 not SRM_FORBIDDEN_M0) and or_list( { 
    over_size( M0_MAIN, WRAPPER_RANGEX1),
    (CHIP_snps not over_size( CHIP_snps, -WRAPPER_RANGEX1)),
    over_size(BEOLBLK_FINAL or DM0EXCL_FINAL, WRAPPER_RANGEX1),
    M0_BOUNDARY_INSIDE
});
#endif
#else
REGION_WRAPPER_DM0 = ((CHIP_SHRINK_M0 not SRM_FORBIDDEN_M0) and (over_size( M0_MAIN, WRAPPER_RANGEX1) or (CHIP_snps not over_size(CHIP_snps, -WRAPPER_RANGEX1)) or over_size((BEOLBLK_FINAL or  DM0EXCL_FINAL), WRAPPER_RANGEX1) or M0_BOUNDARY_INSIDE)) or ((CHIP_snps not SRM_FORBIDDEN_M0) and M0_BOUNDARY_INSIDE);
#endif

#ifdef FULL_CHIP
M0_BOUNDARY_CLOSE_tmp = M0_BOUNDARY_CLOSE coincident_edge REGION_WRAPPER_DM0;
M0_BOUNDARY_CLOSE = edge_size(M0_BOUNDARY_CLOSE_tmp, inside = 0.014);
#endif

WIDECA_M0      = M0CA_GE160;
WIDECB_M0      = M0CB_GE160;
M0CA_WRAP1 = M0_MAIN_CA not or_list( { WIDECA_M0, DM0EXCL_FINAL_NOM0, BEOLBLK_FINAL_NOM0 } ); 
M0CA_WRAPLT165_SRAM = (M0CA_WRAP1 and (SRAMDMY or SRM)) interacting (M0CA_LT165 inside     (SRAMDMY or SRM));
M0CA_WRAPLT165_1    = (M0CA_WRAP1 not (SRAMDMY or SRM)) interacting (M0CA_LT165 not_inside (SRAMDMY or SRM));

M0CB_WRAP1 = M0_MAIN_CB not or_list( { WIDECB_M0, DM0EXCL_FINAL_NOM0, BEOLBLK_FINAL_NOM0 } ); 
M0CB_WRAPLT165_SRAM = (M0CB_WRAP1 and (SRAMDMY or SRM)) interacting (M0CB_LT165 inside     (SRAMDMY or SRM));
M0CB_WRAPLT165_1    = (M0CB_WRAP1 not (SRAMDMY or SRM)) interacting (M0CB_LT165 not_inside (SRAMDMY or SRM));

#ifdef VERTICAL_M0
M0CA_EDGE = angle_edge( M0CA_WRAP1, == 0 );
M0CA_PORJ = external1_error( M0CA_EDGE, <= ISLAND_SPACE_MX1, direction = VERTICAL, extension = NONE, look_thru = ALL, look_thru_count = < 1 ); 
M0CB_EDGE = angle_edge( M0CB_WRAP1, == 0 );
M0CB_PORJ = external1_error( M0CB_EDGE, <= ISLAND_SPACE_MX1, direction = VERTICAL, extension = NONE, look_thru = ALL, look_thru_count = < 1 ); 
#else
M0CA_EDGE = angle_edge( M0CA_WRAP1, == 90 ); 
M0CA_PORJ = external1_error( M0CA_EDGE, <= ISLAND_SPACE_MX1, direction = HORIZONTAL, extension = NONE, look_thru = ALL, look_thru_count = < 1 ); 
M0CB_EDGE = angle_edge( M0CB_WRAP1, == 90 ); 
M0CB_PORJ = external1_error( M0CB_EDGE, <= ISLAND_SPACE_MX1, direction = HORIZONTAL, extension = NONE, look_thru = ALL, look_thru_count = < 1 ); 
#endif


M0CA_MATCH = drc_features_error( primary_layer = M0CA_PORJ, secondary_layers = { "layer2" => M0CA_EDGE }, output_from_layer = M0CA_PORJ, include_touch = EDGE, drc_function = dfm_property_func_w, combine_errors = OPPOSING ); 
M0CA_WRAP2 = error_merge( M0CA_MATCH ); 
M0CA_WRAP = not_interacting( M0CA_WRAP2, M0CB_WRAP1 ) or M0CA_WRAP1; 

M0CA_WRAPLT165_S = (((M0CA_WRAP2 not_interacting M0CB_WRAP1) interacting M0CA_WRAPLT165_SRAM) and (SRAMDMY or SRM)) or M0CA_WRAPLT165_SRAM;
M0CA_WRAPLT165 = (((M0CA_WRAP2 not_interacting M0CB_WRAP1) interacting M0CA_WRAPLT165_1) not (SRAMDMY or SRM)) or M0CA_WRAPLT165_1;

M0CB_MATCH = drc_features_error( primary_layer = M0CB_PORJ, secondary_layers = { "layer2" => M0CB_EDGE }, output_from_layer = M0CB_PORJ, include_touch = EDGE, drc_function = dfm_property_func_w, combine_errors = OPPOSING ); 
M0CB_WRAP2 = error_merge( M0CB_MATCH ); 
M0CB_WRAP = not_interacting( M0CB_WRAP2, M0CA_WRAP1 ) or M0CB_WRAP1; 



M0CB_WRAPLT165_S = (((M0CB_WRAP2 not_interacting M0CA_WRAP1) interacting M0CB_WRAPLT165_SRAM) and (SRAMDMY or SRM)) or M0CB_WRAPLT165_SRAM;
M0CB_WRAPLT165 = (((M0CB_WRAP2 not_interacting M0CA_WRAP1) interacting M0CB_WRAPLT165_1) not (SRAMDMY or SRM)) or M0CB_WRAPLT165_1;

M0_GE160_BOUNDARY = M0_GE160 interacting M0_BOUNDARY_INSIDE;


// DUMMY SPEC : M0_O_DC_E
FSS_M0_WRAPSPEC: list of fill_to_signal_spacing_s = {
    { BEOLBLK_FINAL, min_space = 0 },
    { DM0EXCL_FINAL, min_space = 0 },
    { BEOLBLK_FINAL_NOM0, min_space_x = DMX1_BEOLBLKE, min_space_y = DM0_BEOLBLKR, space_extension_x = DMX1_BEOLBLKE, space_extension_y = DM0_BEOLBLKR },
    { DM0EXCL_FINAL_NOM0, min_space_x = DMX1_DMXEXCLE, min_space_y = DM0_DMXEXCLR, space_extension_x = DMX1_DMXEXCLE, space_extension_y = DM0_DMXEXCLR },
    { INDDMY, min_space = DM_INDDMY },
#ifdef VERTICAL_M0
    { BEOLBLK_FINAL, min_space = 0, min_space_y = CHIP_SHRINK_VALUEX1 }, //for exclusion zone
    { DM0EXCL_FINAL, min_space = 0, min_space_y = CHIP_SHRINK_VALUEX1 }, //for exclusion zone
#else
    { BEOLBLK_FINAL, min_space = 0, min_space_x = CHIP_SHRINK_VALUEX1 }, //for exclusion zone
    { DM0EXCL_FINAL, min_space = 0, min_space_x = CHIP_SHRINK_VALUEX1 }, //for exclusion zone
#endif
//============================================
// DUMMY SPEC : M0_O_DC
    { REGION_WRAPPER_DM0, min_space = 0, context = INTERIOR },
    { CHIP_snps, min_space = 0, context = INTERIOR }, //RD CONFIRM
#ifdef FULL_CHIP
    { CHIP_BOUNDARY, min_space = 0, context = INTERIOR }, //RD CONFIRM
    { CHIP_FILLREGION_X1, min_space = 0, context = INTERIOR },
#else
    { PRBOUNDARY, min_space_x = DM0O_CHIPE, min_space_y = DM0O_CHIPR, context = INTERIOR },
#endif
    { M0FORBIDDEN_CHIP, min_space = 0 },
    { MX1FORBIDDEN_CHIPMH, min_space = 0 },
    { BEOLBLK_FINAL, min_space = 0 },
    { DM0EXCL_FINAL, min_space = 0 },
    { BEOLBLK_FINAL_NOM0, min_space_x = DMX1_BEOLBLKE, min_space_y = DM0_BEOLBLKR, space_extension_x = DMX1_BEOLBLKE, space_extension_y = DM0_BEOLBLKR }, 
    { DM0EXCL_FINAL_NOM0, min_space_x = DMX1_DMXEXCLE, min_space_y = DM0_DMXEXCLR, space_extension_x = DMX1_DMXEXCLE, space_extension_y = DM0_DMXEXCLR },
    { CSR66_3485, min_space_x = DMX1_BEOLBLKE, min_space_y = DM0_BEOLBLKR, space_extension_x = DMX1_BEOLBLKE, space_extension_y = DM0_BEOLBLKR }, 
    { INDDMY, min_space = DM_INDDMY },
    { TCDDMY_M0, min_space = DMX1_TCDDMY_MX },
    { M0_HOLE, min_space = 0 },
    { CM0, min_space = M0_CUT },
    { M0_45, min_space = 0 },
    { ICOVL_SINGLE, min_space = DMX1_ICOVL },
    { SRM, min_space = DMX1_SRM_OUT, min_space_inside = DMX1_SRM_IN, context = EXTERIOR_INTERIOR },
    { SRAMDMY, min_space = DMX1_SRM_OUT, min_space_inside = DMX1_SRM_IN, context = EXTERIOR_INTERIOR },
    { M0_JUMP, min_space = DMX1_O_SRMJUMP },
    { VD2, min_space = DM0_VD2 },
    { ALL_STD_20, min_space = DM0_STD, context = EXTERIOR_INTERIOR },
    { VDR, min_space = DM0_VD2 },
    

    { ALL_STD_20, min_space = DM0O_ALLSTD, context = EXTERIOR_INTERIOR },

#ifdef VERTICAL_M0
    { M0_MAIN, min_space_x = DMX1OR_DC_MXX, min_space_y = DMX1OR_DC_MXY, space_extension_x = DMX1OR_DC_MXX, space_extension_y = DMX1OR_DC_MXY },
#else
    { M0_MAIN, min_space_x = DMX1OR_DC_MXY, min_space_y = DMX1OR_DC_MXX, space_extension_x = DMX1OR_DC_MXY, space_extension_y = DMX1OR_DC_MXX },
#endif


#ifdef VERTICAL_M0
    { M0_LT165, min_space_x = DM0_DC_LEW16, min_space_y = DMX1OR_DC_MXY, space_extension_x = DM0_DC_LEW16, space_extension_y = DMX1OR_DC_MXY },
    { M0_LT285, min_space_x = DMX1OR_DC_MXX, min_space_y = DMX1OR_DC_MXY, space_extension_x = DMX1OR_DC_MXX, space_extension_y = DMX1OR_DC_MXY },
    { M0_LT405, min_space_x = DMX1OR_DC_MXX, min_space_y = DMX1OR_DC_MXY, space_extension_x = DMX1OR_DC_MXX, space_extension_y = DMX1OR_DC_MXY },
    { M0_LT160, min_space_x = DMX1_DC_W405, min_space_y = DMX1OR_DC_MXY, space_extension_x = DMX1_DC_W405, space_extension_y = DMX1OR_DC_MXY },
    { M0_GE160, min_space_x = DMX1_DC_W160, min_space_y = DMX1OR_DC_MXY, space_extension_x = DMX1_DC_W160, space_extension_y = DMX1OR_DC_MXY },
#else
    { M0_LT165, min_space_x = DMX1OR_DC_MXY, min_space_y = DM0_DC_LEW16, space_extension_x = DMX1OR_DC_MXY, space_extension_y = DM0_DC_LEW16 },
    { M0_LT285, min_space_x = DMX1OR_DC_MXY, min_space_y = DMX1OR_DC_MXX, space_extension_x = DMX1OR_DC_MXY, space_extension_y = DMX1OR_DC_MXX },
    { M0_LT405, min_space_x = DMX1OR_DC_MXY, min_space_y = DMX1OR_DC_MXX, space_extension_x = DMX1OR_DC_MXY, space_extension_y = DMX1OR_DC_MXX },
    { M0_LT160, min_space_x = DMX1OR_DC_MXY, min_space_y = DMX1_DC_W405, space_extension_x = DMX1OR_DC_MXY, space_extension_y = DMX1_DC_W405 },
    { M0_GE160, min_space_x = DMX1OR_DC_MXY, min_space_y = DMX1_DC_W160, space_extension_x = DMX1OR_DC_MXY, space_extension_y = DMX1_DC_W160 },
#endif
    { DM0_O, min_space_x = DMX1OR_DMX_O, min_space_y = DMX1OR_DMX_O, space_extension_x = DMX1OR_DMX_O, space_extension_y = DMX1OR_DMX_O },
    { DM0, min_space_x = DMX1OR_DMX, min_space_y = DMX1OR_DMX, space_extension_x = DMX1OR_DMX, space_extension_y = DMX1OR_DMX },
#ifdef VERTICAL_M0
    { M0_HVN_096V, min_space_x = DMX1_MX096V, min_space_y = DMX1OR_SC_MXY, space_extension_x = DMX1_MX096V, space_extension_y = DMX1OR_SC_MXY },
    { M0_HVN_132V, min_space_x = DMX1_MX132V, min_space_y = DMX1OR_SC_MXY, space_extension_x = DMX1_MX132V, space_extension_y = DMX1OR_SC_MXY },
    { M0_HVN_165V, min_space_x = DMX1_MX165V, min_space_y = DMX1OR_SC_MXY, space_extension_x = DMX1_MX165V, space_extension_y = DMX1OR_SC_MXY },
    { M0_HVN_198V, min_space_x = DMX1_MX198V, min_space_y = DMX1OR_SC_MXY, space_extension_x = DMX1_MX198V, space_extension_y = DMX1OR_SC_MXY },
    { M0_HVN_275V, min_space_x = DMX1_MX275V, min_space_y = DMX1OR_275V_MXY, space_extension_x = DMX1_MX275V, space_extension_y = DMX1OR_275V_MXY },
#else
    { M0_HVN_096V, min_space_x = DMX1OR_SC_MXY, min_space_y = DMX1_MX096V, space_extension_x = DMX1OR_SC_MXY, space_extension_y = DMX1_MX096V },
    { M0_HVN_132V, min_space_x = DMX1OR_SC_MXY, min_space_y = DMX1_MX132V, space_extension_x = DMX1OR_SC_MXY, space_extension_y = DMX1_MX132V },
    { M0_HVN_165V, min_space_x = DMX1OR_SC_MXY, min_space_y = DMX1_MX165V, space_extension_x = DMX1OR_SC_MXY, space_extension_y = DMX1_MX165V },
    { M0_HVN_198V, min_space_x = DMX1OR_SC_MXY, min_space_y = DMX1_MX198V, space_extension_x = DMX1OR_SC_MXY, space_extension_y = DMX1_MX198V },
    { M0_HVN_275V, min_space_x = DMX1OR_275V_MXY, min_space_y = DMX1_MX275V, space_extension_x = DMX1OR_275V_MXY, space_extension_y = DMX1_MX275V },
#endif
    { VIAMINUS_HVN_096V, min_space = DMX1_VX096V },
    { VIAMINUS_HVN_132V, min_space = DMX1_VX132V },
    { VIAMINUS_HVN_165V, min_space = DMX1_VX165V },
    { VIAMINUS_HVN_198V, min_space = DMX1_VX198V },
    { VIAMINUS_HVN_275V, min_space = DMX1_VX275V },
    { VIA0_HVN_096V, min_space = DMX1_VX096V },
    { VIA0_HVN_132V, min_space = DMX1_VX132V },
    { VIA0_HVN_165V, min_space = DMX1_VX165V },
    { VIA0_HVN_198V, min_space = DMX1_VX198V },
    { VIA0_HVN_275V, min_space = DMX1_VX275V },

//============================================
// DUMMY SPEC : M0_O_SCA
#ifdef VERTICAL_M0
      { M0_MAIN_CA, min_space_x = DM0OR_SC_MXX, min_space_y = DMX1OR_SC_MXY, space_extension_x = DM0OR_SC_MXX, space_extension_y = DMX1OR_SC_MXY, color_aware_to_fill = ONLY_COLOR_1 },
      { M0_MAIN_CA, min_space = 0 },//for parsing
      { M0CA_LT405, min_space_x = DMX1_SC_W285, min_space_y = DMX1OR_SC_MXY, space_extension_x = DMX1_SC_W285, space_extension_y = DMX1OR_SC_MXY, color_aware_to_fill = ONLY_COLOR_1 },
      { M0CA_LT405, min_space = 0 },//for parsing
      { M0CA_LT160, min_space_x = DMX1_SC_W405, min_space_y = DMX1OR_SC_MXY, space_extension_x = DMX1_SC_W405, space_extension_y = DMX1OR_SC_MXY, color_aware_to_fill = ONLY_COLOR_1 },
      { M0CA_LT160, min_space = 0 },//for parsing
#else
      { M0_MAIN_CA, min_space_x = DMX1OR_SC_MXY, min_space_y = DM0OR_SC_MXX, space_extension_x = DMX1OR_SC_MXY, space_extension_y = DM0OR_SC_MXX, color_aware_to_fill = ONLY_COLOR_1 },
      { M0_MAIN_CA, min_space = 0 },//for parsing
      { M0CA_LT405, min_space_x = DMX1OR_SC_MXY, min_space_y = DMX1_SC_W285, space_extension_x = DMX1OR_SC_MXY, space_extension_y = DMX1_SC_W285, color_aware_to_fill = ONLY_COLOR_1 },
      { M0CA_LT405, min_space = 0 },//for parsing
      { M0CA_LT160, min_space_x = DMX1OR_SC_MXY, min_space_y = DMX1_SC_W405, space_extension_x = DMX1OR_SC_MXY, space_extension_y = DMX1_SC_W405, color_aware_to_fill = ONLY_COLOR_1 },
      { M0CA_LT160, min_space = 0 },//for parsing
#endif
      { M0CA_GE160, min_space = DMX1_SC_W160, color_aware_to_fill = ONLY_COLOR_1 },
      { M0CA_GE160, min_space = 0 },//for parsing
#ifdef VERTICAL_M0
      { M0CA_LE, min_space_y = 0.06, space_extension_x = 0.06, projection = CORNER, color_aware_to_fill = ONLY_COLOR_1 },
#else
      { M0CA_LE, min_space_x = 0.06, space_extension_y = 0.06, projection = CORNER, color_aware_to_fill = ONLY_COLOR_1 },
#endif
      { M0CA_LE, min_space = 0 },//for parsing
//=========================================================
// DUMMY SPEC : M0_O_SCB
#ifdef VERTICAL_M0
      { M0_MAIN_CB, min_space_x = DM0OR_SC_MXX, min_space_y = DMX1OR_SC_MXY, space_extension_x = DM0OR_SC_MXX, space_extension_y = DMX1OR_SC_MXY, color_aware_to_fill = ONLY_COLOR_2 },
      { M0_MAIN_CB, min_space = 0 },//for parsing
      { M0CB_LT405, min_space_x = DMX1_SC_W285, min_space_y = DMX1OR_SC_MXY, space_extension_x = DMX1_SC_W285, space_extension_y = DMX1OR_SC_MXY, color_aware_to_fill = ONLY_COLOR_2 },
      { M0CB_LT405, min_space = 0 },//for parsing
      { M0CB_LT160, min_space_x = DMX1_SC_W405, min_space_y = DMX1OR_SC_MXY, space_extension_x = DMX1_SC_W405, space_extension_y = DMX1OR_SC_MXY, color_aware_to_fill = ONLY_COLOR_2 },
      { M0CB_LT160, min_space = 0 },//for parsing
#else
      { M0_MAIN_CB, min_space_x = DMX1OR_SC_MXY, min_space_y = DM0OR_SC_MXX, space_extension_x = DMX1OR_SC_MXY, space_extension_y = DM0OR_SC_MXX, color_aware_to_fill = ONLY_COLOR_2 },
      { M0_MAIN_CB, min_space = 0 },//for parsing
      { M0CB_LT405, min_space_x = DMX1OR_SC_MXY, min_space_y = DMX1_SC_W285, space_extension_x = DMX1OR_SC_MXY, space_extension_y = DMX1_SC_W285, color_aware_to_fill = ONLY_COLOR_2 },
      { M0CB_LT405, min_space = 0 },//for parsing
      { M0CB_LT160, min_space_x = DMX1OR_SC_MXY, min_space_y = DMX1_SC_W405, space_extension_x = DMX1OR_SC_MXY, space_extension_y = DMX1_SC_W405, color_aware_to_fill = ONLY_COLOR_2 },
      { M0CB_LT160, min_space = 0 },//for parsing
#endif
      { M0CB_GE160, min_space = DMX1_SC_W160, color_aware_to_fill = ONLY_COLOR_2 },
      { M0CB_GE160, min_space = 0 },//for parsing
#ifdef VERTICAL_M0
      { M0CB_LE, min_space_y = 0.06, space_extension_x = 0.06, projection = CORNER, color_aware_to_fill = ONLY_COLOR_2 },
#else
      { M0CB_LE, min_space_x = 0.06, space_extension_y = 0.06, projection = CORNER, color_aware_to_fill = ONLY_COLOR_2 },
#endif
      { M0CB_LE, min_space = 0 },//for parsing
//=======================================================
// DUMMY SPEC : WIDTH_DC_M0CA_O
    { M0CA_WRAP, width_based_spacing = {
			{>= 0.0, 	{>= DMX1OR_DC_MXX} },
			{>= 0.012, 	{>= DMX1OR_DC_MXX} },
			{>= 0.0405, 	{>= DMX1_DC_W405} },
			{>= 0.16, 	{>= DMX1_DC_W160} },
		}, color_aware_to_fill = ALL },
    { M0CA_WRAPLT165_S, width_based_spacing = {
			{>= 0.0, 	{>= DM0_DC_LEW16} },
			{>= 0.012, 	{>= DM0_DC_LEW16} },
		}, color_aware_to_fill = ALL },
    { M0CA_WRAPLT165, width_based_spacing = {
			{>= 0.0, 	{>= DM0_DC_LEW16} },
			{>= 0.012, 	{>= DM0_DC_LEW16} },
		}, color_aware_to_fill = ALL },
    { CM0, min_space = M0_CUT },
#ifdef VERTICAL_M0
    { M0_HVN_096V, min_space_x = DMX1_MX096V, min_space_y = DMX1OR_SC_MXY, space_extension_x = DMX1_MX096V, space_extension_y = DMX1OR_SC_MXY },
    { M0_HVN_132V, min_space_x = DMX1_MX132V, min_space_y = DMX1OR_SC_MXY, space_extension_x = DMX1_MX132V, space_extension_y = DMX1OR_SC_MXY },
    { M0_HVN_165V, min_space_x = DMX1_MX165V, min_space_y = DMX1OR_SC_MXY, space_extension_x = DMX1_MX165V, space_extension_y = DMX1OR_SC_MXY },
    { M0_HVN_198V, min_space_x = DMX1_MX198V, min_space_y = DMX1OR_SC_MXY, space_extension_x = DMX1_MX198V, space_extension_y = DMX1OR_SC_MXY },
    { M0_HVN_275V, min_space_x = DMX1_MX275V, min_space_y = DMX1OR_275V_MXY, space_extension_x = DMX1_MX275V, space_extension_y = DMX1OR_275V_MXY },
#else
    { M0_HVN_096V, min_space_x = DMX1OR_SC_MXY, min_space_y = DMX1_MX096V, space_extension_x = DMX1OR_SC_MXY, space_extension_y = DMX1_MX096V },
    { M0_HVN_132V, min_space_x = DMX1OR_SC_MXY, min_space_y = DMX1_MX132V, space_extension_x = DMX1OR_SC_MXY, space_extension_y = DMX1_MX132V },
    { M0_HVN_165V, min_space_x = DMX1OR_SC_MXY, min_space_y = DMX1_MX165V, space_extension_x = DMX1OR_SC_MXY, space_extension_y = DMX1_MX165V },
    { M0_HVN_198V, min_space_x = DMX1OR_SC_MXY, min_space_y = DMX1_MX198V, space_extension_x = DMX1OR_SC_MXY, space_extension_y = DMX1_MX198V },
    { M0_HVN_275V, min_space_x = DMX1OR_275V_MXY, min_space_y = DMX1_MX275V, space_extension_x = DMX1OR_275V_MXY, space_extension_y = DMX1_MX275V },
#endif
    { VIAMINUS_HVN_096V, min_space = DMX1_VX096V },
    { VIAMINUS_HVN_132V, min_space = DMX1_VX132V },
    { VIAMINUS_HVN_165V, min_space = DMX1_VX165V },
    { VIAMINUS_HVN_198V, min_space = DMX1_VX198V },
    { VIAMINUS_HVN_275V, min_space = DMX1_VX275V },
    { VIA0_HVN_096V, min_space = DMX1_VX096V },
    { VIA0_HVN_132V, min_space = DMX1_VX132V },
    { VIA0_HVN_165V, min_space = DMX1_VX165V },
    { VIA0_HVN_198V, min_space = DMX1_VX198V },
    { VIA0_HVN_275V, min_space = DMX1_VX275V },

#ifdef VERTICAL_M0
    { M0_GE160_BOUNDARY, min_space_x = 0.001, min_space_y = DMX1OR_SC_MXY, space_extension_x = 0.001, space_extension_y = DMX1OR_SC_MXY },
#else
    { M0_GE160_BOUNDARY, min_space_x = DMX1OR_SC_MXY, min_space_y = 0.001, space_extension_x = DMX1OR_SC_MXY, space_extension_y = 0.001 },
#endif
    { BEOLBLK_FINAL, min_space = 0 },
    { DM0EXCL_FINAL, min_space = 0 },
    { BEOLBLK_FINAL_NOM0, min_space_x = DMX1_BEOLBLKE, min_space_y = DM0_BEOLBLKR, space_extension_x = DMX1_BEOLBLKE, space_extension_y = DM0_BEOLBLKR },
    { DM0EXCL_FINAL_NOM0, min_space_x = DMX1_DMXEXCLE, min_space_y = DM0_DMXEXCLR, space_extension_x = DMX1_DMXEXCLE, space_extension_y = DM0_DMXEXCLR },
    { M0_BOUNDARY_CLOSE, min_space = DM0O_CHIPR },
//=======================================================
// DUMMY SPEC : WIDTH_DC_M0CB_O
    { M0CB_WRAP, width_based_spacing = {
			{>= 0.0, 	{>= DMX1OR_DC_MXX} },
			{>= 0.012, 	{>= DMX1OR_DC_MXX} },
			{>= 0.0405, 	{>= DMX1_DC_W405} },
			{>= 0.16, 	{>= DMX1_DC_W160} },
		}, color_aware_to_fill = ALL },
    { M0CB_WRAPLT165_S, width_based_spacing = {
			{>= 0.0, 	{>= DM0_DC_LEW16} },
			{>= 0.012, 	{>= DM0_DC_LEW16} },
		}, color_aware_to_fill = ALL },
    { M0CB_WRAPLT165, width_based_spacing = {
			{>= 0.0, 	{>= DM0_DC_LEW16} },
			{>= 0.012, 	{>= DM0_DC_LEW16} },
		}, color_aware_to_fill = ALL },

//for 3pty chk
    { CM0, min_space = M0_CUT },
#ifdef VERTICAL_M0
    { M0_HVN_096V, min_space_x = DMX1_MX096V, min_space_y = DMX1OR_SC_MXY, space_extension_x = DMX1_MX096V, space_extension_y = DMX1OR_SC_MXY },
    { M0_HVN_132V, min_space_x = DMX1_MX132V, min_space_y = DMX1OR_SC_MXY, space_extension_x = DMX1_MX132V, space_extension_y = DMX1OR_SC_MXY },
    { M0_HVN_165V, min_space_x = DMX1_MX165V, min_space_y = DMX1OR_SC_MXY, space_extension_x = DMX1_MX165V, space_extension_y = DMX1OR_SC_MXY },
    { M0_HVN_198V, min_space_x = DMX1_MX198V, min_space_y = DMX1OR_SC_MXY, space_extension_x = DMX1_MX198V, space_extension_y = DMX1OR_SC_MXY },
    { M0_HVN_275V, min_space_x = DMX1_MX275V, min_space_y = DMX1OR_275V_MXY, space_extension_x = DMX1_MX275V, space_extension_y = DMX1OR_275V_MXY },
#else
    { M0_HVN_096V, min_space_x = DMX1OR_SC_MXY, min_space_y = DMX1_MX096V, space_extension_x = DMX1OR_SC_MXY, space_extension_y = DMX1_MX096V },
    { M0_HVN_132V, min_space_x = DMX1OR_SC_MXY, min_space_y = DMX1_MX132V, space_extension_x = DMX1OR_SC_MXY, space_extension_y = DMX1_MX132V },
    { M0_HVN_165V, min_space_x = DMX1OR_SC_MXY, min_space_y = DMX1_MX165V, space_extension_x = DMX1OR_SC_MXY, space_extension_y = DMX1_MX165V },
    { M0_HVN_198V, min_space_x = DMX1OR_SC_MXY, min_space_y = DMX1_MX198V, space_extension_x = DMX1OR_SC_MXY, space_extension_y = DMX1_MX198V },
    { M0_HVN_275V, min_space_x = DMX1OR_275V_MXY, min_space_y = DMX1_MX275V, space_extension_x = DMX1OR_275V_MXY, space_extension_y = DMX1_MX275V },
#endif
    { VIAMINUS_HVN_096V, min_space = DMX1_VX096V },
    { VIAMINUS_HVN_132V, min_space = DMX1_VX132V },
    { VIAMINUS_HVN_165V, min_space = DMX1_VX165V },
    { VIAMINUS_HVN_198V, min_space = DMX1_VX198V },
    { VIAMINUS_HVN_275V, min_space = DMX1_VX275V },
    { VIA0_HVN_096V, min_space = DMX1_VX096V },
    { VIA0_HVN_132V, min_space = DMX1_VX132V },
    { VIA0_HVN_165V, min_space = DMX1_VX165V },
    { VIA0_HVN_198V, min_space = DMX1_VX198V },
    { VIA0_HVN_275V, min_space = DMX1_VX275V },

#ifdef VERTICAL_M0
    { M0_GE160_BOUNDARY, min_space_x = 0.001, min_space_y = DMX1OR_SC_MXY, space_extension_x = 0.001, space_extension_y = DMX1OR_SC_MXY },
#else
    { M0_GE160_BOUNDARY, min_space_x = DMX1OR_SC_MXY, min_space_y = 0.001, space_extension_x = DMX1OR_SC_MXY, space_extension_y = 0.001 },
#endif
    { BEOLBLK_FINAL, min_space = 0 },
    { DM0EXCL_FINAL, min_space = 0 },
    { BEOLBLK_FINAL_NOM0, min_space_x = DMX1_BEOLBLKE, min_space_y = DM0_BEOLBLKR, space_extension_x = DMX1_BEOLBLKE, space_extension_y = DM0_BEOLBLKR },
    { DM0EXCL_FINAL_NOM0, min_space_x = DMX1_DMXEXCLE, min_space_y = DM0_DMXEXCLR, space_extension_x = DMX1_DMXEXCLE, space_extension_y = DM0_DMXEXCLR },
    { M0_BOUNDARY_CLOSE, min_space = DM0O_CHIPR },
//end for 3pty chk


//=======================================================
// DUMMY SPEC : WIDTH_SC_M0CA_O
    { M0CA_WRAP, width_based_spacing = {
			{>= 0.0, 	{>= DM0OR_SC_MXX} },
			{>= 0.012, 	{>= DM0OR_SC_MXX} },
			{>= 0.0285, 	{>= DMX1_SC_W285} },
			{>= 0.0405, 	{>= DMX1_SC_W405} },
			{>= 0.16, 	{>= DMX1_SC_W160} },
		}, color_aware_to_fill = ONLY_COLOR_1 },
    { M0CA_WRAPLT165_S, width_based_spacing = {
			{>= 0.0, 	{>= DM0_SC_LEW16} },
			{>= 0.012, 	{>= DM0_SC_LEW16} },
		}, color_aware_to_fill = ONLY_COLOR_1 },
    { M0CA_WRAPLT165, width_based_spacing = {
			{>= 0.0, 	{>= DM0_SC_LEW16} },
			{>= 0.012, 	{>= DM0_SC_LEW16} },
		}, color_aware_to_fill = ONLY_COLOR_1 },
    { CM0, min_space = M0_CUT },
#ifdef VERTICAL_M0
    { M0_HVN_096V, min_space_x = DMX1_MX096V, min_space_y = DMX1OR_SC_MXY, space_extension_x = DMX1_MX096V, space_extension_y = DMX1OR_SC_MXY },
    { M0_HVN_132V, min_space_x = DMX1_MX132V, min_space_y = DMX1OR_SC_MXY, space_extension_x = DMX1_MX132V, space_extension_y = DMX1OR_SC_MXY },
    { M0_HVN_165V, min_space_x = DMX1_MX165V, min_space_y = DMX1OR_SC_MXY, space_extension_x = DMX1_MX165V, space_extension_y = DMX1OR_SC_MXY },
    { M0_HVN_198V, min_space_x = DMX1_MX198V, min_space_y = DMX1OR_SC_MXY, space_extension_x = DMX1_MX198V, space_extension_y = DMX1OR_SC_MXY },
    { M0_HVN_275V, min_space_x = DMX1_MX275V, min_space_y = DMX1OR_275V_MXY, space_extension_x = DMX1_MX275V, space_extension_y = DMX1OR_275V_MXY },
#else
    { M0_HVN_096V, min_space_x = DMX1OR_SC_MXY, min_space_y = DMX1_MX096V, space_extension_x = DMX1OR_SC_MXY, space_extension_y = DMX1_MX096V },
    { M0_HVN_132V, min_space_x = DMX1OR_SC_MXY, min_space_y = DMX1_MX132V, space_extension_x = DMX1OR_SC_MXY, space_extension_y = DMX1_MX132V },
    { M0_HVN_165V, min_space_x = DMX1OR_SC_MXY, min_space_y = DMX1_MX165V, space_extension_x = DMX1OR_SC_MXY, space_extension_y = DMX1_MX165V },
    { M0_HVN_198V, min_space_x = DMX1OR_SC_MXY, min_space_y = DMX1_MX198V, space_extension_x = DMX1OR_SC_MXY, space_extension_y = DMX1_MX198V },
    { M0_HVN_275V, min_space_x = DMX1OR_275V_MXY, min_space_y = DMX1_MX275V, space_extension_x = DMX1OR_275V_MXY, space_extension_y = DMX1_MX275V },
#endif
    { VIAMINUS_HVN_096V, min_space = DMX1_VX096V },
    { VIAMINUS_HVN_132V, min_space = DMX1_VX132V },
    { VIAMINUS_HVN_165V, min_space = DMX1_VX165V },
    { VIAMINUS_HVN_198V, min_space = DMX1_VX198V },
    { VIAMINUS_HVN_275V, min_space = DMX1_VX275V },
    { VIA0_HVN_096V, min_space = DMX1_VX096V },
    { VIA0_HVN_132V, min_space = DMX1_VX132V },
    { VIA0_HVN_165V, min_space = DMX1_VX165V },
    { VIA0_HVN_198V, min_space = DMX1_VX198V },
    { VIA0_HVN_275V, min_space = DMX1_VX275V },

#ifdef VERTICAL_M0
    { M0_GE160_BOUNDARY, min_space_x = 0.001, min_space_y = DMX1OR_SC_MXY, space_extension_x = 0.001, space_extension_y = DMX1OR_SC_MXY },
#else
    { M0_GE160_BOUNDARY, min_space_x = DMX1OR_SC_MXY, min_space_y = 0.001, space_extension_x = DMX1OR_SC_MXY, space_extension_y = 0.001 },
#endif
    { BEOLBLK_FINAL, min_space = 0 },
    { DM0EXCL_FINAL, min_space = 0 },
    { BEOLBLK_FINAL_NOM0, min_space_x = DMX1_BEOLBLKE, min_space_y = DM0_BEOLBLKR, space_extension_x = DMX1_BEOLBLKE, space_extension_y = DM0_BEOLBLKR },
    { DM0EXCL_FINAL_NOM0, min_space_x = DMX1_DMXEXCLE, min_space_y = DM0_DMXEXCLR, space_extension_x = DMX1_DMXEXCLE, space_extension_y = DM0_DMXEXCLR },

//=======================================================

// DUMMY SPEC : WIDTH_SC_M0CB_O
    { M0CB_WRAP, width_based_spacing = {
			{>= 0.0, 	{>= DM0OR_SC_MXX} },
			{>= 0.012, 	{>= DM0OR_SC_MXX} },
			{>= 0.0285, 	{>= DMX1_SC_W285} },
			{>= 0.0405, 	{>= DMX1_SC_W405} },
			{>= 0.16, 	{>= DMX1_SC_W160} },
		}, color_aware_to_fill = ONLY_COLOR_2 },
    { M0CB_WRAPLT165_S, width_based_spacing = {
			{>= 0.0, 	{>= DM0_SC_LEW16} },
			{>= 0.012, 	{>= DM0_SC_LEW16} },
		}, color_aware_to_fill = ONLY_COLOR_2 },
    { M0CB_WRAPLT165, width_based_spacing = {
			{>= 0.0, 	{>= DM0_SC_LEW16} },
			{>= 0.012, 	{>= DM0_SC_LEW16} },
		}, color_aware_to_fill = ONLY_COLOR_2 },
    { CM0, min_space = M0_CUT },
#ifdef VERTICAL_M0
    { M0_HVN_096V, min_space_x = DMX1_MX096V, min_space_y = DMX1OR_SC_MXY, space_extension_x = DMX1_MX096V, space_extension_y = DMX1OR_SC_MXY },
    { M0_HVN_132V, min_space_x = DMX1_MX132V, min_space_y = DMX1OR_SC_MXY, space_extension_x = DMX1_MX132V, space_extension_y = DMX1OR_SC_MXY },
    { M0_HVN_165V, min_space_x = DMX1_MX165V, min_space_y = DMX1OR_SC_MXY, space_extension_x = DMX1_MX165V, space_extension_y = DMX1OR_SC_MXY },
    { M0_HVN_198V, min_space_x = DMX1_MX198V, min_space_y = DMX1OR_SC_MXY, space_extension_x = DMX1_MX198V, space_extension_y = DMX1OR_SC_MXY },
    { M0_HVN_275V, min_space_x = DMX1_MX275V, min_space_y = DMX1OR_275V_MXY, space_extension_x = DMX1_MX275V, space_extension_y = DMX1OR_275V_MXY },
#else
    { M0_HVN_096V, min_space_x = DMX1OR_SC_MXY, min_space_y = DMX1_MX096V, space_extension_x = DMX1OR_SC_MXY, space_extension_y = DMX1_MX096V },
    { M0_HVN_132V, min_space_x = DMX1OR_SC_MXY, min_space_y = DMX1_MX132V, space_extension_x = DMX1OR_SC_MXY, space_extension_y = DMX1_MX132V },
    { M0_HVN_165V, min_space_x = DMX1OR_SC_MXY, min_space_y = DMX1_MX165V, space_extension_x = DMX1OR_SC_MXY, space_extension_y = DMX1_MX165V },
    { M0_HVN_198V, min_space_x = DMX1OR_SC_MXY, min_space_y = DMX1_MX198V, space_extension_x = DMX1OR_SC_MXY, space_extension_y = DMX1_MX198V },
    { M0_HVN_275V, min_space_x = DMX1OR_275V_MXY, min_space_y = DMX1_MX275V, space_extension_x = DMX1OR_275V_MXY, space_extension_y = DMX1_MX275V },
#endif
    { VIAMINUS_HVN_096V, min_space = DMX1_VX096V },
    { VIAMINUS_HVN_132V, min_space = DMX1_VX132V },
    { VIAMINUS_HVN_165V, min_space = DMX1_VX165V },
    { VIAMINUS_HVN_198V, min_space = DMX1_VX198V },
    { VIAMINUS_HVN_275V, min_space = DMX1_VX275V },
    { VIA0_HVN_096V, min_space = DMX1_VX096V },
    { VIA0_HVN_132V, min_space = DMX1_VX132V },
    { VIA0_HVN_165V, min_space = DMX1_VX165V },
    { VIA0_HVN_198V, min_space = DMX1_VX198V },
    { VIA0_HVN_275V, min_space = DMX1_VX275V },

#ifdef VERTICAL_M0
    { M0_GE160_BOUNDARY, min_space_x = 0.001, min_space_y = DMX1OR_SC_MXY, space_extension_x = 0.001, space_extension_y = DMX1OR_SC_MXY },
#else
    { M0_GE160_BOUNDARY, min_space_x = DMX1OR_SC_MXY, min_space_y = 0.001, space_extension_x = DMX1OR_SC_MXY, space_extension_y = 0.001 },
#endif
    { BEOLBLK_FINAL, min_space = 0 },
    { DM0EXCL_FINAL, min_space = 0 },
    { BEOLBLK_FINAL_NOM0, min_space_x = DMX1_BEOLBLKE, min_space_y = DM0_BEOLBLKR, space_extension_x = DMX1_BEOLBLKE, space_extension_y = DM0_BEOLBLKR },
    { DM0EXCL_FINAL_NOM0, min_space_x = DMX1_DMXEXCLE, min_space_y = DM0_DMXEXCLR, space_extension_x = DMX1_DMXEXCLE, space_extension_y = DM0_DMXEXCLR },

}; //end of FSS_M0_WRAPSPEC
//===================================================
// DUMMY SPEC : M0_guideSpec
//===================================================
// DUMMY SPEC : M0_wrapSpec
PATTERN_M0_WRAPSPEC = get_single_linear_pattern(
    FSS_M0_WRAPSPEC,
    {
        { M0CA_WRAP, COLOR_1 },
        { M0CA_WRAPLT165_S, COLOR_1 },
        { M0CA_WRAPLT165, COLOR_1 },
        { CM0, COLOR_1 },
        { M0CB_WRAP, COLOR_2 },
        { M0CB_WRAPLT165_S, COLOR_2 },
        { M0CB_WRAPLT165, COLOR_2 },
        { DM0EXCL_FINAL, COLOR_1 },
        { BEOLBLK_FINAL, COLOR_1 },
        { M0_GE160_BOUNDARY, COLOR_1 }, 
        { M0_BOUNDARY_CLOSE, COLOR_1 },
#ifdef VERTICAL_M0
    { M0_HVN_096V, COLOR_2 },
    { M0_HVN_132V, COLOR_2 },
    { M0_HVN_165V, COLOR_2 },
    { M0_HVN_198V, COLOR_2 },
    { M0_HVN_275V, COLOR_2 },   
#else
    { M0_HVN_096V, COLOR_2 },
    { M0_HVN_132V, COLOR_2 },
    { M0_HVN_165V, COLOR_2 },
    { M0_HVN_198V, COLOR_2 },
    { M0_HVN_275V, COLOR_2 },  
#endif
    },
    0.125,
    "M0_WRAPSPEC",
#ifdef VERTICAL_M0
	VERTICAL, "M0VWRAP", DMX1OR_W, DMX1OR_W_MAX, DMX1OR_L, DMX1OR_L_MAX,
	DM0OR_SX_SC, DMX1OR_SY_SC, DMX1OR_SX_DC, DMX1OR_SY_DC, //for step checking
#else
	HORIZONTAL, "M0HWRAP", DMX1OR_W, DMX1OR_W_MAX, DMX1OR_L, DMX1OR_L_MAX,
	DMX1OR_SY_SC, DM0OR_SX_SC, DMX1OR_SY_DC, DMX1OR_SX_DC, //for step checking
#endif				
	15, SHRINK
);

PATTERN_M0_WRAPSPEC.polygon_fill.signal_linear.valid_heights = {== 0.02, == 0.024, == 0.028 };
        
PATTERN_M0_WRAPSPEC.polygon_fill.pattern_spec.pattern_spacing = {
    corner_extension_x = DMX1OR_SY_SC,
    corner_extension_y = DMX1OR_SY_SC,
    extension = INTERSECTION,
};

M0_WRAPSPEC = unified_fill(
	fill_patterns = { PATTERN_M0_WRAPSPEC },
	fill_boundary = {
	    layer = CHIP_snps,
        type = LAYER,
	},
    boundary = ALIGN,
	grid = vGRID
);


//=========================================================

WRAPPER_DM0_O_A_L =  M0_WRAPSPEC["M0_WRAPSPEC"][1];
WRAPPER_DM0_O_B_L =  M0_WRAPSPEC["M0_WRAPSPEC"][2];
WRAPPER_DM0_O_A_C =  M0_WRAPSPEC["M0_WRAPSPEC"][1];
WRAPPER_DM0_O_B_C =  M0_WRAPSPEC["M0_WRAPSPEC"][2];
WRAPPER_DM0_O_L   =  WRAPPER_DM0_O_A_L or WRAPPER_DM0_O_B_L;
#endif

#ifdef FILL_DM1
M1_MAIN_EDGE_END = M1_MAIN;
 
#ifdef VERTICAL_M1
CHIP_SHRINK_M1 = shrink( CHIP_snps, north = CHIP_SHRINK_VALUEX1, south = CHIP_SHRINK_VALUEX1 );
SRM_FORBIDDEN_M1  = edge_size( angle_edge(SRM or SRAMDMY, == 0), outside = 0.4 );
#ifdef FULL_CHIP
M1_BOUNDARY_CLOSE  = edge_size( angle_edge(CHIP_BOUNDARY, == 90), outside = 0.014 );
M1_BOUNDARY_INSIDE = edge_size( angle_edge(CHIP_BOUNDARY, == 90), inside = CHIP_SHRINK_VALUEY1 );
#else
M1_BOUNDARY_CLOSE_PRE1 = edge_size( angle_edge( PRBOUNDARY, == 90 ), outside = 0.014 ); 
M1_BOUNDARY_CLOSE_PRE2 = shrink( M1_BOUNDARY_CLOSE_PRE1, north = 1, south = 1 ); 
M1_BOUNDARY_CLOSE_PRE3 = M1_BOUNDARY_CLOSE_PRE1 not M1_BOUNDARY_CLOSE_PRE2; 
M1_BOUNDARY_CLOSE_PRE4 = shrink( M1_BOUNDARY_CLOSE_PRE2, north = 0.1, south = 0.1 ); 
M1_BOUNDARY_CLOSE = M1_BOUNDARY_CLOSE_PRE3 or M1_BOUNDARY_CLOSE_PRE4; 
M1_BOUNDARY_INSIDE = edge_size( angle_edge( PRBOUNDARY, == 90 ), inside = CHIP_SHRINK_VALUEY1 ); 
#endif

#else
CHIP_SHRINK_M1 = shrink( CHIP_snps, east = CHIP_SHRINK_VALUEX1, west = CHIP_SHRINK_VALUEX1 );
SRM_FORBIDDEN_M1  = edge_size( angle_edge( SRM or SRAMDMY, == 90 ), outside = 0.4 );
#ifdef FULL_CHIP
M1_BOUNDARY_CLOSE  = edge_size( angle_edge(CHIP_BOUNDARY, == 0), outside = 0.014 );
M1_BOUNDARY_INSIDE = edge_size( angle_edge(CHIP_BOUNDARY, == 0), inside = CHIP_SHRINK_VALUEY1 );
#else
M1_BOUNDARY_CLOSE_PRE1  = edge_size(angle_edge( PRBOUNDARY, == 0), outside = 0.014 );
M1_BOUNDARY_CLOSE_PRE2  = shrink( M1_BOUNDARY_CLOSE_PRE1, west = 1, east = 1 );
M1_BOUNDARY_CLOSE_PRE3  = M1_BOUNDARY_CLOSE_PRE1 not M1_BOUNDARY_CLOSE_PRE2;
M1_BOUNDARY_CLOSE_PRE4  = shrink( M1_BOUNDARY_CLOSE_PRE2, west = 0.1, east = 0.1 );
M1_BOUNDARY_CLOSE  = or_list( { M1_BOUNDARY_CLOSE_PRE3, M1_BOUNDARY_CLOSE_PRE4 } );
M1_BOUNDARY_INSIDE = edge_size( angle_edge( PRBOUNDARY, == 0), inside = CHIP_SHRINK_VALUEY1 );
#endif

#endif

#ifdef FULL_CHIP
REGION_WRAPPER_DM1 = (CHIP_SHRINK_M1 not SRM_FORBIDDEN_M1) and (or_list( { (size( M1_MAIN, clip_acute = TRUNCATE, distance = WRAPPER_RANGEX1 )), (CHIP_snps not (size( CHIP_snps, clip_acute = TRUNCATE, distance = - WRAPPER_RANGEX1 ))), (size( (BEOLBLK_FINAL or DM1EXCL_FINAL), clip_acute = TRUNCATE, distance = WRAPPER_RANGEX1 )), M1_BOUNDARY_INSIDE } )); 
#else
REGION_WRAPPER_DM1 = ((CHIP_SHRINK_M1 not SRM_FORBIDDEN_M1) and (or_list( { (size( M1_MAIN, clip_acute = TRUNCATE, distance = WRAPPER_RANGEX1 )), (CHIP_snps not (size( CHIP_snps, clip_acute = TRUNCATE, distance = - WRAPPER_RANGEX1 ))), (size( (BEOLBLK_FINAL or DM1EXCL_FINAL), clip_acute = TRUNCATE, distance = WRAPPER_RANGEX1 )), M1_BOUNDARY_INSIDE } ))) or ((CHIP_snps not SRM_FORBIDDEN_M1) and M1_BOUNDARY_INSIDE); 
#endif

#ifdef FULL_CHIP
M1_BOUNDARY_CLOSE_tmp = M1_BOUNDARY_CLOSE coincident_edge REGION_WRAPPER_DM1;
M1_BOUNDARY_CLOSE = edge_size(M1_BOUNDARY_CLOSE_tmp, inside = 0.014);
#endif


WIDE_M1      = M1_GE160;
M1_WRAP1 = M1_MAIN not or_list( { WIDE_M1, DM1EXCL_FINAL_NOM1, BEOLBLK_FINAL_NOM1 } ); 

#ifdef VERTICAL_M1
M1_EDGE = angle_edge( M1_WRAP1, == 0 );
M1_PORJ = external1_error( M1_EDGE, <= ISLAND_SPACE_MX1, direction = VERTICAL, extension = NONE, look_thru = ALL, look_thru_count = < 1 ); 
#else
M1_EDGE = angle_edge( M1_WRAP1, == 90 ); 
M1_PORJ = external1_error( M1_EDGE, <= ISLAND_SPACE_MX1, direction = HORIZONTAL, extension = NONE, look_thru = ALL, look_thru_count = < 1 ); 
#endif


M1_MATCH = drc_features_error( primary_layer = M1_PORJ, secondary_layers = { "layer2" => M1_EDGE }, output_from_layer = M1_PORJ, include_touch = EDGE, drc_function = dfm_property_func_w, combine_errors = OPPOSING ); 
M1_WRAP2 = error_merge( M1_MATCH ); 
M1_WRAP =  M1_WRAP2 or M1_WRAP1; 


M1_GE160_BOUNDARY = M1_GE160 interacting M1_BOUNDARY_INSIDE;


// DUMMY SPEC : M1_O_SC_E
FSS_M1_WRAPSPEC: list of fill_to_signal_spacing_s = {
    { BEOLBLK_FINAL, min_space = 0 },
    { DM1EXCL_FINAL, min_space = 0 },
    { BEOLBLK_FINAL_NOM1, min_space_x = DMX1_BEOLBLKR, min_space_y = DMX1_BEOLBLKE, space_extension_x = DMX1_BEOLBLKR, space_extension_y = DMX1_BEOLBLKE }, 
    { DM1EXCL_FINAL_NOM1, min_space_x = DMX1_DMXEXCLR, min_space_y = DMX1_DMXEXCLE, space_extension_x = DMX1_DMXEXCLR, space_extension_y = DMX1_DMXEXCLE }, 
    { INDDMY, min_space = DM_INDDMY },
#ifdef VERTICAL_M1
    { BEOLBLK_FINAL, min_space = 0, min_space_y = CHIP_SHRINK_VALUEX1 }, //for exclusion zone
    { DM1EXCL_FINAL, min_space = 0, min_space_y = CHIP_SHRINK_VALUEX1 }, //for exclusion zone
#else
    { BEOLBLK_FINAL, min_space = 0, min_space_x = CHIP_SHRINK_VALUEX1 }, //for exclusion zone
    { DM1EXCL_FINAL, min_space = 0, min_space_x = CHIP_SHRINK_VALUEX1 }, //for exclusion zone
#endif
//============================================
// DUMMY SPEC : M1_O_SC
    { REGION_WRAPPER_DM1, min_space = 0, context = INTERIOR },
    { CHIP_snps, min_space = 0, context = INTERIOR }, //RD CONFIRM
#ifdef FULL_CHIP
    { CHIP_BOUNDARY, min_space = 0, context = INTERIOR }, //RD CONFIRM
    { CHIP_FILLREGION_X1, min_space = 0, context = INTERIOR },
#else
    { PRBOUNDARY, min_space_x = DMX1O_CHIPR, min_space_y = DMX1O_CHIPE, context = INTERIOR }, 
#endif
    { MX1FORBIDDEN_CHIPMV, min_space = 0 },
    { BEOLBLK_FINAL, min_space = 0 },
    { DM1EXCL_FINAL, min_space = 0 },
    { BEOLBLK_FINAL_NOM1, min_space_x = DMX1_BEOLBLKR, min_space_y = DMX1_BEOLBLKE, space_extension_x = DMX1_BEOLBLKR, space_extension_y = DMX1_BEOLBLKE }, 
    { DM1EXCL_FINAL_NOM1, min_space_x = DMX1_DMXEXCLR, min_space_y = DMX1_DMXEXCLE, space_extension_x = DMX1_DMXEXCLR, space_extension_y = DMX1_DMXEXCLE }, 
    { CSR66_3485, min_space_x = DMX1_DMXEXCLR, min_space_y = DMX1_DMXEXCLE, space_extension_x = DMX1_DMXEXCLR, space_extension_y = DMX1_DMXEXCLE },
    { INDDMY, min_space = DM_INDDMY },
    { TCDDMY_M1, min_space = DMX1_TCDDMY_MX },
    { M1_HOLE, min_space = 0 },
    { M1_45, min_space = 0 },
    { ICOVL_SINGLE, min_space = DMX1_ICOVL },
    { SRM, min_space = DMX1_SRM_OUT, min_space_inside = DMX1_SRM_IN, context = EXTERIOR_INTERIOR },
    { SRAMDMY, min_space = DMX1_SRM_OUT, min_space_inside = DMX1_SRM_IN, context = EXTERIOR_INTERIOR },
    { M1_JUMP, min_space = DMX1_O_SRMJUMP },

#ifdef VERTICAL_M1
    { M1_MAIN, min_space_x = DMX1OR_SC_MXX_P48, min_space_y = DMX1OR_SC_MXY_P48, space_extension_x = DMX1OR_SC_MXX_P48, space_extension_y = DMX1OR_SC_MXY_P48 },
#else
    { M1_MAIN, min_space_x = DMX1OR_SC_MXY_P48, min_space_y = DMX1OR_SC_MXX_P48, space_extension_x = DMX1OR_SC_MXY_P48, space_extension_y = DMX1OR_SC_MXX_P48 },
#endif


#ifdef VERTICAL_M1
    { M1_LT285, min_space_x = DMX1OR_SC_MXX_P48, min_space_y = DMX1OR_SC_MXY, space_extension_x = DMX1OR_SC_MXX_P48, space_extension_y = DMX1OR_SC_MXY },
    { M1_LT405, min_space_x = DMX1_SC_W285, min_space_y = DMX1OR_SC_MXY, space_extension_x = DMX1_SC_W285, space_extension_y = DMX1OR_SC_MXY },
    { M1_LT160, min_space_x = DMX1_SC_W405, min_space_y = DMX1OR_SC_MXY, space_extension_x = DMX1_SC_W405, space_extension_y = DMX1OR_SC_MXY },
    { M1_GE160, min_space_x = DMX1_SC_W160, min_space_y = DMX1OR_SC_MXY, space_extension_x = DMX1_SC_W160, space_extension_y = DMX1OR_SC_MXY },
#else
    { M1_LT285, min_space_x = DMX1OR_SC_MXY, min_space_y = DMX1OR_SC_MXX_P48, space_extension_x = DMX1OR_SC_MXY, space_extension_y = DMX1OR_SC_MXX_P48 },
    { M1_LT405, min_space_x = DMX1OR_SC_MXY, min_space_y = DMX1_SC_W285, space_extension_x = DMX1OR_SC_MXY, space_extension_y = DMX1_SC_W285 },
    { M1_LT160, min_space_x = DMX1OR_SC_MXY, min_space_y = DMX1_SC_W405, space_extension_x = DMX1OR_SC_MXY, space_extension_y = DMX1_SC_W405 },
    { M1_GE160, min_space_x = DMX1OR_SC_MXY, min_space_y = DMX1_SC_W160, space_extension_x = DMX1OR_SC_MXY, space_extension_y = DMX1_SC_W160 },
#endif
    { DM1_O, min_space_x = DMX1OR_DMX_O_P48, min_space_y = DMX1OR_DMX_O_P48, space_extension_x = DMX1OR_DMX_O_P48, space_extension_y = DMX1OR_DMX_O_P48 },
    { DM1, min_space_x = DMX1OR_DMX_P48, min_space_y = DMX1OR_DMX_P48, space_extension_x = DMX1OR_DMX_P48, space_extension_y = DMX1OR_DMX_P48 },
#ifdef VERTICAL_M1
    { M1_HVN_096V, min_space_x = DM1_MX096V, min_space_y = DMX1OR_SC_MXY, space_extension_x = DM1_MX096V, space_extension_y = DMX1OR_SC_MXY },
    { M1_HVN_132V, min_space_x = DMX1_MX132V, min_space_y = DMX1OR_SC_MXY, space_extension_x = DMX1_MX132V, space_extension_y = DMX1OR_SC_MXY },
    { M1_HVN_165V, min_space_x = DMX1_MX165V, min_space_y = DMX1OR_SC_MXY, space_extension_x = DMX1_MX165V, space_extension_y = DMX1OR_SC_MXY },
    { M1_HVN_198V, min_space_x = DMX1_MX198V, min_space_y = DMX1OR_SC_MXY, space_extension_x = DMX1_MX198V, space_extension_y = DMX1OR_SC_MXY },
    { M1_HVN_275V, min_space_x = DMX1_MX275V, min_space_y = DMX1OR_275V_MXY, space_extension_x = DMX1_MX275V, space_extension_y = DMX1OR_275V_MXY },
#else
    { M1_HVN_096V, min_space_x = DMX1OR_SC_MXY, min_space_y = DM1_MX096V, space_extension_x = DMX1OR_SC_MXY, space_extension_y = DM1_MX096V },
    { M1_HVN_132V, min_space_x = DMX1OR_SC_MXY, min_space_y = DMX1_MX132V, space_extension_x = DMX1OR_SC_MXY, space_extension_y = DMX1_MX132V },
    { M1_HVN_165V, min_space_x = DMX1OR_SC_MXY, min_space_y = DMX1_MX165V, space_extension_x = DMX1OR_SC_MXY, space_extension_y = DMX1_MX165V },
    { M1_HVN_198V, min_space_x = DMX1OR_SC_MXY, min_space_y = DMX1_MX198V, space_extension_x = DMX1OR_SC_MXY, space_extension_y = DMX1_MX198V },
    { M1_HVN_275V, min_space_x = DMX1OR_275V_MXY, min_space_y = DMX1_MX275V, space_extension_x = DMX1OR_275V_MXY, space_extension_y = DMX1_MX275V },
#endif
    { VIA0_HVN_096V, min_space = DMX1_VX096V },
    { VIA0_HVN_132V, min_space = DMX1_VX132V },
    { VIA0_HVN_165V, min_space = DMX1_VX165V },
    { VIA0_HVN_198V, min_space = DMX1_VX198V },
    { VIA0_HVN_275V, min_space = DMX1_VX275V },
    { VIA1_HVN_096V, min_space = DMX1_VX096V },
    { VIA1_HVN_132V, min_space = DMX1_VX132V },
    { VIA1_HVN_165V, min_space = DMX1_VX165V },
    { VIA1_HVN_198V, min_space = DMX1_VX198V },
    { VIA1_HVN_275V, min_space = DMX1_VX275V },

#ifdef VERTICAL_M1
      { M1_MAIN_EDGE_END, min_space_y = 0.06, space_extension_x = 0.06, projection = CORNER, color_aware_to_fill = ALL },
#else
      { M1_MAIN_EDGE_END, min_space_x = 0.06, space_extension_y = 0.06, projection = CORNER, color_aware_to_fill = ALL },
#endif

#ifdef VERTICAL_M1
      { M1_096V_LE, min_space_y = 0.07, space_extension_x = 0.042, projection = CORNER, color_aware_to_fill = ALL },
#else
      { M1_096V_LE, min_space_x = 0.07, space_extension_y = 0.042, projection = CORNER, color_aware_to_fill = ALL },
#endif
#ifdef VERTICAL_M1
      { M1_096V_LE, min_space_y = 0.042, space_extension_x = 0.07, projection = CORNER, color_aware_to_fill = ALL },
#else
      { M1_096V_LE, min_space_x = 0.042, space_extension_y = 0.07, projection = CORNER, color_aware_to_fill = ALL },
#endif

#ifdef VERTICAL_M1
      { M1_198V_LE, min_space_y = 0.07, space_extension_x = 0.061, projection = CORNER, color_aware_to_fill = ALL },
#else
      { M1_198V_LE, min_space_x = 0.07, space_extension_y = 0.061, projection = CORNER, color_aware_to_fill = ALL },
#endif

#ifdef VERTICAL_M1
      { M1_198V_LE, min_space_y = 0.061, space_extension_x = 0.07, projection = CORNER, color_aware_to_fill = ALL },
#else
      { M1_198V_LE, min_space_x = 0.061, space_extension_y = 0.07, projection = CORNER, color_aware_to_fill = ALL },
#endif

//============================================
// DUMMY SPEC : WIDTH_SC_M1_O
    { M1_WRAP, width_based_spacing = {
			{>= 0.012, 	{>= DMX1OR_SC_MXX_P48} },
			{>= 0.0285, 	{>= DMX1_SC_W285} },
			{>= 0.0405, 	{>= DMX1_SC_W405} },
			{>= 0.16, 	{>= DMX1_SC_W160} },
		}, color_aware_to_fill = ALL },
#ifdef VERTICAL_M1
    { M1_HVN_096V, min_space_x = DM1_MX096V, min_space_y = DMX1OR_SC_MXY, space_extension_x = DM1_MX096V, space_extension_y = DMX1OR_SC_MXY },
    { M1_HVN_132V, min_space_x = DMX1_MX132V, min_space_y = DMX1OR_SC_MXY, space_extension_x = DMX1_MX132V, space_extension_y = DMX1OR_SC_MXY },
    { M1_HVN_165V, min_space_x = DMX1_MX165V, min_space_y = DMX1OR_SC_MXY, space_extension_x = DMX1_MX165V, space_extension_y = DMX1OR_SC_MXY },
    { M1_HVN_198V, min_space_x = DMX1_MX198V, min_space_y = DMX1OR_SC_MXY, space_extension_x = DMX1_MX198V, space_extension_y = DMX1OR_SC_MXY },
    { M1_HVN_275V, min_space_x = DMX1_MX275V, min_space_y = DMX1OR_275V_MXY, space_extension_x = DMX1_MX275V, space_extension_y = DMX1OR_275V_MXY },
#else
    { M1_HVN_096V, min_space_x = DMX1OR_SC_MXY, min_space_y = DM1_MX096V, space_extension_x = DMX1OR_SC_MXY, space_extension_y = DM1_MX096V },
    { M1_HVN_132V, min_space_x = DMX1OR_SC_MXY, min_space_y = DMX1_MX132V, space_extension_x = DMX1OR_SC_MXY, space_extension_y = DMX1_MX132V },
    { M1_HVN_165V, min_space_x = DMX1OR_SC_MXY, min_space_y = DMX1_MX165V, space_extension_x = DMX1OR_SC_MXY, space_extension_y = DMX1_MX165V },
    { M1_HVN_198V, min_space_x = DMX1OR_SC_MXY, min_space_y = DMX1_MX198V, space_extension_x = DMX1OR_SC_MXY, space_extension_y = DMX1_MX198V },
    { M1_HVN_275V, min_space_x = DMX1OR_275V_MXY, min_space_y = DMX1_MX275V, space_extension_x = DMX1OR_275V_MXY, space_extension_y = DMX1_MX275V },
#endif
    { VIA0_HVN_096V, min_space = DMX1_VX096V },
    { VIA0_HVN_132V, min_space = DMX1_VX132V },
    { VIA0_HVN_165V, min_space = DMX1_VX165V },
    { VIA0_HVN_198V, min_space = DMX1_VX198V },
    { VIA0_HVN_275V, min_space = DMX1_VX275V },
    { VIA1_HVN_096V, min_space = DMX1_VX096V },
    { VIA1_HVN_132V, min_space = DMX1_VX132V },
    { VIA1_HVN_165V, min_space = DMX1_VX165V },
    { VIA1_HVN_198V, min_space = DMX1_VX198V },
    { VIA1_HVN_275V, min_space = DMX1_VX275V },

#ifdef VERTICAL_M1
    { M1_GE160_BOUNDARY, min_space_x = 0.001, min_space_y = DMX1OR_SC_MXY, space_extension_x = 0.001, space_extension_y = DMX1OR_SC_MXY },
#else
    { M1_GE160_BOUNDARY, min_space_x = DMX1OR_SC_MXY, min_space_y = 0.001, space_extension_x = DMX1OR_SC_MXY, space_extension_y = 0.001 },
#endif
    { BEOLBLK_FINAL, min_space = 0 },
    { DM1EXCL_FINAL, min_space = 0 },
    { BEOLBLK_FINAL_NOM1, min_space_x = DMX1_BEOLBLKR, min_space_y = DMX1_BEOLBLKE, space_extension_x = DMX1_BEOLBLKR, space_extension_y = DMX1_BEOLBLKE },
    { DM1EXCL_FINAL_NOM1, min_space_x = DMX1_DMXEXCLR, min_space_y = DMX1_DMXEXCLE, space_extension_x = DMX1_DMXEXCLR, space_extension_y = DMX1_DMXEXCLE },
    { M1_BOUNDARY_CLOSE, min_space = DMX1O_CHIPR },

}; //end of FSS_M1_WRAPSPEC
//==================================================
// DUMMY SPEC : M1_guideSpec
//==================================================
// DUMMY SPEC : M1_wrapSpec
PATTERN_M1_WRAPSPEC = get_single_linear_pattern(
    FSS_M1_WRAPSPEC,
    {
        { M1_WRAP, NO_COLOR },
        { M1_GE160_BOUNDARY, NO_COLOR }, 
        { DM1EXCL_FINAL, NO_COLOR },
        { BEOLBLK_FINAL, NO_COLOR },
	{ M1_BOUNDARY_CLOSE, NO_COLOR },
    },
    0.125,
    "M1_WRAPSPEC",
#ifdef VERTICAL_M1
	VERTICAL, "M1VWRAP", DMX1OR_W_P48, DMX1OR_W_P48, DMX1OR_L_P48, DMX1OR_L_MAX_P48,
	0, 0, DMX1OR_SX_SC_P48, DMX1OR_SY_SC_P48, //for step checking
#else
	HORIZONTAL, "M1HWRAP", DMX1OR_W_P48, DMX1OR_W_P48, DMX1OR_L_P48, DMX1OR_L_MAX_P48,
	0, 0, DMX1OR_SY_SC_P48, DMX1OR_SX_SC_P48, //for step checking
#endif				
	15, SHRINK
);
        
PATTERN_M1_WRAPSPEC.polygon_fill.pattern_spec.pattern_spacing = {
    corner_extension_x = DMX1OR_SY_SC_P48,
    corner_extension_y = DMX1OR_SY_SC_P48,
    extension = INTERSECTION,
};
PATTERN_M1_WRAPSPEC.polygon_fill.color = false;

M1_WRAPSPEC = unified_fill(
	fill_patterns = { PATTERN_M1_WRAPSPEC },
	fill_boundary = {
	    layer = CHIP_snps,
	    type = LAYER,
	},
    boundary = ALIGN,
	grid = vGRID
);


//=========================================================

WRAPPER_DM1_O_L =  M1_WRAPSPEC["M1_WRAPSPEC"][0];
WRAPPER_DM1_O_C =  M1_WRAPSPEC["M1_WRAPSPEC"][0];
#endif

#ifdef FILL_DM2
#ifdef VERTICAL_M2
CHIP_SHRINK_M2 = shrink( CHIP_snps, north = CHIP_SHRINK_VALUEX1, south = CHIP_SHRINK_VALUEX1 );
SRM_FORBIDDEN_M2  = edge_size( angle_edge(SRM or SRAMDMY, == 0), outside = 0.4 );
#ifdef FULL_CHIP
M2_BOUNDARY_CLOSE  = edge_size( angle_edge(CHIP_BOUNDARY, == 90), outside = 0.014 );
M2_BOUNDARY_INSIDE = edge_size( angle_edge(CHIP_BOUNDARY, == 90), inside = CHIP_SHRINK_VALUEY1 );
#else
M2_BOUNDARY_CLOSE_PRE1 = edge_size( angle_edge( PRBOUNDARY, == 90 ), outside = 0.014 ); 
M2_BOUNDARY_CLOSE_PRE2 = shrink( M2_BOUNDARY_CLOSE_PRE1, north = 1, south = 1 ); 
M2_BOUNDARY_CLOSE_PRE3 = M2_BOUNDARY_CLOSE_PRE1 not M2_BOUNDARY_CLOSE_PRE2; 
M2_BOUNDARY_CLOSE_PRE4 = shrink( M2_BOUNDARY_CLOSE_PRE2, north = 0.1, south = 0.1 ); 
M2_BOUNDARY_CLOSE = M2_BOUNDARY_CLOSE_PRE3 or M2_BOUNDARY_CLOSE_PRE4; 
M2_BOUNDARY_INSIDE = edge_size( angle_edge( PRBOUNDARY, == 90 ), inside = CHIP_SHRINK_VALUEY1 ); 
#endif

#else
CHIP_SHRINK_M2 = shrink( CHIP_snps, east = CHIP_SHRINK_VALUEX1, west = CHIP_SHRINK_VALUEX1 );
SRM_FORBIDDEN_M2  = edge_size( angle_edge( SRM or SRAMDMY, == 90 ), outside = 0.4 );
#ifdef FULL_CHIP
M2_BOUNDARY_CLOSE  = edge_size( angle_edge(CHIP_BOUNDARY, == 0), outside = 0.014 );
M2_BOUNDARY_INSIDE = edge_size( angle_edge(CHIP_BOUNDARY, == 0), inside = CHIP_SHRINK_VALUEY1 );
#else
M2_BOUNDARY_CLOSE_PRE1  = edge_size(angle_edge( PRBOUNDARY, == 0), outside = 0.014 );
M2_BOUNDARY_CLOSE_PRE2  = shrink( M2_BOUNDARY_CLOSE_PRE1, west = 1, east = 1 );
M2_BOUNDARY_CLOSE_PRE3  = M2_BOUNDARY_CLOSE_PRE1 not M2_BOUNDARY_CLOSE_PRE2;
M2_BOUNDARY_CLOSE_PRE4  = shrink( M2_BOUNDARY_CLOSE_PRE2, west = 0.1, east = 0.1 );
M2_BOUNDARY_CLOSE  = or_list( { M2_BOUNDARY_CLOSE_PRE3, M2_BOUNDARY_CLOSE_PRE4 } );
M2_BOUNDARY_INSIDE = edge_size( angle_edge( PRBOUNDARY, == 0), inside = CHIP_SHRINK_VALUEY1 );
#endif

#endif

#ifdef FULL_CHIP
REGION_WRAPPER_DM2 = (CHIP_SHRINK_M2 not SRM_FORBIDDEN_M2) and (or_list( { (size( M2_MAIN, clip_acute = TRUNCATE, distance = WRAPPER_RANGEX1 )), (CHIP_snps not (size( CHIP_snps, clip_acute = TRUNCATE, distance = - WRAPPER_RANGEX1 ))), (size( (BEOLBLK_FINAL or DM2EXCL_FINAL), clip_acute = TRUNCATE, distance = WRAPPER_RANGEX1 )), M2_BOUNDARY_INSIDE } )); 
#else
REGION_WRAPPER_DM2 = ((CHIP_SHRINK_M2 not SRM_FORBIDDEN_M2) and (or_list( { (size( M2_MAIN, clip_acute = TRUNCATE, distance = WRAPPER_RANGEX1 )), (CHIP_snps not (size( CHIP_snps, clip_acute = TRUNCATE, distance = - WRAPPER_RANGEX1 ))), (size( (BEOLBLK_FINAL or DM2EXCL_FINAL), clip_acute = TRUNCATE, distance = WRAPPER_RANGEX1 )), M2_BOUNDARY_INSIDE } ))) or ((CHIP_snps not SRM_FORBIDDEN_M2) and M2_BOUNDARY_INSIDE); 
#endif

#ifdef FULL_CHIP
M2_BOUNDARY_CLOSE_tmp = M2_BOUNDARY_CLOSE coincident_edge REGION_WRAPPER_DM2;
M2_BOUNDARY_CLOSE = edge_size(M2_BOUNDARY_CLOSE_tmp, inside = 0.014);
#endif

WIDECA_M2      = M2CA_GE160;
WIDECB_M2      = M2CB_GE160;
M2CA_WRAP1 = M2_MAIN_CA not or_list( { WIDECA_M2, DM2EXCL_FINAL_NOM2, BEOLBLK_FINAL_NOM2 } ); 

M2CB_WRAP1 = M2_MAIN_CB not or_list( { WIDECB_M2, DM2EXCL_FINAL_NOM2, BEOLBLK_FINAL_NOM2 } ); 

#ifdef VERTICAL_M2
M2CA_EDGE = angle_edge( M2CA_WRAP1, == 0 );
M2CA_PORJ = external1_error( M2CA_EDGE, <= ISLAND_SPACE_MX1, direction = VERTICAL, extension = NONE, look_thru = ALL, look_thru_count = < 1 ); 
M2CB_EDGE = angle_edge( M2CB_WRAP1, == 0 );
M2CB_PORJ = external1_error( M2CB_EDGE, <= ISLAND_SPACE_MX1, direction = VERTICAL, extension = NONE, look_thru = ALL, look_thru_count = < 1 ); 
#else
M2CA_EDGE = angle_edge( M2CA_WRAP1, == 90 ); 
M2CA_PORJ = external1_error( M2CA_EDGE, <= ISLAND_SPACE_MX1, direction = HORIZONTAL, extension = NONE, look_thru = ALL, look_thru_count = < 1 ); 
M2CB_EDGE = angle_edge( M2CB_WRAP1, == 90 ); 
M2CB_PORJ = external1_error( M2CB_EDGE, <= ISLAND_SPACE_MX1, direction = HORIZONTAL, extension = NONE, look_thru = ALL, look_thru_count = < 1 ); 
#endif


M2CA_MATCH = drc_features_error( primary_layer = M2CA_PORJ, secondary_layers = { "layer2" => M2CA_EDGE }, output_from_layer = M2CA_PORJ, include_touch = EDGE, drc_function = dfm_property_func_w, combine_errors = OPPOSING ); 
M2CA_WRAP2 = error_merge( M2CA_MATCH ); 
M2CA_WRAP = not_interacting( M2CA_WRAP2, M2CB_WRAP1 ) or M2CA_WRAP1; 


M2CB_MATCH = drc_features_error( primary_layer = M2CB_PORJ, secondary_layers = { "layer2" => M2CB_EDGE }, output_from_layer = M2CB_PORJ, include_touch = EDGE, drc_function = dfm_property_func_w, combine_errors = OPPOSING ); 
M2CB_WRAP2 = error_merge( M2CB_MATCH ); 
M2CB_WRAP = not_interacting( M2CB_WRAP2, M2CA_WRAP1 ) or M2CB_WRAP1; 




M2_GE160_BOUNDARY = M2_GE160 interacting M2_BOUNDARY_INSIDE;


// DUMMY SPEC : M2_O_DC_E
FSS_M2_WRAPSPEC: list of fill_to_signal_spacing_s = {
    { BEOLBLK_FINAL, min_space = 0 },
    { DM2EXCL_FINAL, min_space = 0 },
    { BEOLBLK_FINAL_NOM2, min_space_x = DMX1_BEOLBLKE, min_space_y = DMX1_BEOLBLKR, space_extension_x = DMX1_BEOLBLKE, space_extension_y = DMX1_BEOLBLKR },
    { DM2EXCL_FINAL_NOM2, min_space_x = DMX1_DMXEXCLE, min_space_y = DMX1_DMXEXCLR, space_extension_x = DMX1_DMXEXCLE, space_extension_y = DMX1_DMXEXCLR },
    { INDDMY, min_space = DM_INDDMY },
#ifdef VERTICAL_M2
    { BEOLBLK_FINAL, min_space = 0, min_space_y = CHIP_SHRINK_VALUEX1 }, //for exclusion zone
    { DM2EXCL_FINAL, min_space = 0, min_space_y = CHIP_SHRINK_VALUEX1 }, //for exclusion zone
#else
    { BEOLBLK_FINAL, min_space = 0, min_space_x = CHIP_SHRINK_VALUEX1 }, //for exclusion zone
    { DM2EXCL_FINAL, min_space = 0, min_space_x = CHIP_SHRINK_VALUEX1 }, //for exclusion zone
#endif
//============================================
// DUMMY SPEC : M2_O_DC
    { REGION_WRAPPER_DM2, min_space = 0, context = INTERIOR },
    { CHIP_snps, min_space = 0, context = INTERIOR }, //RD CONFIRM
#ifdef FULL_CHIP
    { CHIP_BOUNDARY, min_space = 0, context = INTERIOR }, //RD CONFIRM
    { CHIP_FILLREGION_X1, min_space = 0, context = INTERIOR },
#else
    { PRBOUNDARY, min_space_x = DMX1O_CHIPE, min_space_y = DMX1O_CHIPR, context = INTERIOR },
#endif
    { MX1FORBIDDEN_CHIPMH, min_space = 0 },
    { BEOLBLK_FINAL, min_space = 0 },
    { DM2EXCL_FINAL, min_space = 0 },
    { BEOLBLK_FINAL_NOM2, min_space_x = DMX1_BEOLBLKE, min_space_y = DMX1_BEOLBLKR, space_extension_x = DMX1_BEOLBLKE, space_extension_y = DMX1_BEOLBLKR }, 
    { DM2EXCL_FINAL_NOM2, min_space_x = DMX1_DMXEXCLE, min_space_y = DMX1_DMXEXCLR, space_extension_x = DMX1_DMXEXCLE, space_extension_y = DMX1_DMXEXCLR }, 
    { CSR66_3485, min_space_x = DMX1_DMXEXCLE, min_space_y = DMX1_DMXEXCLR, space_extension_x = DMX1_DMXEXCLE, space_extension_y = DMX1_DMXEXCLR },
    { INDDMY, min_space = DM_INDDMY },
    { TCDDMY_M2, min_space = DMX1_TCDDMY_MX },
    { M2_HOLE, min_space = 0 },
    { M2_45, min_space = 0 },
    { ICOVL_SINGLE, min_space = DMX1_ICOVL },
    { FLOATING_M2_JUMP, min_space = 0.08 },
    { M2_JUMP, min_space = DMX1_O_SRMJUMP },

#ifdef VERTICAL_M2
    { M2_MAIN, min_space_x = DMX1OR_DC_MXX, min_space_y = DMX1OR_DC_MXY, space_extension_x = DMX1OR_DC_MXX, space_extension_y = DMX1OR_DC_MXY },
#else
    { M2_MAIN, min_space_x = DMX1OR_DC_MXY, min_space_y = DMX1OR_DC_MXX, space_extension_x = DMX1OR_DC_MXY, space_extension_y = DMX1OR_DC_MXX },
#endif


#ifdef VERTICAL_M2
    { M2_LT285, min_space_x = DMX1OR_DC_MXX, min_space_y = DMX1OR_DC_MXY, space_extension_x = DMX1OR_DC_MXX, space_extension_y = DMX1OR_DC_MXY },
    { M2_LT405, min_space_x = DMX1OR_DC_MXX, min_space_y = DMX1OR_DC_MXY, space_extension_x = DMX1OR_DC_MXX, space_extension_y = DMX1OR_DC_MXY },
    { M2_LT160, min_space_x = DMX1_DC_W405, min_space_y = DMX1OR_DC_MXY, space_extension_x = DMX1_DC_W405, space_extension_y = DMX1OR_DC_MXY },
    { M2_GE160, min_space_x = DMX1_DC_W160, min_space_y = DMX1OR_DC_MXY, space_extension_x = DMX1_DC_W160, space_extension_y = DMX1OR_DC_MXY },
#else
    { M2_LT285, min_space_x = DMX1OR_DC_MXY, min_space_y = DMX1OR_DC_MXX, space_extension_x = DMX1OR_DC_MXY, space_extension_y = DMX1OR_DC_MXX },
    { M2_LT405, min_space_x = DMX1OR_DC_MXY, min_space_y = DMX1OR_DC_MXX, space_extension_x = DMX1OR_DC_MXY, space_extension_y = DMX1OR_DC_MXX },
    { M2_LT160, min_space_x = DMX1OR_DC_MXY, min_space_y = DMX1_DC_W405, space_extension_x = DMX1OR_DC_MXY, space_extension_y = DMX1_DC_W405 },
    { M2_GE160, min_space_x = DMX1OR_DC_MXY, min_space_y = DMX1_DC_W160, space_extension_x = DMX1OR_DC_MXY, space_extension_y = DMX1_DC_W160 },
#endif
    { DM2_O, min_space_x = DMX1OR_DMX_O, min_space_y = DMX1OR_DMX_O, space_extension_x = DMX1OR_DMX_O, space_extension_y = DMX1OR_DMX_O },
    { DM2, min_space_x = DMX1OR_DMX, min_space_y = DMX1OR_DMX, space_extension_x = DMX1OR_DMX, space_extension_y = DMX1OR_DMX },
#ifdef VERTICAL_M2
    { M2_HVN_096V, min_space_x = DMX1_MX096V, min_space_y = DMX1OR_SC_MXY, space_extension_x = DMX1_MX096V, space_extension_y = DMX1OR_SC_MXY },
    { M2_HVN_132V, min_space_x = DMX1_MX132V, min_space_y = DMX1OR_SC_MXY, space_extension_x = DMX1_MX132V, space_extension_y = DMX1OR_SC_MXY },
    { M2_HVN_165V, min_space_x = DMX1_MX165V, min_space_y = DMX1OR_SC_MXY, space_extension_x = DMX1_MX165V, space_extension_y = DMX1OR_SC_MXY },
    { M2_HVN_198V, min_space_x = DMX1_MX198V, min_space_y = DMX1OR_SC_MXY, space_extension_x = DMX1_MX198V, space_extension_y = DMX1OR_SC_MXY },
    { M2_HVN_275V, min_space_x = DMX1_MX275V, min_space_y = DMX1OR_275V_MXY, space_extension_x = DMX1_MX275V, space_extension_y = DMX1OR_275V_MXY },
#else
    { M2_HVN_096V, min_space_x = DMX1OR_SC_MXY, min_space_y = DMX1_MX096V, space_extension_x = DMX1OR_SC_MXY, space_extension_y = DMX1_MX096V },
    { M2_HVN_132V, min_space_x = DMX1OR_SC_MXY, min_space_y = DMX1_MX132V, space_extension_x = DMX1OR_SC_MXY, space_extension_y = DMX1_MX132V },
    { M2_HVN_165V, min_space_x = DMX1OR_SC_MXY, min_space_y = DMX1_MX165V, space_extension_x = DMX1OR_SC_MXY, space_extension_y = DMX1_MX165V },
    { M2_HVN_198V, min_space_x = DMX1OR_SC_MXY, min_space_y = DMX1_MX198V, space_extension_x = DMX1OR_SC_MXY, space_extension_y = DMX1_MX198V },
    { M2_HVN_275V, min_space_x = DMX1OR_275V_MXY, min_space_y = DMX1_MX275V, space_extension_x = DMX1OR_275V_MXY, space_extension_y = DMX1_MX275V },
#endif
    { VIA1_HVN_096V, min_space = DMX1_VX096V },
    { VIA1_HVN_132V, min_space = DMX1_VX132V },
    { VIA1_HVN_165V, min_space = DMX1_VX165V },
    { VIA1_HVN_198V, min_space = DMX1_VX198V },
    { VIA1_HVN_275V, min_space = DMX1_VX275V },
    { VIA2_HVN_096V, min_space = DMX1_VX096V },
    { VIA2_HVN_132V, min_space = DMX1_VX132V },
    { VIA2_HVN_165V, min_space = DMX1_VX165V },
    { VIA2_HVN_198V, min_space = DMX1_VX198V },
    { VIA2_HVN_275V, min_space = DMX1_VX275V },

//============================================
// DUMMY SPEC : M2_O_SCA
#ifdef VERTICAL_M2
      { M2_MAIN_CA, min_space_x = DMX1OR_SC_MXX, min_space_y = DMX1OR_SC_MXY, space_extension_x = DMX1OR_SC_MXX, space_extension_y = DMX1OR_SC_MXY, color_aware_to_fill = ONLY_COLOR_1 },
      { M2_MAIN_CA, min_space = 0 },//for parsing
      { M2CA_LT405, min_space_x = DMX1_SC_W285, min_space_y = DMX1OR_SC_MXY, space_extension_x = DMX1_SC_W285, space_extension_y = DMX1OR_SC_MXY, color_aware_to_fill = ONLY_COLOR_1 },
      { M2CA_LT405, min_space = 0 },//for parsing
      { M2CA_LT160, min_space_x = DMX1_SC_W405, min_space_y = DMX1OR_SC_MXY, space_extension_x = DMX1_SC_W405, space_extension_y = DMX1OR_SC_MXY, color_aware_to_fill = ONLY_COLOR_1 },
      { M2CA_LT160, min_space = 0 },//for parsing
#else
      { M2_MAIN_CA, min_space_x = DMX1OR_SC_MXY, min_space_y = DMX1OR_SC_MXX, space_extension_x = DMX1OR_SC_MXY, space_extension_y = DMX1OR_SC_MXX, color_aware_to_fill = ONLY_COLOR_1 },
      { M2_MAIN_CA, min_space = 0 },//for parsing
      { M2CA_LT405, min_space_x = DMX1OR_SC_MXY, min_space_y = DMX1_SC_W285, space_extension_x = DMX1OR_SC_MXY, space_extension_y = DMX1_SC_W285, color_aware_to_fill = ONLY_COLOR_1 },
      { M2CA_LT405, min_space = 0 },//for parsing
      { M2CA_LT160, min_space_x = DMX1OR_SC_MXY, min_space_y = DMX1_SC_W405, space_extension_x = DMX1OR_SC_MXY, space_extension_y = DMX1_SC_W405, color_aware_to_fill = ONLY_COLOR_1 },
      { M2CA_LT160, min_space = 0 },//for parsing
#endif
      { M2CA_GE160, min_space = DMX1_SC_W160, color_aware_to_fill = ONLY_COLOR_1 },
      { M2CA_GE160, min_space = 0 },//for parsing
#ifdef VERTICAL_M2
      { M2CA_LE, min_space_y = 0.06, space_extension_x = 0.06, projection = CORNER, color_aware_to_fill = ONLY_COLOR_1 },
#else
      { M2CA_LE, min_space_x = 0.06, space_extension_y = 0.06, projection = CORNER, color_aware_to_fill = ONLY_COLOR_1 },
#endif
      { M2CA_LE, min_space = 0 },//for parsing
//=========================================================
// DUMMY SPEC : M2_O_SCB
#ifdef VERTICAL_M2
      { M2_MAIN_CB, min_space_x = DMX1OR_SC_MXX, min_space_y = DMX1OR_SC_MXY, space_extension_x = DMX1OR_SC_MXX, space_extension_y = DMX1OR_SC_MXY, color_aware_to_fill = ONLY_COLOR_2 },
      { M2_MAIN_CB, min_space = 0 },//for parsing
      { M2CB_LT405, min_space_x = DMX1_SC_W285, min_space_y = DMX1OR_SC_MXY, space_extension_x = DMX1_SC_W285, space_extension_y = DMX1OR_SC_MXY, color_aware_to_fill = ONLY_COLOR_2 },
      { M2CB_LT405, min_space = 0 },//for parsing
      { M2CB_LT160, min_space_x = DMX1_SC_W405, min_space_y = DMX1OR_SC_MXY, space_extension_x = DMX1_SC_W405, space_extension_y = DMX1OR_SC_MXY, color_aware_to_fill = ONLY_COLOR_2 },
      { M2CB_LT160, min_space = 0 },//for parsing
#else
      { M2_MAIN_CB, min_space_x = DMX1OR_SC_MXY, min_space_y = DMX1OR_SC_MXX, space_extension_x = DMX1OR_SC_MXY, space_extension_y = DMX1OR_SC_MXX, color_aware_to_fill = ONLY_COLOR_2 },
      { M2_MAIN_CB, min_space = 0 },//for parsing
      { M2CB_LT405, min_space_x = DMX1OR_SC_MXY, min_space_y = DMX1_SC_W285, space_extension_x = DMX1OR_SC_MXY, space_extension_y = DMX1_SC_W285, color_aware_to_fill = ONLY_COLOR_2 },
      { M2CB_LT405, min_space = 0 },//for parsing
      { M2CB_LT160, min_space_x = DMX1OR_SC_MXY, min_space_y = DMX1_SC_W405, space_extension_x = DMX1OR_SC_MXY, space_extension_y = DMX1_SC_W405, color_aware_to_fill = ONLY_COLOR_2 },
      { M2CB_LT160, min_space = 0 },//for parsing
#endif
      { M2CB_GE160, min_space = DMX1_SC_W160, color_aware_to_fill = ONLY_COLOR_2 },
      { M2CB_GE160, min_space = 0 },//for parsing
#ifdef VERTICAL_M2
      { M2CB_LE, min_space_y = 0.06, space_extension_x = 0.06, projection = CORNER, color_aware_to_fill = ONLY_COLOR_2 },
#else
      { M2CB_LE, min_space_x = 0.06, space_extension_y = 0.06, projection = CORNER, color_aware_to_fill = ONLY_COLOR_2 },
#endif
      { M2CB_LE, min_space = 0 },//for parsing
//=======================================================
// DUMMY SPEC : WIDTH_DC_M2CA_O
    { M2CA_WRAP, width_based_spacing = {
			{>= 0.0, 	{>= DMX1OR_DC_MXX} },
			{>= 0.012, 	{>= DMX1OR_DC_MXX} },
			{>= 0.0405, 	{>= DMX1_DC_W405} },
			{>= 0.16, 	{>= DMX1_DC_W160} },
		}, color_aware_to_fill = ALL },
#ifdef VERTICAL_M2
    { M2_HVN_096V, min_space_x = DMX1_MX096V, min_space_y = DMX1OR_SC_MXY, space_extension_x = DMX1_MX096V, space_extension_y = DMX1OR_SC_MXY },
    { M2_HVN_132V, min_space_x = DMX1_MX132V, min_space_y = DMX1OR_SC_MXY, space_extension_x = DMX1_MX132V, space_extension_y = DMX1OR_SC_MXY },
    { M2_HVN_165V, min_space_x = DMX1_MX165V, min_space_y = DMX1OR_SC_MXY, space_extension_x = DMX1_MX165V, space_extension_y = DMX1OR_SC_MXY },
    { M2_HVN_198V, min_space_x = DMX1_MX198V, min_space_y = DMX1OR_SC_MXY, space_extension_x = DMX1_MX198V, space_extension_y = DMX1OR_SC_MXY },
    { M2_HVN_275V, min_space_x = DMX1_MX275V, min_space_y = DMX1OR_275V_MXY, space_extension_x = DMX1_MX275V, space_extension_y = DMX1OR_275V_MXY },
#else
    { M2_HVN_096V, min_space_x = DMX1OR_SC_MXY, min_space_y = DMX1_MX096V, space_extension_x = DMX1OR_SC_MXY, space_extension_y = DMX1_MX096V },
    { M2_HVN_132V, min_space_x = DMX1OR_SC_MXY, min_space_y = DMX1_MX132V, space_extension_x = DMX1OR_SC_MXY, space_extension_y = DMX1_MX132V },
    { M2_HVN_165V, min_space_x = DMX1OR_SC_MXY, min_space_y = DMX1_MX165V, space_extension_x = DMX1OR_SC_MXY, space_extension_y = DMX1_MX165V },
    { M2_HVN_198V, min_space_x = DMX1OR_SC_MXY, min_space_y = DMX1_MX198V, space_extension_x = DMX1OR_SC_MXY, space_extension_y = DMX1_MX198V },
    { M2_HVN_275V, min_space_x = DMX1OR_275V_MXY, min_space_y = DMX1_MX275V, space_extension_x = DMX1OR_275V_MXY, space_extension_y = DMX1_MX275V },
#endif
    { VIA1_HVN_096V, min_space = DMX1_VX096V },
    { VIA1_HVN_132V, min_space = DMX1_VX132V },
    { VIA1_HVN_165V, min_space = DMX1_VX165V },
    { VIA1_HVN_198V, min_space = DMX1_VX198V },
    { VIA1_HVN_275V, min_space = DMX1_VX275V },
    { VIA2_HVN_096V, min_space = DMX1_VX096V },
    { VIA2_HVN_132V, min_space = DMX1_VX132V },
    { VIA2_HVN_165V, min_space = DMX1_VX165V },
    { VIA2_HVN_198V, min_space = DMX1_VX198V },
    { VIA2_HVN_275V, min_space = DMX1_VX275V },

#ifdef VERTICAL_M2
    { M2_GE160_BOUNDARY, min_space_x = 0.001, min_space_y = DMX1OR_SC_MXY, space_extension_x = 0.001, space_extension_y = DMX1OR_SC_MXY },
#else
    { M2_GE160_BOUNDARY, min_space_x = DMX1OR_SC_MXY, min_space_y = 0.001, space_extension_x = DMX1OR_SC_MXY, space_extension_y = 0.001 },
#endif
    { BEOLBLK_FINAL, min_space = 0 },
    { DM2EXCL_FINAL, min_space = 0 },
    { BEOLBLK_FINAL_NOM2, min_space_x = DMX1_BEOLBLKE, min_space_y = DMX1_BEOLBLKR, space_extension_x = DMX1_BEOLBLKE, space_extension_y = DMX1_BEOLBLKR },
    { DM2EXCL_FINAL_NOM2, min_space_x = DMX1_DMXEXCLE, min_space_y = DMX1_DMXEXCLR, space_extension_x = DMX1_DMXEXCLE, space_extension_y = DMX1_DMXEXCLR },
    { M2_BOUNDARY_CLOSE, min_space = DMX1O_CHIPR },
//=======================================================
// DUMMY SPEC : WIDTH_DC_M2CB_O
    { M2CB_WRAP, width_based_spacing = {
			{>= 0.0, 	{>= DMX1OR_DC_MXX} },
			{>= 0.012, 	{>= DMX1OR_DC_MXX} },
			{>= 0.0405, 	{>= DMX1_DC_W405} },
			{>= 0.16, 	{>= DMX1_DC_W160} },
		}, color_aware_to_fill = ALL },

//for 3pty chk
#ifdef VERTICAL_M2
    { M2_HVN_096V, min_space_x = DMX1_MX096V, min_space_y = DMX1OR_SC_MXY, space_extension_x = DMX1_MX096V, space_extension_y = DMX1OR_SC_MXY },
    { M2_HVN_132V, min_space_x = DMX1_MX132V, min_space_y = DMX1OR_SC_MXY, space_extension_x = DMX1_MX132V, space_extension_y = DMX1OR_SC_MXY },
    { M2_HVN_165V, min_space_x = DMX1_MX165V, min_space_y = DMX1OR_SC_MXY, space_extension_x = DMX1_MX165V, space_extension_y = DMX1OR_SC_MXY },
    { M2_HVN_198V, min_space_x = DMX1_MX198V, min_space_y = DMX1OR_SC_MXY, space_extension_x = DMX1_MX198V, space_extension_y = DMX1OR_SC_MXY },
    { M2_HVN_275V, min_space_x = DMX1_MX275V, min_space_y = DMX1OR_275V_MXY, space_extension_x = DMX1_MX275V, space_extension_y = DMX1OR_275V_MXY },
#else
    { M2_HVN_096V, min_space_x = DMX1OR_SC_MXY, min_space_y = DMX1_MX096V, space_extension_x = DMX1OR_SC_MXY, space_extension_y = DMX1_MX096V },
    { M2_HVN_132V, min_space_x = DMX1OR_SC_MXY, min_space_y = DMX1_MX132V, space_extension_x = DMX1OR_SC_MXY, space_extension_y = DMX1_MX132V },
    { M2_HVN_165V, min_space_x = DMX1OR_SC_MXY, min_space_y = DMX1_MX165V, space_extension_x = DMX1OR_SC_MXY, space_extension_y = DMX1_MX165V },
    { M2_HVN_198V, min_space_x = DMX1OR_SC_MXY, min_space_y = DMX1_MX198V, space_extension_x = DMX1OR_SC_MXY, space_extension_y = DMX1_MX198V },
    { M2_HVN_275V, min_space_x = DMX1OR_275V_MXY, min_space_y = DMX1_MX275V, space_extension_x = DMX1OR_275V_MXY, space_extension_y = DMX1_MX275V },
#endif
    { VIA1_HVN_096V, min_space = DMX1_VX096V },
    { VIA1_HVN_132V, min_space = DMX1_VX132V },
    { VIA1_HVN_165V, min_space = DMX1_VX165V },
    { VIA1_HVN_198V, min_space = DMX1_VX198V },
    { VIA1_HVN_275V, min_space = DMX1_VX275V },
    { VIA2_HVN_096V, min_space = DMX1_VX096V },
    { VIA2_HVN_132V, min_space = DMX1_VX132V },
    { VIA2_HVN_165V, min_space = DMX1_VX165V },
    { VIA2_HVN_198V, min_space = DMX1_VX198V },
    { VIA2_HVN_275V, min_space = DMX1_VX275V },

#ifdef VERTICAL_M2
    { M2_GE160_BOUNDARY, min_space_x = 0.001, min_space_y = DMX1OR_SC_MXY, space_extension_x = 0.001, space_extension_y = DMX1OR_SC_MXY },
#else
    { M2_GE160_BOUNDARY, min_space_x = DMX1OR_SC_MXY, min_space_y = 0.001, space_extension_x = DMX1OR_SC_MXY, space_extension_y = 0.001 },
#endif
    { BEOLBLK_FINAL, min_space = 0 },
    { DM2EXCL_FINAL, min_space = 0 },
    { BEOLBLK_FINAL_NOM2, min_space_x = DMX1_BEOLBLKE, min_space_y = DMX1_BEOLBLKR, space_extension_x = DMX1_BEOLBLKE, space_extension_y = DMX1_BEOLBLKR },
    { DM2EXCL_FINAL_NOM2, min_space_x = DMX1_DMXEXCLE, min_space_y = DMX1_DMXEXCLR, space_extension_x = DMX1_DMXEXCLE, space_extension_y = DMX1_DMXEXCLR },
    { M2_BOUNDARY_CLOSE, min_space = DMX1O_CHIPR },
//end for 3pty chk


//=======================================================
// DUMMY SPEC : WIDTH_SC_M2CA_O
    { M2CA_WRAP, width_based_spacing = {
			{>= 0.0, 	{>= DMX1OR_SC_MXX} },
			{>= 0.012, 	{>= DMX1OR_SC_MXX} },
			{>= 0.0285, 	{>= DMX1_SC_W285} },
			{>= 0.0405, 	{>= DMX1_SC_W405} },
			{>= 0.16, 	{>= DMX1_SC_W160} },
		}, color_aware_to_fill = ONLY_COLOR_1 },
#ifdef VERTICAL_M2
    { M2_HVN_096V, min_space_x = DMX1_MX096V, min_space_y = DMX1OR_SC_MXY, space_extension_x = DMX1_MX096V, space_extension_y = DMX1OR_SC_MXY },
    { M2_HVN_132V, min_space_x = DMX1_MX132V, min_space_y = DMX1OR_SC_MXY, space_extension_x = DMX1_MX132V, space_extension_y = DMX1OR_SC_MXY },
    { M2_HVN_165V, min_space_x = DMX1_MX165V, min_space_y = DMX1OR_SC_MXY, space_extension_x = DMX1_MX165V, space_extension_y = DMX1OR_SC_MXY },
    { M2_HVN_198V, min_space_x = DMX1_MX198V, min_space_y = DMX1OR_SC_MXY, space_extension_x = DMX1_MX198V, space_extension_y = DMX1OR_SC_MXY },
    { M2_HVN_275V, min_space_x = DMX1_MX275V, min_space_y = DMX1OR_275V_MXY, space_extension_x = DMX1_MX275V, space_extension_y = DMX1OR_275V_MXY },
#else
    { M2_HVN_096V, min_space_x = DMX1OR_SC_MXY, min_space_y = DMX1_MX096V, space_extension_x = DMX1OR_SC_MXY, space_extension_y = DMX1_MX096V },
    { M2_HVN_132V, min_space_x = DMX1OR_SC_MXY, min_space_y = DMX1_MX132V, space_extension_x = DMX1OR_SC_MXY, space_extension_y = DMX1_MX132V },
    { M2_HVN_165V, min_space_x = DMX1OR_SC_MXY, min_space_y = DMX1_MX165V, space_extension_x = DMX1OR_SC_MXY, space_extension_y = DMX1_MX165V },
    { M2_HVN_198V, min_space_x = DMX1OR_SC_MXY, min_space_y = DMX1_MX198V, space_extension_x = DMX1OR_SC_MXY, space_extension_y = DMX1_MX198V },
    { M2_HVN_275V, min_space_x = DMX1OR_275V_MXY, min_space_y = DMX1_MX275V, space_extension_x = DMX1OR_275V_MXY, space_extension_y = DMX1_MX275V },
#endif
    { VIA1_HVN_096V, min_space = DMX1_VX096V },
    { VIA1_HVN_132V, min_space = DMX1_VX132V },
    { VIA1_HVN_165V, min_space = DMX1_VX165V },
    { VIA1_HVN_198V, min_space = DMX1_VX198V },
    { VIA1_HVN_275V, min_space = DMX1_VX275V },
    { VIA2_HVN_096V, min_space = DMX1_VX096V },
    { VIA2_HVN_132V, min_space = DMX1_VX132V },
    { VIA2_HVN_165V, min_space = DMX1_VX165V },
    { VIA2_HVN_198V, min_space = DMX1_VX198V },
    { VIA2_HVN_275V, min_space = DMX1_VX275V },

#ifdef VERTICAL_M2
    { M2_GE160_BOUNDARY, min_space_x = 0.001, min_space_y = DMX1OR_SC_MXY, space_extension_x = 0.001, space_extension_y = DMX1OR_SC_MXY },
#else
    { M2_GE160_BOUNDARY, min_space_x = DMX1OR_SC_MXY, min_space_y = 0.001, space_extension_x = DMX1OR_SC_MXY, space_extension_y = 0.001 },
#endif
    { BEOLBLK_FINAL, min_space = 0 },
    { DM2EXCL_FINAL, min_space = 0 },
    { BEOLBLK_FINAL_NOM2, min_space_x = DMX1_BEOLBLKE, min_space_y = DMX1_BEOLBLKR, space_extension_x = DMX1_BEOLBLKE, space_extension_y = DMX1_BEOLBLKR },
    { DM2EXCL_FINAL_NOM2, min_space_x = DMX1_DMXEXCLE, min_space_y = DMX1_DMXEXCLR, space_extension_x = DMX1_DMXEXCLE, space_extension_y = DMX1_DMXEXCLR },

//=======================================================

// DUMMY SPEC : WIDTH_SC_M2CB_O
    { M2CB_WRAP, width_based_spacing = {
			{>= 0.0, 	{>= DMX1OR_SC_MXX} },
			{>= 0.012, 	{>= DMX1OR_SC_MXX} },
			{>= 0.0285, 	{>= DMX1_SC_W285} },
			{>= 0.0405, 	{>= DMX1_SC_W405} },
			{>= 0.16, 	{>= DMX1_SC_W160} },
		}, color_aware_to_fill = ONLY_COLOR_2 },
#ifdef VERTICAL_M2
    { M2_HVN_096V, min_space_x = DMX1_MX096V, min_space_y = DMX1OR_SC_MXY, space_extension_x = DMX1_MX096V, space_extension_y = DMX1OR_SC_MXY },
    { M2_HVN_132V, min_space_x = DMX1_MX132V, min_space_y = DMX1OR_SC_MXY, space_extension_x = DMX1_MX132V, space_extension_y = DMX1OR_SC_MXY },
    { M2_HVN_165V, min_space_x = DMX1_MX165V, min_space_y = DMX1OR_SC_MXY, space_extension_x = DMX1_MX165V, space_extension_y = DMX1OR_SC_MXY },
    { M2_HVN_198V, min_space_x = DMX1_MX198V, min_space_y = DMX1OR_SC_MXY, space_extension_x = DMX1_MX198V, space_extension_y = DMX1OR_SC_MXY },
    { M2_HVN_275V, min_space_x = DMX1_MX275V, min_space_y = DMX1OR_275V_MXY, space_extension_x = DMX1_MX275V, space_extension_y = DMX1OR_275V_MXY },
#else
    { M2_HVN_096V, min_space_x = DMX1OR_SC_MXY, min_space_y = DMX1_MX096V, space_extension_x = DMX1OR_SC_MXY, space_extension_y = DMX1_MX096V },
    { M2_HVN_132V, min_space_x = DMX1OR_SC_MXY, min_space_y = DMX1_MX132V, space_extension_x = DMX1OR_SC_MXY, space_extension_y = DMX1_MX132V },
    { M2_HVN_165V, min_space_x = DMX1OR_SC_MXY, min_space_y = DMX1_MX165V, space_extension_x = DMX1OR_SC_MXY, space_extension_y = DMX1_MX165V },
    { M2_HVN_198V, min_space_x = DMX1OR_SC_MXY, min_space_y = DMX1_MX198V, space_extension_x = DMX1OR_SC_MXY, space_extension_y = DMX1_MX198V },
    { M2_HVN_275V, min_space_x = DMX1OR_275V_MXY, min_space_y = DMX1_MX275V, space_extension_x = DMX1OR_275V_MXY, space_extension_y = DMX1_MX275V },
#endif
    { VIA1_HVN_096V, min_space = DMX1_VX096V },
    { VIA1_HVN_132V, min_space = DMX1_VX132V },
    { VIA1_HVN_165V, min_space = DMX1_VX165V },
    { VIA1_HVN_198V, min_space = DMX1_VX198V },
    { VIA1_HVN_275V, min_space = DMX1_VX275V },
    { VIA2_HVN_096V, min_space = DMX1_VX096V },
    { VIA2_HVN_132V, min_space = DMX1_VX132V },
    { VIA2_HVN_165V, min_space = DMX1_VX165V },
    { VIA2_HVN_198V, min_space = DMX1_VX198V },
    { VIA2_HVN_275V, min_space = DMX1_VX275V },

#ifdef VERTICAL_M2
    { M2_GE160_BOUNDARY, min_space_x = 0.001, min_space_y = DMX1OR_SC_MXY, space_extension_x = 0.001, space_extension_y = DMX1OR_SC_MXY },
#else
    { M2_GE160_BOUNDARY, min_space_x = DMX1OR_SC_MXY, min_space_y = 0.001, space_extension_x = DMX1OR_SC_MXY, space_extension_y = 0.001 },
#endif
    { BEOLBLK_FINAL, min_space = 0 },
    { DM2EXCL_FINAL, min_space = 0 },
    { BEOLBLK_FINAL_NOM2, min_space_x = DMX1_BEOLBLKE, min_space_y = DMX1_BEOLBLKR, space_extension_x = DMX1_BEOLBLKE, space_extension_y = DMX1_BEOLBLKR },
    { DM2EXCL_FINAL_NOM2, min_space_x = DMX1_DMXEXCLE, min_space_y = DMX1_DMXEXCLR, space_extension_x = DMX1_DMXEXCLE, space_extension_y = DMX1_DMXEXCLR },

}; //end of FSS_M2_WRAPSPEC
//===================================================
// DUMMY SPEC : M2_guideSpec
//===================================================
// DUMMY SPEC : M2_wrapSpec
PATTERN_M2_WRAPSPEC = get_single_linear_pattern(
    FSS_M2_WRAPSPEC,
    {
        { M2CA_WRAP, COLOR_1 },
        { M2CB_WRAP, COLOR_2 },
        { DM2EXCL_FINAL, COLOR_1 },
        { BEOLBLK_FINAL, COLOR_1 },
        { M2_GE160_BOUNDARY, COLOR_1 }, 
        { M2_BOUNDARY_CLOSE, COLOR_1 },
#ifdef VERTICAL_M2
    { M2_HVN_096V, COLOR_2 },
    { M2_HVN_132V, COLOR_2 },
    { M2_HVN_165V, COLOR_2 },
    { M2_HVN_198V, COLOR_2 },
    { M2_HVN_275V, COLOR_2 },   
#else
    { M2_HVN_096V, COLOR_2 },
    { M2_HVN_132V, COLOR_2 },
    { M2_HVN_165V, COLOR_2 },
    { M2_HVN_198V, COLOR_2 },
    { M2_HVN_275V, COLOR_2 },  
#endif
    },
    0.125,
    "M2_WRAPSPEC",
#ifdef VERTICAL_M2
	VERTICAL, "M2VWRAP", DMX1OR_W, DMX1OR_W_MAX, DMXOR_L, DMX1OR_L_MAX,
	DMXOR_SX_SC, DMX1OR_SY_SC, DMX1OR_SX_DC, DMX1OR_SY_DC, //for step checking
#else
	HORIZONTAL, "M2HWRAP", DMX1OR_W, DMX1OR_W_MAX, DMXOR_L, DMX1OR_L_MAX,
	DMX1OR_SY_SC, DMXOR_SX_SC, DMX1OR_SY_DC, DMX1OR_SX_DC, //for step checking
#endif				
	15, SHRINK
);

PATTERN_M2_WRAPSPEC.polygon_fill.signal_linear.valid_heights = {== 0.02, == 0.024, == 0.028 };
        
PATTERN_M2_WRAPSPEC.polygon_fill.pattern_spec.pattern_spacing = {
    corner_extension_x = DMX1OR_SY_SC,
    corner_extension_y = DMX1OR_SY_SC,
    extension = INTERSECTION,
};

M2_WRAPSPEC = unified_fill(
	fill_patterns = { PATTERN_M2_WRAPSPEC },
	fill_boundary = {
	    layer = CHIP_snps,
        type = LAYER,
	},
    boundary = ALIGN,
	grid = vGRID
);


//=========================================================

WRAPPER_DM2_O_A_L =  M2_WRAPSPEC["M2_WRAPSPEC"][1];
WRAPPER_DM2_O_B_L =  M2_WRAPSPEC["M2_WRAPSPEC"][2];
WRAPPER_DM2_O_A_C =  M2_WRAPSPEC["M2_WRAPSPEC"][1];
WRAPPER_DM2_O_B_C =  M2_WRAPSPEC["M2_WRAPSPEC"][2];
WRAPPER_DM2_O_L   =  WRAPPER_DM2_O_A_L or WRAPPER_DM2_O_B_L;
#endif

#ifdef FILL_DM3

#ifdef VERTICAL_M3
CHIP_SHRINK_M3 = shrink( CHIP_snps, north = 0.4, south = 0.4 ); 

#ifdef FULL_CHIP
M3_BOUNDARY_CLOSE = edge_size( angle_edge( CHIP_BOUNDARY, == 90 ), outside = 0.014 ); 
M3_BOUNDARY_INSIDE = edge_size( angle_edge( CHIP_BOUNDARY, == 90 ), inside = CHIP_SHRINK_VALUEY1 ); 

#else
M3_BOUNDARY_CLOSE = edge_size( angle_edge( PRBOUNDARY, == 90 ), outside = 0.014 ); 
M3_BOUNDARY_INSIDE = edge_size( angle_edge( PRBOUNDARY, == 90 ), inside = CHIP_SHRINK_VALUEY1 ); 

#endif
#else
CHIP_SHRINK_M3 = shrink( CHIP_snps, east = 0.4, west = 0.4 ); 

#ifdef FULL_CHIP
M3_BOUNDARY_CLOSE = edge_size( angle_edge( CHIP_BOUNDARY, == 0 ), outside = 0.014 ); 
M3_BOUNDARY_INSIDE = edge_size( angle_edge( CHIP_BOUNDARY, == 0 ), inside = CHIP_SHRINK_VALUEY1 ); 

#else
M3_BOUNDARY_CLOSE = edge_size( angle_edge( PRBOUNDARY, == 0 ), outside = 0.014 ); 
M3_BOUNDARY_INSIDE = edge_size( angle_edge( PRBOUNDARY, == 0 ), inside = CHIP_SHRINK_VALUEY1 ); 

#endif
#endif
REGION_WRAPPER_DM3 = CHIP_SHRINK_M3 and or_list( { size( M3_MAIN, clip_acute = TRUNCATE, distance = WRAPPER_RANGEX1 ), (CHIP_snps not size( CHIP_snps, clip_acute = TRUNCATE, distance = - WRAPPER_RANGEX1 )), size( (BEOLBLK_FINAL or DM3EXCL_FINAL), clip_acute = TRUNCATE, distance = WRAPPER_RANGEX1 ), M3_BOUNDARY_INSIDE } ); 
M3_WRAP1    = (M3_MAIN not (DM3EXCL_FINAL or BEOLBLK_FINAL)) not_interacting (M3_BOUNDARY_INSIDE2 or M3_BLK_OUTSIDE);

#ifdef FULL_CHIP
M3_BOUNDARY_CLOSE_tmp = M3_BOUNDARY_CLOSE coincident_edge REGION_WRAPPER_DM3;
M3_BOUNDARY_CLOSE = edge_size(M3_BOUNDARY_CLOSE_tmp, inside = 0.014);
#endif




#ifdef VERTICAL_M3
M3_EDGE = angle_edge( M3_WRAP1, == 0 ); 
M3_PORJ = external1_error( M3_EDGE, <= ISLAND_SPACE_MX2, direction = VERTICAL, extension = NONE, look_thru = ALL, look_thru_count = < 1 ); 
BLK_M3_EDGE_PRE = edge_size( angle_edge( ( BEOLBLK_FINAL or DM3EXCL_FINAL ), == 90 ), inside = 0.0005 ); 
BLK_M3_EDGE = not_interacting( BLK_M3_EDGE_PRE, M3_BOUNDARY_INSIDE2 );
#else
M3_EDGE = angle_edge( M3_WRAP1, == 90 ); 
M3_PORJ = external1_error( M3_EDGE, <= ISLAND_SPACE_MX2, direction = HORIZONTAL, extension = NONE, look_thru = ALL, look_thru_count = < 1 ); 
BLK_M3_EDGE_PRE = edge_size( angle_edge( ( BEOLBLK_FINAL or DM3EXCL_FINAL ), == 0 ), inside = 0.0005 ); 
BLK_M3_EDGE = not_interacting( BLK_M3_EDGE_PRE, M3_BOUNDARY_INSIDE2 );
#endif

M3_MATCH = drc_features_error( primary_layer = M3_PORJ, secondary_layers = { "layer2" => M3_EDGE }, output_from_layer = M3_PORJ, include_touch = EDGE, drc_function = dfm_property_func_w, combine_errors = OPPOSING ); 
M3_WRAP2   = error_merge( M3_MATCH );
M3_WRAP    = M3_WRAP2 or M3_WRAP1;

// DUMMY SPEC : M3_SC_E
FSS_M3_WRAPSPEC: list of fill_to_signal_spacing_s = {
    { BEOLBLK_FINAL, min_space_x = DMX2_BEOLBLKR, min_space_y = DMX2_BEOLBLKE, space_extension_x = DMX2_BEOLBLKR, space_extension_y = DMX2_BEOLBLKE },
    { DM3EXCL_FINAL, min_space_x = DMX2_DMXEXCLR, min_space_y = DMX2_DMXEXCLE, space_extension_x = DMX2_DMXEXCLR, space_extension_y = DMX2_DMXEXCLE },
    { INDDMY, min_space = DM_INDDMY },
#ifdef VERTICAL_M3
    { BEOLBLK_FINAL, min_space = 0, min_space_y = 0.35 }, //for exclusion zone
    { DM3EXCL_FINAL, min_space = 0, min_space_y = 0.35 }, //for exclusion zone
#else
    { BEOLBLK_FINAL, min_space = 0, min_space_x = 0.35 }, //for exclusion zone
    { DM3EXCL_FINAL, min_space = 0, min_space_x = 0.35 }, //for exclusion zone
#endif

//===================================================
// DUMMY SPEC : M3_SC

    { REGION_WRAPPER_DM3, min_space = 0, context = INTERIOR },
    { CHIP_snps, min_space = 0, context = INTERIOR }, //RD CONFIRM
#ifdef FULL_CHIP
    { CHIP_BOUNDARY, min_space = 0, context = INTERIOR }, //RD CONFIRM
    { CHIP_FILLREGION_X2, min_space = 0, context = INTERIOR },
#else
    { PRBOUNDARY, min_space_x = DMX2O_CHIPR, min_space_y = DMX2O_CHIPE, context = INTERIOR },
#endif
    { MX2FORBIDDEN_CHIPMV, min_space = 0 },
    { BEOLBLK_FINAL, min_space_x = DMX2_BEOLBLKR, min_space_y = DMX2_BEOLBLKE, space_extension_x = DMX2_BEOLBLKR, space_extension_y = DMX2_BEOLBLKE }, 
    { DM3EXCL_FINAL, min_space_x = DMX2_DMXEXCLR, min_space_y = DMX2_DMXEXCLE, space_extension_x = DMX2_DMXEXCLR, space_extension_y = DMX2_DMXEXCLE }, 
    { CSR66_3485, min_space_x = DMX2_BEOLBLKR, min_space_y = DMX2_BEOLBLKE, space_extension_x = DMX2_BEOLBLKR, space_extension_y = DMX2_BEOLBLKE },
    { INDDMY, min_space = DM_INDDMY },
    { TCDDMY_M3, min_space = DMX2_TCDDMY_MX },
    { M3_HOLE, min_space = 0 },
    { M3_45, min_space = 0 },
    { ICOVL_SINGLE, min_space = DMX2_ICOVL },
#ifdef VERTICAL_M3
    { M3_MAIN, min_space_x = DMX2OR_SC_MXX, min_space_y = DMX2OR_SC_MXY, space_extension_x = DMX2OR_SC_MXX, space_extension_y = DMX2OR_SC_MXY },
#else
    { M3_MAIN, min_space_x = DMX2OR_SC_MXY, min_space_y = DMX2OR_SC_MXX, space_extension_x = DMX2OR_SC_MXY, space_extension_y = DMX2OR_SC_MXX },
#endif
#ifdef VERTICAL_M3
    { DM3_O, min_space_x = DMX2OR_DMX_O_X, min_space_y = DMX2OR_DMX_O_Y, space_extension_x = DMX2OR_DMX_O_X, space_extension_y = DMX2OR_DMX_O_Y },
    { DM3, min_space_x = DMX2OR_DMX_X, min_space_y = DMX2OR_DMX_Y, space_extension_x = DMX2OR_DMX_X, space_extension_y = DMX2OR_DMX_Y },
#else
    { DM3_O, min_space_x = DMX2OR_DMX_O_Y, min_space_y = DMX2OR_DMX_O_X, space_extension_x = DMX2OR_DMX_O_Y, space_extension_y = DMX2OR_DMX_O_X },
    { DM3, min_space_x = DMX2OR_DMX_Y, min_space_y = DMX2OR_DMX_X, space_extension_x = DMX2OR_DMX_Y, space_extension_y = DMX2OR_DMX_X },
#endif
    { VIA2, min_space = 0.06 },
#ifdef VERTICAL_M3
    { M3_HVN_096V, min_space_x = DMX2_MX096V, min_space_y = DMX2OR_SC_MXY, space_extension_x = DMX2_MX096V, space_extension_y = DMX2OR_SC_MXY },
    { M3_HVN_132V, min_space_x = DMX2_MX132V, min_space_y = DMX2OR_SC_MXY, space_extension_x = DMX2_MX132V, space_extension_y = DMX2OR_SC_MXY },
    { M3_HVN_165V, min_space_x = DMX2_MX165V, min_space_y = DMX2OR_SC_MXY, space_extension_x = DMX2_MX165V, space_extension_y = DMX2OR_SC_MXY },
    { M3_HVN_198V, min_space_x = DMX2_MX198V, min_space_y = DMX2OR_SC_MXY, space_extension_x = DMX2_MX198V, space_extension_y = DMX2OR_SC_MXY },
    { M3_HVN_275V, min_space_x = DMX2_MX275V, min_space_y = DMX2OR_SC_MXY, space_extension_x = DMX2_MX275V, space_extension_y = DMX2OR_SC_MXY },
#else
    { M3_HVN_096V, min_space_x = DMX2OR_SC_MXY, min_space_y = DMX2_MX096V, space_extension_x = DMX2OR_SC_MXY, space_extension_y = DMX2_MX096V },
    { M3_HVN_132V, min_space_x = DMX2OR_SC_MXY, min_space_y = DMX2_MX132V, space_extension_x = DMX2OR_SC_MXY, space_extension_y = DMX2_MX132V },
    { M3_HVN_165V, min_space_x = DMX2OR_SC_MXY, min_space_y = DMX2_MX165V, space_extension_x = DMX2OR_SC_MXY, space_extension_y = DMX2_MX165V },
    { M3_HVN_198V, min_space_x = DMX2OR_SC_MXY, min_space_y = DMX2_MX198V, space_extension_x = DMX2OR_SC_MXY, space_extension_y = DMX2_MX198V },
    { M3_HVN_275V, min_space_x = DMX2OR_SC_MXY, min_space_y = DMX2_MX275V, space_extension_x = DMX2OR_SC_MXY, space_extension_y = DMX2_MX275V },
#endif
    { VIA2_HVN_096V, min_space = DMX2_VX096V },
    { VIA2_HVN_132V, min_space = DMX2_VX132V },
    { VIA2_HVN_165V, min_space = DMX2_VX165V },
    { VIA2_HVN_198V, min_space = DMX2_VX198V },
    { VIA2_HVN_275V, min_space = DMX2_VX275V },
    { VIA3_HVN_096V, min_space = DMX2_VX096V },
    { VIA3_HVN_132V, min_space = DMX2_VX132V },
    { VIA3_HVN_165V, min_space = DMX2_VX165V },
    { VIA3_HVN_198V, min_space = DMX2_VX198V },
    { VIA3_HVN_275V, min_space = DMX2_VX275V },

#ifdef VERTICAL_M3
    { M3_MAIN_LE, min_space_y = 0.06, space_extension_x = 0.06, projection = CORNER }, 
#else
    { M3_MAIN_LE, min_space_x = 0.06, space_extension_y = 0.06, projection = CORNER },
#endif
#ifdef VERTICAL_M3
    { M3_096V_LE, min_space_y = 0.09, space_extension_x = 0.042, projection = CORNER },
#else
    { M3_096V_LE, min_space_x = 0.09, space_extension_y = 0.042, projection = CORNER },
#endif
#ifdef VERTICAL_M3
    { M3_096V_LE, min_space_y = 0.042, space_extension_x = 0.09, projection = CORNER },
#else
    { M3_096V_LE, min_space_x = 0.042, space_extension_y = 0.09, projection = CORNER },
#endif
#ifdef VERTICAL_M3
    { M3_198V_LE, min_space_y = 0.09, space_extension_x = 0.061, projection = CORNER },
#else
    { M3_198V_LE, min_space_x = 0.09, space_extension_y = 0.061, projection = CORNER },
#endif
#ifdef VERTICAL_M3
    { M3_198V_LE, min_space_y = 0.061, space_extension_x = 0.09, projection = CORNER },
#else
    { M3_198V_LE, min_space_x = 0.061, space_extension_y = 0.09, projection = CORNER },
#endif
//===================================================
// DUMMY SPEC : WIDTH_SC_M3
    { M3_WRAP, width_based_spacing = {
                               { >= 0.000, { >=  DMX2OR_SC_MXX}},
                               { >= 0.012, { >=  DMX2OR_SC_MXX}}, }, color_aware_to_fill = ALL },
#ifdef VERTICAL_M3
    { M3_HVN_096VP, min_space_x = DMX2_MX096V, min_space_y = DMX2OR_SC_MXY, space_extension_x = DMX2_MX096V, space_extension_y = DMX2OR_SC_MXY },
    { M3_HVN_132VP, min_space_x = DMX2_MX132V, min_space_y = DMX2OR_SC_MXY, space_extension_x = DMX2_MX132V, space_extension_y = DMX2OR_SC_MXY },
    { M3_HVN_165VP, min_space_x = DMX2_MX165V, min_space_y = DMX2OR_SC_MXY, space_extension_x = DMX2_MX165V, space_extension_y = DMX2OR_SC_MXY },
    { M3_HVN_198VP, min_space_x = DMX2_MX198V, min_space_y = DMX2OR_SC_MXY, space_extension_x = DMX2_MX198V, space_extension_y = DMX2OR_SC_MXY },
    { M3_HVN_275VP, min_space_x = DMX2_MX275V, min_space_y = DMX2OR_SC_MXY, space_extension_x = DMX2_MX275V, space_extension_y = DMX2OR_SC_MXY },
#else
    { M3_HVN_096VP, min_space_x = DMX2OR_SC_MXY, min_space_y = DMX2_MX096V, space_extension_x = DMX2OR_SC_MXY, space_extension_y = DMX2_MX096V },
    { M3_HVN_132VP, min_space_x = DMX2OR_SC_MXY, min_space_y = DMX2_MX132V, space_extension_x = DMX2OR_SC_MXY, space_extension_y = DMX2_MX132V },
    { M3_HVN_165VP, min_space_x = DMX2OR_SC_MXY, min_space_y = DMX2_MX165V, space_extension_x = DMX2OR_SC_MXY, space_extension_y = DMX2_MX165V },
    { M3_HVN_198VP, min_space_x = DMX2OR_SC_MXY, min_space_y = DMX2_MX198V, space_extension_x = DMX2OR_SC_MXY, space_extension_y = DMX2_MX198V },
    { M3_HVN_275VP, min_space_x = DMX2OR_SC_MXY, min_space_y = DMX2_MX275V, space_extension_x = DMX2OR_SC_MXY, space_extension_y = DMX2_MX275V },
#endif
    { VIA2_HVN_096VP, min_space = DMX2_VX096V },
    { VIA2_HVN_132VP, min_space = DMX2_VX132V },
    { VIA2_HVN_165VP, min_space = DMX2_VX165V },
    { VIA2_HVN_198VP, min_space = DMX2_VX198V },
    { VIA2_HVN_275VP, min_space = DMX2_VX275V },
    { VIA3_HVN_096VPT, min_space = DMX2_VX096V },
    { VIA3_HVN_132VPT, min_space = DMX2_VX132V },
    { VIA3_HVN_165VPT, min_space = DMX2_VX165V },
    { VIA3_HVN_198VPT, min_space = DMX2_VX198V },
    { VIA3_HVN_275VPT, min_space = DMX2_VX275V },

    { BLK_M3_EDGE, min_space_x = DMX2_DMXEXCLR, min_space_y = DMX2_DMXEXCLE, space_extension_x = DMX2_DMXEXCLR, space_extension_y = DMX2_DMXEXCLE },
    { M3_BOUNDARY_CLOSE, min_space = DMX2O_CHIPR },


}; //end of FSS_M3_WRAPSPEC
//===================================================
// DUMMY SPEC : M3_guideSpec
//===================================================
// DUMMY SPEC : M3_wrapSpec
PATTERN_M3_WRAPSPEC = get_single_linear_pattern(
    FSS_M3_WRAPSPEC,
    {
        { M3_WRAP, NO_COLOR },
        { DM3EXCL_FINAL, NO_COLOR },
        { BEOLBLK_FINAL, NO_COLOR },
        { M3_BOUNDARY_CLOSE, NO_COLOR },
#ifdef VERTICAL_M3
    { M3_HVN_096VP, NO_COLOR },
    { M3_HVN_132VP, NO_COLOR },
    { M3_HVN_165VP, NO_COLOR },
    { M3_HVN_198VP, NO_COLOR },
    { M3_HVN_275VP, NO_COLOR },
#else
    { M3_HVN_096VP, NO_COLOR },
    { M3_HVN_132VP, NO_COLOR },
    { M3_HVN_165VP, NO_COLOR },
    { M3_HVN_198VP, NO_COLOR },
    { M3_HVN_275VP, NO_COLOR },
#endif

    },
    0.125,
    "M3_WRAPSPEC",
#ifdef VERTICAL_M3
	VERTICAL, "M3VWRAP", DMX2OR_W, DMX2OR_W, DMX2OR_L, DMX2OR_L_MAX,
	0, 0, 0.020, DMX2OR_SY_SC, //for step checking
#else
	HORIZONTAL, "M3HWRAP", DMX2OR_W, DMX2OR_W, DMX2OR_L, DMX2OR_L_MAX,
	0, 0, DMX2OR_SY_SC, 0.020, //for step checking
#endif			
	12, SHRINK
);

PATTERN_M3_WRAPSPEC.polygon_fill.color = false;
PATTERN_M3_WRAPSPEC.polygon_fill.dpt_spacing = {};
PATTERN_M3_WRAPSPEC.polygon_fill.pattern_spec.pattern_spacing = {
#ifdef VERTICAL_M3
    allowed_spacing_x = { == 0.02, == 0.062, >= 0.083  },
    allowed_spacing_y = { >= DMX2OR_SY_SC },
    corner_extension_x = DMX2OR_SX_SC,
    corner_extension_y = DMX2OR_SY_SC,
#else
    allowed_spacing_y = { == 0.02, == 0.062, >= 0.083  },
    allowed_spacing_x = { >= DMX2OR_SY_SC },
    corner_extension_x = DMX2OR_SY_SC,
    corner_extension_y = DMX2OR_SX_SC,
#endif    
    extension = INTERSECTION,
};

PATTERN_M3_WRAPSPEC.polygon_fill.signal_linear.middle_fill_adjustment = NONE;

M3_WRAPSPEC = unified_fill(
	fill_patterns = { PATTERN_M3_WRAPSPEC },
	fill_boundary = {
	    layer = CHIP_snps,
	    type = LAYER,
	},
    boundary = ALIGN,
	grid = vGRID
);



//===================================================
WRAPPER_DM3_O_L = M3_WRAPSPEC["M3_WRAPSPEC"][0]; 
WRAPPER_DM3_O_C = WRAPPER_DM3_O_L;

#endif

#ifdef FILL_DM4

#ifdef VERTICAL_M4
CHIP_SHRINK_M4 = shrink( CHIP_snps, north = 0.4, south = 0.4 ); 

#ifdef FULL_CHIP
M4_BOUNDARY_CLOSE = edge_size( angle_edge( CHIP_BOUNDARY, == 90 ), outside = 0.014 ); 
M4_BOUNDARY_INSIDE = edge_size( angle_edge( CHIP_BOUNDARY, == 90 ), inside = CHIP_SHRINK_VALUEY1 ); 

#else
M4_BOUNDARY_CLOSE = edge_size( angle_edge( PRBOUNDARY, == 90 ), outside = 0.014 ); 
M4_BOUNDARY_INSIDE = edge_size( angle_edge( PRBOUNDARY, == 90 ), inside = CHIP_SHRINK_VALUEY1 ); 

#endif
#else
CHIP_SHRINK_M4 = shrink( CHIP_snps, east = 0.4, west = 0.4 ); 

#ifdef FULL_CHIP
M4_BOUNDARY_CLOSE = edge_size( angle_edge( CHIP_BOUNDARY, == 0 ), outside = 0.014 ); 
M4_BOUNDARY_INSIDE = edge_size( angle_edge( CHIP_BOUNDARY, == 0 ), inside = CHIP_SHRINK_VALUEY1 ); 

#else
M4_BOUNDARY_CLOSE = edge_size( angle_edge( PRBOUNDARY, == 0 ), outside = 0.014 ); 
M4_BOUNDARY_INSIDE = edge_size( angle_edge( PRBOUNDARY, == 0 ), inside = CHIP_SHRINK_VALUEY1 ); 

#endif
#endif
REGION_WRAPPER_DM4 = CHIP_SHRINK_M4 and or_list( { size( M4_MAIN, clip_acute = TRUNCATE, distance = WRAPPER_RANGEX1 ), (CHIP_snps not size( CHIP_snps, clip_acute = TRUNCATE, distance = - WRAPPER_RANGEX1 )), size( (BEOLBLK_FINAL or DM4EXCL_FINAL), clip_acute = TRUNCATE, distance = WRAPPER_RANGEX1 ), M4_BOUNDARY_INSIDE } ); 
M4_WRAP1    = (M4_MAIN not (DM4EXCL_FINAL or BEOLBLK_FINAL)) not_interacting (M4_BOUNDARY_INSIDE2 or M4_BLK_OUTSIDE);

#ifdef FULL_CHIP
M4_BOUNDARY_CLOSE_tmp = M4_BOUNDARY_CLOSE coincident_edge REGION_WRAPPER_DM4;
M4_BOUNDARY_CLOSE = edge_size(M4_BOUNDARY_CLOSE_tmp, inside = 0.014);
#endif




#ifdef VERTICAL_M4
M4_EDGE = angle_edge( M4_WRAP1, == 0 ); 
M4_PORJ = external1_error( M4_EDGE, <= ISLAND_SPACE_MX2, direction = VERTICAL, extension = NONE, look_thru = ALL, look_thru_count = < 1 ); 
BLK_M4_EDGE_PRE = edge_size( angle_edge( ( BEOLBLK_FINAL or DM4EXCL_FINAL ), == 90 ), inside = 0.0005 ); 
BLK_M4_EDGE = not_interacting( BLK_M4_EDGE_PRE, M4_BOUNDARY_INSIDE2 );
#else
M4_EDGE = angle_edge( M4_WRAP1, == 90 ); 
M4_PORJ = external1_error( M4_EDGE, <= ISLAND_SPACE_MX2, direction = HORIZONTAL, extension = NONE, look_thru = ALL, look_thru_count = < 1 ); 
BLK_M4_EDGE_PRE = edge_size( angle_edge( ( BEOLBLK_FINAL or DM4EXCL_FINAL ), == 0 ), inside = 0.0005 ); 
BLK_M4_EDGE = not_interacting( BLK_M4_EDGE_PRE, M4_BOUNDARY_INSIDE2 );
#endif

M4_MATCH = drc_features_error( primary_layer = M4_PORJ, secondary_layers = { "layer2" => M4_EDGE }, output_from_layer = M4_PORJ, include_touch = EDGE, drc_function = dfm_property_func_w, combine_errors = OPPOSING ); 
M4_WRAP2   = error_merge( M4_MATCH );
M4_WRAP    = M4_WRAP2 or M4_WRAP1;

// DUMMY SPEC : M4_SC_E
FSS_M4_WRAPSPEC: list of fill_to_signal_spacing_s = {
    { BEOLBLK_FINAL, min_space_x = DMX2_BEOLBLKE, min_space_y = DMX2_BEOLBLKR, space_extension_x = DMX2_BEOLBLKE, space_extension_y = DMX2_BEOLBLKR },
    { DM4EXCL_FINAL, min_space_x = DMX2_DMXEXCLE, min_space_y = DMX2_DMXEXCLR, space_extension_x = DMX2_DMXEXCLE, space_extension_y = DMX2_DMXEXCLR },
    { INDDMY, min_space = DM_INDDMY },
#ifdef VERTICAL_M4
    { BEOLBLK_FINAL, min_space = 0, min_space_y = 0.35 }, //for exclusion zone
    { DM4EXCL_FINAL, min_space = 0, min_space_y = 0.35 }, //for exclusion zone
#else
    { BEOLBLK_FINAL, min_space = 0, min_space_x = 0.35 }, //for exclusion zone
    { DM4EXCL_FINAL, min_space = 0, min_space_x = 0.35 }, //for exclusion zone
#endif

//===================================================
// DUMMY SPEC : M4_SC

    { REGION_WRAPPER_DM4, min_space = 0, context = INTERIOR },
    { CHIP_snps, min_space = 0, context = INTERIOR }, //RD CONFIRM
#ifdef FULL_CHIP
    { CHIP_BOUNDARY, min_space = 0, context = INTERIOR }, //RD CONFIRM
    { CHIP_FILLREGION_X2, min_space = 0, context = INTERIOR },
#else
    { PRBOUNDARY, min_space_x = DMX2O_CHIPE, min_space_y = DMX2O_CHIPR, context = INTERIOR },
#endif
    { MX2FORBIDDEN_CHIPMH, min_space = 0 },
    { BEOLBLK_FINAL, min_space_x = DMX2_BEOLBLKE, min_space_y = DMX2_BEOLBLKR, space_extension_x = DMX2_BEOLBLKE, space_extension_y = DMX2_BEOLBLKR }, 
    { DM4EXCL_FINAL, min_space_x = DMX2_DMXEXCLE, min_space_y = DMX2_DMXEXCLR, space_extension_x = DMX2_DMXEXCLE, space_extension_y = DMX2_DMXEXCLR },
    { CSR66_3485, min_space_x = DMX2_BEOLBLKE, min_space_y = DMX2_BEOLBLKR, space_extension_x = DMX2_BEOLBLKE, space_extension_y = DMX2_BEOLBLKR },
    { INDDMY, min_space = DM_INDDMY },
    { TCDDMY_M4, min_space = DMX2_TCDDMY_MX },
    { M4_HOLE, min_space = 0 },
    { M4_45, min_space = 0 },
    { ICOVL_SINGLE, min_space = DMX2_ICOVL },
#ifdef VERTICAL_M4
    { M4_MAIN, min_space_x = DMX2OR_SC_MXX, min_space_y = DMX2OR_SC_MXY, space_extension_x = DMX2OR_SC_MXX, space_extension_y = DMX2OR_SC_MXY },
#else
    { M4_MAIN, min_space_x = DMX2OR_SC_MXY, min_space_y = DMX2OR_SC_MXX, space_extension_x = DMX2OR_SC_MXY, space_extension_y = DMX2OR_SC_MXX },
#endif
#ifdef VERTICAL_M4
    { DM4_O, min_space_x = DMX2OR_DMX_O_X, min_space_y = DMX2OR_DMX_O_Y, space_extension_x = DMX2OR_DMX_O_X, space_extension_y = DMX2OR_DMX_O_Y },
    { DM4, min_space_x = DMX2OR_DMX_X, min_space_y = DMX2OR_DMX_Y, space_extension_x = DMX2OR_DMX_X, space_extension_y = DMX2OR_DMX_Y },
#else
    { DM4_O, min_space_x = DMX2OR_DMX_O_Y, min_space_y = DMX2OR_DMX_O_X, space_extension_x = DMX2OR_DMX_O_Y, space_extension_y = DMX2OR_DMX_O_X },
    { DM4, min_space_x = DMX2OR_DMX_Y, min_space_y = DMX2OR_DMX_X, space_extension_x = DMX2OR_DMX_Y, space_extension_y = DMX2OR_DMX_X },
#endif
    { VIA3, min_space = 0.06 },
#ifdef VERTICAL_M4
    { M4_HVN_096V, min_space_x = DMX2_MX096V, min_space_y = DMX2OR_SC_MXY, space_extension_x = DMX2_MX096V, space_extension_y = DMX2OR_SC_MXY },
    { M4_HVN_132V, min_space_x = DMX2_MX132V, min_space_y = DMX2OR_SC_MXY, space_extension_x = DMX2_MX132V, space_extension_y = DMX2OR_SC_MXY },
    { M4_HVN_165V, min_space_x = DMX2_MX165V, min_space_y = DMX2OR_SC_MXY, space_extension_x = DMX2_MX165V, space_extension_y = DMX2OR_SC_MXY },
    { M4_HVN_198V, min_space_x = DMX2_MX198V, min_space_y = DMX2OR_SC_MXY, space_extension_x = DMX2_MX198V, space_extension_y = DMX2OR_SC_MXY },
    { M4_HVN_275V, min_space_x = DMX2_MX275V, min_space_y = DMX2OR_SC_MXY, space_extension_x = DMX2_MX275V, space_extension_y = DMX2OR_SC_MXY },
#else
    { M4_HVN_096V, min_space_x = DMX2OR_SC_MXY, min_space_y = DMX2_MX096V, space_extension_x = DMX2OR_SC_MXY, space_extension_y = DMX2_MX096V },
    { M4_HVN_132V, min_space_x = DMX2OR_SC_MXY, min_space_y = DMX2_MX132V, space_extension_x = DMX2OR_SC_MXY, space_extension_y = DMX2_MX132V },
    { M4_HVN_165V, min_space_x = DMX2OR_SC_MXY, min_space_y = DMX2_MX165V, space_extension_x = DMX2OR_SC_MXY, space_extension_y = DMX2_MX165V },
    { M4_HVN_198V, min_space_x = DMX2OR_SC_MXY, min_space_y = DMX2_MX198V, space_extension_x = DMX2OR_SC_MXY, space_extension_y = DMX2_MX198V },
    { M4_HVN_275V, min_space_x = DMX2OR_SC_MXY, min_space_y = DMX2_MX275V, space_extension_x = DMX2OR_SC_MXY, space_extension_y = DMX2_MX275V },
#endif
    { VIA3_HVN_096V, min_space = DMX2_VX096V },
    { VIA3_HVN_132V, min_space = DMX2_VX132V },
    { VIA3_HVN_165V, min_space = DMX2_VX165V },
    { VIA3_HVN_198V, min_space = DMX2_VX198V },
    { VIA3_HVN_275V, min_space = DMX2_VX275V },
    { VIA4_HVN_096V, min_space = DMX2_VX096V },
    { VIA4_HVN_132V, min_space = DMX2_VX132V },
    { VIA4_HVN_165V, min_space = DMX2_VX165V },
    { VIA4_HVN_198V, min_space = DMX2_VX198V },
    { VIA4_HVN_275V, min_space = DMX2_VX275V },

#ifdef VERTICAL_M4
    { M4_MAIN_LE, min_space_y = 0.06, space_extension_x = 0.06, projection = CORNER }, 
#else
    { M4_MAIN_LE, min_space_x = 0.06, space_extension_y = 0.06, projection = CORNER },
#endif
#ifdef VERTICAL_M4
    { M4_096V_LE, min_space_y = 0.09, space_extension_x = 0.042, projection = CORNER },
#else
    { M4_096V_LE, min_space_x = 0.09, space_extension_y = 0.042, projection = CORNER },
#endif
#ifdef VERTICAL_M4
    { M4_096V_LE, min_space_y = 0.042, space_extension_x = 0.09, projection = CORNER },
#else
    { M4_096V_LE, min_space_x = 0.042, space_extension_y = 0.09, projection = CORNER },
#endif
#ifdef VERTICAL_M4
    { M4_198V_LE, min_space_y = 0.09, space_extension_x = 0.061, projection = CORNER },
#else
    { M4_198V_LE, min_space_x = 0.09, space_extension_y = 0.061, projection = CORNER },
#endif
#ifdef VERTICAL_M4
    { M4_198V_LE, min_space_y = 0.061, space_extension_x = 0.09, projection = CORNER },
#else
    { M4_198V_LE, min_space_x = 0.061, space_extension_y = 0.09, projection = CORNER },
#endif
//===================================================
// DUMMY SPEC : WIDTH_SC_M4
    { M4_WRAP, width_based_spacing = {
                               { >= 0.000, { >=  DMX2OR_SC_MXX}},
                               { >= 0.012, { >=  DMX2OR_SC_MXX}}, }, color_aware_to_fill = ALL },
#ifdef VERTICAL_M4
    { M4_HVN_096VP, min_space_x = DMX2_MX096V, min_space_y = DMX2OR_SC_MXY, space_extension_x = DMX2_MX096V, space_extension_y = DMX2OR_SC_MXY },
    { M4_HVN_132VP, min_space_x = DMX2_MX132V, min_space_y = DMX2OR_SC_MXY, space_extension_x = DMX2_MX132V, space_extension_y = DMX2OR_SC_MXY },
    { M4_HVN_165VP, min_space_x = DMX2_MX165V, min_space_y = DMX2OR_SC_MXY, space_extension_x = DMX2_MX165V, space_extension_y = DMX2OR_SC_MXY },
    { M4_HVN_198VP, min_space_x = DMX2_MX198V, min_space_y = DMX2OR_SC_MXY, space_extension_x = DMX2_MX198V, space_extension_y = DMX2OR_SC_MXY },
    { M4_HVN_275VP, min_space_x = DMX2_MX275V, min_space_y = DMX2OR_SC_MXY, space_extension_x = DMX2_MX275V, space_extension_y = DMX2OR_SC_MXY },
#else
    { M4_HVN_096VP, min_space_x = DMX2OR_SC_MXY, min_space_y = DMX2_MX096V, space_extension_x = DMX2OR_SC_MXY, space_extension_y = DMX2_MX096V },
    { M4_HVN_132VP, min_space_x = DMX2OR_SC_MXY, min_space_y = DMX2_MX132V, space_extension_x = DMX2OR_SC_MXY, space_extension_y = DMX2_MX132V },
    { M4_HVN_165VP, min_space_x = DMX2OR_SC_MXY, min_space_y = DMX2_MX165V, space_extension_x = DMX2OR_SC_MXY, space_extension_y = DMX2_MX165V },
    { M4_HVN_198VP, min_space_x = DMX2OR_SC_MXY, min_space_y = DMX2_MX198V, space_extension_x = DMX2OR_SC_MXY, space_extension_y = DMX2_MX198V },
    { M4_HVN_275VP, min_space_x = DMX2OR_SC_MXY, min_space_y = DMX2_MX275V, space_extension_x = DMX2OR_SC_MXY, space_extension_y = DMX2_MX275V },
#endif
    { VIA3_HVN_096VP, min_space = DMX2_VX096V },
    { VIA3_HVN_132VP, min_space = DMX2_VX132V },
    { VIA3_HVN_165VP, min_space = DMX2_VX165V },
    { VIA3_HVN_198VP, min_space = DMX2_VX198V },
    { VIA3_HVN_275VP, min_space = DMX2_VX275V },
    { VIA4_HVN_096VPT, min_space = DMX2_VX096V },
    { VIA4_HVN_132VPT, min_space = DMX2_VX132V },
    { VIA4_HVN_165VPT, min_space = DMX2_VX165V },
    { VIA4_HVN_198VPT, min_space = DMX2_VX198V },
    { VIA4_HVN_275VPT, min_space = DMX2_VX275V },

    { BLK_M4_EDGE, min_space_x = DMX2_DMXEXCLE, min_space_y = DMX2_DMXEXCLR, space_extension_x = DMX2_DMXEXCLE, space_extension_y = DMX2_DMXEXCLR },
    { M4_BOUNDARY_CLOSE, min_space = DMX2O_CHIPR },


}; //end of FSS_M4_WRAPSPEC
//===================================================
// DUMMY SPEC : M4_guideSpec
//===================================================
// DUMMY SPEC : M4_wrapSpec
PATTERN_M4_WRAPSPEC = get_single_linear_pattern(
    FSS_M4_WRAPSPEC,
    {
        { M4_WRAP, NO_COLOR },
        { DM4EXCL_FINAL, NO_COLOR },
        { BEOLBLK_FINAL, NO_COLOR },
        { M4_BOUNDARY_CLOSE, NO_COLOR },
#ifdef VERTICAL_M4
    { M4_HVN_096VP, NO_COLOR },
    { M4_HVN_132VP, NO_COLOR },
    { M4_HVN_165VP, NO_COLOR },
    { M4_HVN_198VP, NO_COLOR },
    { M4_HVN_275VP, NO_COLOR },
#else
    { M4_HVN_096VP, NO_COLOR },
    { M4_HVN_132VP, NO_COLOR },
    { M4_HVN_165VP, NO_COLOR },
    { M4_HVN_198VP, NO_COLOR },
    { M4_HVN_275VP, NO_COLOR },
#endif

    },
    0.125,
    "M4_WRAPSPEC",
#ifdef VERTICAL_M4
	VERTICAL, "M4VWRAP", DMX2OR_W, DMX2OR_W, DMX2OR_L, DMX2OR_L_MAX,
	0, 0, 0.020, DMX2OR_SY_SC, //for step checking
#else
	HORIZONTAL, "M4HWRAP", DMX2OR_W, DMX2OR_W, DMX2OR_L, DMX2OR_L_MAX,
	0, 0, DMX2OR_SY_SC, 0.020, //for step checking
#endif			
	12, SHRINK
);

PATTERN_M4_WRAPSPEC.polygon_fill.color = false;
PATTERN_M4_WRAPSPEC.polygon_fill.dpt_spacing = {};
PATTERN_M4_WRAPSPEC.polygon_fill.pattern_spec.pattern_spacing = {
#ifdef VERTICAL_M4
    allowed_spacing_x = { == 0.02, == 0.062, >= 0.083  },
    allowed_spacing_y = { >= DMX2OR_SY_SC },
    corner_extension_x = DMX2OR_SX_SC,
    corner_extension_y = DMX2OR_SY_SC,
#else
    allowed_spacing_y = { == 0.02, == 0.062, >= 0.083  },
    allowed_spacing_x = { >= DMX2OR_SY_SC },
    corner_extension_x = DMX2OR_SY_SC,
    corner_extension_y = DMX2OR_SX_SC,
#endif    
    extension = INTERSECTION,
};

PATTERN_M4_WRAPSPEC.polygon_fill.signal_linear.middle_fill_adjustment = NONE;

M4_WRAPSPEC = unified_fill(
	fill_patterns = { PATTERN_M4_WRAPSPEC },
	fill_boundary = {
	    layer = CHIP_snps,
	    type = LAYER,
	},
    boundary = ALIGN,
	grid = vGRID
);



//===================================================
WRAPPER_DM4_O_L = M4_WRAPSPEC["M4_WRAPSPEC"][0]; 
WRAPPER_DM4_O_C = WRAPPER_DM4_O_L;

#endif

#ifdef FILL_DM5
//***** filling region *********************************************************
#ifdef VERTICAL_M5
CHIP_SHRINK_M5 = shrink( CHIP_snps, north = CHIP_SHRINK_VALUEX3, south = CHIP_SHRINK_VALUEX3 );
#ifdef FULL_CHIP
M5_BOUNDARY_CLOSE  = edge_size(angle_edge( CHIP_BOUNDARY, == 90), outside = 0.02 );
M5_BOUNDARY_INSIDE = edge_size(angle_edge( CHIP_BOUNDARY, == 90), inside = CHIP_SHRINK_VALUEY2 );
#else
M5_BOUNDARY_CLOSE  = edge_size(angle_edge(PRBOUNDARY, == 90), outside = 0.02 );
M5_BOUNDARY_INSIDE = edge_size(angle_edge(PRBOUNDARY, == 90), inside = CHIP_SHRINK_VALUEY2 );
#endif
#else
CHIP_SHRINK_M5 = shrink( CHIP_snps, east = CHIP_SHRINK_VALUEX3, west = CHIP_SHRINK_VALUEX3 );
#ifdef FULL_CHIP
M5_BOUNDARY_CLOSE  = edge_size(angle_edge( CHIP_BOUNDARY, == 0), outside = 0.02 );
M5_BOUNDARY_INSIDE = edge_size(angle_edge( CHIP_BOUNDARY, == 0), inside = CHIP_SHRINK_VALUEY2 );
#else
M5_BOUNDARY_CLOSE  = edge_size(angle_edge( PRBOUNDARY, == 0), outside = 0.02 );
M5_BOUNDARY_INSIDE = edge_size(angle_edge( PRBOUNDARY, == 0), inside = CHIP_SHRINK_VALUEY2 );
#endif
#endif
REGION_WRAPPER_DM5 = CHIP_SHRINK_M5 and or_list( {
    over_size( M5_MAIN, WRAPPER_RANGEX3),
    (CHIP_snps not over_size( CHIP_snps, -WRAPPER_RANGEX3)),
    over_size( (BEOLBLK_FINAL or DM5EXCL_FINAL), WRAPPER_RANGEX3),
    M5_BOUNDARY_INSIDE } );

#ifdef FULL_CHIP
M5_BOUNDARY_CLOSE_tmp = M5_BOUNDARY_CLOSE coincident_edge REGION_WRAPPER_DM5;
M5_BOUNDARY_CLOSE = edge_size(M5_BOUNDARY_CLOSE_tmp, inside = 0.02);
#endif

M5CA_WRAP1 = M5_MAIN_CA not (M5_GE260 or DM5EXCL_FINAL or BEOLBLK_FINAL);
M5CB_WRAP1 = M5_MAIN_CB not (M5_GE260 or DM5EXCL_FINAL or BEOLBLK_FINAL);

macroLAYER_36 = wide( M5CA_WRAP1, > 0.02, forty_five = INTERNAL ); 
macroLAYER_37 = wide( M5CA_WRAP1, >= 0.02, forty_five = INTERNAL ); 
M5CA_WRAP20_WIDTH = not( macroLAYER_37, macroLAYER_36 ); 

#ifdef VERTICAL_M5
M5CA_WRAP20_EDGE = angle_edge( M5CA_WRAP20_WIDTH, == 0 ); 
#else
M5CA_WRAP20_EDGE = angle_edge( M5CA_WRAP20_WIDTH, == 90 ); 
#endif
M5CA_WRAP20_PRE = external1( M5CA_WRAP20_EDGE, <= ISLAND_SPACE, extension = NONE, intersecting = {  }, look_thru = NOT_ADJACENT, orientation = { PARALLEL }, projection_length = == 0.02 ); 
M5CA_WRAP20_OTHER = not_interacting( M5I, M5CA_WRAP20_WIDTH ); 
M5CA_WRAP20_ISLAND = not_interacting( M5CA_WRAP20_PRE, M5CA_WRAP20_OTHER ); 
M5CA_WRAP20_BIG_EXT = external2( M5_260_BIG, M5CA_WRAP20_EDGE, <= LINEEND_RET, edge_containment = OUTSIDE, extension = NONE, intersecting = {  }, look_thru = NOT_ADJACENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
macroLAYER_32 = M5CA_WRAP20_BIG_EXT not M5_260_SIZE; 
macroLAYER_31 = interacting( macroLAYER_32, M5I, == 1 ); 
macroLAYER_30 = not_interacting( macroLAYER_31, DM5_O ); 
macroLAYER_38 = wide( macroLAYER_30, > 0.02, forty_five = INTERNAL );
macroLAYER_39 = wide( macroLAYER_30, >= 0.02, forty_five = INTERNAL );
M5CA_WRAP20_LINEEND_R = not( macroLAYER_39, macroLAYER_38 ); 
M5CA_WRAP20 = M5CA_WRAP20_ISLAND or M5CA_WRAP20_LINEEND_R;

macroLAYER_36 = wide( M5CA_WRAP1, > 0.022, forty_five = INTERNAL ); 
macroLAYER_37 = wide( M5CA_WRAP1, >= 0.022, forty_five = INTERNAL ); 
M5CA_WRAP22_WIDTH = not( macroLAYER_37, macroLAYER_36 ); 

#ifdef VERTICAL_M5
M5CA_WRAP22_EDGE = angle_edge( M5CA_WRAP22_WIDTH, == 0 ); 
#else
M5CA_WRAP22_EDGE = angle_edge( M5CA_WRAP22_WIDTH, == 90 ); 
#endif
M5CA_WRAP22_PRE = external1( M5CA_WRAP22_EDGE, <= ISLAND_SPACE, extension = NONE, intersecting = {  }, look_thru = NOT_ADJACENT, orientation = { PARALLEL }, projection_length = == 0.022 ); 
M5CA_WRAP22_OTHER = not_interacting( M5I, M5CA_WRAP22_WIDTH ); 
M5CA_WRAP22_ISLAND = not_interacting( M5CA_WRAP22_PRE, M5CA_WRAP22_OTHER ); 
M5CA_WRAP22_BIG_EXT = external2( M5_260_BIG, M5CA_WRAP22_EDGE, <= LINEEND_RET, edge_containment = OUTSIDE, extension = NONE, intersecting = {  }, look_thru = NOT_ADJACENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
macroLAYER_32 = M5CA_WRAP22_BIG_EXT not M5_260_SIZE; 
macroLAYER_31 = interacting( macroLAYER_32, M5I, == 1 ); 
macroLAYER_30 = not_interacting( macroLAYER_31, DM5_O ); 
macroLAYER_38 = wide( macroLAYER_30, > 0.022, forty_five = INTERNAL );
macroLAYER_39 = wide( macroLAYER_30, >= 0.022, forty_five = INTERNAL );
M5CA_WRAP22_LINEEND_R = not( macroLAYER_39, macroLAYER_38 ); 
M5CA_WRAP22 = M5CA_WRAP22_ISLAND or M5CA_WRAP22_LINEEND_R;

macroLAYER_36 = wide( M5CA_WRAP1, > 0.024, forty_five = INTERNAL ); 
macroLAYER_37 = wide( M5CA_WRAP1, >= 0.024, forty_five = INTERNAL ); 
M5CA_WRAP24_WIDTH = not( macroLAYER_37, macroLAYER_36 ); 

#ifdef VERTICAL_M5
M5CA_WRAP24_EDGE = angle_edge( M5CA_WRAP24_WIDTH, == 0 ); 
#else
M5CA_WRAP24_EDGE = angle_edge( M5CA_WRAP24_WIDTH, == 90 ); 
#endif
M5CA_WRAP24_PRE = external1( M5CA_WRAP24_EDGE, <= ISLAND_SPACE, extension = NONE, intersecting = {  }, look_thru = NOT_ADJACENT, orientation = { PARALLEL }, projection_length = == 0.024 ); 
M5CA_WRAP24_OTHER = not_interacting( M5I, M5CA_WRAP24_WIDTH ); 
M5CA_WRAP24_ISLAND = not_interacting( M5CA_WRAP24_PRE, M5CA_WRAP24_OTHER ); 
M5CA_WRAP24_BIG_EXT = external2( M5_260_BIG, M5CA_WRAP24_EDGE, <= LINEEND_RET, edge_containment = OUTSIDE, extension = NONE, intersecting = {  }, look_thru = NOT_ADJACENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
macroLAYER_32 = M5CA_WRAP24_BIG_EXT not M5_260_SIZE; 
macroLAYER_31 = interacting( macroLAYER_32, M5I, == 1 ); 
macroLAYER_30 = not_interacting( macroLAYER_31, DM5_O ); 
macroLAYER_38 = wide( macroLAYER_30, > 0.024, forty_five = INTERNAL );
macroLAYER_39 = wide( macroLAYER_30, >= 0.024, forty_five = INTERNAL );
M5CA_WRAP24_LINEEND_R = not( macroLAYER_39, macroLAYER_38 ); 
M5CA_WRAP24 = M5CA_WRAP24_ISLAND or M5CA_WRAP24_LINEEND_R;

macroLAYER_36 = wide( M5CA_WRAP1, > 0.026, forty_five = INTERNAL ); 
macroLAYER_37 = wide( M5CA_WRAP1, >= 0.026, forty_five = INTERNAL ); 
M5CA_WRAP26_WIDTH = not( macroLAYER_37, macroLAYER_36 ); 

#ifdef VERTICAL_M5
M5CA_WRAP26_EDGE = angle_edge( M5CA_WRAP26_WIDTH, == 0 ); 
#else
M5CA_WRAP26_EDGE = angle_edge( M5CA_WRAP26_WIDTH, == 90 ); 
#endif
M5CA_WRAP26_PRE = external1( M5CA_WRAP26_EDGE, <= ISLAND_SPACE, extension = NONE, intersecting = {  }, look_thru = NOT_ADJACENT, orientation = { PARALLEL }, projection_length = == 0.026 ); 
M5CA_WRAP26_OTHER = not_interacting( M5I, M5CA_WRAP26_WIDTH ); 
M5CA_WRAP26_ISLAND = not_interacting( M5CA_WRAP26_PRE, M5CA_WRAP26_OTHER ); 
M5CA_WRAP26_BIG_EXT = external2( M5_260_BIG, M5CA_WRAP26_EDGE, <= LINEEND_RET, edge_containment = OUTSIDE, extension = NONE, intersecting = {  }, look_thru = NOT_ADJACENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
macroLAYER_32 = M5CA_WRAP26_BIG_EXT not M5_260_SIZE; 
macroLAYER_31 = interacting( macroLAYER_32, M5I, == 1 ); 
macroLAYER_30 = not_interacting( macroLAYER_31, DM5_O ); 
macroLAYER_38 = wide( macroLAYER_30, > 0.026, forty_five = INTERNAL );
macroLAYER_39 = wide( macroLAYER_30, >= 0.026, forty_five = INTERNAL );
M5CA_WRAP26_LINEEND_R = not( macroLAYER_39, macroLAYER_38 ); 
M5CA_WRAP26 = M5CA_WRAP26_ISLAND or M5CA_WRAP26_LINEEND_R;

macroLAYER_36 = wide( M5CA_WRAP1, > 0.036, forty_five = INTERNAL ); 
macroLAYER_37 = wide( M5CA_WRAP1, >= 0.036, forty_five = INTERNAL ); 
M5CA_WRAP36_WIDTH = not( macroLAYER_37, macroLAYER_36 ); 

#ifdef VERTICAL_M5
M5CA_WRAP36_EDGE = angle_edge( M5CA_WRAP36_WIDTH, == 0 ); 
#else
M5CA_WRAP36_EDGE = angle_edge( M5CA_WRAP36_WIDTH, == 90 ); 
#endif
M5CA_WRAP36_PRE = external1( M5CA_WRAP36_EDGE, <= ISLAND_SPACE, extension = NONE, intersecting = {  }, look_thru = NOT_ADJACENT, orientation = { PARALLEL }, projection_length = == 0.036 ); 
M5CA_WRAP36_OTHER = not_interacting( M5I, M5CA_WRAP36_WIDTH ); 
M5CA_WRAP36_ISLAND = not_interacting( M5CA_WRAP36_PRE, M5CA_WRAP36_OTHER ); 
M5CA_WRAP36_BIG_EXT = external2( M5_260_BIG, M5CA_WRAP36_EDGE, <= LINEEND_RET, edge_containment = OUTSIDE, extension = NONE, intersecting = {  }, look_thru = NOT_ADJACENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
macroLAYER_32 = M5CA_WRAP36_BIG_EXT not M5_260_SIZE; 
macroLAYER_31 = interacting( macroLAYER_32, M5I, == 1 ); 
macroLAYER_30 = not_interacting( macroLAYER_31, DM5_O ); 
macroLAYER_38 = wide( macroLAYER_30, > 0.036, forty_five = INTERNAL );
macroLAYER_39 = wide( macroLAYER_30, >= 0.036, forty_five = INTERNAL );
M5CA_WRAP36_LINEEND_R = not( macroLAYER_39, macroLAYER_38 ); 
M5CA_WRAP36 = M5CA_WRAP36_ISLAND or M5CA_WRAP36_LINEEND_R;

macroLAYER_36 = wide( M5CA_WRAP1, > 0.040, forty_five = INTERNAL ); 
macroLAYER_37 = wide( M5CA_WRAP1, >= 0.040, forty_five = INTERNAL ); 
M5CA_WRAP40_WIDTH = not( macroLAYER_37, macroLAYER_36 ); 

#ifdef VERTICAL_M5
M5CA_WRAP40_EDGE = angle_edge( M5CA_WRAP40_WIDTH, == 0 ); 
#else
M5CA_WRAP40_EDGE = angle_edge( M5CA_WRAP40_WIDTH, == 90 ); 
#endif
M5CA_WRAP40_PRE = external1( M5CA_WRAP40_EDGE, <= ISLAND_SPACE, extension = NONE, intersecting = {  }, look_thru = NOT_ADJACENT, orientation = { PARALLEL }, projection_length = == 0.040 ); 
M5CA_WRAP40_OTHER = not_interacting( M5I, M5CA_WRAP40_WIDTH ); 
M5CA_WRAP40_ISLAND = not_interacting( M5CA_WRAP40_PRE, M5CA_WRAP40_OTHER ); 
M5CA_WRAP40_BIG_EXT = external2( M5_260_BIG, M5CA_WRAP40_EDGE, <= LINEEND_RET, edge_containment = OUTSIDE, extension = NONE, intersecting = {  }, look_thru = NOT_ADJACENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
macroLAYER_32 = M5CA_WRAP40_BIG_EXT not M5_260_SIZE; 
macroLAYER_31 = interacting( macroLAYER_32, M5I, == 1 ); 
macroLAYER_30 = not_interacting( macroLAYER_31, DM5_O ); 
macroLAYER_38 = wide( macroLAYER_30, > 0.040, forty_five = INTERNAL );
macroLAYER_39 = wide( macroLAYER_30, >= 0.040, forty_five = INTERNAL );
M5CA_WRAP40_LINEEND_R = not( macroLAYER_39, macroLAYER_38 ); 
M5CA_WRAP40 = M5CA_WRAP40_ISLAND or M5CA_WRAP40_LINEEND_R;

macroLAYER_36 = wide( M5CA_WRAP1, > 0.060, forty_five = INTERNAL ); 
macroLAYER_37 = wide( M5CA_WRAP1, >= 0.060, forty_five = INTERNAL ); 
M5CA_WRAP60_WIDTH = not( macroLAYER_37, macroLAYER_36 ); 

#ifdef VERTICAL_M5
M5CA_WRAP60_EDGE = angle_edge( M5CA_WRAP60_WIDTH, == 0 ); 
#else
M5CA_WRAP60_EDGE = angle_edge( M5CA_WRAP60_WIDTH, == 90 ); 
#endif
M5CA_WRAP60_PRE = external1( M5CA_WRAP60_EDGE, <= ISLAND_SPACE, extension = NONE, intersecting = {  }, look_thru = NOT_ADJACENT, orientation = { PARALLEL }, projection_length = == 0.060 ); 
M5CA_WRAP60_OTHER = not_interacting( M5I, M5CA_WRAP60_WIDTH ); 
M5CA_WRAP60_ISLAND = not_interacting( M5CA_WRAP60_PRE, M5CA_WRAP60_OTHER ); 
M5CA_WRAP60_BIG_EXT = external2( M5_260_BIG, M5CA_WRAP60_EDGE, <= LINEEND_RET, edge_containment = OUTSIDE, extension = NONE, intersecting = {  }, look_thru = NOT_ADJACENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
macroLAYER_32 = M5CA_WRAP60_BIG_EXT not M5_260_SIZE; 
macroLAYER_31 = interacting( macroLAYER_32, M5I, == 1 ); 
macroLAYER_30 = not_interacting( macroLAYER_31, DM5_O ); 
macroLAYER_38 = wide( macroLAYER_30, > 0.060, forty_five = INTERNAL );
macroLAYER_39 = wide( macroLAYER_30, >= 0.060, forty_five = INTERNAL );
M5CA_WRAP60_LINEEND_R = not( macroLAYER_39, macroLAYER_38 ); 
M5CA_WRAP60 = M5CA_WRAP60_ISLAND or M5CA_WRAP60_LINEEND_R;

macroLAYER_36 = wide( M5CA_WRAP1, > 0.080, forty_five = INTERNAL ); 
macroLAYER_37 = wide( M5CA_WRAP1, >= 0.080, forty_five = INTERNAL ); 
M5CA_WRAP80_WIDTH = not( macroLAYER_37, macroLAYER_36 ); 

#ifdef VERTICAL_M5
M5CA_WRAP80_EDGE = angle_edge( M5CA_WRAP80_WIDTH, == 0 ); 
#else
M5CA_WRAP80_EDGE = angle_edge( M5CA_WRAP80_WIDTH, == 90 ); 
#endif
M5CA_WRAP80_PRE = external1( M5CA_WRAP80_EDGE, <= ISLAND_SPACE, extension = NONE, intersecting = {  }, look_thru = NOT_ADJACENT, orientation = { PARALLEL }, projection_length = == 0.080 ); 
M5CA_WRAP80_OTHER = not_interacting( M5I, M5CA_WRAP80_WIDTH ); 
M5CA_WRAP80_ISLAND = not_interacting( M5CA_WRAP80_PRE, M5CA_WRAP80_OTHER ); 
M5CA_WRAP80_BIG_EXT = external2( M5_260_BIG, M5CA_WRAP80_EDGE, <= LINEEND_RET, edge_containment = OUTSIDE, extension = NONE, intersecting = {  }, look_thru = NOT_ADJACENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
macroLAYER_32 = M5CA_WRAP80_BIG_EXT not M5_260_SIZE; 
macroLAYER_31 = interacting( macroLAYER_32, M5I, == 1 ); 
macroLAYER_30 = not_interacting( macroLAYER_31, DM5_O ); 
macroLAYER_38 = wide( macroLAYER_30, > 0.080, forty_five = INTERNAL );
macroLAYER_39 = wide( macroLAYER_30, >= 0.080, forty_five = INTERNAL );
M5CA_WRAP80_LINEEND_R = not( macroLAYER_39, macroLAYER_38 ); 
M5CA_WRAP80 = M5CA_WRAP80_ISLAND or M5CA_WRAP80_LINEEND_R;

macroLAYER_36 = wide( M5CA_WRAP1, > 0.100, forty_five = INTERNAL ); 
macroLAYER_37 = wide( M5CA_WRAP1, >= 0.100, forty_five = INTERNAL ); 
M5CA_WRAP100_WIDTH = not( macroLAYER_37, macroLAYER_36 ); 

#ifdef VERTICAL_M5
M5CA_WRAP100_EDGE = angle_edge( M5CA_WRAP100_WIDTH, == 0 ); 
#else
M5CA_WRAP100_EDGE = angle_edge( M5CA_WRAP100_WIDTH, == 90 ); 
#endif
M5CA_WRAP100_PRE = external1( M5CA_WRAP100_EDGE, <= ISLAND_SPACE, extension = NONE, intersecting = {  }, look_thru = NOT_ADJACENT, orientation = { PARALLEL }, projection_length = == 0.100 ); 
M5CA_WRAP100_OTHER = not_interacting( M5I, M5CA_WRAP100_WIDTH ); 
M5CA_WRAP100_ISLAND = not_interacting( M5CA_WRAP100_PRE, M5CA_WRAP100_OTHER ); 
M5CA_WRAP100_BIG_EXT = external2( M5_260_BIG, M5CA_WRAP100_EDGE, <= LINEEND_RET, edge_containment = OUTSIDE, extension = NONE, intersecting = {  }, look_thru = NOT_ADJACENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
macroLAYER_32 = M5CA_WRAP100_BIG_EXT not M5_260_SIZE; 
macroLAYER_31 = interacting( macroLAYER_32, M5I, == 1 ); 
macroLAYER_30 = not_interacting( macroLAYER_31, DM5_O ); 
macroLAYER_38 = wide( macroLAYER_30, > 0.100, forty_five = INTERNAL );
macroLAYER_39 = wide( macroLAYER_30, >= 0.100, forty_five = INTERNAL );
M5CA_WRAP100_LINEEND_R = not( macroLAYER_39, macroLAYER_38 ); 
M5CA_WRAP100 = M5CA_WRAP100_ISLAND or M5CA_WRAP100_LINEEND_R;

macroLAYER_36 = wide( M5CA_WRAP1, > 0.120, forty_five = INTERNAL ); 
macroLAYER_37 = wide( M5CA_WRAP1, >= 0.120, forty_five = INTERNAL ); 
M5CA_WRAP120_WIDTH = not( macroLAYER_37, macroLAYER_36 ); 

#ifdef VERTICAL_M5
M5CA_WRAP120_EDGE = angle_edge( M5CA_WRAP120_WIDTH, == 0 ); 
#else
M5CA_WRAP120_EDGE = angle_edge( M5CA_WRAP120_WIDTH, == 90 ); 
#endif
M5CA_WRAP120_PRE = external1( M5CA_WRAP120_EDGE, <= ISLAND_SPACE, extension = NONE, intersecting = {  }, look_thru = NOT_ADJACENT, orientation = { PARALLEL }, projection_length = == 0.120 ); 
M5CA_WRAP120_OTHER = not_interacting( M5I, M5CA_WRAP120_WIDTH ); 
M5CA_WRAP120_ISLAND = not_interacting( M5CA_WRAP120_PRE, M5CA_WRAP120_OTHER ); 
M5CA_WRAP120_BIG_EXT = external2( M5_260_BIG, M5CA_WRAP120_EDGE, <= LINEEND_RET, edge_containment = OUTSIDE, extension = NONE, intersecting = {  }, look_thru = NOT_ADJACENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
macroLAYER_32 = M5CA_WRAP120_BIG_EXT not M5_260_SIZE; 
macroLAYER_31 = interacting( macroLAYER_32, M5I, == 1 ); 
macroLAYER_30 = not_interacting( macroLAYER_31, DM5_O ); 
macroLAYER_38 = wide( macroLAYER_30, > 0.120, forty_five = INTERNAL );
macroLAYER_39 = wide( macroLAYER_30, >= 0.120, forty_five = INTERNAL );
M5CA_WRAP120_LINEEND_R = not( macroLAYER_39, macroLAYER_38 ); 
M5CA_WRAP120 = M5CA_WRAP120_ISLAND or M5CA_WRAP120_LINEEND_R;

macroLAYER_36 = wide( M5CA_WRAP1, > 0.140, forty_five = INTERNAL ); 
macroLAYER_37 = wide( M5CA_WRAP1, >= 0.140, forty_five = INTERNAL ); 
M5CA_WRAP140_WIDTH = not( macroLAYER_37, macroLAYER_36 ); 

#ifdef VERTICAL_M5
M5CA_WRAP140_EDGE = angle_edge( M5CA_WRAP140_WIDTH, == 0 ); 
#else
M5CA_WRAP140_EDGE = angle_edge( M5CA_WRAP140_WIDTH, == 90 ); 
#endif
M5CA_WRAP140_PRE = external1( M5CA_WRAP140_EDGE, <= ISLAND_SPACE, extension = NONE, intersecting = {  }, look_thru = NOT_ADJACENT, orientation = { PARALLEL }, projection_length = == 0.140 ); 
M5CA_WRAP140_OTHER = not_interacting( M5I, M5CA_WRAP140_WIDTH ); 
M5CA_WRAP140_ISLAND = not_interacting( M5CA_WRAP140_PRE, M5CA_WRAP140_OTHER ); 
M5CA_WRAP140_BIG_EXT = external2( M5_260_BIG, M5CA_WRAP140_EDGE, <= LINEEND_RET, edge_containment = OUTSIDE, extension = NONE, intersecting = {  }, look_thru = NOT_ADJACENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
macroLAYER_32 = M5CA_WRAP140_BIG_EXT not M5_260_SIZE; 
macroLAYER_31 = interacting( macroLAYER_32, M5I, == 1 ); 
macroLAYER_30 = not_interacting( macroLAYER_31, DM5_O ); 
macroLAYER_38 = wide( macroLAYER_30, > 0.140, forty_five = INTERNAL );
macroLAYER_39 = wide( macroLAYER_30, >= 0.140, forty_five = INTERNAL );
M5CA_WRAP140_LINEEND_R = not( macroLAYER_39, macroLAYER_38 ); 
M5CA_WRAP140 = M5CA_WRAP140_ISLAND or M5CA_WRAP140_LINEEND_R;

macroLAYER_36 = wide( M5CA_WRAP1, > 0.180, forty_five = INTERNAL ); 
macroLAYER_37 = wide( M5CA_WRAP1, >= 0.180, forty_five = INTERNAL ); 
M5CA_WRAP180_WIDTH = not( macroLAYER_37, macroLAYER_36 ); 

#ifdef VERTICAL_M5
M5CA_WRAP180_EDGE = angle_edge( M5CA_WRAP180_WIDTH, == 0 ); 
#else
M5CA_WRAP180_EDGE = angle_edge( M5CA_WRAP180_WIDTH, == 90 ); 
#endif
M5CA_WRAP180_PRE = external1( M5CA_WRAP180_EDGE, <= 0.7, extension = NONE, intersecting = {  }, look_thru = NOT_ADJACENT, orientation = { PARALLEL }, projection_length = == 0.180 ); 
M5CA_WRAP180_OTHER = not_interacting( M5I, M5CA_WRAP180_WIDTH ); 
M5CA_WRAP180_ISLAND = not_interacting( M5CA_WRAP180_PRE, M5CA_WRAP180_OTHER ); 
M5CA_WRAP180_BIG_EXT = external2( M5_260_BIG, M5CA_WRAP180_EDGE, <= LINEEND_RET, edge_containment = OUTSIDE, extension = NONE, intersecting = {  }, look_thru = NOT_ADJACENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
macroLAYER_32 = M5CA_WRAP180_BIG_EXT not M5_260_SIZE; 
macroLAYER_31 = interacting( macroLAYER_32, M5I, == 1 ); 
macroLAYER_30 = not_interacting( macroLAYER_31, DM5_O ); 
macroLAYER_38 = wide( macroLAYER_30, > 0.180, forty_five = INTERNAL );
macroLAYER_39 = wide( macroLAYER_30, >= 0.180, forty_five = INTERNAL );
M5CA_WRAP180_LINEEND_R = not( macroLAYER_39, macroLAYER_38 ); 
M5CA_WRAP180 = M5CA_WRAP180_ISLAND or M5CA_WRAP180_LINEEND_R;

macroLAYER_36 = wide( M5CA_WRAP1, > 0.200, forty_five = INTERNAL ); 
macroLAYER_37 = wide( M5CA_WRAP1, >= 0.200, forty_five = INTERNAL ); 
M5CA_WRAP200_WIDTH = not( macroLAYER_37, macroLAYER_36 ); 

#ifdef VERTICAL_M5
M5CA_WRAP200_EDGE = angle_edge( M5CA_WRAP200_WIDTH, == 0 ); 
#else
M5CA_WRAP200_EDGE = angle_edge( M5CA_WRAP200_WIDTH, == 90 ); 
#endif
M5CA_WRAP200_PRE = external1( M5CA_WRAP200_EDGE, <= 0.7, extension = NONE, intersecting = {  }, look_thru = NOT_ADJACENT, orientation = { PARALLEL }, projection_length = == 0.200 ); 
M5CA_WRAP200_OTHER = not_interacting( M5I, M5CA_WRAP200_WIDTH ); 
M5CA_WRAP200_ISLAND = not_interacting( M5CA_WRAP200_PRE, M5CA_WRAP200_OTHER ); 
M5CA_WRAP200_BIG_EXT = external2( M5_260_BIG, M5CA_WRAP200_EDGE, <= LINEEND_RET, edge_containment = OUTSIDE, extension = NONE, intersecting = {  }, look_thru = NOT_ADJACENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
macroLAYER_32 = M5CA_WRAP200_BIG_EXT not M5_260_SIZE; 
macroLAYER_31 = interacting( macroLAYER_32, M5I, == 1 ); 
macroLAYER_30 = not_interacting( macroLAYER_31, DM5_O ); 
macroLAYER_38 = wide( macroLAYER_30, > 0.200, forty_five = INTERNAL );
macroLAYER_39 = wide( macroLAYER_30, >= 0.200, forty_five = INTERNAL );
M5CA_WRAP200_LINEEND_R = not( macroLAYER_39, macroLAYER_38 ); 
M5CA_WRAP200 = M5CA_WRAP200_ISLAND or M5CA_WRAP200_LINEEND_R;

M5CA_WRAP = or_list( { M5CA_WRAP20, M5CA_WRAP22, M5CA_WRAP24, M5CA_WRAP26, M5CA_WRAP36, M5CA_WRAP40, M5CA_WRAP60, M5CA_WRAP80, M5CA_WRAP100, M5CA_WRAP120, M5CA_WRAP140, M5CA_WRAP180, M5CA_WRAP200, M5CA_WRAP1 } ); 
macroLAYER_36 = wide( M5CB_WRAP1, > 0.02, forty_five = INTERNAL ); 
macroLAYER_37 = wide( M5CB_WRAP1, >= 0.02, forty_five = INTERNAL ); 
M5CB_WRAP20_WIDTH = not( macroLAYER_37, macroLAYER_36 ); 

#ifdef VERTICAL_M5
M5CB_WRAP20_EDGE = angle_edge( M5CB_WRAP20_WIDTH, == 0 ); 
#else
M5CB_WRAP20_EDGE = angle_edge( M5CB_WRAP20_WIDTH, == 90 ); 
#endif
M5CB_WRAP20_PRE = external1( M5CB_WRAP20_EDGE, <= ISLAND_SPACE, extension = NONE, intersecting = {  }, look_thru = NOT_ADJACENT, orientation = { PARALLEL }, projection_length = == 0.02 ); 
M5CB_WRAP20_OTHER = not_interacting( M5I, M5CB_WRAP20_WIDTH ); 
M5CB_WRAP20_ISLAND = not_interacting( M5CB_WRAP20_PRE, M5CB_WRAP20_OTHER ); 
M5CB_WRAP20_BIG_EXT = external2( M5_260_BIG, M5CB_WRAP20_EDGE, <= LINEEND_RET, edge_containment = OUTSIDE, extension = NONE, intersecting = {  }, look_thru = NOT_ADJACENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
macroLAYER_32 = M5CB_WRAP20_BIG_EXT not M5_260_SIZE; 
macroLAYER_31 = interacting( macroLAYER_32, M5I, == 1 ); 
macroLAYER_30 = not_interacting( macroLAYER_31, DM5_O ); 
macroLAYER_38 = wide( macroLAYER_30, > 0.02, forty_five = INTERNAL );
macroLAYER_39 = wide( macroLAYER_30, >= 0.02, forty_five = INTERNAL );
M5CB_WRAP20_LINEEND_R = not( macroLAYER_39, macroLAYER_38 ); 
M5CB_WRAP20 = M5CB_WRAP20_ISLAND or M5CB_WRAP20_LINEEND_R;

macroLAYER_36 = wide( M5CB_WRAP1, > 0.022, forty_five = INTERNAL ); 
macroLAYER_37 = wide( M5CB_WRAP1, >= 0.022, forty_five = INTERNAL ); 
M5CB_WRAP22_WIDTH = not( macroLAYER_37, macroLAYER_36 ); 

#ifdef VERTICAL_M5
M5CB_WRAP22_EDGE = angle_edge( M5CB_WRAP22_WIDTH, == 0 ); 
#else
M5CB_WRAP22_EDGE = angle_edge( M5CB_WRAP22_WIDTH, == 90 ); 
#endif
M5CB_WRAP22_PRE = external1( M5CB_WRAP22_EDGE, <= ISLAND_SPACE, extension = NONE, intersecting = {  }, look_thru = NOT_ADJACENT, orientation = { PARALLEL }, projection_length = == 0.022 ); 
M5CB_WRAP22_OTHER = not_interacting( M5I, M5CB_WRAP22_WIDTH ); 
M5CB_WRAP22_ISLAND = not_interacting( M5CB_WRAP22_PRE, M5CB_WRAP22_OTHER ); 
M5CB_WRAP22_BIG_EXT = external2( M5_260_BIG, M5CB_WRAP22_EDGE, <= LINEEND_RET, edge_containment = OUTSIDE, extension = NONE, intersecting = {  }, look_thru = NOT_ADJACENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
macroLAYER_32 = M5CB_WRAP22_BIG_EXT not M5_260_SIZE; 
macroLAYER_31 = interacting( macroLAYER_32, M5I, == 1 ); 
macroLAYER_30 = not_interacting( macroLAYER_31, DM5_O ); 
macroLAYER_38 = wide( macroLAYER_30, > 0.022, forty_five = INTERNAL );
macroLAYER_39 = wide( macroLAYER_30, >= 0.022, forty_five = INTERNAL );
M5CB_WRAP22_LINEEND_R = not( macroLAYER_39, macroLAYER_38 ); 
M5CB_WRAP22 = M5CB_WRAP22_ISLAND or M5CB_WRAP22_LINEEND_R;

macroLAYER_36 = wide( M5CB_WRAP1, > 0.024, forty_five = INTERNAL ); 
macroLAYER_37 = wide( M5CB_WRAP1, >= 0.024, forty_five = INTERNAL ); 
M5CB_WRAP24_WIDTH = not( macroLAYER_37, macroLAYER_36 ); 

#ifdef VERTICAL_M5
M5CB_WRAP24_EDGE = angle_edge( M5CB_WRAP24_WIDTH, == 0 ); 
#else
M5CB_WRAP24_EDGE = angle_edge( M5CB_WRAP24_WIDTH, == 90 ); 
#endif
M5CB_WRAP24_PRE = external1( M5CB_WRAP24_EDGE, <= ISLAND_SPACE, extension = NONE, intersecting = {  }, look_thru = NOT_ADJACENT, orientation = { PARALLEL }, projection_length = == 0.024 ); 
M5CB_WRAP24_OTHER = not_interacting( M5I, M5CB_WRAP24_WIDTH ); 
M5CB_WRAP24_ISLAND = not_interacting( M5CB_WRAP24_PRE, M5CB_WRAP24_OTHER ); 
M5CB_WRAP24_BIG_EXT = external2( M5_260_BIG, M5CB_WRAP24_EDGE, <= LINEEND_RET, edge_containment = OUTSIDE, extension = NONE, intersecting = {  }, look_thru = NOT_ADJACENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
macroLAYER_32 = M5CB_WRAP24_BIG_EXT not M5_260_SIZE; 
macroLAYER_31 = interacting( macroLAYER_32, M5I, == 1 ); 
macroLAYER_30 = not_interacting( macroLAYER_31, DM5_O ); 
macroLAYER_38 = wide( macroLAYER_30, > 0.024, forty_five = INTERNAL );
macroLAYER_39 = wide( macroLAYER_30, >= 0.024, forty_five = INTERNAL );
M5CB_WRAP24_LINEEND_R = not( macroLAYER_39, macroLAYER_38 ); 
M5CB_WRAP24 = M5CB_WRAP24_ISLAND or M5CB_WRAP24_LINEEND_R;

macroLAYER_36 = wide( M5CB_WRAP1, > 0.026, forty_five = INTERNAL ); 
macroLAYER_37 = wide( M5CB_WRAP1, >= 0.026, forty_five = INTERNAL ); 
M5CB_WRAP26_WIDTH = not( macroLAYER_37, macroLAYER_36 ); 

#ifdef VERTICAL_M5
M5CB_WRAP26_EDGE = angle_edge( M5CB_WRAP26_WIDTH, == 0 ); 
#else
M5CB_WRAP26_EDGE = angle_edge( M5CB_WRAP26_WIDTH, == 90 ); 
#endif
M5CB_WRAP26_PRE = external1( M5CB_WRAP26_EDGE, <= ISLAND_SPACE, extension = NONE, intersecting = {  }, look_thru = NOT_ADJACENT, orientation = { PARALLEL }, projection_length = == 0.026 ); 
M5CB_WRAP26_OTHER = not_interacting( M5I, M5CB_WRAP26_WIDTH ); 
M5CB_WRAP26_ISLAND = not_interacting( M5CB_WRAP26_PRE, M5CB_WRAP26_OTHER ); 
M5CB_WRAP26_BIG_EXT = external2( M5_260_BIG, M5CB_WRAP26_EDGE, <= LINEEND_RET, edge_containment = OUTSIDE, extension = NONE, intersecting = {  }, look_thru = NOT_ADJACENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
macroLAYER_32 = M5CB_WRAP26_BIG_EXT not M5_260_SIZE; 
macroLAYER_31 = interacting( macroLAYER_32, M5I, == 1 ); 
macroLAYER_30 = not_interacting( macroLAYER_31, DM5_O ); 
macroLAYER_38 = wide( macroLAYER_30, > 0.026, forty_five = INTERNAL );
macroLAYER_39 = wide( macroLAYER_30, >= 0.026, forty_five = INTERNAL );
M5CB_WRAP26_LINEEND_R = not( macroLAYER_39, macroLAYER_38 ); 
M5CB_WRAP26 = M5CB_WRAP26_ISLAND or M5CB_WRAP26_LINEEND_R;

macroLAYER_36 = wide( M5CB_WRAP1, > 0.036, forty_five = INTERNAL ); 
macroLAYER_37 = wide( M5CB_WRAP1, >= 0.036, forty_five = INTERNAL ); 
M5CB_WRAP36_WIDTH = not( macroLAYER_37, macroLAYER_36 ); 

#ifdef VERTICAL_M5
M5CB_WRAP36_EDGE = angle_edge( M5CB_WRAP36_WIDTH, == 0 ); 
#else
M5CB_WRAP36_EDGE = angle_edge( M5CB_WRAP36_WIDTH, == 90 ); 
#endif
M5CB_WRAP36_PRE = external1( M5CB_WRAP36_EDGE, <= ISLAND_SPACE, extension = NONE, intersecting = {  }, look_thru = NOT_ADJACENT, orientation = { PARALLEL }, projection_length = == 0.036 ); 
M5CB_WRAP36_OTHER = not_interacting( M5I, M5CB_WRAP36_WIDTH ); 
M5CB_WRAP36_ISLAND = not_interacting( M5CB_WRAP36_PRE, M5CB_WRAP36_OTHER ); 
M5CB_WRAP36_BIG_EXT = external2( M5_260_BIG, M5CB_WRAP36_EDGE, <= LINEEND_RET, edge_containment = OUTSIDE, extension = NONE, intersecting = {  }, look_thru = NOT_ADJACENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
macroLAYER_32 = M5CB_WRAP36_BIG_EXT not M5_260_SIZE; 
macroLAYER_31 = interacting( macroLAYER_32, M5I, == 1 ); 
macroLAYER_30 = not_interacting( macroLAYER_31, DM5_O ); 
macroLAYER_38 = wide( macroLAYER_30, > 0.036, forty_five = INTERNAL );
macroLAYER_39 = wide( macroLAYER_30, >= 0.036, forty_five = INTERNAL );
M5CB_WRAP36_LINEEND_R = not( macroLAYER_39, macroLAYER_38 ); 
M5CB_WRAP36 = M5CB_WRAP36_ISLAND or M5CB_WRAP36_LINEEND_R;

macroLAYER_36 = wide( M5CB_WRAP1, > 0.040, forty_five = INTERNAL ); 
macroLAYER_37 = wide( M5CB_WRAP1, >= 0.040, forty_five = INTERNAL ); 
M5CB_WRAP40_WIDTH = not( macroLAYER_37, macroLAYER_36 ); 

#ifdef VERTICAL_M5
M5CB_WRAP40_EDGE = angle_edge( M5CB_WRAP40_WIDTH, == 0 ); 
#else
M5CB_WRAP40_EDGE = angle_edge( M5CB_WRAP40_WIDTH, == 90 ); 
#endif
M5CB_WRAP40_PRE = external1( M5CB_WRAP40_EDGE, <= ISLAND_SPACE, extension = NONE, intersecting = {  }, look_thru = NOT_ADJACENT, orientation = { PARALLEL }, projection_length = == 0.040 ); 
M5CB_WRAP40_OTHER = not_interacting( M5I, M5CB_WRAP40_WIDTH ); 
M5CB_WRAP40_ISLAND = not_interacting( M5CB_WRAP40_PRE, M5CB_WRAP40_OTHER ); 
M5CB_WRAP40_BIG_EXT = external2( M5_260_BIG, M5CB_WRAP40_EDGE, <= LINEEND_RET, edge_containment = OUTSIDE, extension = NONE, intersecting = {  }, look_thru = NOT_ADJACENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
macroLAYER_32 = M5CB_WRAP40_BIG_EXT not M5_260_SIZE; 
macroLAYER_31 = interacting( macroLAYER_32, M5I, == 1 ); 
macroLAYER_30 = not_interacting( macroLAYER_31, DM5_O ); 
macroLAYER_38 = wide( macroLAYER_30, > 0.040, forty_five = INTERNAL );
macroLAYER_39 = wide( macroLAYER_30, >= 0.040, forty_five = INTERNAL );
M5CB_WRAP40_LINEEND_R = not( macroLAYER_39, macroLAYER_38 ); 
M5CB_WRAP40 = M5CB_WRAP40_ISLAND or M5CB_WRAP40_LINEEND_R;

macroLAYER_36 = wide( M5CB_WRAP1, > 0.060, forty_five = INTERNAL ); 
macroLAYER_37 = wide( M5CB_WRAP1, >= 0.060, forty_five = INTERNAL ); 
M5CB_WRAP60_WIDTH = not( macroLAYER_37, macroLAYER_36 ); 

#ifdef VERTICAL_M5
M5CB_WRAP60_EDGE = angle_edge( M5CB_WRAP60_WIDTH, == 0 ); 
#else
M5CB_WRAP60_EDGE = angle_edge( M5CB_WRAP60_WIDTH, == 90 ); 
#endif
M5CB_WRAP60_PRE = external1( M5CB_WRAP60_EDGE, <= ISLAND_SPACE, extension = NONE, intersecting = {  }, look_thru = NOT_ADJACENT, orientation = { PARALLEL }, projection_length = == 0.060 ); 
M5CB_WRAP60_OTHER = not_interacting( M5I, M5CB_WRAP60_WIDTH ); 
M5CB_WRAP60_ISLAND = not_interacting( M5CB_WRAP60_PRE, M5CB_WRAP60_OTHER ); 
M5CB_WRAP60_BIG_EXT = external2( M5_260_BIG, M5CB_WRAP60_EDGE, <= LINEEND_RET, edge_containment = OUTSIDE, extension = NONE, intersecting = {  }, look_thru = NOT_ADJACENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
macroLAYER_32 = M5CB_WRAP60_BIG_EXT not M5_260_SIZE; 
macroLAYER_31 = interacting( macroLAYER_32, M5I, == 1 ); 
macroLAYER_30 = not_interacting( macroLAYER_31, DM5_O ); 
macroLAYER_38 = wide( macroLAYER_30, > 0.060, forty_five = INTERNAL );
macroLAYER_39 = wide( macroLAYER_30, >= 0.060, forty_five = INTERNAL );
M5CB_WRAP60_LINEEND_R = not( macroLAYER_39, macroLAYER_38 ); 
M5CB_WRAP60 = M5CB_WRAP60_ISLAND or M5CB_WRAP60_LINEEND_R;

macroLAYER_36 = wide( M5CB_WRAP1, > 0.080, forty_five = INTERNAL ); 
macroLAYER_37 = wide( M5CB_WRAP1, >= 0.080, forty_five = INTERNAL ); 
M5CB_WRAP80_WIDTH = not( macroLAYER_37, macroLAYER_36 ); 

#ifdef VERTICAL_M5
M5CB_WRAP80_EDGE = angle_edge( M5CB_WRAP80_WIDTH, == 0 ); 
#else
M5CB_WRAP80_EDGE = angle_edge( M5CB_WRAP80_WIDTH, == 90 ); 
#endif
M5CB_WRAP80_PRE = external1( M5CB_WRAP80_EDGE, <= ISLAND_SPACE, extension = NONE, intersecting = {  }, look_thru = NOT_ADJACENT, orientation = { PARALLEL }, projection_length = == 0.080 ); 
M5CB_WRAP80_OTHER = not_interacting( M5I, M5CB_WRAP80_WIDTH ); 
M5CB_WRAP80_ISLAND = not_interacting( M5CB_WRAP80_PRE, M5CB_WRAP80_OTHER ); 
M5CB_WRAP80_BIG_EXT = external2( M5_260_BIG, M5CB_WRAP80_EDGE, <= LINEEND_RET, edge_containment = OUTSIDE, extension = NONE, intersecting = {  }, look_thru = NOT_ADJACENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
macroLAYER_32 = M5CB_WRAP80_BIG_EXT not M5_260_SIZE; 
macroLAYER_31 = interacting( macroLAYER_32, M5I, == 1 ); 
macroLAYER_30 = not_interacting( macroLAYER_31, DM5_O ); 
macroLAYER_38 = wide( macroLAYER_30, > 0.080, forty_five = INTERNAL );
macroLAYER_39 = wide( macroLAYER_30, >= 0.080, forty_five = INTERNAL );
M5CB_WRAP80_LINEEND_R = not( macroLAYER_39, macroLAYER_38 ); 
M5CB_WRAP80 = M5CB_WRAP80_ISLAND or M5CB_WRAP80_LINEEND_R;

macroLAYER_36 = wide( M5CB_WRAP1, > 0.100, forty_five = INTERNAL ); 
macroLAYER_37 = wide( M5CB_WRAP1, >= 0.100, forty_five = INTERNAL ); 
M5CB_WRAP100_WIDTH = not( macroLAYER_37, macroLAYER_36 ); 

#ifdef VERTICAL_M5
M5CB_WRAP100_EDGE = angle_edge( M5CB_WRAP100_WIDTH, == 0 ); 
#else
M5CB_WRAP100_EDGE = angle_edge( M5CB_WRAP100_WIDTH, == 90 ); 
#endif
M5CB_WRAP100_PRE = external1( M5CB_WRAP100_EDGE, <= ISLAND_SPACE, extension = NONE, intersecting = {  }, look_thru = NOT_ADJACENT, orientation = { PARALLEL }, projection_length = == 0.100 ); 
M5CB_WRAP100_OTHER = not_interacting( M5I, M5CB_WRAP100_WIDTH ); 
M5CB_WRAP100_ISLAND = not_interacting( M5CB_WRAP100_PRE, M5CB_WRAP100_OTHER ); 
M5CB_WRAP100_BIG_EXT = external2( M5_260_BIG, M5CB_WRAP100_EDGE, <= LINEEND_RET, edge_containment = OUTSIDE, extension = NONE, intersecting = {  }, look_thru = NOT_ADJACENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
macroLAYER_32 = M5CB_WRAP100_BIG_EXT not M5_260_SIZE; 
macroLAYER_31 = interacting( macroLAYER_32, M5I, == 1 ); 
macroLAYER_30 = not_interacting( macroLAYER_31, DM5_O ); 
macroLAYER_38 = wide( macroLAYER_30, > 0.100, forty_five = INTERNAL );
macroLAYER_39 = wide( macroLAYER_30, >= 0.100, forty_five = INTERNAL );
M5CB_WRAP100_LINEEND_R = not( macroLAYER_39, macroLAYER_38 ); 
M5CB_WRAP100 = M5CB_WRAP100_ISLAND or M5CB_WRAP100_LINEEND_R;

macroLAYER_36 = wide( M5CB_WRAP1, > 0.120, forty_five = INTERNAL ); 
macroLAYER_37 = wide( M5CB_WRAP1, >= 0.120, forty_five = INTERNAL ); 
M5CB_WRAP120_WIDTH = not( macroLAYER_37, macroLAYER_36 ); 

#ifdef VERTICAL_M5
M5CB_WRAP120_EDGE = angle_edge( M5CB_WRAP120_WIDTH, == 0 ); 
#else
M5CB_WRAP120_EDGE = angle_edge( M5CB_WRAP120_WIDTH, == 90 ); 
#endif
M5CB_WRAP120_PRE = external1( M5CB_WRAP120_EDGE, <= ISLAND_SPACE, extension = NONE, intersecting = {  }, look_thru = NOT_ADJACENT, orientation = { PARALLEL }, projection_length = == 0.120 ); 
M5CB_WRAP120_OTHER = not_interacting( M5I, M5CB_WRAP120_WIDTH ); 
M5CB_WRAP120_ISLAND = not_interacting( M5CB_WRAP120_PRE, M5CB_WRAP120_OTHER ); 
M5CB_WRAP120_BIG_EXT = external2( M5_260_BIG, M5CB_WRAP120_EDGE, <= LINEEND_RET, edge_containment = OUTSIDE, extension = NONE, intersecting = {  }, look_thru = NOT_ADJACENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
macroLAYER_32 = M5CB_WRAP120_BIG_EXT not M5_260_SIZE; 
macroLAYER_31 = interacting( macroLAYER_32, M5I, == 1 ); 
macroLAYER_30 = not_interacting( macroLAYER_31, DM5_O ); 
macroLAYER_38 = wide( macroLAYER_30, > 0.120, forty_five = INTERNAL );
macroLAYER_39 = wide( macroLAYER_30, >= 0.120, forty_five = INTERNAL );
M5CB_WRAP120_LINEEND_R = not( macroLAYER_39, macroLAYER_38 ); 
M5CB_WRAP120 = M5CB_WRAP120_ISLAND or M5CB_WRAP120_LINEEND_R;

macroLAYER_36 = wide( M5CB_WRAP1, > 0.140, forty_five = INTERNAL ); 
macroLAYER_37 = wide( M5CB_WRAP1, >= 0.140, forty_five = INTERNAL ); 
M5CB_WRAP140_WIDTH = not( macroLAYER_37, macroLAYER_36 ); 

#ifdef VERTICAL_M5
M5CB_WRAP140_EDGE = angle_edge( M5CB_WRAP140_WIDTH, == 0 ); 
#else
M5CB_WRAP140_EDGE = angle_edge( M5CB_WRAP140_WIDTH, == 90 ); 
#endif
M5CB_WRAP140_PRE = external1( M5CB_WRAP140_EDGE, <= ISLAND_SPACE, extension = NONE, intersecting = {  }, look_thru = NOT_ADJACENT, orientation = { PARALLEL }, projection_length = == 0.140 ); 
M5CB_WRAP140_OTHER = not_interacting( M5I, M5CB_WRAP140_WIDTH ); 
M5CB_WRAP140_ISLAND = not_interacting( M5CB_WRAP140_PRE, M5CB_WRAP140_OTHER ); 
M5CB_WRAP140_BIG_EXT = external2( M5_260_BIG, M5CB_WRAP140_EDGE, <= LINEEND_RET, edge_containment = OUTSIDE, extension = NONE, intersecting = {  }, look_thru = NOT_ADJACENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
macroLAYER_32 = M5CB_WRAP140_BIG_EXT not M5_260_SIZE; 
macroLAYER_31 = interacting( macroLAYER_32, M5I, == 1 ); 
macroLAYER_30 = not_interacting( macroLAYER_31, DM5_O ); 
macroLAYER_38 = wide( macroLAYER_30, > 0.140, forty_five = INTERNAL );
macroLAYER_39 = wide( macroLAYER_30, >= 0.140, forty_five = INTERNAL );
M5CB_WRAP140_LINEEND_R = not( macroLAYER_39, macroLAYER_38 ); 
M5CB_WRAP140 = M5CB_WRAP140_ISLAND or M5CB_WRAP140_LINEEND_R;

macroLAYER_36 = wide( M5CB_WRAP1, > 0.180, forty_five = INTERNAL ); 
macroLAYER_37 = wide( M5CB_WRAP1, >= 0.180, forty_five = INTERNAL ); 
M5CB_WRAP180_WIDTH = not( macroLAYER_37, macroLAYER_36 ); 

#ifdef VERTICAL_M5
M5CB_WRAP180_EDGE = angle_edge( M5CB_WRAP180_WIDTH, == 0 ); 
#else
M5CB_WRAP180_EDGE = angle_edge( M5CB_WRAP180_WIDTH, == 90 ); 
#endif
M5CB_WRAP180_PRE = external1( M5CB_WRAP180_EDGE, <= 0.7, extension = NONE, intersecting = {  }, look_thru = NOT_ADJACENT, orientation = { PARALLEL }, projection_length = == 0.180 ); 
M5CB_WRAP180_OTHER = not_interacting( M5I, M5CB_WRAP180_WIDTH ); 
M5CB_WRAP180_ISLAND = not_interacting( M5CB_WRAP180_PRE, M5CB_WRAP180_OTHER ); 
M5CB_WRAP180_BIG_EXT = external2( M5_260_BIG, M5CB_WRAP180_EDGE, <= LINEEND_RET, edge_containment = OUTSIDE, extension = NONE, intersecting = {  }, look_thru = NOT_ADJACENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
macroLAYER_32 = M5CB_WRAP180_BIG_EXT not M5_260_SIZE; 
macroLAYER_31 = interacting( macroLAYER_32, M5I, == 1 ); 
macroLAYER_30 = not_interacting( macroLAYER_31, DM5_O ); 
macroLAYER_38 = wide( macroLAYER_30, > 0.180, forty_five = INTERNAL );
macroLAYER_39 = wide( macroLAYER_30, >= 0.180, forty_five = INTERNAL );
M5CB_WRAP180_LINEEND_R = not( macroLAYER_39, macroLAYER_38 ); 
M5CB_WRAP180 = M5CB_WRAP180_ISLAND or M5CB_WRAP180_LINEEND_R;

macroLAYER_36 = wide( M5CB_WRAP1, > 0.200, forty_five = INTERNAL ); 
macroLAYER_37 = wide( M5CB_WRAP1, >= 0.200, forty_five = INTERNAL ); 
M5CB_WRAP200_WIDTH = not( macroLAYER_37, macroLAYER_36 ); 

#ifdef VERTICAL_M5
M5CB_WRAP200_EDGE = angle_edge( M5CB_WRAP200_WIDTH, == 0 ); 
#else
M5CB_WRAP200_EDGE = angle_edge( M5CB_WRAP200_WIDTH, == 90 ); 
#endif
M5CB_WRAP200_PRE = external1( M5CB_WRAP200_EDGE, <= 0.7, extension = NONE, intersecting = {  }, look_thru = NOT_ADJACENT, orientation = { PARALLEL }, projection_length = == 0.200 ); 
M5CB_WRAP200_OTHER = not_interacting( M5I, M5CB_WRAP200_WIDTH ); 
M5CB_WRAP200_ISLAND = not_interacting( M5CB_WRAP200_PRE, M5CB_WRAP200_OTHER ); 
M5CB_WRAP200_BIG_EXT = external2( M5_260_BIG, M5CB_WRAP200_EDGE, <= LINEEND_RET, edge_containment = OUTSIDE, extension = NONE, intersecting = {  }, look_thru = NOT_ADJACENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
macroLAYER_32 = M5CB_WRAP200_BIG_EXT not M5_260_SIZE; 
macroLAYER_31 = interacting( macroLAYER_32, M5I, == 1 ); 
macroLAYER_30 = not_interacting( macroLAYER_31, DM5_O ); 
macroLAYER_38 = wide( macroLAYER_30, > 0.200, forty_five = INTERNAL );
macroLAYER_39 = wide( macroLAYER_30, >= 0.200, forty_five = INTERNAL );
M5CB_WRAP200_LINEEND_R = not( macroLAYER_39, macroLAYER_38 ); 
M5CB_WRAP200 = M5CB_WRAP200_ISLAND or M5CB_WRAP200_LINEEND_R;

M5CB_WRAP = or_list( { M5CB_WRAP20, M5CB_WRAP22, M5CB_WRAP24, M5CB_WRAP26, M5CB_WRAP36, M5CB_WRAP40, M5CB_WRAP60, M5CB_WRAP80, M5CB_WRAP100, M5CB_WRAP120, M5CB_WRAP140, M5CB_WRAP180, M5CB_WRAP200, M5CB_WRAP1 } ); 

// DUMMY SPEC : M5_DC_E
FSS_M5_WRAPSPEC: list of fill_to_signal_spacing_s = {

    { BEOLBLK_FINAL, min_space = DM_BEOLBLK },
    { INDDMY, min_space = DM_INDDMY },
    { DM5EXCL_FINAL, min_space = DM_DMXEXCL },
#ifdef VERTICAL_M5
    { BEOLBLK_FINAL, min_space = 0, min_space_y = CHIP_SHRINK_VALUEX3 }, //for exclusion zone
    { DM5EXCL_FINAL, min_space = 0, min_space_y = CHIP_SHRINK_VALUEX3 }, //for exclusion zone
#else
    { BEOLBLK_FINAL, min_space = 0, min_space_x = CHIP_SHRINK_VALUEX3 }, //for exclusion zone
    { DM5EXCL_FINAL, min_space = 0, min_space_x = CHIP_SHRINK_VALUEX3 }, //for exclusion zone
#endif
//===================================================
// DUMMY SPEC : M5_DC
    { REGION_WRAPPER_DM5, min_space = 0, context = INTERIOR },
    { CHIP_snps, min_space = DMX3O_PRBOUNDARY, context = INTERIOR },
#ifdef FULL_CHIP
    { CHIP_BOUNDARY, min_space = DMX3O_CHIP, context = INTERIOR },
    { CHIP_FILLREGION_X3, min_space = 0, context = INTERIOR },
#else
    { PRBOUNDARY, min_space = DMX3O_PRBOUNDARY, context = INTERIOR },
#endif
    { BEOLBLK_FINAL, min_space = DM_BEOLBLK },
    { INDDMY, min_space = DM_INDDMY },

    { DM5EXCL_FINAL, min_space = DM_DMXEXCL },
    { CSR66_3485, min_space = DM_BEOLBLK },
    { TCDDMY_M5, min_space = DM_TCDDMY_MX },

    { M5_HOLE, min_space = 0 },
    { M5_LT180, min_space = DMX3_DC_W140 },
    { M5_LT260, min_space = DMX3_DC_W180 },
    { M5_260_SIZE, min_space = 0 },
    { M5_45, min_space = 0 },
    { ICOVL_SINGLE, min_space = DMX3_ICOVL },
{ M5_LT245, min_space = DMX3_DC_W20 },
//+++Mxd 1P1E+++
#ifdef VERTICAL_M5
    { M5_MAIN, min_space_x = DMX3OR_MX, min_space_y = MX3_SC_END_END, space_extension_x = DMX3OR_MX, space_extension_y = MX3_SC_END_END },

#else
    { M5_MAIN, min_space_x = MX3_SC_END_END, min_space_y = DMX3OR_MX, space_extension_x = MX3_SC_END_END, space_extension_y = DMX3OR_MX },

#endif
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    { M5_LT60, min_space = DMX3_DC_W245 },
    { M5_LT100, min_space = DMX3_DC_W60 },
    { M5_LT140, min_space = DMX3_DC_W100 },

#ifdef VERTICAL_M5
    { M5_MAIN, min_space_x = DMX3OR_MX, min_space_y = MX3_SC_END_END, space_extension_x = DMX3OR_MX, space_extension_y = MX3_SC_END_END },
#else
    { M5_MAIN, min_space_x = MX3_SC_END_END, min_space_y = DMX3OR_MX, space_extension_x = MX3_SC_END_END, space_extension_y = DMX3OR_MX },
#endif
    { DM5_O_S, min_space = 0.13 },
    { DM5_O_B, min_space = 0.26 },
    { DM5, min_space = 0.26 },
    { M5_HVN_180V, min_space = DMX3_MX180V },
    { M5_S42, min_space = 0 },
#ifdef VERTICAL_M5
    { M5_MAIN_LE, min_space_y = 0.06, space_extension_x = 0.1, projection = CORNER },
#else
    { M5_MAIN_LE, min_space_x = 0.06, space_extension_y = 0.1, projection = CORNER },
#endif
//===================================================
// DUMMY SPEC : M5_SCA
      { M5CA_LT245, min_space = DMX3OR_SC_MX, color_aware_to_fill = ONLY_COLOR_1 },
      { M5CA_LT60, min_space = DMX3_SC_W245, color_aware_to_fill = ONLY_COLOR_1 },
      { M5CA_LT100, min_space = DMX3_SC_W60, color_aware_to_fill = ONLY_COLOR_1 },
      { M5CA_LT140, min_space = DMX3_SC_W100, color_aware_to_fill = ONLY_COLOR_1 },
      { M5CA_LT180, min_space = DMX3_SC_W140, color_aware_to_fill = ONLY_COLOR_1 },
      { M5CA_LT260, min_space = DMX3_SC_W180, color_aware_to_fill = ONLY_COLOR_1 },
      { M5CA_LT245, min_space = 0 }, //for parsing
      { M5CA_LT60,  min_space = 0 }, //for parsing
      { M5CA_LT100, min_space = 0 }, //for parsing
      { M5CA_LT140, min_space = 0 }, //for parsing
      { M5CA_LT180, min_space = 0 }, //for parsing
      { M5CA_LT260, min_space = 0 }, //for parsing
//===================================================
// DUMMY SPEC : M5_SCB
      { M5CB_LT245, min_space = DMX3OR_SC_MX, color_aware_to_fill = ONLY_COLOR_2 },
      { M5CB_LT60, min_space = DMX3_SC_W245, color_aware_to_fill = ONLY_COLOR_2 },
      { M5CB_LT100, min_space = DMX3_SC_W60, color_aware_to_fill = ONLY_COLOR_2 },
      { M5CB_LT140, min_space = DMX3_SC_W100, color_aware_to_fill = ONLY_COLOR_2 },
      { M5CB_LT180, min_space = DMX3_SC_W140, color_aware_to_fill = ONLY_COLOR_2 },
      { M5CB_LT260, min_space = DMX3_SC_W180, color_aware_to_fill = ONLY_COLOR_2 },
      { M5CB_LT245, min_space = 0 }, //for parsing
      { M5CB_LT60,  min_space = 0 }, //for parsing
      { M5CB_LT100, min_space = 0 }, //for parsing
      { M5CB_LT140, min_space = 0 }, //for parsing
      { M5CB_LT180, min_space = 0 }, //for parsing
      { M5CB_LT260, min_space = 0 }, //for parsing
//===================================================
// DUMMY SPEC : WIDTH_DC_M5CA
    { M5CA_WRAP, width_based_spacing = {
			{>= 0.0, 	{>= DMX3_DC_W20} },
			{>= 0.02, 	{>= DMX3_DC_W20} },
			{>= 0.0245, 	{>= DMX3_DC_W245} },
			{>= 0.06, 	{>= DMX3_DC_W60} },
			{>= 0.1, 	{>= DMX3_DC_W100} },
			{>= 0.14, 	{>= DMX3_DC_W140} },
			{>= 0.18, 	{>= DMX3_DC_W180} },
		}, color_aware_to_fill = ALL },
    { M5_HVN_180V, min_space = DMX3_MX180V },
    { DM5EXCL_FINAL, min_space = DM_DMXEXCL },
    { BEOLBLK_FINAL, min_space = DM_BEOLBLK },
    { M5_260_SIZE, min_space = 0 },
#ifdef FULL_CHIP
    { M5_BOUNDARY_CLOSE, min_space = DMX3O_CHIP },
#else
    { M5_BOUNDARY_CLOSE, min_space = DMX3O_PRBOUNDARY },
#endif
//===================================================
// DUMMY SPEC : WIDTH_DC_M5CB

    { M5CB_WRAP, width_based_spacing = {
			{>= 0.0, 	{>= DMX3_DC_W20} },
			{>= 0.02, 	{>= DMX3_DC_W20} },
			{>= 0.0245, 	{>= DMX3_DC_W245} },
			{>= 0.06, 	{>= DMX3_DC_W60} },
			{>= 0.1, 	{>= DMX3_DC_W100} },
			{>= 0.14, 	{>= DMX3_DC_W140} },
			{>= 0.18, 	{>= DMX3_DC_W180} },
		}, color_aware_to_fill = ALL },
    { M5_HVN_180V, min_space = DMX3_MX180V },
    { DM5EXCL_FINAL, min_space = DM_DMXEXCL },
    { BEOLBLK_FINAL, min_space = DM_BEOLBLK },
    { M5_260_SIZE, min_space = 0 },
#ifdef FULL_CHIP
    { M5_BOUNDARY_CLOSE, min_space = DMX3O_CHIP },
#else
    { M5_BOUNDARY_CLOSE, min_space = DMX3O_PRBOUNDARY },
#endif
//===================================================
// DUMMY SPEC : WIDTH_SC_M5CA
    { M5CA_WRAP, width_based_spacing = {
			{>= 0.0, 	{>= DMX3_SC_W20} },
			{>= 0.02, 	{>= DMX3_SC_W20} },
			{>= 0.0245, 	{>= DMX3_SC_W245} },
			{>= 0.06, 	{>= DMX3_SC_W60} },
			{>= 0.1, 	{>= DMX3_SC_W100} },
			{>= 0.14, 	{>= DMX3_SC_W140} },
			{>= 0.18, 	{>= DMX3_SC_W180} },
		}, color_aware_to_fill = ONLY_COLOR_1 },
    { M5_HVN_180V, width_based_spacing = { {>= 0.0, {>= DMX3_MX180V}} }, color_aware_to_fill = ONLY_COLOR_1 },
    { DM5EXCL_FINAL, width_based_spacing = { {>= 0.0, {>= DM_DMXEXCL}} }, color_aware_to_fill = ONLY_COLOR_1 },
    { BEOLBLK_FINAL, width_based_spacing = { {>= 0.0, {>= DM_BEOLBLK}} }, color_aware_to_fill = ONLY_COLOR_1 },
    { M5_HVN_180V, min_space = DMX3_MX180V },//for 3pty chk
    { DM5EXCL_FINAL, min_space = DM_DMXEXCL },//for 3pty chk
    { BEOLBLK_FINAL, min_space = DM_BEOLBLK },//for 3pty chk 
    { M5_260_SIZE, min_space = 0 },
//===================================================
// DUMMY SPEC : WIDTH_SC_M5CB
    { M5CB_WRAP, width_based_spacing = {
			{>= 0.0, 	{>= DMX3_SC_W20} },
			{>= 0.02, 	{>= DMX3_SC_W20} },
			{>= 0.0245, 	{>= DMX3_SC_W245} },
			{>= 0.06, 	{>= DMX3_SC_W60} },
			{>= 0.1, 	{>= DMX3_SC_W100} },
			{>= 0.14, 	{>= DMX3_SC_W140} },
			{>= 0.18, 	{>= DMX3_SC_W180} },
		}, color_aware_to_fill = ONLY_COLOR_2 },
    { M5_HVN_180V, min_space = DMX3_MX180V },//for 3pty chk
    { DM5EXCL_FINAL, min_space = DM_DMXEXCL },//for 3pty chk
    { BEOLBLK_FINAL, min_space = DM_BEOLBLK },//for 3pty chk 
    { M5_260_SIZE, min_space = 0 },//for 3pty chk

}; //end of FSS_M5_WRAPSPEC
//===================================================
// DUMMY SPEC : M5_guideSpec
//===================================================
// DUMMY SPEC : M5_wrapSpec	
PATTERN_M5_WRAPSPEC = get_single_linear_pattern(
    FSS_M5_WRAPSPEC,
    {
        { M5CA_WRAP, COLOR_1 },
        { M5CB_WRAP, COLOR_2 },
        { M5_HVN_180V, COLOR_1 },
        { DM5EXCL_FINAL, COLOR_1 },
        { BEOLBLK_FINAL, COLOR_1 },
        { M5_260_SIZE, COLOR_1 },
        { M5_BOUNDARY_CLOSE, COLOR_1 },
    },
    0.221,
    "M5_WRAPSPEC",
#ifdef VERTICAL_M5
	VERTICAL, "M5VWRAP", DMX3OR_W, DMX3OR_W, DMX3OR_L, DMX3OR_L_MAX,
	DMX3OR_SX_SC, DMX3OR_SY_SC, DMX3OR_SX_DC, DMX3OR_SY_DC, //for step checking
#else
	HORIZONTAL, "M5HWRAP", DMX3OR_W, DMX3OR_W, DMX3OR_L, DMX3OR_L_MAX,
	DMX3OR_SY_SC, DMX3OR_SX_SC, DMX3OR_SY_DC, DMX3OR_SX_DC, //for step checking
#endif				
	24, SHRINK
);

PATTERN_M5_WRAPSPEC.polygon_fill.pattern_spec.pattern_spacing = {
    min_space_corner = SQRT2 * 0.06,
    extension = RADIAL_INTERSECTION,
};


M5_WRAPSPEC = unified_fill(
	fill_patterns = { PATTERN_M5_WRAPSPEC },
	fill_boundary = {
	    layer = CHIP_snps,
        type = LAYER,
	},
    boundary = ALIGN,
	grid = vGRID
);



//===================================================


WRAPPER_DM5_O_A_L =  post_drc_projection_corner(M5_WRAPSPEC["M5_WRAPSPEC"][1], FSS_M5_WRAPSPEC);
WRAPPER_DM5_O_B_L =  post_drc_projection_corner(M5_WRAPSPEC["M5_WRAPSPEC"][2], FSS_M5_WRAPSPEC);
WRAPPER_DM5_O_A_C =  post_drc_projection_corner(M5_WRAPSPEC["M5_WRAPSPEC"][1], FSS_M5_WRAPSPEC);
WRAPPER_DM5_O_B_C =  post_drc_projection_corner(M5_WRAPSPEC["M5_WRAPSPEC"][2], FSS_M5_WRAPSPEC);
WRAPPER_DM5_O_L   =  WRAPPER_DM5_O_A_L or WRAPPER_DM5_O_B_L;
#endif

#ifdef FILL_DM6
//***** filling region *********************************************************
REGION_WRAPPER_DM6 = CHIP_snps and or_list( {
    over_size( M6_MAIN, WRAPPER_RANGEY1),
    (CHIP_snps not over_size( CHIP_snps, -WRAPPER_RANGEY1)),
    over_size( (BEOLBLK_FINAL or DM6EXCL_FINAL), WRAPPER_RANGEY1)
 });

#pragma PXL encrypted begin
1!F",'+Q3QQ$S@[1')5/(K/.8T5G5++3[EIC%K#KVU*M!<X60@U>S"40ZP%"4K+%<VL_0=)2
X$"?O 7R% W@RH2=>UXF@O[*)[,=!X0R0$\GWR3*!L5("!??
#pragma PXL encrypted end

// DUMMY SPEC : Wrapper_DM6_O_Connect
//***DM6_O_Connect***
FSS_SPEC_WRAPPER_DM6_O_CONNECT: list of fill_to_signal_spacing_s = {
    { CHIP_snps, min_space = DMY1_CHIP, context = INTERIOR },
#ifdef FULL_CHIP
    { CHIP_BOUNDARY, min_space = DMY1_CHIP, context = INTERIOR },
#else
    { PRBOUNDARY, min_space = DMY1_CHIP, context = INTERIOR },
#endif
    { ICOVL_SINGLE, min_space = DMY1_ICOVL },
    { BEOLBLK_FINAL, min_space = DM_BEOLBLK },
    { CSR66_3485, min_space = DM_BEOLBLK },
    { INDDMY, min_space = DM_INDDMY },
    { DM6EXCL_FINAL, min_space = DM_DMXEXCL },
    { TCDDMY_M6, min_space = DM_TCDDMY_MX },
    { M6_MAIN, min_space = DMY1OR_MY1 },
    { DM6_O, min_space = DMY1OR_DMY1O },
    { DM6, min_space = 0.2 }, //DMn.S.3.5
    { DM6_GT1350, min_space = 0.45 },
    { M6_HOLE, min_space = 0 },
    { M6_GT76, min_space = DMY1_MY1W1 },
    { M6_GT114, min_space = DMY1_MY1W2 },
    { M6_GT152, min_space = DMY1_MY1W3 },
    { M6_GT180, min_space = DMY1_MY1W4 },
    { M6_GT240, min_space = DMY1_MY1W5 },
    { M6_GT280, min_space = DMY1_MY1W6 },
    { M6_GT500, min_space = DMY1_MY1W7 },
    { M6_GT1350, min_space = DMY1_MY1W8 },
    { M6_45, min_space = 0 },
    { VIA5_HVN_5V, min_space = DMY1_VY15V },
    { M6_HVN_5V, min_space = DMY1_MY15V },
    { VIA6_HVN_5V, min_space = DMY1_VY15V },

{ R7_VIA5_CHK_REGION, min_space = 0 },
{ S164_M6_REGION, min_space = 0 },
{ R15_VIA6_CHK_REGION, min_space = 0 },

{ S22_M6_REGION, min_space = 0 },
#pragma PXL encrypted begin
,YOI?S7^<G0S<W28;%!<>VQS@8*LQR(29_R!TN;R5'P;N#?2M_"Y.C0B,!NW@/^^#K>(N6^ 
 )ABY#610W4 K,RGA+R[]B:L& !(1$XP+,488+_:W]A=#%%@2^VD>T1)I<-++34;,WL0PCLM
7[ :MXB<!G1?8T?@VU+#V21C/1JJD]U+:5X]Y!22+\F]/&GD5;_;Y8)ZDIA54>WX")H#A251
.<Z2:+N</J@Y>O6Z9"67-VEZ_,XIBX*>1^#\^6P8DZ87Y1CY
#pragma PXL encrypted end

};


LAYER_DM6_MYCELL_H : polygon_layer_s = {
    layer_spec = {
        output_layer_key = "OUTPUT_WRAPPER_DM6_O_CONNECT"
    },
    polygons = MYCELL_H
};

LAYER_DM6_MYCELL_V : polygon_layer_s = {
    layer_spec = {
        output_layer_key = "OUTPUT_WRAPPER_DM6_O_CONNECT"
    },
    polygons = MYCELL_V
};

LAYER_DM6_MYCELL_HEXT : polygon_layer_s = {
    layer_spec = {
        output_layer_key = "OUTPUT_WRAPPER_DM6_O_CONNECT"
    },
    polygons = MYCELL_HEXT
};

LAYER_DM6_MYCELL_VEXT : polygon_layer_s = {
    layer_spec = {
        output_layer_key = "OUTPUT_WRAPPER_DM6_O_CONNECT"
    },
    polygons = MYCELL_VEXT 
};

SPEC_WRAPPER_DM6_O_CONNECT = unified_fill(
    fill_patterns = {
        {
            type = UF_POLYGON,
            polygon_fill = {
                pattern_spec = {
            	    pattern_spacing = {
               	       allowed_spacing_x = { >= DMY1OR_SC },
                       allowed_spacing_y = { >= DMY1OR_SC },
                       extension = INTERSECTION
                    },                    
#ifdef VERTICAL_M6     
                    space_x = DMY1OR_SX,
                    space_y = DMY1OR_SY,
                    stagger_x = DMY1OR_OX,
                    stagger_y = DMY1OR_OY,
#else
                    space_x = DMY1OR_SY,
                    space_y = DMY1OR_SX,
                    stagger_x = DMY1OR_OY,
                    stagger_y = DMY1OR_OX,
#endif 
                },
                insertion = {
#pragma PXL encrypted begin
?L/M@%O[!3Y^*M\$RT>=A?PJ8Z,\Y/8'Q])C^S\@'OZPN/O[KXX4O7L@DG&O'Q)\D4H6+D,?
]J-C!:QY^*7VY^WHM54I,DOGCOU$ U_Y+*Z.U6S+X9P@C9'5P&)\63U]!H[ @TVX]*2I$!F#
VCC0LN"H8T#:$OOIVO/2X^82\E(Q5HOK=3GR
#pragma PXL encrypted end
                    iterations = 3,
#pragma PXL encrypted begin
OEXG/)N5"%:^";Q.T=.D=,0)F;@2IELW'[J9(]>0)Q:0$I<CJ#9;0NGH7;:H9Q[Y5V$M_\)G
:\1_@[3+5EYKOW0QK/NKQ5Z_
#pragma PXL encrypted end
		            starting_point = CENTER,
                    shift_factor = 2,
                },layers = {
#ifdef VERTICAL_M6     
                    LAYER_DM6_MYCELL_V, 
#else
                    LAYER_DM6_MYCELL_H, 
#endif                                                       
                },
                merging_layers = {
#ifdef VERTICAL_M6     
                    LAYER_DM6_MYCELL_VEXT,
#else
                    LAYER_DM6_MYCELL_HEXT,
#endif                                                       
                },

#ifdef ANTPrevention                
                merging_blockage_layer_list = {
                FORBIDDEN_RING
                },
#endif                              
#ifdef CONTROL_MAX_METAL_LENGTH                 
#ifdef VERTICAL_M6     
                merging_direction = VERTICAL,
#else
                merging_direction = HORIZONTAL,
#endif                                                       
                merging_length_limit = 4*( DMY1OR_L + DMY1OR_SY ) - DMY1OR_SY, // repeat 4 
#else
#ifdef VERTICAL_M6     
                merging_direction = VERTICAL,
#else
                merging_direction = HORIZONTAL,
#endif                                                       
                merging_length_limit = 500*( DMY1OR_L + DMY1OR_SY ) - DMY1OR_SY, // repeat 500 
#endif
                fill_to_signal_spacing = FSS_SPEC_WRAPPER_DM6_O_CONNECT,
                hierarchical_fill = false,
#ifdef VERTICAL_M6     
                cell_prefix = "WDMR6VNEW"
#else
                cell_prefix = "WDMR6HNEW"
#endif                                                       
            }
        }
    },
    extents_output = {
        {
            output_layer_key = "OUTPUT_WRAPPER_DM6O_CONNECT_EXTENT"
        },
    },
    fill_boundary = {
        layer = REGION_WRAPPER_DM6, 
        type = LAYER 
    },
	grid = vGRID
);

WRAPPER_DM6NEW_O_C = SPEC_WRAPPER_DM6_O_CONNECT["OUTPUT_WRAPPER_DM6_O_CONNECT"][0];
WRAPPER_DM6NEW_O_L = SPEC_WRAPPER_DM6_O_CONNECT["OUTPUT_WRAPPER_DM6_O_CONNECT"][0];
//=======================================================
#pragma PXL encrypted begin
,+I1?^Y]VS8P5GYF3H";\[Q60;2%PL0::N%!+ 8&J@!7:*HLJ\DK76DLBLNKC=#O6^OIS3>-
7]-Z;X].J#-?#!5?)H!OM(D,
#pragma PXL encrypted end

//***** spec *******************************************************************
// DUMMY SPEC : Wrapper_DM6
//***DM6_O_R***
PATTERN_SPEC_WRAPPER_DM6_0 = get_single_polygon_pattern(
#ifdef VERTICAL_M6
	"WDMR6V", "OUTPUT_WRAPPER_DM6_O", DMY1OR_W, DMY1OR_L,
	step_x = DMY1OR_SX, step_y = DMY1OR_SY,
	offset_x = DMY1OR_OX, offset_y = DMY1OR_OY,
	setback = DMY1OR_SC,
	setback_type = INTERSECTION,
#else
	"WDMR6H", "OUTPUT_WRAPPER_DM6_O", DMY1OR_L, DMY1OR_W,
	step_x = DMY1OR_SY, step_y = DMY1OR_SX,
	offset_x = DMY1OR_OY, offset_y = DMY1OR_OX,
	setback = DMY1OR_SC,
	setback_type = INTERSECTION,
#endif
    FSS = {
    { CHIP_snps, min_space = DMY1_CHIP, context = INTERIOR },
#ifdef FULL_CHIP
    { CHIP_BOUNDARY, min_space = DMY1_CHIP, context = INTERIOR },
#else
    { PRBOUNDARY, min_space = DMY1_CHIP, context = INTERIOR },
#endif
    { ICOVL_SINGLE, min_space = DMY1_ICOVL },
    { BEOLBLK_FINAL, min_space = DM_BEOLBLK },
    { CSR66_3485, min_space = DM_BEOLBLK },
    { INDDMY, min_space = DM_INDDMY },
    { DM6EXCL_FINAL, min_space = DM_DMXEXCL },
    { TCDDMY_M6, min_space = DM_TCDDMY_MX },
    { M6_MAIN, min_space = DMY1OR_MY1 },
    { DM6_O, min_space = DMY1OR_DMY1O },
    { DM6, min_space = 0.2 }, //DMn.S.3.5
    { DM6_GT1350, min_space = 0.45 },
    { M6_HOLE, min_space = 0 },
    { M6_GT76, min_space = DMY1_MY1W1 },
    { M6_GT114, min_space = DMY1_MY1W2 },
    { M6_GT152, min_space = DMY1_MY1W3 },
    { M6_GT180, min_space = DMY1_MY1W4 },
    { M6_GT240, min_space = DMY1_MY1W5 },
    { M6_GT280, min_space = DMY1_MY1W6 },
    { M6_GT500, min_space = DMY1_MY1W7 },
    { M6_GT1350, min_space = DMY1_MY1W8 },
    { M6_45, min_space = 0 },
    { VIA5_HVN_5V, min_space = DMY1_VY15V },
    { M6_HVN_5V, min_space = DMY1_MY15V },
    { VIA6_HVN_5V, min_space = DMY1_VY15V },

              { R7_VIA5_CHK_REGION, min_space = 0 },
              { S164_M6_REGION, min_space = 0 },
              { R15_VIA6_CHK_REGION, min_space = 0 },

              { S22_M6_REGION, min_space = 0 },
#pragma PXL encrypted begin
H15\0D)FKA>A>/B*&=^.I9%X\<.72&^T5D?Q1*:9PA>DC1]$^-0[3>)11,7X2&-<B7-O$&Y(
B;+!1F9V:8*)6HK+CA:Q6"9:SPZW*>(V6WC/7.J-ZC/E'@1<
#pragma PXL encrypted end

              { WRAPPER_DM6NEW_O_L, min_space = DMY1OR_DMY1O },
#pragma PXL encrypted begin
T7!E4'OFP&S1EU4F+K3X)]J7TS'Q"VLAJ[G3KCM:B"?KI0FN#Z%0:=&OSO0/U#&?]4XNI ?4
5A-LO8)@6'E6#UF4H'7O,*X/
#pragma PXL encrypted end

    },//end of FSS
	shift = 2,
#pragma PXL encrypted begin
-S_%3>EK QPW(O"&4G@1C,TBU<\07Y+N66?5(C[8?[EZ@*HB9(\3\/59Z+YDG>1[^0MR#CV=
AKZ:!(P*G/:&^#H!8W!JLW+XDU8,( MRA763WFBMBG1?G3/>;_C46:6VR@AO
#pragma PXL encrypted end
    repeat = 3
#pragma PXL encrypted begin
,"<X;.[FY18PW.XW5$K)U-G<E$A#M]!]L<*475LE>F3$S2==0\2J2'K)?B9#EL.G0W$K:#66
[SN.X5.J8*;OM]=D;?,XJM&W
#pragma PXL encrypted end
);// end of 1st pattern
//==============================================================
//----------------------------------------------------------------------------------------------------

//***DM6_O_W***
// DUMMY SPEC : Wrapper_DM6_O_W
PATTERN_SPEC_WRAPPER_DM6_1 = get_single_polygon_pattern(
#ifdef VERTICAL_M6
	"WDMW6V", "OUTPUT_WRAPPER_DM6_O", DMY1OW_W, DMY1OW_L,
	step_x = DMY1OW_SY, step_y = DMY1OW_SX,
	offset_x = DMY1OW_OY, offset_y = DMY1OW_OX,
	setback = 0.114,
	setback_type = INTERSECTION,
#else
	"WDMW6H", "OUTPUT_WRAPPER_DM6_O", DMY1OW_L, DMY1OW_W,
	step_x = DMY1OW_SX, step_y = DMY1OW_SY,
	offset_x = DMY1OW_OX, offset_y = DMY1OW_OY,
	setback = 0.114,
	setback_type = INTERSECTION,
#endif
    FSS = {
    { CHIP_snps, min_space = DMY1_CHIP, context = INTERIOR },
#ifdef FULL_CHIP
    { CHIP_BOUNDARY, min_space = DMY1_CHIP, context = INTERIOR },
#else
    { PRBOUNDARY, min_space = DMY1_CHIP, context = INTERIOR },
#endif
    { ICOVL_SINGLE, min_space = DMY1_ICOVL },
    { BEOLBLK_FINAL, min_space = DM_BEOLBLK },
    { INDDMY, min_space = DM_INDDMY },

    { DM6EXCL_FINAL, min_space = DM_DMXEXCL },
    { CSR66_3485, min_space = DM_BEOLBLK },
    { TCDDMY_M6, min_space = DM_TCDDMY_MX },

    { M6_MAIN, min_space = DMY1OW_MY1 },
    { DM6_O, min_space = DMY1OW_DMY1O },
    { DM6, min_space = 0.2 }, //DMn.S.3.5
    { DM6_GT1350, min_space = 0.45 },
    { M6_HOLE, min_space = 0 },
    { M6_GT76, min_space = DMY1_MY1W1 },
    { M6_GT114, min_space = DMY1_MY1W2 },
    { M6_GT152, min_space = DMY1_MY1W3 },
    { M6_GT180, min_space = DMY1_MY1W4 },
    { M6_GT240, min_space = DMY1_MY1W5 },
    { M6_GT280, min_space = DMY1_MY1W6 },
    { M6_GT500, min_space = DMY1_MY1W7 },
    { M6_GT1350, min_space = DMY1_MY1W8 },
    { M6_45, min_space = 0 },
    { VIA5_HVN_5V, min_space = DMY1_VY15V },
    { M6_HVN_5V, min_space = DMY1_MY15V },
    { VIA6_HVN_5V, min_space = DMY1_VY15V },

              { R7_VIA5_CHK_REGION, min_space = 0 },
              { S164_M6_REGION, min_space = 0 },
              { R15_VIA6_CHK_REGION, min_space = 0 },

              { S22_M6_REGION, min_space = 0 },
#pragma PXL encrypted begin
-)QU4-G$6$,TP()#U,CRG;+ *9>P.PV$_58I@PL:[):5O'2#"M]\D:'\WU(*M2OK-D!&5[VU
YY#,.?RJ?E'G[1DGO8J7:>'M-#]WK5G RM$T$PK\[)ZJU083
#pragma PXL encrypted end

              { WRAPPER_DM6NEW_O_L, min_space = DMY1OW_DMY1O },
#pragma PXL encrypted begin
]Q!R?ZDZ"V3W85+.^]=ZA.YA?>[Q?";\9+9]F) >[B]+:\J8WY0#&$+3DJ_?X/2S*HO"W8S@
SRIU0U@FN>#/-US=]:89!;PW
#pragma PXL encrypted end

	},
    shift = 2,
#pragma PXL encrypted begin
3)^!3Q&F75!,C8Y3BS ;<<*-9U^:_)>7_(!GXLZI!H5.AG;B(T*J=,<NL!HCGF(1N+!:]5^>
/Y& 9?KWR>4_B#G5DLO]\^*(M%@R&09$:>"T[W5N$J(8^;_OYK5:!+E0M3?F
#pragma PXL encrypted end
    repeat = 3
#pragma PXL encrypted begin
#Q1^?N$;$'$/0E!*[;YITC9"S2+*RV1(Q"[-5#^T3K+VVMI4-DVM2^3='G<V0,BIX>U73H9 
GM$S8\BCIK:>!5$H.E8TT,4%
#pragma PXL encrypted end
); //end of get_single_polygon_pattern


PATTERN_SPEC_WRAPPER_DM6_0.polygon_fill.pattern_spec.other_pattern_spacing = {
         1 => > DMY1OR_DMY1O 
};
PATTERN_SPEC_WRAPPER_DM6_1.polygon_fill.pattern_spec.other_pattern_spacing = {
         0 => > DMY1OW_DMY1O
};
  


SPEC_WRAPPER_DM6 = unified_fill(
    fill_boundary = {
        layer = CHIP_snps and REGION_WRAPPER_DM6,
        type = LAYER
    },
    fill_patterns = {
        PATTERN_SPEC_WRAPPER_DM6_0,
        PATTERN_SPEC_WRAPPER_DM6_1,
    },
    boundary = ALIGN,
	grid = vGRID
);

//==============================================================
//***** fill *******************************************************************
WRAPPER_DM6_O_C     = SPEC_WRAPPER_DM6["OUTPUT_WRAPPER_DM6_O"][0];
WRAPPER_DM6_O_L_PRE = SPEC_WRAPPER_DM6["OUTPUT_WRAPPER_DM6_O"][0];


//===========================================
#pragma PXL encrypted begin
&#Q!2NVPXBX8^DMWF.WY+N#ZH9%K?.;D%Z*AE*X.KU_+SB244.PYVW,]N&E0-K&)_W@W,<PV
A>PE6(>-_X:%-!+6OX?.V_(TC6_#3XN?1/6-MAP"X;2<!0NV
#pragma PXL encrypted end
   WRAPPER_DM6_O_L = WRAPPER_DM6NEW_O_L or WRAPPER_DM6_O_L_PRE; 
   
#pragma PXL encrypted begin
;LI0&E0<-1MNMEOR[>RDKSVV,O-*K$\?H' R!.?!9:PH!<P$/>MVHK_N\[ ]P)2NAKJ?4X7 
A2<:(PDN@S*%/>MVHK_N\[ ]P)2NAKJ?4X7 ^AU>@N6TE%/Z,B01HBJKN,DR&F[KQ.:1XR :
, O<\(_,2!4PRX37^Y! D<O+)UE54)YV$P0GVC,3<D*#K&?:#/I#/$,+E^8,
#pragma PXL encrypted end

#endif

#ifdef FILL_DM7
//***** filling region *********************************************************
REGION_WRAPPER_DM7 = CHIP_snps and or_list( {
    over_size( M7_MAIN, WRAPPER_RANGEY1),
    (CHIP_snps not over_size( CHIP_snps, -WRAPPER_RANGEY1)),
    over_size( (BEOLBLK_FINAL or DM7EXCL_FINAL), WRAPPER_RANGEY1)
 });

#pragma PXL encrypted begin
"@PG!_>FIR0*64/@/.@^3UM96Y87G 'L<>Q;]1/,7C>33V_U/%JLW>T-2* \FWQFH[-R(-2;
X0%L!/EBS0GAH[L3R[C,+6&C<319_^*3;X!Q.9',+9N.U5@Y
#pragma PXL encrypted end

// DUMMY SPEC : Wrapper_DM7_O_Connect
//***DM7_O_Connect***
FSS_SPEC_WRAPPER_DM7_O_CONNECT: list of fill_to_signal_spacing_s = {
    { CHIP_snps, min_space = DMY1_CHIP, context = INTERIOR },
#ifdef FULL_CHIP
    { CHIP_BOUNDARY, min_space = DMY1_CHIP, context = INTERIOR },
#else
    { PRBOUNDARY, min_space = DMY1_CHIP, context = INTERIOR },
#endif
    { ICOVL_SINGLE, min_space = DMY1_ICOVL },
    { BEOLBLK_FINAL, min_space = DM_BEOLBLK },
    { CSR66_3485, min_space = DM_BEOLBLK },
    { INDDMY, min_space = DM_INDDMY },
    { DM7EXCL_FINAL, min_space = DM_DMXEXCL },
    { TCDDMY_M7, min_space = DM_TCDDMY_MX },
    { M7_MAIN, min_space = DMY1OR_MY1 },
    { DM7_O, min_space = DMY1OR_DMY1O },
    { DM7, min_space = 0.2 }, //DMn.S.3.5
    { DM7_GT1350, min_space = 0.45 },
    { M7_HOLE, min_space = 0 },
    { M7_GT76, min_space = DMY1_MY1W1 },
    { M7_GT114, min_space = DMY1_MY1W2 },
    { M7_GT152, min_space = DMY1_MY1W3 },
    { M7_GT180, min_space = DMY1_MY1W4 },
    { M7_GT240, min_space = DMY1_MY1W5 },
    { M7_GT280, min_space = DMY1_MY1W6 },
    { M7_GT500, min_space = DMY1_MY1W7 },
    { M7_GT1350, min_space = DMY1_MY1W8 },
    { M7_45, min_space = 0 },
    { VIA6_HVN_5V, min_space = DMY1_VY15V },
    { M7_HVN_5V, min_space = DMY1_MY15V },
    { VIA7_HVN_5V, min_space = DMY1_VY15V },

{ R7_VIA6_CHK_REGION, min_space = 0 },
{ R15_VIA7_CHK_REGION, min_space = 0 },

{ S22_M7_REGION, min_space = 0 },
#pragma PXL encrypted begin
MXU-(:!+"G&W-3AU=[M;W+(U)Y9\>$8O"34GMRZ #O+P5=6WD8YEO*(##X.1\TKQ(I08 IGS
/^M:1"ZVDB8_M619,A>-CONUA9 MC]/<BA*%NX4HU>EH(LN[QUF% "V?Y)K'I&U%:!ZH)S&D
-(YPTHOK#^PTG?YW*_:6Q["=.^9!:4FXY/L[1N&(!F#/!;U&^+%'VT<>QVGX%W#$912NB@07
H-2\3P4:9SV@)BXZV1 ]>/(F27?//D'QC[%)OY#S\2' KD2_
#pragma PXL encrypted end

};


LAYER_DM7_MYCELL_H : polygon_layer_s = {
    layer_spec = {
        output_layer_key = "OUTPUT_WRAPPER_DM7_O_CONNECT"
    },
    polygons = MYCELL_H
};

LAYER_DM7_MYCELL_V : polygon_layer_s = {
    layer_spec = {
        output_layer_key = "OUTPUT_WRAPPER_DM7_O_CONNECT"
    },
    polygons = MYCELL_V
};

LAYER_DM7_MYCELL_HEXT : polygon_layer_s = {
    layer_spec = {
        output_layer_key = "OUTPUT_WRAPPER_DM7_O_CONNECT"
    },
    polygons = MYCELL_HEXT
};

LAYER_DM7_MYCELL_VEXT : polygon_layer_s = {
    layer_spec = {
        output_layer_key = "OUTPUT_WRAPPER_DM7_O_CONNECT"
    },
    polygons = MYCELL_VEXT 
};

SPEC_WRAPPER_DM7_O_CONNECT = unified_fill(
    fill_patterns = {
        {
            type = UF_POLYGON,
            polygon_fill = {
                pattern_spec = {
            	    pattern_spacing = {
               	       allowed_spacing_x = { >= DMY1OR_SC },
                       allowed_spacing_y = { >= DMY1OR_SC },
                       extension = INTERSECTION
                    },                    
#ifdef VERTICAL_M7     
                    space_x = DMY1OR_SX,
                    space_y = DMY1OR_SY,
                    stagger_x = DMY1OR_OX,
                    stagger_y = DMY1OR_OY,
#else
                    space_x = DMY1OR_SY,
                    space_y = DMY1OR_SX,
                    stagger_x = DMY1OR_OY,
                    stagger_y = DMY1OR_OX,
#endif 
                },
                insertion = {
#pragma PXL encrypted begin
.2G($?I-S10YE<NB3-["1PF5O9@-1IH&9H>]5R]BD^$L;1A7:K9.TRA]+LYJ2MKBQS99[0]*
WV0V:N)+5'/?C#:<. 97OF",I$EBP[D>A>2DG674OP/Z\'>=,]8+YA>]Y48SXXE]N0;E3,+C
,@SJGS=>2,\R^2=+^3+-^*/Y_=;"YG.RE?S]
#pragma PXL encrypted end
                    iterations = 3,
#pragma PXL encrypted begin
G_<G#VC3#T2?K9EUKV;7WW"M2%Q'9C?UY/](AX@O1@I3:-*'UV*0]K*0Y++79T@B9O'N'@]G
:/_APWY\O])HB9SWEJ!R$7Z)
#pragma PXL encrypted end
		            starting_point = CENTER,
                    shift_factor = 2,
                },layers = {
#ifdef VERTICAL_M7     
                    LAYER_DM7_MYCELL_V, 
#else
                    LAYER_DM7_MYCELL_H, 
#endif                                                       
                },
                merging_layers = {
#ifdef VERTICAL_M7     
                    LAYER_DM7_MYCELL_VEXT,
#else
                    LAYER_DM7_MYCELL_HEXT,
#endif                                                       
                },

#ifdef ANTPrevention                
                merging_blockage_layer_list = {
                FORBIDDEN_RING
                },
#endif                              
#ifdef CONTROL_MAX_METAL_LENGTH                 
#ifdef VERTICAL_M7     
                merging_direction = VERTICAL,
#else
                merging_direction = HORIZONTAL,
#endif                                                       
                merging_length_limit = 4*( DMY1OR_L + DMY1OR_SY ) - DMY1OR_SY, // repeat 4 
#else
#ifdef VERTICAL_M7     
                merging_direction = VERTICAL,
#else
                merging_direction = HORIZONTAL,
#endif                                                       
                merging_length_limit = 500*( DMY1OR_L + DMY1OR_SY ) - DMY1OR_SY, // repeat 500 
#endif
                fill_to_signal_spacing = FSS_SPEC_WRAPPER_DM7_O_CONNECT,
                hierarchical_fill = false,
#ifdef VERTICAL_M7     
                cell_prefix = "WDMR7VNEW"
#else
                cell_prefix = "WDMR7HNEW"
#endif                                                       
            }
        }
    },
    extents_output = {
        {
            output_layer_key = "OUTPUT_WRAPPER_DM7O_CONNECT_EXTENT"
        },
    },
    fill_boundary = {
        layer = REGION_WRAPPER_DM7, 
        type = LAYER 
    },
	grid = vGRID
);

WRAPPER_DM7NEW_O_C = SPEC_WRAPPER_DM7_O_CONNECT["OUTPUT_WRAPPER_DM7_O_CONNECT"][0];
WRAPPER_DM7NEW_O_L = SPEC_WRAPPER_DM7_O_CONNECT["OUTPUT_WRAPPER_DM7_O_CONNECT"][0];
//=======================================================
#pragma PXL encrypted begin
$5-24KN[XB01S\&P73DV*/?/9CK(,"<A*8!FRXF6*=#DH3++X[6QJ8Z(H#GC?:3+<I\0*FI]
)U&%J'2GWDPG',XLK2!B_R4<
#pragma PXL encrypted end

//***** spec *******************************************************************
// DUMMY SPEC : Wrapper_DM7
//***DM7_O_R***
PATTERN_SPEC_WRAPPER_DM7_0 = get_single_polygon_pattern(
#ifdef VERTICAL_M7
	"WDMR7V", "OUTPUT_WRAPPER_DM7_O", DMY1OR_W, DMY1OR_L,
	step_x = DMY1OR_SX, step_y = DMY1OR_SY,
	offset_x = DMY1OR_OX, offset_y = DMY1OR_OY,
	setback = DMY1OR_SC,
	setback_type = INTERSECTION,
#else
	"WDMR7H", "OUTPUT_WRAPPER_DM7_O", DMY1OR_L, DMY1OR_W,
	step_x = DMY1OR_SY, step_y = DMY1OR_SX,
	offset_x = DMY1OR_OY, offset_y = DMY1OR_OX,
	setback = DMY1OR_SC,
	setback_type = INTERSECTION,
#endif
    FSS = {
    { CHIP_snps, min_space = DMY1_CHIP, context = INTERIOR },
#ifdef FULL_CHIP
    { CHIP_BOUNDARY, min_space = DMY1_CHIP, context = INTERIOR },
#else
    { PRBOUNDARY, min_space = DMY1_CHIP, context = INTERIOR },
#endif
    { ICOVL_SINGLE, min_space = DMY1_ICOVL },
    { BEOLBLK_FINAL, min_space = DM_BEOLBLK },
    { CSR66_3485, min_space = DM_BEOLBLK },
    { INDDMY, min_space = DM_INDDMY },
    { DM7EXCL_FINAL, min_space = DM_DMXEXCL },
    { TCDDMY_M7, min_space = DM_TCDDMY_MX },
    { M7_MAIN, min_space = DMY1OR_MY1 },
    { DM7_O, min_space = DMY1OR_DMY1O },
    { DM7, min_space = 0.2 }, //DMn.S.3.5
    { DM7_GT1350, min_space = 0.45 },
    { M7_HOLE, min_space = 0 },
    { M7_GT76, min_space = DMY1_MY1W1 },
    { M7_GT114, min_space = DMY1_MY1W2 },
    { M7_GT152, min_space = DMY1_MY1W3 },
    { M7_GT180, min_space = DMY1_MY1W4 },
    { M7_GT240, min_space = DMY1_MY1W5 },
    { M7_GT280, min_space = DMY1_MY1W6 },
    { M7_GT500, min_space = DMY1_MY1W7 },
    { M7_GT1350, min_space = DMY1_MY1W8 },
    { M7_45, min_space = 0 },
    { VIA6_HVN_5V, min_space = DMY1_VY15V },
    { M7_HVN_5V, min_space = DMY1_MY15V },
    { VIA7_HVN_5V, min_space = DMY1_VY15V },

              { R7_VIA6_CHK_REGION, min_space = 0 },
              { R15_VIA7_CHK_REGION, min_space = 0 },

              { S22_M7_REGION, min_space = 0 },
#pragma PXL encrypted begin
SA3)&6MZ-33.+$BY,EMV,*(LQX4<>OIP+\S'YI1G7245I('FR%D!'CY<^P;(66!)G&$=SK)9
3+5PU5D8I#1,!4IQ2_1SPWL% ZV2)&23 $H#H",RN46M3EV@
#pragma PXL encrypted end

              { WRAPPER_DM7NEW_O_L, min_space = DMY1OR_DMY1O },
#pragma PXL encrypted begin
)*/8:=+EAR D&X(L&JTA3/$;[9B]Z2X[36[M$#<L*V&"X+H09<NC)N/ZTU!E$A+&I!E(TAP2
>JV#R?HU"$EZ(#GBA?RC\LT@
#pragma PXL encrypted end

    },//end of FSS
	shift = 2,
#pragma PXL encrypted begin
>3'H.3I1V@QYVG<&WSE0<+G:QPJJJ;GF\K7'A(X5C:XG"DZ$\?N&X\\+FJ'QW&G9I.;JX/O<
5N"?I/OWLT=6K["+_Z<'$Q^O7<](KH@JK?I=FD%1B>.&/3N:TXK0$:#23C[3
#pragma PXL encrypted end
    repeat = 3
#pragma PXL encrypted begin
S[_W":&\+'G/?.&%E@;QL/1\=2#KS^NTC[9U,U>P(P:W,M\SR%Z1;&I,W]7(L_:I&YF#_M"S
C#UGAF%Y"P*,\_W&+14#,X/S
#pragma PXL encrypted end
);// end of 1st pattern
//==============================================================
//----------------------------------------------------------------------------------------------------

//***DM7_O_W***
// DUMMY SPEC : Wrapper_DM7_O_W
PATTERN_SPEC_WRAPPER_DM7_1 = get_single_polygon_pattern(
#ifdef VERTICAL_M7
	"WDMW7V", "OUTPUT_WRAPPER_DM7_O", DMY1OW_W, DMY1OW_L,
	step_x = DMY1OW_SY, step_y = DMY1OW_SX,
	offset_x = DMY1OW_OY, offset_y = DMY1OW_OX,
	setback = 0.114,
	setback_type = INTERSECTION,
#else
	"WDMW7H", "OUTPUT_WRAPPER_DM7_O", DMY1OW_L, DMY1OW_W,
	step_x = DMY1OW_SX, step_y = DMY1OW_SY,
	offset_x = DMY1OW_OX, offset_y = DMY1OW_OY,
	setback = 0.114,
	setback_type = INTERSECTION,
#endif
    FSS = {
    { CHIP_snps, min_space = DMY1_CHIP, context = INTERIOR },
#ifdef FULL_CHIP
    { CHIP_BOUNDARY, min_space = DMY1_CHIP, context = INTERIOR },
#else
    { PRBOUNDARY, min_space = DMY1_CHIP, context = INTERIOR },
#endif
    { ICOVL_SINGLE, min_space = DMY1_ICOVL },
    { BEOLBLK_FINAL, min_space = DM_BEOLBLK },
    { INDDMY, min_space = DM_INDDMY },

    { DM7EXCL_FINAL, min_space = DM_DMXEXCL },
    { CSR66_3485, min_space = DM_BEOLBLK },
    { TCDDMY_M7, min_space = DM_TCDDMY_MX },

    { M7_MAIN, min_space = DMY1OW_MY1 },
    { DM7_O, min_space = DMY1OW_DMY1O },
    { DM7, min_space = 0.2 }, //DMn.S.3.5
    { DM7_GT1350, min_space = 0.45 },
    { M7_HOLE, min_space = 0 },
    { M7_GT76, min_space = DMY1_MY1W1 },
    { M7_GT114, min_space = DMY1_MY1W2 },
    { M7_GT152, min_space = DMY1_MY1W3 },
    { M7_GT180, min_space = DMY1_MY1W4 },
    { M7_GT240, min_space = DMY1_MY1W5 },
    { M7_GT280, min_space = DMY1_MY1W6 },
    { M7_GT500, min_space = DMY1_MY1W7 },
    { M7_GT1350, min_space = DMY1_MY1W8 },
    { M7_45, min_space = 0 },
    { VIA6_HVN_5V, min_space = DMY1_VY15V },
    { M7_HVN_5V, min_space = DMY1_MY15V },
    { VIA7_HVN_5V, min_space = DMY1_VY15V },

              { R7_VIA6_CHK_REGION, min_space = 0 },
              { R15_VIA7_CHK_REGION, min_space = 0 },

              { S22_M7_REGION, min_space = 0 },
#pragma PXL encrypted begin
0!LB3?6D_UE O37=X'RY6YJ]#L.F+8=ZR# ._^(S]0D697/_4?Y@M,HWB=Y1LJ-8XG%L)Y>R
O?FI/DL])6F]Y'TV8=</&WCD<.>,I]?\R+=P.I;$1%YM78 Z
#pragma PXL encrypted end

              { WRAPPER_DM7NEW_O_L, min_space = DMY1OW_DMY1O },
#pragma PXL encrypted begin
S!RH#)$5@B#,+^9A:QA_%/0OUJ;0 'VCN^76,!@&9B3F?7XP58%Q-37L2:)5IE\Z'N?G0/ZF
8L.@#,\[/^9B&E$PXR):$4T:
#pragma PXL encrypted end

	},
    shift = 2,
#pragma PXL encrypted begin
M<3*?8]V=%BU7@FK^!EQ!#Y>PW^FVPF(-R7#*8&*CXIRHZ$IGNRKQ *H3EJ>6=X:GY%HQ9Y9
T:=7I:?]/B'1W(9_P2D65<O<*W23,#1ZT3PK2)Q&B;#I^:](4:!PE<2-<?Q1
#pragma PXL encrypted end
    repeat = 3
#pragma PXL encrypted begin
0<90/2OG]AY!_!O=-IRH0:O\RM[JMC03)DK*Z2TH;^:]SP'I"K!6QI9H(EP*7T9Q%N_]9$]?
#>6(5270%Y8-!&\UM,1>CY<$
#pragma PXL encrypted end
); //end of get_single_polygon_pattern


PATTERN_SPEC_WRAPPER_DM7_0.polygon_fill.pattern_spec.other_pattern_spacing = {
         1 => > DMY1OR_DMY1O 
};
PATTERN_SPEC_WRAPPER_DM7_1.polygon_fill.pattern_spec.other_pattern_spacing = {
         0 => > DMY1OW_DMY1O
};
  


SPEC_WRAPPER_DM7 = unified_fill(
    fill_boundary = {
        layer = CHIP_snps and REGION_WRAPPER_DM7,
        type = LAYER
    },
    fill_patterns = {
        PATTERN_SPEC_WRAPPER_DM7_0,
        PATTERN_SPEC_WRAPPER_DM7_1,
    },
    boundary = ALIGN,
	grid = vGRID
);

//==============================================================
//***** fill *******************************************************************
WRAPPER_DM7_O_C     = SPEC_WRAPPER_DM7["OUTPUT_WRAPPER_DM7_O"][0];
WRAPPER_DM7_O_L_PRE = SPEC_WRAPPER_DM7["OUTPUT_WRAPPER_DM7_O"][0];


//===========================================
#pragma PXL encrypted begin
%'N=&0)WF0(4N8G(=O"?/B>Y!Q*/.<9"D/$'E/+ZQ%:);UB4_]74H'S/"XK_7O@$$'QEB"5>
YOB(8>B=:#[F&L 8FD3G*"$:9GZ3LN*O]Q-F]@BE+ \4W?CV
#pragma PXL encrypted end
   WRAPPER_DM7_O_L = WRAPPER_DM7NEW_O_L or WRAPPER_DM7_O_L_PRE; 
   
#pragma PXL encrypted begin
,Y8V>C7=NQ0SR\-=9D")_!O+E3&2/6VCKZZ5_ZEO"*6T_ G_@)Q0?@[MN*R 8O8$1XV1@EMB
GD1 G64N@3J>@)Q0?@[MN*R 8O8$1XV1@EMB%51T7\.-8O$5?Y!T- ^L?:%_JXE:J(ZX?Q2K
/4W2TC$OD0\]43 M*AH _451[/^6SP_%A-CL26PV&>^)OW=)3+M 'L')T"=,
#pragma PXL encrypted end

#endif

#ifdef FILL_DM8
//***** filling region *********************************************************
REGION_WRAPPER_DM8 = CHIP_snps and or_list( {
    over_size( M8_MAIN, WRAPPER_RANGEY1),
    (CHIP_snps not over_size( CHIP_snps, -WRAPPER_RANGEY1)),
    over_size( (BEOLBLK_FINAL or DM8EXCL_FINAL), WRAPPER_RANGEY1)
 });

#pragma PXL encrypted begin
S]<,9]AG+A[/N-@M^<H,3KRXS!L661,5-1#,I>*TK$KIWA:E8!X0[EY]/X9@"V%XIID$SD8+
)FY'ZE-@9$ FQ/9)7.Z ,5O$W48P?X3EP4W=-",E#Q)$*.LT
#pragma PXL encrypted end

// DUMMY SPEC : Wrapper_DM8_O_Connect
//***DM8_O_Connect***
FSS_SPEC_WRAPPER_DM8_O_CONNECT: list of fill_to_signal_spacing_s = {
    { CHIP_snps, min_space = DMY1_CHIP, context = INTERIOR },
#ifdef FULL_CHIP
    { CHIP_BOUNDARY, min_space = DMY1_CHIP, context = INTERIOR },
#else
    { PRBOUNDARY, min_space = DMY1_CHIP, context = INTERIOR },
#endif
    { ICOVL_SINGLE, min_space = DMY1_ICOVL },
    { BEOLBLK_FINAL, min_space = DM_BEOLBLK },
    { CSR66_3485, min_space = DM_BEOLBLK },
    { INDDMY, min_space = DM_INDDMY },
    { DM8EXCL_FINAL, min_space = DM_DMXEXCL },
    { TCDDMY_M8, min_space = DM_TCDDMY_MX },
    { M8_MAIN, min_space = DMY1OR_MY1 },
    { DM8_O, min_space = DMY1OR_DMY1O },
    { DM8, min_space = 0.2 }, //DMn.S.3.5
    { DM8_GT1350, min_space = 0.45 },
    { M8_HOLE, min_space = 0 },
    { M8_GT76, min_space = DMY1_MY1W1 },
    { M8_GT114, min_space = DMY1_MY1W2 },
    { M8_GT152, min_space = DMY1_MY1W3 },
    { M8_GT180, min_space = DMY1_MY1W4 },
    { M8_GT240, min_space = DMY1_MY1W5 },
    { M8_GT280, min_space = DMY1_MY1W6 },
    { M8_GT500, min_space = DMY1_MY1W7 },
    { M8_GT1350, min_space = DMY1_MY1W8 },
    { M8_45, min_space = 0 },
    { VIA7_HVN_5V, min_space = DMY1_VY15V },
    { M8_HVN_5V, min_space = DMY1_MY15V },
    { VIA8_HVN_5V, min_space = DMY1_VY15V },

{ R7_VIA7_CHK_REGION, min_space = 0 },
{ R15_VIA8_CHK_REGION, min_space = 0 },

{ S22_M8_REGION, min_space = 0 },
#pragma PXL encrypted begin
(+.63QX<(7D@9_8N^$RR%TAGIZ(Z_I$FG>RGXV!L7*X8V_3CTE3OQPOX5Z[2KROA>2**5B:O
"3+1"O%0.'T)KF'3<TPK<E6N-DR"R"/:R1TV\$=J^]_"R1_PSS.QA6Y7.JW/C^]76U&V40>/
_P4<BO=A8_'_514PB_""SS]5[#TZ T$'\3?L K DQ!"]7Q "9GOD('AMG!UF-V-JRN_GSU,W
'^2D:GIWV'L?+Y0['BCSJH$OQ#=717+[OZ/$T.1R.41'O-_0
#pragma PXL encrypted end

};


LAYER_DM8_MYCELL_H : polygon_layer_s = {
    layer_spec = {
        output_layer_key = "OUTPUT_WRAPPER_DM8_O_CONNECT"
    },
    polygons = MYCELL_H
};

LAYER_DM8_MYCELL_V : polygon_layer_s = {
    layer_spec = {
        output_layer_key = "OUTPUT_WRAPPER_DM8_O_CONNECT"
    },
    polygons = MYCELL_V
};

LAYER_DM8_MYCELL_HEXT : polygon_layer_s = {
    layer_spec = {
        output_layer_key = "OUTPUT_WRAPPER_DM8_O_CONNECT"
    },
    polygons = MYCELL_HEXT
};

LAYER_DM8_MYCELL_VEXT : polygon_layer_s = {
    layer_spec = {
        output_layer_key = "OUTPUT_WRAPPER_DM8_O_CONNECT"
    },
    polygons = MYCELL_VEXT 
};

SPEC_WRAPPER_DM8_O_CONNECT = unified_fill(
    fill_patterns = {
        {
            type = UF_POLYGON,
            polygon_fill = {
                pattern_spec = {
            	    pattern_spacing = {
               	       allowed_spacing_x = { >= DMY1OR_SC },
                       allowed_spacing_y = { >= DMY1OR_SC },
                       extension = INTERSECTION
                    },                    
#ifdef VERTICAL_M8     
                    space_x = DMY1OR_SX,
                    space_y = DMY1OR_SY,
                    stagger_x = DMY1OR_OX,
                    stagger_y = DMY1OR_OY,
#else
                    space_x = DMY1OR_SY,
                    space_y = DMY1OR_SX,
                    stagger_x = DMY1OR_OY,
                    stagger_y = DMY1OR_OX,
#endif 
                },
                insertion = {
#pragma PXL encrypted begin
D0[!$G($]%F1F?\B?@E6ZW.9H_O*W# MZZNCB9^)\T'3 0^)@!.BPZDJM#B +MF4GAJUV.,N
6+&C'@H3OJM8YO^)0IA)_C?FSX4W,A*O9XK/'X%2@J_ 4T8?LIX=9F.EF$"RC^_$,(?PFW2/
TL,YC]S+5R72YZ!LTN[..K/GL+*JUOJ<@62P
#pragma PXL encrypted end
                    iterations = 3,
#pragma PXL encrypted begin
5(.]04)ZIGI4/EMB$P205+4^ZC\D"4#YNWGJ)\X>6YTCP<@GC J)JU^=[.>,.)+.CR&%>UTX
YP^*KW[:3:'G*5:(T14*)?HI
#pragma PXL encrypted end
		            starting_point = CENTER,
                    shift_factor = 2,
                },layers = {
#ifdef VERTICAL_M8     
                    LAYER_DM8_MYCELL_V, 
#else
                    LAYER_DM8_MYCELL_H, 
#endif                                                       
                },
                merging_layers = {
#ifdef VERTICAL_M8     
                    LAYER_DM8_MYCELL_VEXT,
#else
                    LAYER_DM8_MYCELL_HEXT,
#endif                                                       
                },

#ifdef ANTPrevention                
                merging_blockage_layer_list = {
                FORBIDDEN_RING
                },
#endif                              
#ifdef CONTROL_MAX_METAL_LENGTH                 
#ifdef VERTICAL_M8     
                merging_direction = VERTICAL,
#else
                merging_direction = HORIZONTAL,
#endif                                                       
                merging_length_limit = 4*( DMY1OR_L + DMY1OR_SY ) - DMY1OR_SY, // repeat 4 
#else
#ifdef VERTICAL_M8     
                merging_direction = VERTICAL,
#else
                merging_direction = HORIZONTAL,
#endif                                                       
                merging_length_limit = 500*( DMY1OR_L + DMY1OR_SY ) - DMY1OR_SY, // repeat 500 
#endif
                fill_to_signal_spacing = FSS_SPEC_WRAPPER_DM8_O_CONNECT,
                hierarchical_fill = false,
#ifdef VERTICAL_M8     
                cell_prefix = "WDMR8VNEW"
#else
                cell_prefix = "WDMR8HNEW"
#endif                                                       
            }
        }
    },
    extents_output = {
        {
            output_layer_key = "OUTPUT_WRAPPER_DM8O_CONNECT_EXTENT"
        },
    },
    fill_boundary = {
        layer = REGION_WRAPPER_DM8, 
        type = LAYER 
    },
	grid = vGRID
);

WRAPPER_DM8NEW_O_C = SPEC_WRAPPER_DM8_O_CONNECT["OUTPUT_WRAPPER_DM8_O_CONNECT"][0];
WRAPPER_DM8NEW_O_L = SPEC_WRAPPER_DM8_O_CONNECT["OUTPUT_WRAPPER_DM8_O_CONNECT"][0];
//=======================================================
#pragma PXL encrypted begin
,L748_]LV0\RAXC-G2E>K3R'@W%?JI7T:.B#R4^:K*77L5[)IS7V%0$,B RGRJ4(*19E]>[*
W&19:A:^$+_<,'IE-=W#30XP
#pragma PXL encrypted end

//***** spec *******************************************************************
// DUMMY SPEC : Wrapper_DM8
//***DM8_O_R***
PATTERN_SPEC_WRAPPER_DM8_0 = get_single_polygon_pattern(
#ifdef VERTICAL_M8
	"WDMR8V", "OUTPUT_WRAPPER_DM8_O", DMY1OR_W, DMY1OR_L,
	step_x = DMY1OR_SX, step_y = DMY1OR_SY,
	offset_x = DMY1OR_OX, offset_y = DMY1OR_OY,
	setback = DMY1OR_SC,
	setback_type = INTERSECTION,
#else
	"WDMR8H", "OUTPUT_WRAPPER_DM8_O", DMY1OR_L, DMY1OR_W,
	step_x = DMY1OR_SY, step_y = DMY1OR_SX,
	offset_x = DMY1OR_OY, offset_y = DMY1OR_OX,
	setback = DMY1OR_SC,
	setback_type = INTERSECTION,
#endif
    FSS = {
    { CHIP_snps, min_space = DMY1_CHIP, context = INTERIOR },
#ifdef FULL_CHIP
    { CHIP_BOUNDARY, min_space = DMY1_CHIP, context = INTERIOR },
#else
    { PRBOUNDARY, min_space = DMY1_CHIP, context = INTERIOR },
#endif
    { ICOVL_SINGLE, min_space = DMY1_ICOVL },
    { BEOLBLK_FINAL, min_space = DM_BEOLBLK },
    { CSR66_3485, min_space = DM_BEOLBLK },
    { INDDMY, min_space = DM_INDDMY },
    { DM8EXCL_FINAL, min_space = DM_DMXEXCL },
    { TCDDMY_M8, min_space = DM_TCDDMY_MX },
    { M8_MAIN, min_space = DMY1OR_MY1 },
    { DM8_O, min_space = DMY1OR_DMY1O },
    { DM8, min_space = 0.2 }, //DMn.S.3.5
    { DM8_GT1350, min_space = 0.45 },
    { M8_HOLE, min_space = 0 },
    { M8_GT76, min_space = DMY1_MY1W1 },
    { M8_GT114, min_space = DMY1_MY1W2 },
    { M8_GT152, min_space = DMY1_MY1W3 },
    { M8_GT180, min_space = DMY1_MY1W4 },
    { M8_GT240, min_space = DMY1_MY1W5 },
    { M8_GT280, min_space = DMY1_MY1W6 },
    { M8_GT500, min_space = DMY1_MY1W7 },
    { M8_GT1350, min_space = DMY1_MY1W8 },
    { M8_45, min_space = 0 },
    { VIA7_HVN_5V, min_space = DMY1_VY15V },
    { M8_HVN_5V, min_space = DMY1_MY15V },
    { VIA8_HVN_5V, min_space = DMY1_VY15V },

              { R7_VIA7_CHK_REGION, min_space = 0 },
              { R15_VIA8_CHK_REGION, min_space = 0 },

              { S22_M8_REGION, min_space = 0 },
#pragma PXL encrypted begin
)OK!&N,P7'DF!>G]H"RR8S@%\U2N "_>-*GS1D?M[2CU8$E&A/A,R1.R.Y:$<&FZUU:,@85P
=\/02GOHWC-W.J2><.]W(>,Z1Z:;T[2!%!='WW ZXKD$>*C?
#pragma PXL encrypted end

              { WRAPPER_DM8NEW_O_L, min_space = DMY1OR_DMY1O },
#pragma PXL encrypted begin
?(C1:DJ<KF5\GDSURC0)]S:>355%9B.)N-]-H,"XHQ2Z65*@&KYU5S.J;;H:R;PG.PP:T S)
9:C,*ZB@RHEE4(#-?/1O0 10
#pragma PXL encrypted end

    },//end of FSS
	shift = 2,
#pragma PXL encrypted begin
FZ-J2WT"T7>;AU-R)'FY0/V'/2RU#9E.&S$]*/76_GMD9NHHN+"/KL%2T=NXP=#O+K96+[_!
*;\M]'1+2V(I\()J1(C\U[KPSIX?*H9WIG/.86'*^K)<AW%A&WNOXOVI8%D;
#pragma PXL encrypted end
    repeat = 3
#pragma PXL encrypted begin
\#%Z&^5M(V3PM34FC\C9RH:U8Z^19K!H .1CGSO=O.S#^3B?%U2.IJ3',JP7R*";!X[L<UC(
]G3RE2)$ZK_V>Y]4M<"= XU[
#pragma PXL encrypted end
);// end of 1st pattern
//==============================================================
//----------------------------------------------------------------------------------------------------

//***DM8_O_W***
// DUMMY SPEC : Wrapper_DM8_O_W
PATTERN_SPEC_WRAPPER_DM8_1 = get_single_polygon_pattern(
#ifdef VERTICAL_M8
	"WDMW8V", "OUTPUT_WRAPPER_DM8_O", DMY1OW_W, DMY1OW_L,
	step_x = DMY1OW_SY, step_y = DMY1OW_SX,
	offset_x = DMY1OW_OY, offset_y = DMY1OW_OX,
	setback = 0.114,
	setback_type = INTERSECTION,
#else
	"WDMW8H", "OUTPUT_WRAPPER_DM8_O", DMY1OW_L, DMY1OW_W,
	step_x = DMY1OW_SX, step_y = DMY1OW_SY,
	offset_x = DMY1OW_OX, offset_y = DMY1OW_OY,
	setback = 0.114,
	setback_type = INTERSECTION,
#endif
    FSS = {
    { CHIP_snps, min_space = DMY1_CHIP, context = INTERIOR },
#ifdef FULL_CHIP
    { CHIP_BOUNDARY, min_space = DMY1_CHIP, context = INTERIOR },
#else
    { PRBOUNDARY, min_space = DMY1_CHIP, context = INTERIOR },
#endif
    { ICOVL_SINGLE, min_space = DMY1_ICOVL },
    { BEOLBLK_FINAL, min_space = DM_BEOLBLK },
    { INDDMY, min_space = DM_INDDMY },

    { DM8EXCL_FINAL, min_space = DM_DMXEXCL },
    { CSR66_3485, min_space = DM_BEOLBLK },
    { TCDDMY_M8, min_space = DM_TCDDMY_MX },

    { M8_MAIN, min_space = DMY1OW_MY1 },
    { DM8_O, min_space = DMY1OW_DMY1O },
    { DM8, min_space = 0.2 }, //DMn.S.3.5
    { DM8_GT1350, min_space = 0.45 },
    { M8_HOLE, min_space = 0 },
    { M8_GT76, min_space = DMY1_MY1W1 },
    { M8_GT114, min_space = DMY1_MY1W2 },
    { M8_GT152, min_space = DMY1_MY1W3 },
    { M8_GT180, min_space = DMY1_MY1W4 },
    { M8_GT240, min_space = DMY1_MY1W5 },
    { M8_GT280, min_space = DMY1_MY1W6 },
    { M8_GT500, min_space = DMY1_MY1W7 },
    { M8_GT1350, min_space = DMY1_MY1W8 },
    { M8_45, min_space = 0 },
    { VIA7_HVN_5V, min_space = DMY1_VY15V },
    { M8_HVN_5V, min_space = DMY1_MY15V },
    { VIA8_HVN_5V, min_space = DMY1_VY15V },

              { R7_VIA7_CHK_REGION, min_space = 0 },
              { R15_VIA8_CHK_REGION, min_space = 0 },

              { S22_M8_REGION, min_space = 0 },
#pragma PXL encrypted begin
B,#*(&9!-ER([C12J/L;=%;N-Z!,%1[&,]8W<OF@#?_VLR5R6]Y.=_>?H/Q;SS+[B$P4R0//
EE]1]A"K <*60U5'2GV)QL!#]GB;RL^FEBGVY-CUIG<#80OD
#pragma PXL encrypted end

              { WRAPPER_DM8NEW_O_L, min_space = DMY1OW_DMY1O },
#pragma PXL encrypted begin
@:@]/VN\&%>!A.PCH%U::.F$*501::\6.CPI'>*3&9OIV8\=O4+<_7TAF^N]C8WP*P[_%HV-
$"/6/+>=( (0-2X.-L4W[C,U
#pragma PXL encrypted end

	},
    shift = 2,
#pragma PXL encrypted begin
H,/6'YXB.VF@?//%H^A"I/5\_T%V2W!*U@G_0QVK1R\:!*9#+#J52<=2'?XLW ,=_J]&/IO<
R*&LD#MI3_?(/O?X_XV%K (^4IDA;-S.6W120,SA?CC ^<) $ZYBAP8.&\X3
#pragma PXL encrypted end
    repeat = 3
#pragma PXL encrypted begin
8CC33F^8[0EB^I/N,:'3#0OZ4XV+96V9&,)3.5;&?S<A 24YE=P)'UYVU)>5O_ZU#IZ&NV2_
:^AI<@IT8(UKA7_">'5[$/*%
#pragma PXL encrypted end
); //end of get_single_polygon_pattern


PATTERN_SPEC_WRAPPER_DM8_0.polygon_fill.pattern_spec.other_pattern_spacing = {
         1 => > DMY1OR_DMY1O 
};
PATTERN_SPEC_WRAPPER_DM8_1.polygon_fill.pattern_spec.other_pattern_spacing = {
         0 => > DMY1OW_DMY1O
};
  


SPEC_WRAPPER_DM8 = unified_fill(
    fill_boundary = {
        layer = CHIP_snps and REGION_WRAPPER_DM8,
        type = LAYER
    },
    fill_patterns = {
        PATTERN_SPEC_WRAPPER_DM8_0,
        PATTERN_SPEC_WRAPPER_DM8_1,
    },
    boundary = ALIGN,
	grid = vGRID
);

//==============================================================
//***** fill *******************************************************************
WRAPPER_DM8_O_C     = SPEC_WRAPPER_DM8["OUTPUT_WRAPPER_DM8_O"][0];
WRAPPER_DM8_O_L_PRE = SPEC_WRAPPER_DM8["OUTPUT_WRAPPER_DM8_O"][0];


//===========================================
#pragma PXL encrypted begin
->T?*T8HD&TUH=/ILX"F3@VA#,%V/O-@G?L,R,$TN00#>!'(NLUE<?9%/2VZD&3-CY >\.&0
!*UX]SM>ZM($KP6WQ^^EH ZO" Q1Z"+/"58(]N(:C2-_&)+V
#pragma PXL encrypted end
   WRAPPER_DM8_O_L = WRAPPER_DM8NEW_O_L or WRAPPER_DM8_O_L_PRE; 
   
#pragma PXL encrypted begin
BWLO>ZV3XEF++\OEUV_DL)XOX"?OV;UGN ?@$TLL"')C<^43(,[ZI*3RC00@B&(?.[QP@0V(
'P%TRA*0Z28?(,[ZI*3RC00@B&(?.[QP@0V(O(OL=-8.2+R\B<?V?"_TT2Z)GORE9\0FD5R>
GS]E]0P3.YV?*PUXY?F<M[DKN6HI2J]!SZ"Y@>NLPFD586*!I'^6W,#_GWND
#pragma PXL encrypted end

#endif

#ifdef FILL_DM9
//***** filling region *********************************************************
REGION_WRAPPER_DM9 = CHIP_snps and or_list( {
    over_size( M9_MAIN, WRAPPER_RANGEY1),
    (CHIP_snps not over_size( CHIP_snps, -WRAPPER_RANGEY1)),
    over_size( (BEOLBLK_FINAL or DM9EXCL_FINAL), WRAPPER_RANGEY1)
 });

#pragma PXL encrypted begin
\4F/>!L9)0GQ<=^#%CN&S1EQIJXOBXW<?:*F)6D*CR!,D_$E\1D4T?LO%:_QNF>OU?>)+XVZ
Z!WJTJ0)Q1'H6QFG.Q:B-:!;K] GW+)5N,"ON>_Y*F@B$%:Y
#pragma PXL encrypted end

// DUMMY SPEC : Wrapper_DM9_O_Connect
//***DM9_O_Connect***
FSS_SPEC_WRAPPER_DM9_O_CONNECT: list of fill_to_signal_spacing_s = {
    { CHIP_snps, min_space = DMY1_CHIP, context = INTERIOR },
#ifdef FULL_CHIP
    { CHIP_BOUNDARY, min_space = DMY1_CHIP, context = INTERIOR },
#else
    { PRBOUNDARY, min_space = DMY1_CHIP, context = INTERIOR },
#endif
    { ICOVL_SINGLE, min_space = DMY1_ICOVL },
    { BEOLBLK_FINAL, min_space = DM_BEOLBLK },
    { CSR66_3485, min_space = DM_BEOLBLK },
    { INDDMY, min_space = DM_INDDMY },
    { DM9EXCL_FINAL, min_space = DM_DMXEXCL },
    { TCDDMY_M9, min_space = DM_TCDDMY_MX },
    { M9_MAIN, min_space = DMY1OR_MY1 },
    { DM9_O, min_space = DMY1OR_DMY1O },
    { DM9, min_space = 0.2 }, //DMn.S.3.5
    { DM9_GT1350, min_space = 0.45 },
    { M9_HOLE, min_space = 0 },
    { M9_GT76, min_space = DMY1_MY1W1 },
    { M9_GT114, min_space = DMY1_MY1W2 },
    { M9_GT152, min_space = DMY1_MY1W3 },
    { M9_GT180, min_space = DMY1_MY1W4 },
    { M9_GT240, min_space = DMY1_MY1W5 },
    { M9_GT280, min_space = DMY1_MY1W6 },
    { M9_GT500, min_space = DMY1_MY1W7 },
    { M9_GT1350, min_space = DMY1_MY1W8 },
    { M9_45, min_space = 0 },
    { VIA8_HVN_5V, min_space = DMY1_VY15V },
    { M9_HVN_5V, min_space = DMY1_MY15V },
    { VIA9_HVN_5V, min_space = DMY1_VY15V },

{ R7_VIA8_CHK_REGION, min_space = 0 },
{ R15_VIA9_CHK_REGION, min_space = 0 },

{ S22_M9_REGION, min_space = 0 },
#pragma PXL encrypted begin
>)B/4);21SYXP_\XL]\DP1'#=%.W;HP &0ITBT.3 3-(X..+);C\<(URZ!,E)L'MX\$F%>TF
N6O*-;FOL;BYO?&I-<A+$,V]QK^C_W;WG(G&C65"P-3UL0Z-28;>(M$=_9Y)?R.RI\/09@-_
STG9SO1#Y 7/MW8T>^SR"Y"WC5TU'QDQ" .-%:HJ$7HQY:\5-7K8168#MS4U9.;6;WR?&\ED
S&5<W!(&R/;,VG!C>Z>$2,S:[2YQSF6C8GOMRKA\^ 9P/J?*
#pragma PXL encrypted end

};


LAYER_DM9_MYCELL_H : polygon_layer_s = {
    layer_spec = {
        output_layer_key = "OUTPUT_WRAPPER_DM9_O_CONNECT"
    },
    polygons = MYCELL_H
};

LAYER_DM9_MYCELL_V : polygon_layer_s = {
    layer_spec = {
        output_layer_key = "OUTPUT_WRAPPER_DM9_O_CONNECT"
    },
    polygons = MYCELL_V
};

LAYER_DM9_MYCELL_HEXT : polygon_layer_s = {
    layer_spec = {
        output_layer_key = "OUTPUT_WRAPPER_DM9_O_CONNECT"
    },
    polygons = MYCELL_HEXT
};

LAYER_DM9_MYCELL_VEXT : polygon_layer_s = {
    layer_spec = {
        output_layer_key = "OUTPUT_WRAPPER_DM9_O_CONNECT"
    },
    polygons = MYCELL_VEXT 
};

SPEC_WRAPPER_DM9_O_CONNECT = unified_fill(
    fill_patterns = {
        {
            type = UF_POLYGON,
            polygon_fill = {
                pattern_spec = {
            	    pattern_spacing = {
               	       allowed_spacing_x = { >= DMY1OR_SC },
                       allowed_spacing_y = { >= DMY1OR_SC },
                       extension = INTERSECTION
                    },                    
#ifdef VERTICAL_M9     
                    space_x = DMY1OR_SX,
                    space_y = DMY1OR_SY,
                    stagger_x = DMY1OR_OX,
                    stagger_y = DMY1OR_OY,
#else
                    space_x = DMY1OR_SY,
                    space_y = DMY1OR_SX,
                    stagger_x = DMY1OR_OY,
                    stagger_y = DMY1OR_OX,
#endif 
                },
                insertion = {
#pragma PXL encrypted begin
#R?@51BF6C8/#9)UCW^-'50-&/: JFR>2X883FR%<V)VL21.:ZV2YU$VB]1K)EPF3L8#150F
;R<JH<*6,A5O;DT1Y^RDP>]N)ZDLA& DZ"LG&'/F"/,J_4<8[%SM+42T8W?L:]/300)S]^1K
3P\1_"7H?GM/",RKO5HD%@,('FG:7-?90G@>
#pragma PXL encrypted end
                    iterations = 3,
#pragma PXL encrypted begin
XMLL,N\U_1GBDKFT@?<U7R22QC&I36'(1(W&M[ #+#B&"!6W8G/<EHI:]-]BLOQA9&X6.]*R
4/K^2?:MY&10^L,])PM66<CZ
#pragma PXL encrypted end
		            starting_point = CENTER,
                    shift_factor = 2,
                },layers = {
#ifdef VERTICAL_M9     
                    LAYER_DM9_MYCELL_V, 
#else
                    LAYER_DM9_MYCELL_H, 
#endif                                                       
                },
                merging_layers = {
#ifdef VERTICAL_M9     
                    LAYER_DM9_MYCELL_VEXT,
#else
                    LAYER_DM9_MYCELL_HEXT,
#endif                                                       
                },

#ifdef ANTPrevention                
                merging_blockage_layer_list = {
                FORBIDDEN_RING
                },
#endif                              
#ifdef CONTROL_MAX_METAL_LENGTH                 
#ifdef VERTICAL_M9     
                merging_direction = VERTICAL,
#else
                merging_direction = HORIZONTAL,
#endif                                                       
                merging_length_limit = 4*( DMY1OR_L + DMY1OR_SY ) - DMY1OR_SY, // repeat 4 
#else
#ifdef VERTICAL_M9     
                merging_direction = VERTICAL,
#else
                merging_direction = HORIZONTAL,
#endif                                                       
                merging_length_limit = 500*( DMY1OR_L + DMY1OR_SY ) - DMY1OR_SY, // repeat 500 
#endif
                fill_to_signal_spacing = FSS_SPEC_WRAPPER_DM9_O_CONNECT,
                hierarchical_fill = false,
#ifdef VERTICAL_M9     
                cell_prefix = "WDMR9VNEW"
#else
                cell_prefix = "WDMR9HNEW"
#endif                                                       
            }
        }
    },
    extents_output = {
        {
            output_layer_key = "OUTPUT_WRAPPER_DM9O_CONNECT_EXTENT"
        },
    },
    fill_boundary = {
        layer = REGION_WRAPPER_DM9, 
        type = LAYER 
    },
	grid = vGRID
);

WRAPPER_DM9NEW_O_C = SPEC_WRAPPER_DM9_O_CONNECT["OUTPUT_WRAPPER_DM9_O_CONNECT"][0];
WRAPPER_DM9NEW_O_L = SPEC_WRAPPER_DM9_O_CONNECT["OUTPUT_WRAPPER_DM9_O_CONNECT"][0];
//=======================================================
#pragma PXL encrypted begin
5#=7=4(>T'I4$B_R5?O:@X 2>H[?:BX\JH1ZYF"4[>X*RD7F4+?7AB"WZD50<GS*5K@OV!]R
#[J'_U=COQ0/Z9"0E[V^]H'I
#pragma PXL encrypted end

//***** spec *******************************************************************
// DUMMY SPEC : Wrapper_DM9
//***DM9_O_R***
PATTERN_SPEC_WRAPPER_DM9_0 = get_single_polygon_pattern(
#ifdef VERTICAL_M9
	"WDMR9V", "OUTPUT_WRAPPER_DM9_O", DMY1OR_W, DMY1OR_L,
	step_x = DMY1OR_SX, step_y = DMY1OR_SY,
	offset_x = DMY1OR_OX, offset_y = DMY1OR_OY,
	setback = DMY1OR_SC,
	setback_type = INTERSECTION,
#else
	"WDMR9H", "OUTPUT_WRAPPER_DM9_O", DMY1OR_L, DMY1OR_W,
	step_x = DMY1OR_SY, step_y = DMY1OR_SX,
	offset_x = DMY1OR_OY, offset_y = DMY1OR_OX,
	setback = DMY1OR_SC,
	setback_type = INTERSECTION,
#endif
    FSS = {
    { CHIP_snps, min_space = DMY1_CHIP, context = INTERIOR },
#ifdef FULL_CHIP
    { CHIP_BOUNDARY, min_space = DMY1_CHIP, context = INTERIOR },
#else
    { PRBOUNDARY, min_space = DMY1_CHIP, context = INTERIOR },
#endif
    { ICOVL_SINGLE, min_space = DMY1_ICOVL },
    { BEOLBLK_FINAL, min_space = DM_BEOLBLK },
    { CSR66_3485, min_space = DM_BEOLBLK },
    { INDDMY, min_space = DM_INDDMY },
    { DM9EXCL_FINAL, min_space = DM_DMXEXCL },
    { TCDDMY_M9, min_space = DM_TCDDMY_MX },
    { M9_MAIN, min_space = DMY1OR_MY1 },
    { DM9_O, min_space = DMY1OR_DMY1O },
    { DM9, min_space = 0.2 }, //DMn.S.3.5
    { DM9_GT1350, min_space = 0.45 },
    { M9_HOLE, min_space = 0 },
    { M9_GT76, min_space = DMY1_MY1W1 },
    { M9_GT114, min_space = DMY1_MY1W2 },
    { M9_GT152, min_space = DMY1_MY1W3 },
    { M9_GT180, min_space = DMY1_MY1W4 },
    { M9_GT240, min_space = DMY1_MY1W5 },
    { M9_GT280, min_space = DMY1_MY1W6 },
    { M9_GT500, min_space = DMY1_MY1W7 },
    { M9_GT1350, min_space = DMY1_MY1W8 },
    { M9_45, min_space = 0 },
    { VIA8_HVN_5V, min_space = DMY1_VY15V },
    { M9_HVN_5V, min_space = DMY1_MY15V },
    { VIA9_HVN_5V, min_space = DMY1_VY15V },

              { R7_VIA8_CHK_REGION, min_space = 0 },
              { R15_VIA9_CHK_REGION, min_space = 0 },

              { S22_M9_REGION, min_space = 0 },
#pragma PXL encrypted begin
2&Q$+";B4F1(]Z3@\S[AW/3WA$?K<=MQ0U2$LK0MHK%WZTBRZKJDS8JW9Z?JU>G1S&L5B;K5
.D8[7^TW 7 Z,RA)AB2*JI(SD&'H@E=]XT>04I^T0JYLK<-2
#pragma PXL encrypted end

              { WRAPPER_DM9NEW_O_L, min_space = DMY1OR_DMY1O },
#pragma PXL encrypted begin
9X?=#%E(=79G$H*=XW6Q[N@2\5%58E-W2QKQLR*7TF'G-JVSD"@"U,?CB".0;<!BN[<P.FIM
#_AI>HA#W6(/_3AQV6NQ4MO]
#pragma PXL encrypted end

    },//end of FSS
	shift = 2,
#pragma PXL encrypted begin
EN+&&I/(ATN6N.5+!FRF;0FX\*,-$$D]!W'P@)J9AAW%PUF E;:Q\%CY//.5>2W?',_\C8MY
-Y?NQ?FAZ!0W'%MTP/#ZQHD<.WJAT"CB_7T[=?B#WISQ^,YUO"+L5SCYL]"\
#pragma PXL encrypted end
    repeat = 3
#pragma PXL encrypted begin
(N1,6B\Y"A(B!&QYCC="2'H$M#3?71Z;WU2TY/!-R%KMY";DI">>72.>\WJDO]BOQQP8UT"_
DHE:?CZELL"2RNKNKGL1'#3*
#pragma PXL encrypted end
);// end of 1st pattern
//==============================================================
//----------------------------------------------------------------------------------------------------

//***DM9_O_W***
// DUMMY SPEC : Wrapper_DM9_O_W
PATTERN_SPEC_WRAPPER_DM9_1 = get_single_polygon_pattern(
#ifdef VERTICAL_M9
	"WDMW9V", "OUTPUT_WRAPPER_DM9_O", DMY1OW_W, DMY1OW_L,
	step_x = DMY1OW_SY, step_y = DMY1OW_SX,
	offset_x = DMY1OW_OY, offset_y = DMY1OW_OX,
	setback = 0.114,
	setback_type = INTERSECTION,
#else
	"WDMW9H", "OUTPUT_WRAPPER_DM9_O", DMY1OW_L, DMY1OW_W,
	step_x = DMY1OW_SX, step_y = DMY1OW_SY,
	offset_x = DMY1OW_OX, offset_y = DMY1OW_OY,
	setback = 0.114,
	setback_type = INTERSECTION,
#endif
    FSS = {
    { CHIP_snps, min_space = DMY1_CHIP, context = INTERIOR },
#ifdef FULL_CHIP
    { CHIP_BOUNDARY, min_space = DMY1_CHIP, context = INTERIOR },
#else
    { PRBOUNDARY, min_space = DMY1_CHIP, context = INTERIOR },
#endif
    { ICOVL_SINGLE, min_space = DMY1_ICOVL },
    { BEOLBLK_FINAL, min_space = DM_BEOLBLK },
    { INDDMY, min_space = DM_INDDMY },

    { DM9EXCL_FINAL, min_space = DM_DMXEXCL },
    { CSR66_3485, min_space = DM_BEOLBLK },
    { TCDDMY_M9, min_space = DM_TCDDMY_MX },

    { M9_MAIN, min_space = DMY1OW_MY1 },
    { DM9_O, min_space = DMY1OW_DMY1O },
    { DM9, min_space = 0.2 }, //DMn.S.3.5
    { DM9_GT1350, min_space = 0.45 },
    { M9_HOLE, min_space = 0 },
    { M9_GT76, min_space = DMY1_MY1W1 },
    { M9_GT114, min_space = DMY1_MY1W2 },
    { M9_GT152, min_space = DMY1_MY1W3 },
    { M9_GT180, min_space = DMY1_MY1W4 },
    { M9_GT240, min_space = DMY1_MY1W5 },
    { M9_GT280, min_space = DMY1_MY1W6 },
    { M9_GT500, min_space = DMY1_MY1W7 },
    { M9_GT1350, min_space = DMY1_MY1W8 },
    { M9_45, min_space = 0 },
    { VIA8_HVN_5V, min_space = DMY1_VY15V },
    { M9_HVN_5V, min_space = DMY1_MY15V },
    { VIA9_HVN_5V, min_space = DMY1_VY15V },

              { R7_VIA8_CHK_REGION, min_space = 0 },
              { R15_VIA9_CHK_REGION, min_space = 0 },

              { S22_M9_REGION, min_space = 0 },
#pragma PXL encrypted begin
X*7#(=[W7"'@WALU^[BV%[W>ID!5WE4V/H"FFL2ZE0<*FDZ:-S?'/Z?;1QHWXP"-)HI%BGGC
X@8/YYF4P5_B*#?S+,=R'3\H!5V 'G!]&!(%GDZ,@K!;PZ.>
#pragma PXL encrypted end

              { WRAPPER_DM9NEW_O_L, min_space = DMY1OW_DMY1O },
#pragma PXL encrypted begin
_\!< A%>?S/_].0EJL%Y]![T-O6^"$;MF'HV,!W^3X: R!<P&6:&DAPZ"1D91T)O7=/.C\Q'
?31)&L=&Y )].>8<6'3UVM<Y
#pragma PXL encrypted end

	},
    shift = 2,
#pragma PXL encrypted begin
/UR6/5'X@4L__;^:\!^@X0+]<)M3Z EH^M1PT=+W8YTD49_1M4!C5PS#0Z*U@G1;< P%6*""
)^@U!D,*QYPG?NS!U0J@2W1^S]T%;]PWB"#/&F-C6V65=W<:6-S-TWT92]U8
#pragma PXL encrypted end
    repeat = 3
#pragma PXL encrypted begin
RUT<?>UH!!++F!)T4=8":3N806>^901\G=5!JQI16-BB#,NKM8PP,;$2+F.URJ^_=N28*G#*
K?S;<&G+#DVM_F^0+C6 ?MK^
#pragma PXL encrypted end
); //end of get_single_polygon_pattern


PATTERN_SPEC_WRAPPER_DM9_0.polygon_fill.pattern_spec.other_pattern_spacing = {
         1 => > DMY1OR_DMY1O 
};
PATTERN_SPEC_WRAPPER_DM9_1.polygon_fill.pattern_spec.other_pattern_spacing = {
         0 => > DMY1OW_DMY1O
};
  


SPEC_WRAPPER_DM9 = unified_fill(
    fill_boundary = {
        layer = CHIP_snps and REGION_WRAPPER_DM9,
        type = LAYER
    },
    fill_patterns = {
        PATTERN_SPEC_WRAPPER_DM9_0,
        PATTERN_SPEC_WRAPPER_DM9_1,
    },
    boundary = ALIGN,
	grid = vGRID
);

//==============================================================
//***** fill *******************************************************************
WRAPPER_DM9_O_C     = SPEC_WRAPPER_DM9["OUTPUT_WRAPPER_DM9_O"][0];
WRAPPER_DM9_O_L_PRE = SPEC_WRAPPER_DM9["OUTPUT_WRAPPER_DM9_O"][0];


//===========================================
#pragma PXL encrypted begin
GA)I6<3XIG6>TD^%P,FYRU'2UPX,''R9;^/7([PE91<6)<8CG/+K41;K*GZ<@K<;6S.Q?'&"
%)$YYLSUQ9(4(,K^UK():Z<@<]?<J-L#EDUS:T$AVPH:3FEK
#pragma PXL encrypted end
   WRAPPER_DM9_O_L = WRAPPER_DM9NEW_O_L or WRAPPER_DM9_O_L_PRE; 
   
#pragma PXL encrypted begin
O2T".O=>R0>]Z.NBBD!FF0KH0-8R>XE*R]A S-PG%\Z@:TO,;7X)X9?$VM-MJ%(@]-489":H
='/K)8A-=O=T;7X)X9?$VM-MJ%(@]-489":H+[V.M_>$0PTOQ,YP>5A7O%[$)%&9^+O6[[TD
>"J=B@(@*BQX)S,M&5IKX]8G-IOLA4DK2&@VQW:(^4.:J7['>^O\:57><6U[
#pragma PXL encrypted end

#endif

#ifdef FILL_DM10
//***** filling region *********************************************************
REGION_WRAPPER_DM10 = CHIP_snps and or_list( {
    over_size( M10_MAIN, WRAPPER_RANGEY1),
    (CHIP_snps not over_size( CHIP_snps, -WRAPPER_RANGEY1)),
    over_size( (BEOLBLK_FINAL or DM10EXCL_FINAL), WRAPPER_RANGEY1)
 });

#pragma PXL encrypted begin
66_8)IKI.Q%9W [),2XGH1;<-_EW.5FC'K<WO9%#I3U:O.6]\50HXIIDCS;Q2OX)]4[7/9%*
W1'O$7N9*17=18TR\J\0T]M%,,MDTIX>HDPPTJD  %X;HUW2
#pragma PXL encrypted end

// DUMMY SPEC : Wrapper_DM10_O_Connect
//***DM10_O_Connect***
FSS_SPEC_WRAPPER_DM10_O_CONNECT: list of fill_to_signal_spacing_s = {
    { CHIP_snps, min_space = DMY1_CHIP, context = INTERIOR },
#ifdef FULL_CHIP
    { CHIP_BOUNDARY, min_space = DMY1_CHIP, context = INTERIOR },
#else
    { PRBOUNDARY, min_space = DMY1_CHIP, context = INTERIOR },
#endif
    { ICOVL_SINGLE, min_space = DMY1_ICOVL },
    { BEOLBLK_FINAL, min_space = DM_BEOLBLK },
    { CSR66_3485, min_space = DM_BEOLBLK },
    { INDDMY, min_space = DM_INDDMY },
    { DM10EXCL_FINAL, min_space = DM_DMXEXCL },
    { TCDDMY_M10, min_space = DM_TCDDMY_MX },
    { M10_MAIN, min_space = DMY1OR_MY1 },
    { DM10_O, min_space = DMY1OR_DMY1O },
    { DM10, min_space = 0.2 }, //DMn.S.3.5
    { DM10_GT1350, min_space = 0.45 },
    { M10_HOLE, min_space = 0 },
    { M10_GT76, min_space = DMY1_MY1W1 },
    { M10_GT114, min_space = DMY1_MY1W2 },
    { M10_GT152, min_space = DMY1_MY1W3 },
    { M10_GT180, min_space = DMY1_MY1W4 },
    { M10_GT240, min_space = DMY1_MY1W5 },
    { M10_GT280, min_space = DMY1_MY1W6 },
    { M10_GT500, min_space = DMY1_MY1W7 },
    { M10_GT1350, min_space = DMY1_MY1W8 },
    { M10_45, min_space = 0 },
    { VIA9_HVN_5V, min_space = DMY1_VY15V },
    { M10_HVN_5V, min_space = DMY1_MY15V },
    { VIA10_HVN_5V, min_space = DMY1_VY15V },

{ R7_VIA9_CHK_REGION, min_space = 0 },
{ R15_VIA10_CHK_REGION, min_space = 0 },

{ S22_M10_REGION, min_space = 0 },
#pragma PXL encrypted begin
JDIB#^"=+FRJD_%E/D#8C'V3*\LZ8TC4%^TK38];9)$!?IU-C$B+>Y+>,9",E34?HN?$KA^5
Q%1&;$WHRA3$)"<^%6N1T]TDNY>9^S<1_<6[ Y0ETHVG,B\#U4F$)B^.Y5?57QSS+3!>GJ!?
L%LY,RG)$2VPW!]@+U05P-?<S@E6!NU1A(C.1H+]6[3*7L1&)NPAAHV3F8 F 82Y""YNL;L!
50_1]"3B4Y15)< ^7G&^Q-LEK2T+2A%PY[.M6*TP_O4$=&Q8
#pragma PXL encrypted end

};


LAYER_DM10_MYCELL_H : polygon_layer_s = {
    layer_spec = {
        output_layer_key = "OUTPUT_WRAPPER_DM10_O_CONNECT"
    },
    polygons = MYCELL_H
};

LAYER_DM10_MYCELL_V : polygon_layer_s = {
    layer_spec = {
        output_layer_key = "OUTPUT_WRAPPER_DM10_O_CONNECT"
    },
    polygons = MYCELL_V
};

LAYER_DM10_MYCELL_HEXT : polygon_layer_s = {
    layer_spec = {
        output_layer_key = "OUTPUT_WRAPPER_DM10_O_CONNECT"
    },
    polygons = MYCELL_HEXT
};

LAYER_DM10_MYCELL_VEXT : polygon_layer_s = {
    layer_spec = {
        output_layer_key = "OUTPUT_WRAPPER_DM10_O_CONNECT"
    },
    polygons = MYCELL_VEXT 
};

SPEC_WRAPPER_DM10_O_CONNECT = unified_fill(
    fill_patterns = {
        {
            type = UF_POLYGON,
            polygon_fill = {
                pattern_spec = {
            	    pattern_spacing = {
               	       allowed_spacing_x = { >= DMY1OR_SC },
                       allowed_spacing_y = { >= DMY1OR_SC },
                       extension = INTERSECTION
                    },                    
#ifdef VERTICAL_M10     
                    space_x = DMY1OR_SX,
                    space_y = DMY1OR_SY,
                    stagger_x = DMY1OR_OX,
                    stagger_y = DMY1OR_OY,
#else
                    space_x = DMY1OR_SY,
                    space_y = DMY1OR_SX,
                    stagger_x = DMY1OR_OY,
                    stagger_y = DMY1OR_OX,
#endif 
                },
                insertion = {
#pragma PXL encrypted begin
&Z:,4C2& 4T;I4Z#6S=):8.E#9IFM@'/5HL-[A-\R\-"BL_NS-9^QL,,^@K,,>A80V\>%2<Q
W6,\B4/1)#_=N,#>G+?FGS.X@AY!PEFVGH2"V($1WT:.PG#8>N^LG::W:HIZF;#YW9''*6J9
:SY1W"[OC<-KI[1PI_;!C"JG:F#H6)U'E-=J
#pragma PXL encrypted end
                    iterations = 3,
#pragma PXL encrypted begin
IZ<2$M#V@Q.GQ>&6M3KA$H;%L0LM":]U!^:QFUC#XLD 9_N;MV>TTPC:212W4 6#XS",=:!0
['-4["^<?$[L_8B"]_!+1?G]
#pragma PXL encrypted end
		            starting_point = CENTER,
                    shift_factor = 2,
                },layers = {
#ifdef VERTICAL_M10     
                    LAYER_DM10_MYCELL_V, 
#else
                    LAYER_DM10_MYCELL_H, 
#endif                                                       
                },
                merging_layers = {
#ifdef VERTICAL_M10     
                    LAYER_DM10_MYCELL_VEXT,
#else
                    LAYER_DM10_MYCELL_HEXT,
#endif                                                       
                },

#ifdef ANTPrevention                
                merging_blockage_layer_list = {
                FORBIDDEN_RING
                },
#endif                              
#ifdef CONTROL_MAX_METAL_LENGTH                 
#ifdef VERTICAL_M10     
                merging_direction = VERTICAL,
#else
                merging_direction = HORIZONTAL,
#endif                                                       
                merging_length_limit = 4*( DMY1OR_L + DMY1OR_SY ) - DMY1OR_SY, // repeat 4 
#else
#ifdef VERTICAL_M10     
                merging_direction = VERTICAL,
#else
                merging_direction = HORIZONTAL,
#endif                                                       
                merging_length_limit = 500*( DMY1OR_L + DMY1OR_SY ) - DMY1OR_SY, // repeat 500 
#endif
                fill_to_signal_spacing = FSS_SPEC_WRAPPER_DM10_O_CONNECT,
                hierarchical_fill = false,
#ifdef VERTICAL_M10     
                cell_prefix = "WDMR10VNEW"
#else
                cell_prefix = "WDMR10HNEW"
#endif                                                       
            }
        }
    },
    extents_output = {
        {
            output_layer_key = "OUTPUT_WRAPPER_DM10O_CONNECT_EXTENT"
        },
    },
    fill_boundary = {
        layer = REGION_WRAPPER_DM10, 
        type = LAYER 
    },
	grid = vGRID
);

WRAPPER_DM10NEW_O_C = SPEC_WRAPPER_DM10_O_CONNECT["OUTPUT_WRAPPER_DM10_O_CONNECT"][0];
WRAPPER_DM10NEW_O_L = SPEC_WRAPPER_DM10_O_CONNECT["OUTPUT_WRAPPER_DM10_O_CONNECT"][0];
//=======================================================
#pragma PXL encrypted begin
W=Q ?LXBQPC=2B&=038  ,-*@*+9%5VGI'V %3X 4RYCMO45%'+4M1B]:YL4MVP4!5JP^:2W
225_J72'I@Q)N@'RW F320FZ
#pragma PXL encrypted end

//***** spec *******************************************************************
// DUMMY SPEC : Wrapper_DM10
//***DM10_O_R***
PATTERN_SPEC_WRAPPER_DM10_0 = get_single_polygon_pattern(
#ifdef VERTICAL_M10
	"WDMR10V", "OUTPUT_WRAPPER_DM10_O", DMY1OR_W, DMY1OR_L,
	step_x = DMY1OR_SX, step_y = DMY1OR_SY,
	offset_x = DMY1OR_OX, offset_y = DMY1OR_OY,
	setback = DMY1OR_SC,
	setback_type = INTERSECTION,
#else
	"WDMR10H", "OUTPUT_WRAPPER_DM10_O", DMY1OR_L, DMY1OR_W,
	step_x = DMY1OR_SY, step_y = DMY1OR_SX,
	offset_x = DMY1OR_OY, offset_y = DMY1OR_OX,
	setback = DMY1OR_SC,
	setback_type = INTERSECTION,
#endif
    FSS = {
    { CHIP_snps, min_space = DMY1_CHIP, context = INTERIOR },
#ifdef FULL_CHIP
    { CHIP_BOUNDARY, min_space = DMY1_CHIP, context = INTERIOR },
#else
    { PRBOUNDARY, min_space = DMY1_CHIP, context = INTERIOR },
#endif
    { ICOVL_SINGLE, min_space = DMY1_ICOVL },
    { BEOLBLK_FINAL, min_space = DM_BEOLBLK },
    { CSR66_3485, min_space = DM_BEOLBLK },
    { INDDMY, min_space = DM_INDDMY },
    { DM10EXCL_FINAL, min_space = DM_DMXEXCL },
    { TCDDMY_M10, min_space = DM_TCDDMY_MX },
    { M10_MAIN, min_space = DMY1OR_MY1 },
    { DM10_O, min_space = DMY1OR_DMY1O },
    { DM10, min_space = 0.2 }, //DMn.S.3.5
    { DM10_GT1350, min_space = 0.45 },
    { M10_HOLE, min_space = 0 },
    { M10_GT76, min_space = DMY1_MY1W1 },
    { M10_GT114, min_space = DMY1_MY1W2 },
    { M10_GT152, min_space = DMY1_MY1W3 },
    { M10_GT180, min_space = DMY1_MY1W4 },
    { M10_GT240, min_space = DMY1_MY1W5 },
    { M10_GT280, min_space = DMY1_MY1W6 },
    { M10_GT500, min_space = DMY1_MY1W7 },
    { M10_GT1350, min_space = DMY1_MY1W8 },
    { M10_45, min_space = 0 },
    { VIA9_HVN_5V, min_space = DMY1_VY15V },
    { M10_HVN_5V, min_space = DMY1_MY15V },
    { VIA10_HVN_5V, min_space = DMY1_VY15V },

              { R7_VIA9_CHK_REGION, min_space = 0 },
              { R15_VIA10_CHK_REGION, min_space = 0 },

              { S22_M10_REGION, min_space = 0 },
#pragma PXL encrypted begin
P='=!ZO,62_!F@ZHH 94RDB:';S#,"P9<UL=/D6GY&.3@_(^,@"&L(?:^94R>DOUL#BJG*!Z
A7EN?GFX</2%SS [.0E*F&[/Z*Q.WG1-["3H7&;]SJ4 78=<
#pragma PXL encrypted end

              { WRAPPER_DM10NEW_O_L, min_space = DMY1OR_DMY1O },
#pragma PXL encrypted begin
<P:*"74H' USES(K.9!3!2R78E*X%28OEIUBGC.,.DZ[=$.>)_HLGY5PK!$G.*JL 8'%H8LX
AGK)&Q(8P*J&V1T?R3D_+)K9
#pragma PXL encrypted end

    },//end of FSS
	shift = 2,
#pragma PXL encrypted begin
)3LV"S^$WFHE"M%'Q5W0I%T*<O"%%"O\,X]R[!,0HUAO>7;LLO74"MC/ 0^R2<Y(0SBV[)U)
1I>,3[_V=+9&Y<7ININ%Q1_E)-T&CJ)6=0\DZ0M*8:-^=0CI0:NQE;E,^XY!
#pragma PXL encrypted end
    repeat = 3
#pragma PXL encrypted begin
#>-8?#[ET"(-&-8H,MB/-F@8.9LHN5!KR\<Y][VB?G.XW]OW8!O9M3[X"$]@#<VJ? GJ[R0-
)NX12*$DE+8F]1?-$#FD<2SU
#pragma PXL encrypted end
);// end of 1st pattern
//==============================================================
//----------------------------------------------------------------------------------------------------

//***DM10_O_W***
// DUMMY SPEC : Wrapper_DM10_O_W
PATTERN_SPEC_WRAPPER_DM10_1 = get_single_polygon_pattern(
#ifdef VERTICAL_M10
	"WDMW10V", "OUTPUT_WRAPPER_DM10_O", DMY1OW_W, DMY1OW_L,
	step_x = DMY1OW_SY, step_y = DMY1OW_SX,
	offset_x = DMY1OW_OY, offset_y = DMY1OW_OX,
	setback = 0.114,
	setback_type = INTERSECTION,
#else
	"WDMW10H", "OUTPUT_WRAPPER_DM10_O", DMY1OW_L, DMY1OW_W,
	step_x = DMY1OW_SX, step_y = DMY1OW_SY,
	offset_x = DMY1OW_OX, offset_y = DMY1OW_OY,
	setback = 0.114,
	setback_type = INTERSECTION,
#endif
    FSS = {
    { CHIP_snps, min_space = DMY1_CHIP, context = INTERIOR },
#ifdef FULL_CHIP
    { CHIP_BOUNDARY, min_space = DMY1_CHIP, context = INTERIOR },
#else
    { PRBOUNDARY, min_space = DMY1_CHIP, context = INTERIOR },
#endif
    { ICOVL_SINGLE, min_space = DMY1_ICOVL },
    { BEOLBLK_FINAL, min_space = DM_BEOLBLK },
    { INDDMY, min_space = DM_INDDMY },

    { DM10EXCL_FINAL, min_space = DM_DMXEXCL },
    { CSR66_3485, min_space = DM_BEOLBLK },
    { TCDDMY_M10, min_space = DM_TCDDMY_MX },

    { M10_MAIN, min_space = DMY1OW_MY1 },
    { DM10_O, min_space = DMY1OW_DMY1O },
    { DM10, min_space = 0.2 }, //DMn.S.3.5
    { DM10_GT1350, min_space = 0.45 },
    { M10_HOLE, min_space = 0 },
    { M10_GT76, min_space = DMY1_MY1W1 },
    { M10_GT114, min_space = DMY1_MY1W2 },
    { M10_GT152, min_space = DMY1_MY1W3 },
    { M10_GT180, min_space = DMY1_MY1W4 },
    { M10_GT240, min_space = DMY1_MY1W5 },
    { M10_GT280, min_space = DMY1_MY1W6 },
    { M10_GT500, min_space = DMY1_MY1W7 },
    { M10_GT1350, min_space = DMY1_MY1W8 },
    { M10_45, min_space = 0 },
    { VIA9_HVN_5V, min_space = DMY1_VY15V },
    { M10_HVN_5V, min_space = DMY1_MY15V },
    { VIA10_HVN_5V, min_space = DMY1_VY15V },

              { R7_VIA9_CHK_REGION, min_space = 0 },
              { R15_VIA10_CHK_REGION, min_space = 0 },

              { S22_M10_REGION, min_space = 0 },
#pragma PXL encrypted begin
RZ3/0^VC(S++977N(CDEXLUE]5VMH,"EB;/U5!BBC6VDR%E4[SS>3D)36I3O:C((\0"(M[9J
- ^2#,FN.54TS'V^'GM>$:;,25>K7@S2WX=)LRE7_Y5I'_NS
#pragma PXL encrypted end

              { WRAPPER_DM10NEW_O_L, min_space = DMY1OW_DMY1O },
#pragma PXL encrypted begin
?=E[1;?_Y0]]TS<<[I*J4B_3G@'-H;MYG:Z>BSX(9<%C7Y6+ "[/M>58SR, IY".399U*$^G
)/._U/$_D98D[CZT-Y_;%$CN
#pragma PXL encrypted end

	},
    shift = 2,
#pragma PXL encrypted begin
TF>+%1]K.'S2CUU6,.?@^ >/HTN@.=,OG.&C6* _E$CE<&I8@8M/$.,=W9:!:DQ53H[[6W!J
.S[,*@SH?;T[C;I$&UP!O)6-X-SR3?)*K O@%[7W['3Y#/H7(T2U)0/.Q:DC
#pragma PXL encrypted end
    repeat = 3
#pragma PXL encrypted begin
QIQX3 ,ONV7&SW7BODV;,,K/WLB![/J@6 [>(+KOY*'MR>4@>T\-6D(]J7A[DN[0Z!1).P"2
8ZGU<X2>G9=CQ\;W.'9Z&XG'
#pragma PXL encrypted end
); //end of get_single_polygon_pattern


PATTERN_SPEC_WRAPPER_DM10_0.polygon_fill.pattern_spec.other_pattern_spacing = {
         1 => > DMY1OR_DMY1O 
};
PATTERN_SPEC_WRAPPER_DM10_1.polygon_fill.pattern_spec.other_pattern_spacing = {
         0 => > DMY1OW_DMY1O
};
  


SPEC_WRAPPER_DM10 = unified_fill(
    fill_boundary = {
        layer = CHIP_snps and REGION_WRAPPER_DM10,
        type = LAYER
    },
    fill_patterns = {
        PATTERN_SPEC_WRAPPER_DM10_0,
        PATTERN_SPEC_WRAPPER_DM10_1,
    },
    boundary = ALIGN,
	grid = vGRID
);

//==============================================================
//***** fill *******************************************************************
WRAPPER_DM10_O_C     = SPEC_WRAPPER_DM10["OUTPUT_WRAPPER_DM10_O"][0];
WRAPPER_DM10_O_L_PRE = SPEC_WRAPPER_DM10["OUTPUT_WRAPPER_DM10_O"][0];


//===========================================
#pragma PXL encrypted begin
T,0[& [$C2/0L<6\"'8S$S6QSP4*MKJ#^#G/UT3D=H^E@YC7OC#E=AW+A=J^D+S+7:R9EM60
=>-W_IR4MW)U1;S0X>0=LE!%C2R[7;+5DRF-;Q*GC-L[0:IO
#pragma PXL encrypted end
   WRAPPER_DM10_O_L = WRAPPER_DM10NEW_O_L or WRAPPER_DM10_O_L_PRE; 
   
#pragma PXL encrypted begin
N&Q>"0TE@%NXQ*RU$VVQ[!/$4N%]ZDUEI/52>BC^3[._[*QZ0&*4L^(U NU IXL,8*7&4>BG
DMMG&CQAXH22*O<ZNT_.5N\J,K30NIL_<_0R:5'PD$(A7[!I/]MLR]A$''4_>D+5<LTAW<AZ
;\-F!+-W.-)O?5EK$J!;'35]3I+S-\7W9@Q.KB!3900.2":N+"M8TKZY A\L
#pragma PXL encrypted end

#endif

#ifdef FILL_DM11
//***** filling region *********************************************************
REGION_WRAPPER_DM11 = CHIP_snps and or_list( {
    over_size( M11_MAIN, WRAPPER_RANGEY1),
    (CHIP_snps not over_size( CHIP_snps, -WRAPPER_RANGEY1)),
    over_size( (BEOLBLK_FINAL or DM11EXCL_FINAL), WRAPPER_RANGEY1)
 });

#pragma PXL encrypted begin
BR&K9>2T(C^+RG!_D>F=@(;*:[5D42VH&>9KAFSH#2ML2;R&4\!CS;F(R*Y363;0;\J=3/U9
GGX.^6Z(P>2>T/^J']D0*!S0+%9II:]C S,L&!T^ID4Q=F08
#pragma PXL encrypted end

// DUMMY SPEC : Wrapper_DM11_O_Connect
//***DM11_O_Connect***
FSS_SPEC_WRAPPER_DM11_O_CONNECT: list of fill_to_signal_spacing_s = {
    { CHIP_snps, min_space = DMY1_CHIP, context = INTERIOR },
#ifdef FULL_CHIP
    { CHIP_BOUNDARY, min_space = DMY1_CHIP, context = INTERIOR },
#else
    { PRBOUNDARY, min_space = DMY1_CHIP, context = INTERIOR },
#endif
    { ICOVL_SINGLE, min_space = DMY1_ICOVL },
    { BEOLBLK_FINAL, min_space = DM_BEOLBLK },
    { CSR66_3485, min_space = DM_BEOLBLK },
    { INDDMY, min_space = DM_INDDMY },
    { DM11EXCL_FINAL, min_space = DM_DMXEXCL },
    { TCDDMY_M11, min_space = DM_TCDDMY_MX },
    { M11_MAIN, min_space = DMY1OR_MY1 },
    { DM11_O, min_space = DMY1OR_DMY1O },
    { DM11, min_space = 0.2 }, //DMn.S.3.5
    { DM11_GT1350, min_space = 0.45 },
    { M11_HOLE, min_space = 0 },
    { M11_GT76, min_space = DMY1_MY1W1 },
    { M11_GT114, min_space = DMY1_MY1W2 },
    { M11_GT152, min_space = DMY1_MY1W3 },
    { M11_GT180, min_space = DMY1_MY1W4 },
    { M11_GT240, min_space = DMY1_MY1W5 },
    { M11_GT280, min_space = DMY1_MY1W6 },
    { M11_GT500, min_space = DMY1_MY1W7 },
    { M11_GT1350, min_space = DMY1_MY1W8 },
    { M11_45, min_space = 0 },
    { VIA10_HVN_5V, min_space = DMY1_VY15V },
    { M11_HVN_5V, min_space = DMY1_MY15V },
    { VIA11_HVN_5V, min_space = DMY1_VY15V },

{ R7_VIA10_CHK_REGION, min_space = 0 },
{ R15_VIA11_CHK_REGION, min_space = 0 },

{ S22_M11_REGION, min_space = 0 },
#pragma PXL encrypted begin
 C!;$%A453$"0]B (0U@ZE]#T<WU?X,18071%)',GU7K"8$4?^!C_;COQQ9_JO?&K:OS]_VJ
;:XNX+1.#4]M].1Y<-9 ^7[TG$A015+%!:*<#25=:MSA,NX-83&4M0.>;IAA6H6_DD?^VC%:
7">G>TCT4 A<RNO4N%*>:93*G(]:3\)>-W^<]'UU0.7C0(7T&':TE3AB#E 8\.X#U7[4QY/P
\9]HJ^3UC,3Q5+BK5B:();U4[ 16(;4:8QSLKE04ZUA*,^^N
#pragma PXL encrypted end

};


LAYER_DM11_MYCELL_H : polygon_layer_s = {
    layer_spec = {
        output_layer_key = "OUTPUT_WRAPPER_DM11_O_CONNECT"
    },
    polygons = MYCELL_H
};

LAYER_DM11_MYCELL_V : polygon_layer_s = {
    layer_spec = {
        output_layer_key = "OUTPUT_WRAPPER_DM11_O_CONNECT"
    },
    polygons = MYCELL_V
};

LAYER_DM11_MYCELL_HEXT : polygon_layer_s = {
    layer_spec = {
        output_layer_key = "OUTPUT_WRAPPER_DM11_O_CONNECT"
    },
    polygons = MYCELL_HEXT
};

LAYER_DM11_MYCELL_VEXT : polygon_layer_s = {
    layer_spec = {
        output_layer_key = "OUTPUT_WRAPPER_DM11_O_CONNECT"
    },
    polygons = MYCELL_VEXT 
};

SPEC_WRAPPER_DM11_O_CONNECT = unified_fill(
    fill_patterns = {
        {
            type = UF_POLYGON,
            polygon_fill = {
                pattern_spec = {
            	    pattern_spacing = {
               	       allowed_spacing_x = { >= DMY1OR_SC },
                       allowed_spacing_y = { >= DMY1OR_SC },
                       extension = INTERSECTION
                    },                    
#ifdef VERTICAL_M11     
                    space_x = DMY1OR_SX,
                    space_y = DMY1OR_SY,
                    stagger_x = DMY1OR_OX,
                    stagger_y = DMY1OR_OY,
#else
                    space_x = DMY1OR_SY,
                    space_y = DMY1OR_SX,
                    stagger_x = DMY1OR_OY,
                    stagger_y = DMY1OR_OX,
#endif 
                },
                insertion = {
#pragma PXL encrypted begin
F;ZK%=HG:"F9/BVE'!53#F4^]]3C4MLD[NSWOU=[XZ!V_QN_T#G^/J[.I8/0'PHB)>SFCJ<?
3BVMJS#)Q,).EE 5+?KY#^>6RNA>X3E:_R#*++U/A>(TKH4L,5+QI#NIN+,QNC4Q]<7CE::Z
$U$2E;)A@_L31/R?A7_,#E!$8N8-E +?I"-B
#pragma PXL encrypted end
                    iterations = 3,
#pragma PXL encrypted begin
7#.H1*J=&DI<$EI6D9!O?H<2V>412F7Y_6[90''.& ==XDA B':&OU6]2%R(NF+V>IH;$ VZ
3#7+@4L6;XU,4%## _63GYU0
#pragma PXL encrypted end
		            starting_point = CENTER,
                    shift_factor = 2,
                },layers = {
#ifdef VERTICAL_M11     
                    LAYER_DM11_MYCELL_V, 
#else
                    LAYER_DM11_MYCELL_H, 
#endif                                                       
                },
                merging_layers = {
#ifdef VERTICAL_M11     
                    LAYER_DM11_MYCELL_VEXT,
#else
                    LAYER_DM11_MYCELL_HEXT,
#endif                                                       
                },

#ifdef ANTPrevention                
                merging_blockage_layer_list = {
                FORBIDDEN_RING
                },
#endif                              
#ifdef CONTROL_MAX_METAL_LENGTH                 
#ifdef VERTICAL_M11     
                merging_direction = VERTICAL,
#else
                merging_direction = HORIZONTAL,
#endif                                                       
                merging_length_limit = 4*( DMY1OR_L + DMY1OR_SY ) - DMY1OR_SY, // repeat 4 
#else
#ifdef VERTICAL_M11     
                merging_direction = VERTICAL,
#else
                merging_direction = HORIZONTAL,
#endif                                                       
                merging_length_limit = 500*( DMY1OR_L + DMY1OR_SY ) - DMY1OR_SY, // repeat 500 
#endif
                fill_to_signal_spacing = FSS_SPEC_WRAPPER_DM11_O_CONNECT,
                hierarchical_fill = false,
#ifdef VERTICAL_M11     
                cell_prefix = "WDMR11VNEW"
#else
                cell_prefix = "WDMR11HNEW"
#endif                                                       
            }
        }
    },
    extents_output = {
        {
            output_layer_key = "OUTPUT_WRAPPER_DM11O_CONNECT_EXTENT"
        },
    },
    fill_boundary = {
        layer = REGION_WRAPPER_DM11, 
        type = LAYER 
    },
	grid = vGRID
);

WRAPPER_DM11NEW_O_C = SPEC_WRAPPER_DM11_O_CONNECT["OUTPUT_WRAPPER_DM11_O_CONNECT"][0];
WRAPPER_DM11NEW_O_L = SPEC_WRAPPER_DM11_O_CONNECT["OUTPUT_WRAPPER_DM11_O_CONNECT"][0];
//=======================================================
#pragma PXL encrypted begin
8*CE*)5[C79@C-H1HARY?'",^S3_NOI(DJ?[:(XI&2=D.M%HVS51>[R'04K;55;UWPF&$P]5
9-\\&%)6B$]D9TO&-OAH9"MG
#pragma PXL encrypted end

//***** spec *******************************************************************
// DUMMY SPEC : Wrapper_DM11
//***DM11_O_R***
PATTERN_SPEC_WRAPPER_DM11_0 = get_single_polygon_pattern(
#ifdef VERTICAL_M11
	"WDMR11V", "OUTPUT_WRAPPER_DM11_O", DMY1OR_W, DMY1OR_L,
	step_x = DMY1OR_SX, step_y = DMY1OR_SY,
	offset_x = DMY1OR_OX, offset_y = DMY1OR_OY,
	setback = DMY1OR_SC,
	setback_type = INTERSECTION,
#else
	"WDMR11H", "OUTPUT_WRAPPER_DM11_O", DMY1OR_L, DMY1OR_W,
	step_x = DMY1OR_SY, step_y = DMY1OR_SX,
	offset_x = DMY1OR_OY, offset_y = DMY1OR_OX,
	setback = DMY1OR_SC,
	setback_type = INTERSECTION,
#endif
    FSS = {
    { CHIP_snps, min_space = DMY1_CHIP, context = INTERIOR },
#ifdef FULL_CHIP
    { CHIP_BOUNDARY, min_space = DMY1_CHIP, context = INTERIOR },
#else
    { PRBOUNDARY, min_space = DMY1_CHIP, context = INTERIOR },
#endif
    { ICOVL_SINGLE, min_space = DMY1_ICOVL },
    { BEOLBLK_FINAL, min_space = DM_BEOLBLK },
    { CSR66_3485, min_space = DM_BEOLBLK },
    { INDDMY, min_space = DM_INDDMY },
    { DM11EXCL_FINAL, min_space = DM_DMXEXCL },
    { TCDDMY_M11, min_space = DM_TCDDMY_MX },
    { M11_MAIN, min_space = DMY1OR_MY1 },
    { DM11_O, min_space = DMY1OR_DMY1O },
    { DM11, min_space = 0.2 }, //DMn.S.3.5
    { DM11_GT1350, min_space = 0.45 },
    { M11_HOLE, min_space = 0 },
    { M11_GT76, min_space = DMY1_MY1W1 },
    { M11_GT114, min_space = DMY1_MY1W2 },
    { M11_GT152, min_space = DMY1_MY1W3 },
    { M11_GT180, min_space = DMY1_MY1W4 },
    { M11_GT240, min_space = DMY1_MY1W5 },
    { M11_GT280, min_space = DMY1_MY1W6 },
    { M11_GT500, min_space = DMY1_MY1W7 },
    { M11_GT1350, min_space = DMY1_MY1W8 },
    { M11_45, min_space = 0 },
    { VIA10_HVN_5V, min_space = DMY1_VY15V },
    { M11_HVN_5V, min_space = DMY1_MY15V },
    { VIA11_HVN_5V, min_space = DMY1_VY15V },

              { R7_VIA10_CHK_REGION, min_space = 0 },
              { R15_VIA11_CHK_REGION, min_space = 0 },

              { S22_M11_REGION, min_space = 0 },
#pragma PXL encrypted begin
.C=W8S"W8'HZ$C4B?O5&3LT25;%XWTB_;IM5;*'ZYMF@2G%L9XRW8,:0;_-G%J5)GJFN1@06
%Y)(DO70B1X7GV'*[-F]0SZ?E\?#!N/6,'F7T$%+=TC26^S0
#pragma PXL encrypted end

              { WRAPPER_DM11NEW_O_L, min_space = DMY1OR_DMY1O },
#pragma PXL encrypted begin
[&LC9?H2(UCLB$MSR7Y2_PB(K(Q?@10_%%BL7'R04"FM%)]<?TTQUYVB?I1_6@ZEH):R %-:
VD78ID"CU>K:;Y97IG'*';EO
#pragma PXL encrypted end

    },//end of FSS
	shift = 2,
#pragma PXL encrypted begin
,;KB!UMDA0$Q0C9A=8\2_G="V'J!L?X>F@S8TIWX-8B&!EC287!"#+8!7ZQA(8]3ZI+BN3@A
2V@Y]+QKQ#I+I-M$>'>H?0.D@.4 /6"Y12& 1>(%);,1_;1%QSB"=^J=$ S'
#pragma PXL encrypted end
    repeat = 3
#pragma PXL encrypted begin
X^Z."27 1U_CGK&,3GM2!3V>?B [&041<8Y^\F0G>/SKF!OR#&FG'Q3^=NT,>>44+I<N_>EY
&?;&GE<YYZ89-KD'^?,=\W,V
#pragma PXL encrypted end
);// end of 1st pattern
//==============================================================
//----------------------------------------------------------------------------------------------------

//***DM11_O_W***
// DUMMY SPEC : Wrapper_DM11_O_W
PATTERN_SPEC_WRAPPER_DM11_1 = get_single_polygon_pattern(
#ifdef VERTICAL_M11
	"WDMW11V", "OUTPUT_WRAPPER_DM11_O", DMY1OW_W, DMY1OW_L,
	step_x = DMY1OW_SY, step_y = DMY1OW_SX,
	offset_x = DMY1OW_OY, offset_y = DMY1OW_OX,
	setback = 0.114,
	setback_type = INTERSECTION,
#else
	"WDMW11H", "OUTPUT_WRAPPER_DM11_O", DMY1OW_L, DMY1OW_W,
	step_x = DMY1OW_SX, step_y = DMY1OW_SY,
	offset_x = DMY1OW_OX, offset_y = DMY1OW_OY,
	setback = 0.114,
	setback_type = INTERSECTION,
#endif
    FSS = {
    { CHIP_snps, min_space = DMY1_CHIP, context = INTERIOR },
#ifdef FULL_CHIP
    { CHIP_BOUNDARY, min_space = DMY1_CHIP, context = INTERIOR },
#else
    { PRBOUNDARY, min_space = DMY1_CHIP, context = INTERIOR },
#endif
    { ICOVL_SINGLE, min_space = DMY1_ICOVL },
    { BEOLBLK_FINAL, min_space = DM_BEOLBLK },
    { INDDMY, min_space = DM_INDDMY },

    { DM11EXCL_FINAL, min_space = DM_DMXEXCL },
    { CSR66_3485, min_space = DM_BEOLBLK },
    { TCDDMY_M11, min_space = DM_TCDDMY_MX },

    { M11_MAIN, min_space = DMY1OW_MY1 },
    { DM11_O, min_space = DMY1OW_DMY1O },
    { DM11, min_space = 0.2 }, //DMn.S.3.5
    { DM11_GT1350, min_space = 0.45 },
    { M11_HOLE, min_space = 0 },
    { M11_GT76, min_space = DMY1_MY1W1 },
    { M11_GT114, min_space = DMY1_MY1W2 },
    { M11_GT152, min_space = DMY1_MY1W3 },
    { M11_GT180, min_space = DMY1_MY1W4 },
    { M11_GT240, min_space = DMY1_MY1W5 },
    { M11_GT280, min_space = DMY1_MY1W6 },
    { M11_GT500, min_space = DMY1_MY1W7 },
    { M11_GT1350, min_space = DMY1_MY1W8 },
    { M11_45, min_space = 0 },
    { VIA10_HVN_5V, min_space = DMY1_VY15V },
    { M11_HVN_5V, min_space = DMY1_MY15V },
    { VIA11_HVN_5V, min_space = DMY1_VY15V },

              { R7_VIA10_CHK_REGION, min_space = 0 },
              { R15_VIA11_CHK_REGION, min_space = 0 },

              { S22_M11_REGION, min_space = 0 },
#pragma PXL encrypted begin
QN,K$P-JV@7&.H3.5K.5+_0Z$]\A+>MRQHP3ATW;KYP>Q/F'L2=I4MNC#'2Q75XFZ$!6!C==
9=9@#=#=73QE"_%N"QYZE<D+4^$6&ZWLK+)3YWF0^R?UA"KG
#pragma PXL encrypted end

              { WRAPPER_DM11NEW_O_L, min_space = DMY1OW_DMY1O },
#pragma PXL encrypted begin
"S+K-62[/"\+:&/Y8R3O M1H25=C(L]SK_A)X/6\,C&V@"C@/(.54+$27<<\0J,K=C]F.5A"
%I?H:E"VFI,6G8LWO@%&=3.=
#pragma PXL encrypted end

	},
    shift = 2,
#pragma PXL encrypted begin
A_,@2/D1SS*'?\F7)V;W]:1_X*%9Y6?'&S+@"$;5#U,WW/H(OPW8VWA':4^_S][$RIJ>JD_/
"H%%F\D$04 *Y63L>%^J.B?E)H3I;4^\60LF)6,Q0.?S(_@E50E6XVEQD595
#pragma PXL encrypted end
    repeat = 3
#pragma PXL encrypted begin
.2C-2<-MD1 Y\* ]@U;#Z%'PDT;HT>ID=P23!%>D>)\">P $Q_B(!2T;GEK'PLSZ!YMZK0?"
BIRP];NR6H2*3C3(/'?RV+%.
#pragma PXL encrypted end
); //end of get_single_polygon_pattern


PATTERN_SPEC_WRAPPER_DM11_0.polygon_fill.pattern_spec.other_pattern_spacing = {
         1 => > DMY1OR_DMY1O 
};
PATTERN_SPEC_WRAPPER_DM11_1.polygon_fill.pattern_spec.other_pattern_spacing = {
         0 => > DMY1OW_DMY1O
};
  


SPEC_WRAPPER_DM11 = unified_fill(
    fill_boundary = {
        layer = CHIP_snps and REGION_WRAPPER_DM11,
        type = LAYER
    },
    fill_patterns = {
        PATTERN_SPEC_WRAPPER_DM11_0,
        PATTERN_SPEC_WRAPPER_DM11_1,
    },
    boundary = ALIGN,
	grid = vGRID
);

//==============================================================
//***** fill *******************************************************************
WRAPPER_DM11_O_C     = SPEC_WRAPPER_DM11["OUTPUT_WRAPPER_DM11_O"][0];
WRAPPER_DM11_O_L_PRE = SPEC_WRAPPER_DM11["OUTPUT_WRAPPER_DM11_O"][0];


//===========================================
#pragma PXL encrypted begin
:(.V5_WMHV5H[O_]O47F6NGN-.)/U _(OMTT/@"<.L%@;J4^8$R\Y37"N+E@@5=/Y#@/IA"!
7Z!B*)Z(C A?M-J@M71"% BT>ZV5LDXE2Q-[WK:_S&[[P1C>
#pragma PXL encrypted end
   WRAPPER_DM11_O_L = WRAPPER_DM11NEW_O_L or WRAPPER_DM11_O_L_PRE; 
   
#pragma PXL encrypted begin
&KAB6<=)9D,:\P2?#427)$WSJ9WJ2  F3P.I(ZDV@_O^#@,C/U7,)L"I]AX_ JM>AK2G2;\"
T*R,UNGXHU_0A=1?8@ ;KHB%7"+_HGXJK>M<S)-C K41W?G,[182;4+Z/YSMK$\_0F+5LM&L
J_"?C0.OMOJK?R,<,$4/IV1_?7NSX)@F)X=]G (6$E(EWZ2<)>[SVS/_^@DE
#pragma PXL encrypted end

#endif

#ifdef FILL_DM12
//***** filling region *********************************************************
REGION_WRAPPER_DM12 = CHIP_snps and or_list( {
    over_size( M12_MAIN, WRAPPER_RANGEY1),
    (CHIP_snps not over_size( CHIP_snps, -WRAPPER_RANGEY1)),
    over_size( (BEOLBLK_FINAL or DM12EXCL_FINAL), WRAPPER_RANGEY1)
 });

#pragma PXL encrypted begin
IKGH&&.ZZ FF(G?TV-;>S,PB;2 *$!$G26)M0]%./$V64GQ#TJ0JX$%?D072A^J@?H/WV^R'
JEM:%6#J12RJ[6UK&U8L'T?M$(G:Z#@CZ,<09CK"-K1<W-5F
#pragma PXL encrypted end

// DUMMY SPEC : Wrapper_DM12_O_Connect
//***DM12_O_Connect***
FSS_SPEC_WRAPPER_DM12_O_CONNECT: list of fill_to_signal_spacing_s = {
    { CHIP_snps, min_space = DMY1_CHIP, context = INTERIOR },
#ifdef FULL_CHIP
    { CHIP_BOUNDARY, min_space = DMY1_CHIP, context = INTERIOR },
#else
    { PRBOUNDARY, min_space = DMY1_CHIP, context = INTERIOR },
#endif
    { ICOVL_SINGLE, min_space = DMY1_ICOVL },
    { BEOLBLK_FINAL, min_space = DM_BEOLBLK },
    { CSR66_3485, min_space = DM_BEOLBLK },
    { INDDMY, min_space = DM_INDDMY },
    { DM12EXCL_FINAL, min_space = DM_DMXEXCL },
    { TCDDMY_M12, min_space = DM_TCDDMY_MX },
    { M12_MAIN, min_space = DMY1OR_MY1 },
    { DM12_O, min_space = DMY1OR_DMY1O },
    { DM12, min_space = 0.2 }, //DMn.S.3.5
    { DM12_GT1350, min_space = 0.45 },
    { M12_HOLE, min_space = 0 },
    { M12_GT76, min_space = DMY1_MY1W1 },
    { M12_GT114, min_space = DMY1_MY1W2 },
    { M12_GT152, min_space = DMY1_MY1W3 },
    { M12_GT180, min_space = DMY1_MY1W4 },
    { M12_GT240, min_space = DMY1_MY1W5 },
    { M12_GT280, min_space = DMY1_MY1W6 },
    { M12_GT500, min_space = DMY1_MY1W7 },
    { M12_GT1350, min_space = DMY1_MY1W8 },
    { M12_45, min_space = 0 },
    { VIA11_HVN_5V, min_space = DMY1_VY15V },
    { M12_HVN_5V, min_space = DMY1_MY15V },
    { VIA12_HVN_5V, min_space = DMY1_VY15V },

{ R7_VIA11_CHK_REGION, min_space = 0 },
{ R15_VIA12_CHK_REGION, min_space = 0 },

{ S22_M12_REGION, min_space = 0 },
#pragma PXL encrypted begin
4SL/,PQ?2U93>QD$ %S5 BQ[3NJWP_(;.;1.QASS!L+(O=3&RLH&:_(&R0#*._9@OI#LT4([
W1TI]K_L\UC=M7B&@T <6RJU*<'Z>XN_D$DI@9NY&BZ@972!HZ9M];CU3RBCCD[5O495M!:.
T[FW1)-,BSO3G2XLEQ;^5R^=2I5[PBOK.M9*W\S?XEPF:7+?2/6JVD+$0!U(V1[),\)GKB39
"?.(N5-Y:YP)[3G>8#6V@@'MU0W 0F8=K<?57RZX[7;P0U=?
#pragma PXL encrypted end

};


LAYER_DM12_MYCELL_H : polygon_layer_s = {
    layer_spec = {
        output_layer_key = "OUTPUT_WRAPPER_DM12_O_CONNECT"
    },
    polygons = MYCELL_H
};

LAYER_DM12_MYCELL_V : polygon_layer_s = {
    layer_spec = {
        output_layer_key = "OUTPUT_WRAPPER_DM12_O_CONNECT"
    },
    polygons = MYCELL_V
};

LAYER_DM12_MYCELL_HEXT : polygon_layer_s = {
    layer_spec = {
        output_layer_key = "OUTPUT_WRAPPER_DM12_O_CONNECT"
    },
    polygons = MYCELL_HEXT
};

LAYER_DM12_MYCELL_VEXT : polygon_layer_s = {
    layer_spec = {
        output_layer_key = "OUTPUT_WRAPPER_DM12_O_CONNECT"
    },
    polygons = MYCELL_VEXT 
};

SPEC_WRAPPER_DM12_O_CONNECT = unified_fill(
    fill_patterns = {
        {
            type = UF_POLYGON,
            polygon_fill = {
                pattern_spec = {
            	    pattern_spacing = {
               	       allowed_spacing_x = { >= DMY1OR_SC },
                       allowed_spacing_y = { >= DMY1OR_SC },
                       extension = INTERSECTION
                    },                    
#ifdef VERTICAL_M12     
                    space_x = DMY1OR_SX,
                    space_y = DMY1OR_SY,
                    stagger_x = DMY1OR_OX,
                    stagger_y = DMY1OR_OY,
#else
                    space_x = DMY1OR_SY,
                    space_y = DMY1OR_SX,
                    stagger_x = DMY1OR_OY,
                    stagger_y = DMY1OR_OX,
#endif 
                },
                insertion = {
#pragma PXL encrypted begin
?N-R620H_AE^!C=.]/PW*W & RR7]2@2R]X#"[,,.2CS51@+XBH6-DYAJT3B,-'2P'&[VFPP
']6/=&5(G'L?9@P,5>HWRM!F2_2BE7L]$>5+WL-!A3ZG-O_>N3FKI2[>AH.Y(%N\1MFH+.4@
*&?^LVSL8/TH:I< H)Y:2<9J4!/S9@]?J'%0
#pragma PXL encrypted end
                    iterations = 3,
#pragma PXL encrypted begin
G?X+.E>.("R=LWC)U_Z8=<"S_X9,) --ZKK_5C75GTN-A4I6M[!>;9*RTLBWI,."F[EK?::D
M2LZE;M*R4JU&U?P<_12[G4;
#pragma PXL encrypted end
		            starting_point = CENTER,
                    shift_factor = 2,
                },layers = {
#ifdef VERTICAL_M12     
                    LAYER_DM12_MYCELL_V, 
#else
                    LAYER_DM12_MYCELL_H, 
#endif                                                       
                },
                merging_layers = {
#ifdef VERTICAL_M12     
                    LAYER_DM12_MYCELL_VEXT,
#else
                    LAYER_DM12_MYCELL_HEXT,
#endif                                                       
                },

#ifdef ANTPrevention                
                merging_blockage_layer_list = {
                FORBIDDEN_RING
                },
#endif                              
#ifdef CONTROL_MAX_METAL_LENGTH                 
#ifdef VERTICAL_M12     
                merging_direction = VERTICAL,
#else
                merging_direction = HORIZONTAL,
#endif                                                       
                merging_length_limit = 4*( DMY1OR_L + DMY1OR_SY ) - DMY1OR_SY, // repeat 4 
#else
#ifdef VERTICAL_M12     
                merging_direction = VERTICAL,
#else
                merging_direction = HORIZONTAL,
#endif                                                       
                merging_length_limit = 500*( DMY1OR_L + DMY1OR_SY ) - DMY1OR_SY, // repeat 500 
#endif
                fill_to_signal_spacing = FSS_SPEC_WRAPPER_DM12_O_CONNECT,
                hierarchical_fill = false,
#ifdef VERTICAL_M12     
                cell_prefix = "WDMR12VNEW"
#else
                cell_prefix = "WDMR12HNEW"
#endif                                                       
            }
        }
    },
    extents_output = {
        {
            output_layer_key = "OUTPUT_WRAPPER_DM12O_CONNECT_EXTENT"
        },
    },
    fill_boundary = {
        layer = REGION_WRAPPER_DM12, 
        type = LAYER 
    },
	grid = vGRID
);

WRAPPER_DM12NEW_O_C = SPEC_WRAPPER_DM12_O_CONNECT["OUTPUT_WRAPPER_DM12_O_CONNECT"][0];
WRAPPER_DM12NEW_O_L = SPEC_WRAPPER_DM12_O_CONNECT["OUTPUT_WRAPPER_DM12_O_CONNECT"][0];
//=======================================================
#pragma PXL encrypted begin
D3/Y<#M2HQ61)^/4!9N-R)DG39$W#4 SCIE-Q5(+-Q%CM-#%*G9/$W'A-?0JI@P9R^2<\K"F
IT%HKXA^%8*GI@>U1%<ZJ*FF
#pragma PXL encrypted end

//***** spec *******************************************************************
// DUMMY SPEC : Wrapper_DM12
//***DM12_O_R***
PATTERN_SPEC_WRAPPER_DM12_0 = get_single_polygon_pattern(
#ifdef VERTICAL_M12
	"WDMR12V", "OUTPUT_WRAPPER_DM12_O", DMY1OR_W, DMY1OR_L,
	step_x = DMY1OR_SX, step_y = DMY1OR_SY,
	offset_x = DMY1OR_OX, offset_y = DMY1OR_OY,
	setback = DMY1OR_SC,
	setback_type = INTERSECTION,
#else
	"WDMR12H", "OUTPUT_WRAPPER_DM12_O", DMY1OR_L, DMY1OR_W,
	step_x = DMY1OR_SY, step_y = DMY1OR_SX,
	offset_x = DMY1OR_OY, offset_y = DMY1OR_OX,
	setback = DMY1OR_SC,
	setback_type = INTERSECTION,
#endif
    FSS = {
    { CHIP_snps, min_space = DMY1_CHIP, context = INTERIOR },
#ifdef FULL_CHIP
    { CHIP_BOUNDARY, min_space = DMY1_CHIP, context = INTERIOR },
#else
    { PRBOUNDARY, min_space = DMY1_CHIP, context = INTERIOR },
#endif
    { ICOVL_SINGLE, min_space = DMY1_ICOVL },
    { BEOLBLK_FINAL, min_space = DM_BEOLBLK },
    { CSR66_3485, min_space = DM_BEOLBLK },
    { INDDMY, min_space = DM_INDDMY },
    { DM12EXCL_FINAL, min_space = DM_DMXEXCL },
    { TCDDMY_M12, min_space = DM_TCDDMY_MX },
    { M12_MAIN, min_space = DMY1OR_MY1 },
    { DM12_O, min_space = DMY1OR_DMY1O },
    { DM12, min_space = 0.2 }, //DMn.S.3.5
    { DM12_GT1350, min_space = 0.45 },
    { M12_HOLE, min_space = 0 },
    { M12_GT76, min_space = DMY1_MY1W1 },
    { M12_GT114, min_space = DMY1_MY1W2 },
    { M12_GT152, min_space = DMY1_MY1W3 },
    { M12_GT180, min_space = DMY1_MY1W4 },
    { M12_GT240, min_space = DMY1_MY1W5 },
    { M12_GT280, min_space = DMY1_MY1W6 },
    { M12_GT500, min_space = DMY1_MY1W7 },
    { M12_GT1350, min_space = DMY1_MY1W8 },
    { M12_45, min_space = 0 },
    { VIA11_HVN_5V, min_space = DMY1_VY15V },
    { M12_HVN_5V, min_space = DMY1_MY15V },
    { VIA12_HVN_5V, min_space = DMY1_VY15V },

              { R7_VIA11_CHK_REGION, min_space = 0 },
              { R15_VIA12_CHK_REGION, min_space = 0 },

              { S22_M12_REGION, min_space = 0 },
#pragma PXL encrypted begin
="B6>AG\-3QTPATL$RW&-[;":X>90*^N@UEK#0"->YJ?+SL-6[Z=8>*K2?U;[Y0IKLZPC_;O
2W0>3]^CIDA+RJLZ0,+5S6C*<>3)LT7DZX%QRZO>03SA0 _+
#pragma PXL encrypted end

              { WRAPPER_DM12NEW_O_L, min_space = DMY1OR_DMY1O },
#pragma PXL encrypted begin
G]#Y(#'%Z'^?^PE@J\J-!2O[-80$>,2FGC,UD<R%8D(9OJZ1M>?HM8\::ERUAPV6[S>USZB'
1J&IN&Z7<H!&TEVTR?_(U(O2
#pragma PXL encrypted end

    },//end of FSS
	shift = 2,
#pragma PXL encrypted begin
ONN2 60K"Q*^'WQLV"O0E,0?]N@8FA90&9+VX@8N;W]!/O;B$41E&8<14H01:32%:_?_<45I
WOL#Z)1%EC/>:9HJ-= !6G!I(U53J71E]/,CB Z/7KFB[B"(/ASBH':$,$0^
#pragma PXL encrypted end
    repeat = 3
#pragma PXL encrypted begin
2NT800";C5A*P;ZSPY96ELS!:+:[,^;>(:UH?V^F\0;'U7E_RG;9=;(35W7*1<@]=:H+4+U%
AG@O2VB&45F&[?V(N&?*&D7M
#pragma PXL encrypted end
);// end of 1st pattern
//==============================================================
//----------------------------------------------------------------------------------------------------

//***DM12_O_W***
// DUMMY SPEC : Wrapper_DM12_O_W
PATTERN_SPEC_WRAPPER_DM12_1 = get_single_polygon_pattern(
#ifdef VERTICAL_M12
	"WDMW12V", "OUTPUT_WRAPPER_DM12_O", DMY1OW_W, DMY1OW_L,
	step_x = DMY1OW_SY, step_y = DMY1OW_SX,
	offset_x = DMY1OW_OY, offset_y = DMY1OW_OX,
	setback = 0.114,
	setback_type = INTERSECTION,
#else
	"WDMW12H", "OUTPUT_WRAPPER_DM12_O", DMY1OW_L, DMY1OW_W,
	step_x = DMY1OW_SX, step_y = DMY1OW_SY,
	offset_x = DMY1OW_OX, offset_y = DMY1OW_OY,
	setback = 0.114,
	setback_type = INTERSECTION,
#endif
    FSS = {
    { CHIP_snps, min_space = DMY1_CHIP, context = INTERIOR },
#ifdef FULL_CHIP
    { CHIP_BOUNDARY, min_space = DMY1_CHIP, context = INTERIOR },
#else
    { PRBOUNDARY, min_space = DMY1_CHIP, context = INTERIOR },
#endif
    { ICOVL_SINGLE, min_space = DMY1_ICOVL },
    { BEOLBLK_FINAL, min_space = DM_BEOLBLK },
    { INDDMY, min_space = DM_INDDMY },

    { DM12EXCL_FINAL, min_space = DM_DMXEXCL },
    { CSR66_3485, min_space = DM_BEOLBLK },
    { TCDDMY_M12, min_space = DM_TCDDMY_MX },

    { M12_MAIN, min_space = DMY1OW_MY1 },
    { DM12_O, min_space = DMY1OW_DMY1O },
    { DM12, min_space = 0.2 }, //DMn.S.3.5
    { DM12_GT1350, min_space = 0.45 },
    { M12_HOLE, min_space = 0 },
    { M12_GT76, min_space = DMY1_MY1W1 },
    { M12_GT114, min_space = DMY1_MY1W2 },
    { M12_GT152, min_space = DMY1_MY1W3 },
    { M12_GT180, min_space = DMY1_MY1W4 },
    { M12_GT240, min_space = DMY1_MY1W5 },
    { M12_GT280, min_space = DMY1_MY1W6 },
    { M12_GT500, min_space = DMY1_MY1W7 },
    { M12_GT1350, min_space = DMY1_MY1W8 },
    { M12_45, min_space = 0 },
    { VIA11_HVN_5V, min_space = DMY1_VY15V },
    { M12_HVN_5V, min_space = DMY1_MY15V },
    { VIA12_HVN_5V, min_space = DMY1_VY15V },

              { R7_VIA11_CHK_REGION, min_space = 0 },
              { R15_VIA12_CHK_REGION, min_space = 0 },

              { S22_M12_REGION, min_space = 0 },
#pragma PXL encrypted begin
NTA#!%2$8#F[X'7#=8'V/\S@.ZVCJ%=G,#D[-"C,NL61+-XTCU+*<X-?UT>/Y$L]XS@%\Q3D
S*;E&V@7!RK,]*![:$>3M@#T9&!^^@K!DXEDUCJ7*#;%L.O6
#pragma PXL encrypted end

              { WRAPPER_DM12NEW_O_L, min_space = DMY1OW_DMY1O },
#pragma PXL encrypted begin
$==25+OOLB41>@-!?@>71<]Z+XWL.\M"OGPO\TMZ=^$=>O?S'R]I;)*D6LP?1U'XZ)^IK_Y'
NK@QW\(,> JZH"F6K7; 1N*@
#pragma PXL encrypted end

	},
    shift = 2,
#pragma PXL encrypted begin
^7YU1;I0I5WY^(C/,:MLSFSXGH=2D[]7%3Z>*?EIC"(-/3@IX(?_/"B>GWO@%W->ETB&+XP7
D]DAMW[B\GJ3F1S%V]59&H.9U7]2,BL(  +5"UTDT1@GG4X+&8(S#//9<QH9
#pragma PXL encrypted end
    repeat = 3
#pragma PXL encrypted begin
3PV%%2&\]TE/PVHV%!],V6G#H-)\1@K!*S*@V9$Y*>V'UXW9G#Y:XAC>>E&<+6=6,#2Q0>(M
Y><D3U3>47GE%^(T4 6O\ @7
#pragma PXL encrypted end
); //end of get_single_polygon_pattern


PATTERN_SPEC_WRAPPER_DM12_0.polygon_fill.pattern_spec.other_pattern_spacing = {
         1 => > DMY1OR_DMY1O 
};
PATTERN_SPEC_WRAPPER_DM12_1.polygon_fill.pattern_spec.other_pattern_spacing = {
         0 => > DMY1OW_DMY1O
};
  


SPEC_WRAPPER_DM12 = unified_fill(
    fill_boundary = {
        layer = CHIP_snps and REGION_WRAPPER_DM12,
        type = LAYER
    },
    fill_patterns = {
        PATTERN_SPEC_WRAPPER_DM12_0,
        PATTERN_SPEC_WRAPPER_DM12_1,
    },
    boundary = ALIGN,
	grid = vGRID
);

//==============================================================
//***** fill *******************************************************************
WRAPPER_DM12_O_C     = SPEC_WRAPPER_DM12["OUTPUT_WRAPPER_DM12_O"][0];
WRAPPER_DM12_O_L_PRE = SPEC_WRAPPER_DM12["OUTPUT_WRAPPER_DM12_O"][0];


//===========================================
#pragma PXL encrypted begin
Q1LU0)9;*CS%,3%#F5)"8L(QAN/W N+]@]"&?10BHAEXM8=]$89,WOZ[(#X1C.^C]C)N+D&,
CQZ95:Z7.T>/*E&T,A[1+1\JQ=%AV#Y]?X;%=<%Q-H$3V[!U
#pragma PXL encrypted end
   WRAPPER_DM12_O_L = WRAPPER_DM12NEW_O_L or WRAPPER_DM12_O_L_PRE; 
   
#pragma PXL encrypted begin
O@.H7IO6##>^XL*&AQ'<+M_BPF,M09?2TA/"HD1A=5_"AL:BS8/:'MELH:K-RGQG(9J!L1_*
G!9U=-01H1&<EA"+MM ^$_"6G&JQ [L%NQ"<)!F<I:G3Y'PDZSH#.KV:G^;K!Q[JDQP9PND'
;B/T9=:6SB=NDY%Y/2MJ?.&3DJE^U V1&ZV2AEIN/S;W0DZ&JO2U)"L<3.*J
#pragma PXL encrypted end

#endif

#ifdef FILL_DM13
//***** filling region *********************************************************
REGION_WRAPPER_DM13 = CHIP_snps and or_list( {
    over_size( M13_MAIN, WRAPPER_RANGEY1),
    (CHIP_snps not over_size( CHIP_snps, -WRAPPER_RANGEY1)),
    over_size( (BEOLBLK_FINAL or DM13EXCL_FINAL), WRAPPER_RANGEY1)
 });

#pragma PXL encrypted begin
15*H-A:0+VQ%_R@9$WEGA</_-#IF;3X>U^4T;S,]?1DZ'TEOQ5C]?QX/?^/%MT*$ 3*"7X^W
%N2/!$"K]IP6(!40UO&[_U@@XPC@?VY7HI7C+U48Z"=(>(XO
#pragma PXL encrypted end

// DUMMY SPEC : Wrapper_DM13_O_Connect
//***DM13_O_Connect***
FSS_SPEC_WRAPPER_DM13_O_CONNECT: list of fill_to_signal_spacing_s = {
    { CHIP_snps, min_space = DMY1_CHIP, context = INTERIOR },
#ifdef FULL_CHIP
    { CHIP_BOUNDARY, min_space = DMY1_CHIP, context = INTERIOR },
#else
    { PRBOUNDARY, min_space = DMY1_CHIP, context = INTERIOR },
#endif
    { ICOVL_SINGLE, min_space = DMY1_ICOVL },
    { BEOLBLK_FINAL, min_space = DM_BEOLBLK },
    { CSR66_3485, min_space = DM_BEOLBLK },
    { INDDMY, min_space = DM_INDDMY },
    { DM13EXCL_FINAL, min_space = DM_DMXEXCL },
    { TCDDMY_M13, min_space = DM_TCDDMY_MX },
    { M13_MAIN, min_space = DMY1OR_MY1 },
    { DM13_O, min_space = DMY1OR_DMY1O },
    { DM13, min_space = 0.2 }, //DMn.S.3.5
    { DM13_GT1350, min_space = 0.45 },
    { M13_HOLE, min_space = 0 },
    { M13_GT76, min_space = DMY1_MY1W1 },
    { M13_GT114, min_space = DMY1_MY1W2 },
    { M13_GT152, min_space = DMY1_MY1W3 },
    { M13_GT180, min_space = DMY1_MY1W4 },
    { M13_GT240, min_space = DMY1_MY1W5 },
    { M13_GT280, min_space = DMY1_MY1W6 },
    { M13_GT500, min_space = DMY1_MY1W7 },
    { M13_GT1350, min_space = DMY1_MY1W8 },
    { M13_45, min_space = 0 },
    { VIA12_HVN_5V, min_space = DMY1_VY15V },
    { M13_HVN_5V, min_space = DMY1_MY15V },
    { VIA13_HVN_5V, min_space = DMY1_VY15V },

{ R7_VIA12_CHK_REGION, min_space = 0 },

{ S22_M13_REGION, min_space = 0 },
#pragma PXL encrypted begin
XI-^([@:HG7B=9O2=@9F*O]U=V)&;LB-04%WQ=V(J>>\7Z+%&PN62E"\YJ0;ENJ5"7U4,CV6
S4G3<GB)3=?-?FTNG1 'NQY^A7'UVV@VQKN%&!F=>].)+Q$8-.*D%T-M;:@T NY98Z)FLP0"
IV?'U":LR@VG4JRK\^]6=.I2Z7UK[VA];QCIGD2:<OR5S!Z>2IQI9H@'.ZI*I.R=]*:-S4VD
])')5Y.KD4/T-W>* '7',^(W]C)U'<U8?UGV1AM_(A&KQ+E&
#pragma PXL encrypted end

};


LAYER_DM13_MYCELL_H : polygon_layer_s = {
    layer_spec = {
        output_layer_key = "OUTPUT_WRAPPER_DM13_O_CONNECT"
    },
    polygons = MYCELL_H
};

LAYER_DM13_MYCELL_V : polygon_layer_s = {
    layer_spec = {
        output_layer_key = "OUTPUT_WRAPPER_DM13_O_CONNECT"
    },
    polygons = MYCELL_V
};

LAYER_DM13_MYCELL_HEXT : polygon_layer_s = {
    layer_spec = {
        output_layer_key = "OUTPUT_WRAPPER_DM13_O_CONNECT"
    },
    polygons = MYCELL_HEXT
};

LAYER_DM13_MYCELL_VEXT : polygon_layer_s = {
    layer_spec = {
        output_layer_key = "OUTPUT_WRAPPER_DM13_O_CONNECT"
    },
    polygons = MYCELL_VEXT 
};

SPEC_WRAPPER_DM13_O_CONNECT = unified_fill(
    fill_patterns = {
        {
            type = UF_POLYGON,
            polygon_fill = {
                pattern_spec = {
            	    pattern_spacing = {
               	       allowed_spacing_x = { >= DMY1OR_SC },
                       allowed_spacing_y = { >= DMY1OR_SC },
                       extension = INTERSECTION
                    },                    
#ifdef VERTICAL_M13     
                    space_x = DMY1OR_SX,
                    space_y = DMY1OR_SY,
                    stagger_x = DMY1OR_OX,
                    stagger_y = DMY1OR_OY,
#else
                    space_x = DMY1OR_SY,
                    space_y = DMY1OR_SX,
                    stagger_x = DMY1OR_OY,
                    stagger_y = DMY1OR_OX,
#endif 
                },
                insertion = {
#pragma PXL encrypted begin
GU7U:FC9] 2?Z:01[-+70\OI*?5??$&OY90IT4U;I33_I;G1-+$[>"H:]F$T[W5LMMW?[/;O
5M+.8BG)$:)6+ D]BMMPBF\L+I.5]?_1I%(NIZ+ Z_/HTBVGBG6^ 7:ZUEN*?GAD9#'HRZE^
"M_P_"4"OJT*IVB)Q6869C.G/*"[JM"^>;<\
#pragma PXL encrypted end
                    iterations = 3,
#pragma PXL encrypted begin
F#UH"6U4UW^80;F+;4S3-:5! /CHH&+V_5\ FRI5PYCM]4Z;3]GK@[#8Z'E/1>N*>&\=GOM%
Z7'\ PG_GW;I4D9#_FBWADM2
#pragma PXL encrypted end
		            starting_point = CENTER,
                    shift_factor = 2,
                },layers = {
#ifdef VERTICAL_M13     
                    LAYER_DM13_MYCELL_V, 
#else
                    LAYER_DM13_MYCELL_H, 
#endif                                                       
                },
                merging_layers = {
#ifdef VERTICAL_M13     
                    LAYER_DM13_MYCELL_VEXT,
#else
                    LAYER_DM13_MYCELL_HEXT,
#endif                                                       
                },

#ifdef ANTPrevention                
                merging_blockage_layer_list = {
                FORBIDDEN_RING
                },
#endif                              
#ifdef CONTROL_MAX_METAL_LENGTH                 
#ifdef VERTICAL_M13     
                merging_direction = VERTICAL,
#else
                merging_direction = HORIZONTAL,
#endif                                                       
                merging_length_limit = 4*( DMY1OR_L + DMY1OR_SY ) - DMY1OR_SY, // repeat 4 
#else
#ifdef VERTICAL_M13     
                merging_direction = VERTICAL,
#else
                merging_direction = HORIZONTAL,
#endif                                                       
                merging_length_limit = 500*( DMY1OR_L + DMY1OR_SY ) - DMY1OR_SY, // repeat 500 
#endif
                fill_to_signal_spacing = FSS_SPEC_WRAPPER_DM13_O_CONNECT,
                hierarchical_fill = false,
#ifdef VERTICAL_M13     
                cell_prefix = "WDMR13VNEW"
#else
                cell_prefix = "WDMR13HNEW"
#endif                                                       
            }
        }
    },
    extents_output = {
        {
            output_layer_key = "OUTPUT_WRAPPER_DM13O_CONNECT_EXTENT"
        },
    },
    fill_boundary = {
        layer = REGION_WRAPPER_DM13, 
        type = LAYER 
    },
	grid = vGRID
);

WRAPPER_DM13NEW_O_C = SPEC_WRAPPER_DM13_O_CONNECT["OUTPUT_WRAPPER_DM13_O_CONNECT"][0];
WRAPPER_DM13NEW_O_L = SPEC_WRAPPER_DM13_O_CONNECT["OUTPUT_WRAPPER_DM13_O_CONNECT"][0];
//=======================================================
#pragma PXL encrypted begin
C')50%$86FF,0G?SHI"=ZWI"-@YZGC0,12TV8*)0N*2X]U)@BB#4E2*< <.*-M/#QT9M8D0V
I\^ZP:/939BG(=]9))%Q<A@A
#pragma PXL encrypted end

//***** spec *******************************************************************
// DUMMY SPEC : Wrapper_DM13
//***DM13_O_R***
PATTERN_SPEC_WRAPPER_DM13_0 = get_single_polygon_pattern(
#ifdef VERTICAL_M13
	"WDMR13V", "OUTPUT_WRAPPER_DM13_O", DMY1OR_W, DMY1OR_L,
	step_x = DMY1OR_SX, step_y = DMY1OR_SY,
	offset_x = DMY1OR_OX, offset_y = DMY1OR_OY,
	setback = DMY1OR_SC,
	setback_type = INTERSECTION,
#else
	"WDMR13H", "OUTPUT_WRAPPER_DM13_O", DMY1OR_L, DMY1OR_W,
	step_x = DMY1OR_SY, step_y = DMY1OR_SX,
	offset_x = DMY1OR_OY, offset_y = DMY1OR_OX,
	setback = DMY1OR_SC,
	setback_type = INTERSECTION,
#endif
    FSS = {
    { CHIP_snps, min_space = DMY1_CHIP, context = INTERIOR },
#ifdef FULL_CHIP
    { CHIP_BOUNDARY, min_space = DMY1_CHIP, context = INTERIOR },
#else
    { PRBOUNDARY, min_space = DMY1_CHIP, context = INTERIOR },
#endif
    { ICOVL_SINGLE, min_space = DMY1_ICOVL },
    { BEOLBLK_FINAL, min_space = DM_BEOLBLK },
    { CSR66_3485, min_space = DM_BEOLBLK },
    { INDDMY, min_space = DM_INDDMY },
    { DM13EXCL_FINAL, min_space = DM_DMXEXCL },
    { TCDDMY_M13, min_space = DM_TCDDMY_MX },
    { M13_MAIN, min_space = DMY1OR_MY1 },
    { DM13_O, min_space = DMY1OR_DMY1O },
    { DM13, min_space = 0.2 }, //DMn.S.3.5
    { DM13_GT1350, min_space = 0.45 },
    { M13_HOLE, min_space = 0 },
    { M13_GT76, min_space = DMY1_MY1W1 },
    { M13_GT114, min_space = DMY1_MY1W2 },
    { M13_GT152, min_space = DMY1_MY1W3 },
    { M13_GT180, min_space = DMY1_MY1W4 },
    { M13_GT240, min_space = DMY1_MY1W5 },
    { M13_GT280, min_space = DMY1_MY1W6 },
    { M13_GT500, min_space = DMY1_MY1W7 },
    { M13_GT1350, min_space = DMY1_MY1W8 },
    { M13_45, min_space = 0 },
    { VIA12_HVN_5V, min_space = DMY1_VY15V },
    { M13_HVN_5V, min_space = DMY1_MY15V },
    { VIA13_HVN_5V, min_space = DMY1_VY15V },

              { R7_VIA12_CHK_REGION, min_space = 0 },

              { S22_M13_REGION, min_space = 0 },
#pragma PXL encrypted begin
W4W?*)?,3$3=B/8M-6/E^]>('04S5Y.7,1,=8,RUI&R0^)U@*K4HFA/JF'@JM9QAY],_2(ZU
(D2*X:M5=6TB;GNA11O*54MN_)L6+;2XZ/3\-/X_?Q!V'%<T
#pragma PXL encrypted end

              { WRAPPER_DM13NEW_O_L, min_space = DMY1OR_DMY1O },
#pragma PXL encrypted begin
_&AX"<HR;U;\9QSI/:EF3^YGJ1,_Z5MGDXRIJV_K9'2_&SJK.N,IAAO@W.<Z+)#0E=.UVI@L
[*]:9;N8XMSL!TBJZ5^,(=8'
#pragma PXL encrypted end

    },//end of FSS
	shift = 2,
#pragma PXL encrypted begin
KITD"Y2.,32N&S<1]X*Y/P ;[38^YDZT8L3M8YV$RG[!<K-C'KMDP/;=@)D>-<!#;17N,GPU
.I<<[O6V>4,Z  ?&HS9IN:L EE#KLAHLSO66, 1U*)HHO"@PM'(FO3GY9D>T
#pragma PXL encrypted end
    repeat = 3
#pragma PXL encrypted begin
*5]:'2KEPS<I *"PBNBR"KT +<J/C,V>H<HMJ/0;#H0I$T"H&.'I1CM\"*\8+P$KTVNCY!<O
V1AVPH;!,0+9>RM&2-M>BGI[
#pragma PXL encrypted end
);// end of 1st pattern
//==============================================================
//----------------------------------------------------------------------------------------------------

//***DM13_O_W***
// DUMMY SPEC : Wrapper_DM13_O_W
PATTERN_SPEC_WRAPPER_DM13_1 = get_single_polygon_pattern(
#ifdef VERTICAL_M13
	"WDMW13V", "OUTPUT_WRAPPER_DM13_O", DMY1OW_W, DMY1OW_L,
	step_x = DMY1OW_SY, step_y = DMY1OW_SX,
	offset_x = DMY1OW_OY, offset_y = DMY1OW_OX,
	setback = 0.114,
	setback_type = INTERSECTION,
#else
	"WDMW13H", "OUTPUT_WRAPPER_DM13_O", DMY1OW_L, DMY1OW_W,
	step_x = DMY1OW_SX, step_y = DMY1OW_SY,
	offset_x = DMY1OW_OX, offset_y = DMY1OW_OY,
	setback = 0.114,
	setback_type = INTERSECTION,
#endif
    FSS = {
    { CHIP_snps, min_space = DMY1_CHIP, context = INTERIOR },
#ifdef FULL_CHIP
    { CHIP_BOUNDARY, min_space = DMY1_CHIP, context = INTERIOR },
#else
    { PRBOUNDARY, min_space = DMY1_CHIP, context = INTERIOR },
#endif
    { ICOVL_SINGLE, min_space = DMY1_ICOVL },
    { BEOLBLK_FINAL, min_space = DM_BEOLBLK },
    { INDDMY, min_space = DM_INDDMY },

    { DM13EXCL_FINAL, min_space = DM_DMXEXCL },
    { CSR66_3485, min_space = DM_BEOLBLK },
    { TCDDMY_M13, min_space = DM_TCDDMY_MX },

    { M13_MAIN, min_space = DMY1OW_MY1 },
    { DM13_O, min_space = DMY1OW_DMY1O },
    { DM13, min_space = 0.2 }, //DMn.S.3.5
    { DM13_GT1350, min_space = 0.45 },
    { M13_HOLE, min_space = 0 },
    { M13_GT76, min_space = DMY1_MY1W1 },
    { M13_GT114, min_space = DMY1_MY1W2 },
    { M13_GT152, min_space = DMY1_MY1W3 },
    { M13_GT180, min_space = DMY1_MY1W4 },
    { M13_GT240, min_space = DMY1_MY1W5 },
    { M13_GT280, min_space = DMY1_MY1W6 },
    { M13_GT500, min_space = DMY1_MY1W7 },
    { M13_GT1350, min_space = DMY1_MY1W8 },
    { M13_45, min_space = 0 },
    { VIA12_HVN_5V, min_space = DMY1_VY15V },
    { M13_HVN_5V, min_space = DMY1_MY15V },
    { VIA13_HVN_5V, min_space = DMY1_VY15V },

              { R7_VIA12_CHK_REGION, min_space = 0 },

              { S22_M13_REGION, min_space = 0 },
#pragma PXL encrypted begin
#53W)@>/5EX-8@$\R"Z(>DYBGE<['J"EQXV>0Y+1B2TMS1M#&01.6D2LBM(9#,;^L7:5P^8,
8VBC2!VO\H]C. .[82J@AG4XY)'?+>E]ZN'DMZZ8PPSMF$"W
#pragma PXL encrypted end

              { WRAPPER_DM13NEW_O_L, min_space = DMY1OW_DMY1O },
#pragma PXL encrypted begin
OXBC*-'J&#R_98Z_YBYLP69E1[19=!-6JS='S@Q!BKKV]$W.1J#BC8[:^(A&MHCE#&O-P:FV
\'4ORT;'I_#PG-XQ_DR?+Q6<
#pragma PXL encrypted end

	},
    shift = 2,
#pragma PXL encrypted begin
!-=B2S(\>V4$M=_S@0TOQ$2UOU+O%Q R@IJ_>]R*G8R&?P%[(<L)G)_(W+HAP5PIBOHPJ"S!
/'UC!/4T>&(\1R 8)%^[.<-'->-D)LM&01<UXNZ\B]<=D4WBET*7?YAM/1^7
#pragma PXL encrypted end
    repeat = 3
#pragma PXL encrypted begin
M@L/3?R7/4.V>T?C&7\VV;A[K@7\V.3:)+^N352SN-,L;MQ-,*OI.37XJS\PRG;_C)=7(WG*
/2KTV8'='SD]U<EL= 7[6JG5
#pragma PXL encrypted end
); //end of get_single_polygon_pattern


PATTERN_SPEC_WRAPPER_DM13_0.polygon_fill.pattern_spec.other_pattern_spacing = {
         1 => > DMY1OR_DMY1O 
};
PATTERN_SPEC_WRAPPER_DM13_1.polygon_fill.pattern_spec.other_pattern_spacing = {
         0 => > DMY1OW_DMY1O
};
  


SPEC_WRAPPER_DM13 = unified_fill(
    fill_boundary = {
        layer = CHIP_snps and REGION_WRAPPER_DM13,
        type = LAYER
    },
    fill_patterns = {
        PATTERN_SPEC_WRAPPER_DM13_0,
        PATTERN_SPEC_WRAPPER_DM13_1,
    },
    boundary = ALIGN,
	grid = vGRID
);

//==============================================================
//***** fill *******************************************************************
WRAPPER_DM13_O_C     = SPEC_WRAPPER_DM13["OUTPUT_WRAPPER_DM13_O"][0];
WRAPPER_DM13_O_L_PRE = SPEC_WRAPPER_DM13["OUTPUT_WRAPPER_DM13_O"][0];


//===========================================
#pragma PXL encrypted begin
+!J_=W$W<#4LH4FV..>OFCRA,STDX"MC+!@SSQ>8*NE-&0#/,]N[$',<XO,SAJR%-T6,C"R&
=_-LDUF.RDIW-]J&"_,[I\(WF@R2VS/V54":GQ\%C2M%\7V?
#pragma PXL encrypted end
   WRAPPER_DM13_O_L = WRAPPER_DM13NEW_O_L or WRAPPER_DM13_O_L_PRE; 
   
#pragma PXL encrypted begin
J-OT"0:. CFH^%OS4]'3+6OX+BS!^BWDWILN@%^E<;L;]0. -2L),P2[YT0U"2/W=$R,1*L)
5QD,KG ";&M7.I]C5@WVEA<Z1K5[2_S-,AA&,DTUY0!E.^0RLCY'=!%B&D&R^ZR:$JI[!9O[
\*HMU*?U-A[PK=K1M.Q=CEJM77I*;E?# )9=1 O!AN)F1"5$<.D;<@>\=,UP
#pragma PXL encrypted end

#endif

#ifdef FILL_DM14
//***** filling region *********************************************************
REGION_WRAPPER_DM14 = CHIP_snps and or_list({
     over_size( M14_MAIN, WRAPPER_RANGE2),
     (CHIP_snps not over_size( CHIP_snps, -WRAPPER_RANGE2)),
     over_size( (BEOLBLK_FINAL or DM14EXCL_FINAL), WRAPPER_RANGE2) });
REGION_LONG_M14_V_LONG_M14_MAIN = length_edge( M14_MAIN, >= LONG_METAL_L ); 
REGION_LONG_M14_V_LONG_M14_MAIN_V = angle_edge( REGION_LONG_M14_V_LONG_M14_MAIN, == 90 ); 
REGION_LONG_M14_V_LONG_M14_MAIN_H = angle_edge( REGION_LONG_M14_V_LONG_M14_MAIN, == 0 ); 
REGION_LONG_M14_V_M14_MAIN_ISLAND = M14_MAIN not_touching REGION_LONG_M14_V_LONG_M14_MAIN; 

macroLAYER_1 = edge_size( REGION_LONG_M14_V_LONG_M14_MAIN_V, inside = GRID ); 
REGION_LONG_M14_V_REGION_LONG_M14_MAIN_V = size( macroLAYER_1, clip_acute = TRUNCATE, distance = WRAPPER_RANGE2 ); 
REGION_LONG_M14_V_REGION_LONG_M14_MAIN_H = edge_size( REGION_LONG_M14_V_LONG_M14_MAIN_H, outside = ( WRAPPER_RANGE2 * 0.75 ) ); 
macroLAYER_4 = edge_size( REGION_LONG_M14_V_LONG_M14_MAIN_H, inside = GRID ); 
macroLAYER_3 = size( macroLAYER_4, clip_acute = TRUNCATE, distance = WRAPPER_RANGE2 );
macroLAYER_2 = not_interacting( REGION_LONG_M14_V_M14_MAIN_ISLAND, macroLAYER_3 ); 
REGION_LONG_M14_V_REGION_M14_MAIN_ISLAND = size( macroLAYER_2, clip_acute = TRUNCATE, distance = WRAPPER_RANGE2 ); 
macroLAYER_5 = REGION_LONG_M14_V_REGION_LONG_M14_MAIN_V or REGION_LONG_M14_V_REGION_M14_MAIN_ISLAND; 
REGION_LONG_M14_V = macroLAYER_5 not REGION_LONG_M14_V_REGION_LONG_M14_MAIN_H; 


REGION_LONG_M14_H_LONG_M14_MAIN = length_edge( M14_MAIN, >= LONG_METAL_L ); 
REGION_LONG_M14_H_LONG_M14_MAIN_V = angle_edge( REGION_LONG_M14_H_LONG_M14_MAIN, == 90 ); 
REGION_LONG_M14_H_LONG_M14_MAIN_H = angle_edge( REGION_LONG_M14_H_LONG_M14_MAIN, == 0 ); 
REGION_LONG_M14_H_M14_MAIN_ISLAND = M14_MAIN not_touching REGION_LONG_M14_H_LONG_M14_MAIN; 

macroLAYER_6 = edge_size( REGION_LONG_M14_H_LONG_M14_MAIN_H, inside = GRID ); 
REGION_LONG_M14_H_REGION_LONG_M14_MAIN_H = size( macroLAYER_6, clip_acute = TRUNCATE, distance = WRAPPER_RANGE2 ); 
REGION_LONG_M14_H_REGION_LONG_M14_MAIN_V = edge_size( REGION_LONG_M14_H_LONG_M14_MAIN_V, outside = ( WRAPPER_RANGE2 * 0.75 ) ); 
macroLAYER_9 = edge_size( REGION_LONG_M14_H_LONG_M14_MAIN_V, inside = GRID ); 
macroLAYER_8 = size( macroLAYER_9, clip_acute = TRUNCATE, distance = WRAPPER_RANGE2 );
macroLAYER_7 = not_interacting( REGION_LONG_M14_H_M14_MAIN_ISLAND, macroLAYER_8 ); 
REGION_LONG_M14_H_REGION_M14_MAIN_ISLAND = size( macroLAYER_7, clip_acute = TRUNCATE, distance = WRAPPER_RANGE2 ); 
macroLAYER_10 = REGION_LONG_M14_H_REGION_LONG_M14_MAIN_H or REGION_LONG_M14_H_REGION_M14_MAIN_ISLAND; 
REGION_LONG_M14_H = macroLAYER_10 not REGION_LONG_M14_H_REGION_LONG_M14_MAIN_V; 



//***** spec *******************************************************************
// DUMMY SPEC : Wrapper_DM14
//***DM14_O***
PATTERN_SPEC_WRAPPER_DM14_0 = get_single_polygon_pattern(
#ifdef VERTICAL_M14
    "WDM14V",
    "OUTPUT_WRAPPER_DM14_O", DMYYO_W, DMYYO_L,
	step_x = DMYYO_SX, step_y = DMYYO_SY,
	offset_x = DMYYO_OX, offset_y = DMYYO_OY,
#else
        "WDM14H",
        "OUTPUT_WRAPPER_DM14_O", DMYYO_L, DMYYO_W,
	step_x = DMYYO_SY, step_y = DMYYO_SX,
	offset_x = DMYYO_OY, offset_y = DMYYO_OX,
#endif
    FSS = {
#ifdef VERTICAL_M14
         { REGION_LONG_M14_V, min_space = 0, context = INTERIOR },
#else
         { REGION_LONG_M14_H, min_space = 0, context = INTERIOR },
#endif
#ifdef FULL_CHIP
    { CHIP_BOUNDARY, min_space = DMYY_CHIP, context = INTERIOR },
#else
    { PRBOUNDARY, min_space = DMYY_CHIP, context = INTERIOR },
#endif
    { CHIP_snps, min_space = DMYY_CHIP, context = INTERIOR },
    { INDDMY, min_space = DM_INDDMY },
    { TCDDMY_M14, min_space = DM_TCDDMY_MX },
    { M14_HOLE, min_space = 0 },
    { ALL_M14_GT1350, min_space = DMYY_MYYW },
    { ALL_M14_GT4050, min_space = DMYY_MYYWB },
    { BEOLBLK_FINAL, min_space = 0.144 },
    { DM14EXCL_FINAL, min_space = DM_DMXEXCL },
    { CSR66_3485, min_space = 0.144 },
    { M14_MAIN, min_space = DMYYO_MYY },
    { DM14_O, min_space = 0.54 },
    { DM14, min_space = DMYYO_DMYY },
    },//end of fss
	shift = 2,
	repeat = 3
);//end of pattern_0

PATTERN_SPEC_WRAPPER_DM14_1 = get_single_polygon_pattern(
#ifdef VERTICAL_M14
        "WDM14H",
        "OUTPUT_WRAPPER_DM14_O", DMYYO_L, DMYYO_W,
	step_x = DMYYO_SY, step_y = DMYYO_SX,
	offset_x = DMYYO_OY, offset_y = DMYYO_OX,
#else
        "WDM14V",
        "OUTPUT_WRAPPER_DM14_O", DMYYO_W, DMYYO_L,
	step_x = DMYYO_SX, step_y = DMYYO_SY,
	offset_x = DMYYO_OX, offset_y = DMYYO_OY,
#endif

    FSS = {
#ifdef VERTICAL_M14
         { REGION_LONG_M14_H, min_space = 0, context = INTERIOR },
#else
         { REGION_LONG_M14_V, min_space = 0, context = INTERIOR },
#endif
#ifdef FULL_CHIP
    { CHIP_BOUNDARY, min_space = DMYY_CHIP, context = INTERIOR },
#else
    { PRBOUNDARY, min_space = DMYY_CHIP, context = INTERIOR },
#endif
    { CHIP_snps, min_space = DMYY_CHIP, context = INTERIOR },
    { INDDMY, min_space = DM_INDDMY },
    { TCDDMY_M14, min_space = DM_TCDDMY_MX },
    { M14_HOLE, min_space = 0 },
    { ALL_M14_GT1350, min_space = DMYY_MYYW },
    { ALL_M14_GT4050, min_space = DMYY_MYYWB },
    { BEOLBLK_FINAL, min_space = 0.144 },
    { DM14EXCL_FINAL, min_space = DM_DMXEXCL },
    { CSR66_3485, min_space = 0.144 },
    { M14_MAIN, min_space = DMYYO_MYY },
    { DM14_O, min_space = 0.54 },
    { DM14, min_space = DMYYO_DMYY },
    },//end of fss
	shift = 2,
	repeat = 3
);//end of pattern_1

PATTERN_SPEC_WRAPPER_DM14_2 = get_single_polygon_pattern(
	"WDM14", "OUTPUT_WRAPPER_DM14_O", DMYYO_W, DMYYO_L,
	step_x = DMYYO_SX, step_y = DMYYO_SY,
	offset_x = DMYYO_OX, offset_y = DMYYO_OY,
    FSS = {
#ifdef FULL_CHIP
    { CHIP_BOUNDARY, min_space = DMYY_CHIP, context = INTERIOR },
#else
    { PRBOUNDARY, min_space = DMYY_CHIP, context = INTERIOR },
#endif
    { CHIP_snps, min_space = DMYY_CHIP, context = INTERIOR },
    { INDDMY, min_space = DM_INDDMY },
    { TCDDMY_M14, min_space = DM_TCDDMY_MX },
    { M14_HOLE, min_space = 0 },
    { ALL_M14_GT1350, min_space = DMYY_MYYW },
    { ALL_M14_GT4050, min_space = DMYY_MYYWB },
    { BEOLBLK_FINAL, min_space = 0.144 },
    { DM14EXCL_FINAL, min_space = DM_DMXEXCL },
    { CSR66_3485, min_space = 0.144 },
    { M14_MAIN, min_space = DMYYO_MYY },
    { DM14_O, min_space = 0.54 },
    { DM14, min_space = DMYYO_DMYY },
    },//end of FSS
	shift = 2,
	repeat = 3
); //end of get_single_polygon_pattern


PATTERN_SPEC_WRAPPER_DM14_0.polygon_fill.pattern_spec.other_pattern_spacing = {
         1 => > DMY1OW_DMY1O,
         2 => > DMY1OW_DMY1O,
};

PATTERN_SPEC_WRAPPER_DM14_1.polygon_fill.pattern_spec.other_pattern_spacing = {
         0 => > find_max( {DMYYO_SX, DMYYO_SY} ),
         2 => > find_max( {DMYYO_SX, DMYYO_SY} ),
};

PATTERN_SPEC_WRAPPER_DM14_2.polygon_fill.pattern_spec.other_pattern_spacing = {
         0 => > DMYYO_DMYYO,
         1 => > DMYYO_DMYYO,
};
PATTERN_SPEC_WRAPPER_DM14_2.polygon_fill.insertion.auto_rotate = MAX_INSERTION;

SPEC_WRAPPER_DM14 = unified_fill(
    fill_boundary = {
        layer = BULK_PRE and REGION_WRAPPER_DM14,
        type = LAYER
    },
    fill_patterns = {
        PATTERN_SPEC_WRAPPER_DM14_0,
        PATTERN_SPEC_WRAPPER_DM14_1,
        PATTERN_SPEC_WRAPPER_DM14_2,
    },
    criteria = {
        { 
            target = { target = MYY_DN_2_1 }, 
            fill_layer_keys = "OUTPUT_WRAPPER_DM14_O", 
            design_layers = { M14_MAIN, DM14, DM14_O } 
        }
    }, 
    delta_window = { MYY_DN_2_1_W, MYY_DN_2_1_W}, 
    delta_x = MYY_DN_2_1_S,
    delta_y = MYY_DN_2_1_S,
    window_layer = CHIP_snps,
    boundary = ALIGN,
	grid = vGRID

);
//======================================

//***** fill *******************************************************************
WRAPPER_DM14_O_C = SPEC_WRAPPER_DM14["OUTPUT_WRAPPER_DM14_O"][0];
WRAPPER_DM14_O_L = SPEC_WRAPPER_DM14["OUTPUT_WRAPPER_DM14_O"][0];
//======================================
#endif

#ifdef FILL_DM15
//***** filling region *********************************************************
REGION_WRAPPER_DM15 = CHIP_snps and or_list({
     over_size( M15_MAIN, WRAPPER_RANGE2),
     (CHIP_snps not over_size( CHIP_snps, -WRAPPER_RANGE2)),
     over_size( (BEOLBLK_FINAL or DM15EXCL_FINAL), WRAPPER_RANGE2) });
REGION_LONG_M15_V_LONG_M15_MAIN = length_edge( M15_MAIN, >= LONG_METAL_L ); 
REGION_LONG_M15_V_LONG_M15_MAIN_V = angle_edge( REGION_LONG_M15_V_LONG_M15_MAIN, == 90 ); 
REGION_LONG_M15_V_LONG_M15_MAIN_H = angle_edge( REGION_LONG_M15_V_LONG_M15_MAIN, == 0 ); 
REGION_LONG_M15_V_M15_MAIN_ISLAND = M15_MAIN not_touching REGION_LONG_M15_V_LONG_M15_MAIN; 

macroLAYER_1 = edge_size( REGION_LONG_M15_V_LONG_M15_MAIN_V, inside = GRID ); 
REGION_LONG_M15_V_REGION_LONG_M15_MAIN_V = size( macroLAYER_1, clip_acute = TRUNCATE, distance = WRAPPER_RANGE2 ); 
REGION_LONG_M15_V_REGION_LONG_M15_MAIN_H = edge_size( REGION_LONG_M15_V_LONG_M15_MAIN_H, outside = ( WRAPPER_RANGE2 * 0.75 ) ); 
macroLAYER_4 = edge_size( REGION_LONG_M15_V_LONG_M15_MAIN_H, inside = GRID ); 
macroLAYER_3 = size( macroLAYER_4, clip_acute = TRUNCATE, distance = WRAPPER_RANGE2 );
macroLAYER_2 = not_interacting( REGION_LONG_M15_V_M15_MAIN_ISLAND, macroLAYER_3 ); 
REGION_LONG_M15_V_REGION_M15_MAIN_ISLAND = size( macroLAYER_2, clip_acute = TRUNCATE, distance = WRAPPER_RANGE2 ); 
macroLAYER_5 = REGION_LONG_M15_V_REGION_LONG_M15_MAIN_V or REGION_LONG_M15_V_REGION_M15_MAIN_ISLAND; 
REGION_LONG_M15_V = macroLAYER_5 not REGION_LONG_M15_V_REGION_LONG_M15_MAIN_H; 


REGION_LONG_M15_H_LONG_M15_MAIN = length_edge( M15_MAIN, >= LONG_METAL_L ); 
REGION_LONG_M15_H_LONG_M15_MAIN_V = angle_edge( REGION_LONG_M15_H_LONG_M15_MAIN, == 90 ); 
REGION_LONG_M15_H_LONG_M15_MAIN_H = angle_edge( REGION_LONG_M15_H_LONG_M15_MAIN, == 0 ); 
REGION_LONG_M15_H_M15_MAIN_ISLAND = M15_MAIN not_touching REGION_LONG_M15_H_LONG_M15_MAIN; 

macroLAYER_6 = edge_size( REGION_LONG_M15_H_LONG_M15_MAIN_H, inside = GRID ); 
REGION_LONG_M15_H_REGION_LONG_M15_MAIN_H = size( macroLAYER_6, clip_acute = TRUNCATE, distance = WRAPPER_RANGE2 ); 
REGION_LONG_M15_H_REGION_LONG_M15_MAIN_V = edge_size( REGION_LONG_M15_H_LONG_M15_MAIN_V, outside = ( WRAPPER_RANGE2 * 0.75 ) ); 
macroLAYER_9 = edge_size( REGION_LONG_M15_H_LONG_M15_MAIN_V, inside = GRID ); 
macroLAYER_8 = size( macroLAYER_9, clip_acute = TRUNCATE, distance = WRAPPER_RANGE2 );
macroLAYER_7 = not_interacting( REGION_LONG_M15_H_M15_MAIN_ISLAND, macroLAYER_8 ); 
REGION_LONG_M15_H_REGION_M15_MAIN_ISLAND = size( macroLAYER_7, clip_acute = TRUNCATE, distance = WRAPPER_RANGE2 ); 
macroLAYER_10 = REGION_LONG_M15_H_REGION_LONG_M15_MAIN_H or REGION_LONG_M15_H_REGION_M15_MAIN_ISLAND; 
REGION_LONG_M15_H = macroLAYER_10 not REGION_LONG_M15_H_REGION_LONG_M15_MAIN_V; 



//***** spec *******************************************************************
// DUMMY SPEC : Wrapper_DM15
//***DM15_O***
PATTERN_SPEC_WRAPPER_DM15_0 = get_single_polygon_pattern(
#ifdef VERTICAL_M15
    "WDM15V",
    "OUTPUT_WRAPPER_DM15_O", DMYYO_W, DMYYO_L,
	step_x = DMYYO_SX, step_y = DMYYO_SY,
	offset_x = DMYYO_OX, offset_y = DMYYO_OY,
#else
        "WDM15H",
        "OUTPUT_WRAPPER_DM15_O", DMYYO_L, DMYYO_W,
	step_x = DMYYO_SY, step_y = DMYYO_SX,
	offset_x = DMYYO_OY, offset_y = DMYYO_OX,
#endif
    FSS = {
#ifdef VERTICAL_M15
         { REGION_LONG_M15_V, min_space = 0, context = INTERIOR },
#else
         { REGION_LONG_M15_H, min_space = 0, context = INTERIOR },
#endif
#ifdef FULL_CHIP
    { CHIP_BOUNDARY, min_space = DMYY_CHIP, context = INTERIOR },
#else
    { PRBOUNDARY, min_space = DMYY_CHIP, context = INTERIOR },
#endif
    { CHIP_snps, min_space = DMYY_CHIP, context = INTERIOR },
    { INDDMY, min_space = DM_INDDMY },
    { TCDDMY_M15, min_space = DM_TCDDMY_MX },
    { M15_HOLE, min_space = 0 },
    { ALL_M15_GT1350, min_space = DMYY_MYYW },
    { ALL_M15_GT4050, min_space = DMYY_MYYWB },
    { BEOLBLK_FINAL, min_space = 0.144 },
    { DM15EXCL_FINAL, min_space = DM_DMXEXCL },
    { CSR66_3485, min_space = 0.144 },
    { M15_MAIN, min_space = DMYYO_MYY },
    { DM15_O, min_space = 0.54 },
    { DM15, min_space = DMYYO_DMYY },
    },//end of fss
	shift = 2,
	repeat = 3
);//end of pattern_0

PATTERN_SPEC_WRAPPER_DM15_1 = get_single_polygon_pattern(
#ifdef VERTICAL_M15
        "WDM15H",
        "OUTPUT_WRAPPER_DM15_O", DMYYO_L, DMYYO_W,
	step_x = DMYYO_SY, step_y = DMYYO_SX,
	offset_x = DMYYO_OY, offset_y = DMYYO_OX,
#else
        "WDM15V",
        "OUTPUT_WRAPPER_DM15_O", DMYYO_W, DMYYO_L,
	step_x = DMYYO_SX, step_y = DMYYO_SY,
	offset_x = DMYYO_OX, offset_y = DMYYO_OY,
#endif

    FSS = {
#ifdef VERTICAL_M15
         { REGION_LONG_M15_H, min_space = 0, context = INTERIOR },
#else
         { REGION_LONG_M15_V, min_space = 0, context = INTERIOR },
#endif
#ifdef FULL_CHIP
    { CHIP_BOUNDARY, min_space = DMYY_CHIP, context = INTERIOR },
#else
    { PRBOUNDARY, min_space = DMYY_CHIP, context = INTERIOR },
#endif
    { CHIP_snps, min_space = DMYY_CHIP, context = INTERIOR },
    { INDDMY, min_space = DM_INDDMY },
    { TCDDMY_M15, min_space = DM_TCDDMY_MX },
    { M15_HOLE, min_space = 0 },
    { ALL_M15_GT1350, min_space = DMYY_MYYW },
    { ALL_M15_GT4050, min_space = DMYY_MYYWB },
    { BEOLBLK_FINAL, min_space = 0.144 },
    { DM15EXCL_FINAL, min_space = DM_DMXEXCL },
    { CSR66_3485, min_space = 0.144 },
    { M15_MAIN, min_space = DMYYO_MYY },
    { DM15_O, min_space = 0.54 },
    { DM15, min_space = DMYYO_DMYY },
    },//end of fss
	shift = 2,
	repeat = 3
);//end of pattern_1

PATTERN_SPEC_WRAPPER_DM15_2 = get_single_polygon_pattern(
	"WDM15", "OUTPUT_WRAPPER_DM15_O", DMYYO_W, DMYYO_L,
	step_x = DMYYO_SX, step_y = DMYYO_SY,
	offset_x = DMYYO_OX, offset_y = DMYYO_OY,
    FSS = {
#ifdef FULL_CHIP
    { CHIP_BOUNDARY, min_space = DMYY_CHIP, context = INTERIOR },
#else
    { PRBOUNDARY, min_space = DMYY_CHIP, context = INTERIOR },
#endif
    { CHIP_snps, min_space = DMYY_CHIP, context = INTERIOR },
    { INDDMY, min_space = DM_INDDMY },
    { TCDDMY_M15, min_space = DM_TCDDMY_MX },
    { M15_HOLE, min_space = 0 },
    { ALL_M15_GT1350, min_space = DMYY_MYYW },
    { ALL_M15_GT4050, min_space = DMYY_MYYWB },
    { BEOLBLK_FINAL, min_space = 0.144 },
    { DM15EXCL_FINAL, min_space = DM_DMXEXCL },
    { CSR66_3485, min_space = 0.144 },
    { M15_MAIN, min_space = DMYYO_MYY },
    { DM15_O, min_space = 0.54 },
    { DM15, min_space = DMYYO_DMYY },
    },//end of FSS
	shift = 2,
	repeat = 3
); //end of get_single_polygon_pattern


PATTERN_SPEC_WRAPPER_DM15_0.polygon_fill.pattern_spec.other_pattern_spacing = {
         1 => > DMY1OW_DMY1O,
         2 => > DMY1OW_DMY1O,
};

PATTERN_SPEC_WRAPPER_DM15_1.polygon_fill.pattern_spec.other_pattern_spacing = {
         0 => > find_max( {DMYYO_SX, DMYYO_SY} ),
         2 => > find_max( {DMYYO_SX, DMYYO_SY} ),
};

PATTERN_SPEC_WRAPPER_DM15_2.polygon_fill.pattern_spec.other_pattern_spacing = {
         0 => > DMYYO_DMYYO,
         1 => > DMYYO_DMYYO,
};
PATTERN_SPEC_WRAPPER_DM15_2.polygon_fill.insertion.auto_rotate = MAX_INSERTION;

SPEC_WRAPPER_DM15 = unified_fill(
    fill_boundary = {
        layer = BULK_PRE and REGION_WRAPPER_DM15,
        type = LAYER
    },
    fill_patterns = {
        PATTERN_SPEC_WRAPPER_DM15_0,
        PATTERN_SPEC_WRAPPER_DM15_1,
        PATTERN_SPEC_WRAPPER_DM15_2,
    },
    criteria = {
        { 
            target = { target = MYY_DN_2_1 }, 
            fill_layer_keys = "OUTPUT_WRAPPER_DM15_O", 
            design_layers = { M15_MAIN, DM15, DM15_O } 
        }
    }, 
    delta_window = { MYY_DN_2_1_W, MYY_DN_2_1_W}, 
    delta_x = MYY_DN_2_1_S,
    delta_y = MYY_DN_2_1_S,
    window_layer = CHIP_snps,
    boundary = ALIGN,
	grid = vGRID

);
//======================================

//***** fill *******************************************************************
WRAPPER_DM15_O_C = SPEC_WRAPPER_DM15["OUTPUT_WRAPPER_DM15_O"][0];
WRAPPER_DM15_O_L = SPEC_WRAPPER_DM15["OUTPUT_WRAPPER_DM15_O"][0];
//======================================
#endif









#ifdef FILL_DM0



SHAPE_N3DMYM0CELL_900_0 : list of coordinate_l = {
	{ {(-0.3000), 0.0400},  {0.3000, 0.0400},  {0.3000, 0.4100},  {(-0.3000), 0.4100}, },
};

SHAPE_N3DMYM0CELL_330_151 : list of coordinate_l = {
	{ {(-0.3000), 0.3900},  {0.3000, 0.3900},  {0.3000, 0.4100},  {(-0.3000), 0.4100}, },
	{ {(-0.3000), 0.2900},  {0.3000, 0.2900},  {0.3000, 0.3100},  {(-0.3000), 0.3100}, },
	{ {(-0.3000), 0.1900},  {0.3000, 0.1900},  {0.3000, 0.2100},  {(-0.3000), 0.2100}, },
	{ {(-0.3000), 0.0900},  {0.3000, 0.0900},  {0.3000, 0.1100},  {(-0.3000), 0.1100}, },
};

SHAPE_N3DMYM0CELL_530_150 : list of coordinate_l = {
	{ {0.1140, 0.1500},  {0.1280, 0.1500},  {0.1280, 0.3500},  {0.1140, 0.3500}, },
	{ {(-0.0280), 0.1500},  {(-0.0140), 0.1500},  {(-0.0140), 0.3500},  {(-0.0280), 0.3500}, },
	{ {(-0.1700), 0.1500},  {(-0.1560), 0.1500},  {(-0.1560), 0.3500},  {(-0.1700), 0.3500}, },
};

SHAPE_N3DMYM0CELL_330_152 : list of coordinate_l = {
	{ {(-0.3000), 0.3400},  {0.3000, 0.3400},  {0.3000, 0.3600},  {(-0.3000), 0.3600}, },
	{ {(-0.3000), 0.2400},  {0.3000, 0.2400},  {0.3000, 0.2600},  {(-0.3000), 0.2600}, },
	{ {(-0.3000), 0.1400},  {0.3000, 0.1400},  {0.3000, 0.1600},  {(-0.3000), 0.1600}, },
	{ {(-0.3000), 0.0400},  {0.3000, 0.0400},  {0.3000, 0.0600},  {(-0.3000), 0.0600}, },
};

SHAPE_N3DMYM0CELL_530_155 : list of coordinate_l = {
	{ {0.1140, 0.1000},  {0.1280, 0.1000},  {0.1280, 0.3000},  {0.1140, 0.3000}, },
	{ {(-0.0280), 0.1000},  {(-0.0140), 0.1000},  {(-0.0140), 0.3000},  {(-0.0280), 0.3000}, },
	{ {(-0.1700), 0.1000},  {(-0.1560), 0.1000},  {(-0.1560), 0.3000},  {(-0.1700), 0.3000}, },
};

SHAPE_N3DMYM0CELL_930_151 : list of coordinate_l = {
	{ {0.3000, 0.3900},  {0.3700, 0.3900},  {0.3700, 0.4100},  {0.3000, 0.4100}, },
	{ {0.3000, 0.2900},  {0.3700, 0.2900},  {0.3700, 0.3100},  {0.3000, 0.3100}, },
	{ {0.3000, 0.1900},  {0.3700, 0.1900},  {0.3700, 0.2100},  {0.3000, 0.2100}, },
	{ {0.3000, 0.0900},  {0.3700, 0.0900},  {0.3700, 0.1100},  {0.3000, 0.1100}, },
};

SHAPE_N3DMYM0CELL_930_152 : list of coordinate_l = {
	{ {0.3000, 0.3400},  {0.3700, 0.3400},  {0.3700, 0.3600},  {0.3000, 0.3600}, },
	{ {0.3000, 0.2400},  {0.3700, 0.2400},  {0.3700, 0.2600},  {0.3000, 0.2600}, },
	{ {0.3000, 0.1400},  {0.3700, 0.1400},  {0.3700, 0.1600},  {0.3000, 0.1600}, },
	{ {0.3000, 0.0400},  {0.3700, 0.0400},  {0.3700, 0.0600},  {0.3000, 0.0600}, },
};
CM0_REGION = over_size( M0_MAIN, 3.5 );

LAYER_SHAPE_N3DMYM0CELL_330_151 : polygon_layer_s = {
    layer_spec = {
        output_layer_key = "OUTPUT_CM0CELL_330_151"
    },
    polygons = SHAPE_N3DMYM0CELL_330_151
};
LAYER_SHAPE_N3DMYM0CELL_330_152 : polygon_layer_s = {
    layer_spec = {
        output_layer_key = "OUTPUT_CM0CELL_330_152"
    },
    polygons = SHAPE_N3DMYM0CELL_330_152
};
LAYER_SHAPE_N3DMYM0CELL_530_150 : polygon_layer_s = {
    layer_spec = {
        output_layer_key = "OUTPUT_CM0CELL_530_150"
    },
    polygons = SHAPE_N3DMYM0CELL_530_150
};
LAYER_SHAPE_N3DMYM0CELL_530_155 : polygon_layer_s = {
    layer_spec = {
        output_layer_key = "OUTPUT_CM0CELL_530_155"
    },
    polygons = SHAPE_N3DMYM0CELL_530_155
};
LAYER_SHAPE_N3DMYM0CELL_900_0 : polygon_layer_s = {
    layer_spec = {
        output_layer_key = "OUTPUT_CM0CELL_900_0"
    },
    polygons = SHAPE_N3DMYM0CELL_900_0
};
// DUMMY SPEC : CM0Cell
FSS_SPEC_CM0CELL : list of fill_to_signal_spacing_s = {
   	   { M0_MAIN, min_space = CM0CELLTOM0 },
	   { CM0_REGION, min_space = 0, context = INTERIOR },
#ifdef FULL_CHIP
    { CHIP_BOUNDARY, min_space = 1, context = INTERIOR }, // Avoid Boundary empty space
    { CHIP_FILLREGION_X1, min_space = 1.5, context = INTERIOR },
#else
    { PRBOUNDARY, min_space = 1, context = INTERIOR }, // Avoid Boundary empty space
#endif
    { TCDDMY_M0, min_space = DMX1_TCDDMY_MX },
    { M0_HOLE, min_space = 0 },
    { CM0, min_space = M0_CUT },
    { ICOVL_SINGLE, min_space = DMX1_ICOVL },
    { VD2, min_space = DM0_VD2 },
    { VDR, min_space = DM0_VD2 },
#ifdef FILL_M0_VIA0_M1_BTCD
       { BTCD_M0_V0_M1_E, min_space = BTCD_DX1 },
#endif
#ifdef FILL_M0_BTCD2
       { BTCD_M0_E, min_space = BTCD_DX1 },
#endif
#ifdef VERTICAL_M0
       { WRAPPER_DM0_O_L, min_space_x = 0.054, min_space_y = 0.07, space_extension_x = 0.054, space_extension_y = 0.07 },
#else
       { WRAPPER_DM0_O_L, min_space_x = 0.07, min_space_y = 0.054, space_extension_x = 0.07, space_extension_y = 0.054 },
#endif
       { INDDMY, min_space = DM_INDDMY },
       { ALL_STD_20, min_space = CMCELLTOSTD },
       { BEOLBLK_FINAL, min_space = CM0CELLTOM0 },
       { DM0EXCL_FINAL, min_space = CM0CELLTOM0 },
       { CSR66_3485, min_space = CM0CELLTOM0 },
       { DM0_O, min_space = 0.07 },
       { DM0, min_space = CM0CELLTODM0 },
       { SRM, min_space = 0.5 },
       { SRAMDMY, min_space = 0.5 },
       { M0_JUMP, min_space = 0.5 }, 
};
//=======================================

SPEC_CM0CELL = unified_fill(
    fill_patterns = {
        {
            type = UF_POLYGON,
            polygon_fill = {
                pattern_spec = {
                    space_x = 0.07,
                    space_y = 0.018
                },
                layers = {
                    LAYER_SHAPE_N3DMYM0CELL_330_151,
                    LAYER_SHAPE_N3DMYM0CELL_330_152,
                    LAYER_SHAPE_N3DMYM0CELL_530_150,
                    LAYER_SHAPE_N3DMYM0CELL_530_155,
                    LAYER_SHAPE_N3DMYM0CELL_900_0,
                },
                fill_to_signal_spacing = FSS_SPEC_CM0CELL,
                hierarchical_fill = false,
                insertion = {
                    starting_point = CENTER,
                },
                cell_prefix = "CM0CELL"
            }
        }
    },
    extents_output = {
        {
            output_layer_key = "OUTPUT_CM0_EXTENT"
        },
    },
    fill_boundary = {
        layer = CHIP_snps, 
        type = LAYER 
    },
    boundary = ALIGN,
    grid = vGRID
);





CM0CELL_C_330_151    = SPEC_CM0CELL["OUTPUT_CM0CELL_330_151"][0];
CM0CELL_C_330_152    = SPEC_CM0CELL["OUTPUT_CM0CELL_330_152"][0];
CM0CELL_C_530_150    = SPEC_CM0CELL["OUTPUT_CM0CELL_530_150"][0];
CM0CELL_C_530_155    = SPEC_CM0CELL["OUTPUT_CM0CELL_530_155"][0];
CM0CELL_E            = SPEC_CM0CELL["OUTPUT_CM0CELL_900_0"][0];
CM0CELL_E_330_151    = SPEC_CM0CELL["OUTPUT_CM0CELL_330_151"][0];
CM0CELL_E_330_152    = SPEC_CM0CELL["OUTPUT_CM0CELL_330_152"][0];
CM0CELL_E_530_150    = SPEC_CM0CELL["OUTPUT_CM0CELL_530_150"][0];
CM0CELL_E_530_155    = SPEC_CM0CELL["OUTPUT_CM0CELL_530_155"][0];

#else

CM0CELL_E_330_151    = empty_layer();
CM0CELL_E_330_152    = empty_layer();
CM0CELL_E_530_150    = empty_layer();
CM0CELL_E_530_155    = empty_layer();

#endif

//=======================================































#ifdef FILL_DM0




PATTERN_SPEC_DM0_SHAPE = get_single_adjustable_pattern(
    adj_type = GROW,
#ifdef VERTICAL_M0
    min_bound = { DMX1B_W, DMX1B_L },
    max_bound = { 0.09, DMX1B_L },
//#ifdef HIGHMETALDN
    valid_widths = { == 0.06, == 0.07, == 0.08, == 0.09 }, 
//#endif
#else
    min_bound = { DMX1B_L, DMX1B_W },
    max_bound = { DMX1B_L, 0.09 },
//#ifdef HIGHMETALDN
    valid_heights = { == 0.06, == 0.07, == 0.08, == 0.09 }, 
//#endif
#endif
    color = true,
    color_scheme = UF_CHECKERED,

#ifdef VERTICAL_M0
    cell_prefix = "DMB0V", output = "OUTPUT_DM0",
    spacing = { DMX1B_SX, DMX1B_SY },
#else
    cell_prefix = "DMB0H", output = "OUTPUT_DM0", 
    spacing = { DMX1B_SY, DMX1B_SX },
#endif
// DUMMY SPEC : DM0_x1
    FSS = {
    { CHIP_snps, min_space = DMX1_CHIP, context = INTERIOR },
#ifdef FULL_CHIP
    { CHIP_BOUNDARY, min_space_x = DM0O_CHIPE, min_space_y = DM0O_CHIPR, context = INTERIOR },
#else
    { PRBOUNDARY, min_space = 4, context = INTERIOR },
#endif
    { INDDMY, min_space = DM_INDDMY },
    { M0_HOLE, min_space = 0 },
    { CM0, min_space = M0_CUT },
    { VD2, min_space = DM0_VD2 },
    { VDR, min_space = DM0_VD2 },
    { ALL_STD_20, min_space = DM0_STD, context = EXTERIOR_INTERIOR },

    { BEOLBLK_FINAL, min_space = DMX1B_MX },
    { DM0EXCL_FINAL, min_space = DMX1B_MX },
    { CSR66_3485, min_space = DMX1B_MX },
    { M0_MAIN, min_space = DMX1B_MX },
    { DM0_GE91, min_space = DMX1_DMW091 },
    { DM0_O, min_space = DMX1B_DMX_O },
    { DM0, min_space = DMX1B_DMX },
    { SRM, min_space = 2 },
    { SRAMDMY, min_space = 2 },
    { M0_JUMP, min_space = DMX1_SRMJUMP },
    { ICOVL_SINGLE, min_space = 5 },
    { TCDDMY_M0, min_space = BTCD_DX1B },
#ifdef FILL_M0_VIA0_M1_BTCD
              { BTCD_M0_V0_M1_E, min_space = BTCD_DX1B },
#endif
#ifdef FILL_M0_BTCD2
              { BTCD_M0_E, min_space = BTCD_DX1B },
#endif
              { WRAPPER_DM0_O_L, min_space = DMX1B_DMX_O },
    },
    shift = 2,
    repeat = 3,
    starting_point = CENTER
);
//=======================================================
PATTERN_SPEC_DM0_SHAPE.adjustable_fill.density_optimization = NONE;

PATTERN_SPEC_DM0_SHAPE.adjustable_fill.dpt_spacing = {
            dpt_space_x = DMX1B_DMX,
            dpt_space_y = DMX1B_DMX,
            dpt_space_extension = INTERSECTION,
};

SPEC_DM0 = unified_fill(
	fill_patterns = {
        PATTERN_SPEC_DM0_SHAPE,
    },
	fill_boundary = {
	    layer = CHIP_snps,
	    type = LAYER,
	},
    boundary = ALIGN,
	grid = vGRID
);

DM0_A_C   = SPEC_DM0["OUTPUT_DM0"][1];
DM0_B_C   = SPEC_DM0["OUTPUT_DM0"][2];
DM0_L     = SPEC_DM0["OUTPUT_DM0"][0];


//=======================================================


// DUMMY SPEC : DM0_shape_OR
PATTERN_SPEC_DM0_SHAPE_OR = get_single_adjustable_pattern(
    adj_type = SHRINK,
#ifdef VERTICAL_M0
    min_bound = { DMX1OR_W, DMX1OR_L },
#ifdef HIGHMETALDN
    max_bound = { 0.028, DMX1OR_L_MAX },
    valid_widths = { == 0.020, == 0.024, == 0.028 },
#else
    max_bound = { DMX1OR_W, DMX1OR_L_MAX },
#endif


#else
    min_bound = { DMX1OR_L, DMX1OR_W },
#ifdef HIGHMETALDN
    max_bound = { DMX1OR_L_MAX, 0.028 },
    valid_heights = { == 0.020, == 0.024, == 0.028 },
#else
    max_bound = { DMX1OR_L_MAX, DMX1OR_W },
#endif    

#endif
    color = true,
    color_scheme = UF_LINE_SIDE,
#ifdef VERTICAL_M0
    cell_prefix = "WDM0V", output = "OUTPUT_DM0_OR",
    spacing = { DMX1OR_SX, DMX1OR_SY },
#else
    cell_prefix = "WDM0H", output = "OUTPUT_DM0_OR",
    spacing = { DMX1OR_SY, DMX1OR_SX },
#endif
    FSS = {
#ifdef VERTICAL_M0
        { M0CA_LE, min_space_y = 0.06, space_extension_x = 0.06, projection = CORNER, color_aware_to_fill = ONLY_COLOR_1 },
#else
        { M0CA_LE, min_space_x = 0.06, space_extension_y = 0.06, projection = CORNER, color_aware_to_fill = ONLY_COLOR_1 },
#endif
      

#ifdef VERTICAL_M0
        { M0CB_LE, min_space_y = 0.06, space_extension_x = 0.06, projection = CORNER, color_aware_to_fill = ONLY_COLOR_2 },
#else
        { M0CB_LE, min_space_x = 0.06, space_extension_y = 0.06, projection = CORNER, color_aware_to_fill = ONLY_COLOR_2 },
#endif


 
        { M0CA_LE, min_space = 0 }, //for parsing
        { M0CB_LE, min_space = 0 }, //for parsing
//=======================================================

// DUMMY SPEC : DM0_OR_x1
    { CHIP_snps, min_space = 0, context = INTERIOR }, //RD CONFIRM
#ifdef FULL_CHIP
    { CHIP_BOUNDARY, min_space = 0, context = INTERIOR }, //RD CONFIRM
    { CHIP_FILLREGION_X1, min_space = 0, context = INTERIOR },
#else
    { PRBOUNDARY, min_space_x = DM0O_CHIPE, min_space_y = DM0O_CHIPR, context = INTERIOR },
#endif
    { M0FORBIDDEN_CHIP, min_space = 0 },
    { MX1FORBIDDEN_CHIPMH, min_space = 0 },
    { BEOLBLK_FINAL, min_space = 0 },
    { DM0EXCL_FINAL, min_space = 0 },
    { BEOLBLK_FINAL_NOM0, min_space_x = DMX1_BEOLBLKE, min_space_y = DM0_BEOLBLKR, space_extension_x = DMX1_BEOLBLKE, space_extension_y = DM0_BEOLBLKR }, 
    { DM0EXCL_FINAL_NOM0, min_space_x = DMX1_DMXEXCLE, min_space_y = DM0_DMXEXCLR, space_extension_x = DMX1_DMXEXCLE, space_extension_y = DM0_DMXEXCLR },
    { CSR66_3485, min_space_x = DMX1_BEOLBLKE, min_space_y = DM0_BEOLBLKR, space_extension_x = DMX1_BEOLBLKE, space_extension_y = DM0_BEOLBLKR }, 
    { INDDMY, min_space = DM_INDDMY },
    { TCDDMY_M0, min_space = DMX1_TCDDMY_MX },
    { M0_HOLE, min_space = 0 },
    { CM0, min_space = M0_CUT },
    { M0_45, min_space = 0 },
    { ICOVL_SINGLE, min_space = DMX1_ICOVL },
    { SRM, min_space = DMX1_SRM_OUT, min_space_inside = DMX1_SRM_IN, context = EXTERIOR_INTERIOR },
    { SRAMDMY, min_space = DMX1_SRM_OUT, min_space_inside = DMX1_SRM_IN, context = EXTERIOR_INTERIOR },
    { M0_JUMP, min_space = DMX1_O_SRMJUMP },
    { VD2, min_space = DM0_VD2 },
    { ALL_STD_20, min_space = DM0_STD, context = EXTERIOR_INTERIOR },
    { VDR, min_space = DM0_VD2 },
    

    { ALL_STD_20, min_space = DM0O_ALLSTD, context = EXTERIOR_INTERIOR },

#ifdef VERTICAL_M0
    { M0_MAIN, min_space_x = DMX1OR_DC_MXX, min_space_y = DMX1OR_DC_MXY, space_extension_x = DMX1OR_DC_MXX, space_extension_y = DMX1OR_DC_MXY },
#else
    { M0_MAIN, min_space_x = DMX1OR_DC_MXY, min_space_y = DMX1OR_DC_MXX, space_extension_x = DMX1OR_DC_MXY, space_extension_y = DMX1OR_DC_MXX },
#endif

#ifdef VERTICAL_M0
    { M0CA_LT165, min_space_x = DM0_SC_LEW16, space_extension_y = DMX1OR_SC_MXY, color_aware_to_fill = ONLY_COLOR_1 },
    { M0CA_LT165, min_space_x = DM0_SC_LEW16, space_extension_y = DMX1OR_SC_MXY, color_aware_to_fill = ONLY_COLOR_1, projection = CORNER  }, //for parsing
    { M0CA_LT165, min_space = 0 }, //for parsing
    { M0CB_LT165, min_space_x = DM0_SC_LEW16, space_extension_y = DMX1OR_SC_MXY, color_aware_to_fill = ONLY_COLOR_2 },
    { M0CB_LT165, min_space_x = DM0_SC_LEW16, space_extension_y = DMX1OR_SC_MXY, color_aware_to_fill = ONLY_COLOR_2, projection = CORNER  }, //for parsing
    { M0CB_LT165, min_space = 0 }, //for parsing
    { M0CA_LT285, min_space_x = DM0OR_SC_MXX, space_extension_y = DMX1OR_SC_MXY, color_aware_to_fill = ONLY_COLOR_1 },
    { M0CA_LT285, min_space_x = DM0OR_SC_MXX, space_extension_y = DMX1OR_SC_MXY, color_aware_to_fill = ONLY_COLOR_1, projection = CORNER  }, //for parsing
    { M0CA_LT285, min_space = 0 }, //for parsing
    { M0CB_LT285, min_space_x = DM0OR_SC_MXX, space_extension_y = DMX1OR_SC_MXY, color_aware_to_fill = ONLY_COLOR_2 },
    { M0CB_LT285, min_space_x = DM0OR_SC_MXX, space_extension_y = DMX1OR_SC_MXY, color_aware_to_fill = ONLY_COLOR_2, projection = CORNER  }, //for parsing
    { M0CB_LT285, min_space = 0 }, //for parsing
#else
    { M0CA_LT165, min_space_y = DM0_SC_LEW16, space_extension_x = DMX1OR_SC_MXY, color_aware_to_fill = ONLY_COLOR_1 },
    { M0CA_LT165, min_space_y = DM0_SC_LEW16, space_extension_x = DMX1OR_SC_MXY, color_aware_to_fill = ONLY_COLOR_1, projection = CORNER  }, //for parsing
    { M0CA_LT165, min_space = 0 }, //for parsing
    { M0CB_LT165, min_space_y = DM0_SC_LEW16, space_extension_x = DMX1OR_SC_MXY, color_aware_to_fill = ONLY_COLOR_2 },
    { M0CB_LT165, min_space_y = DM0_SC_LEW16, space_extension_x = DMX1OR_SC_MXY, color_aware_to_fill = ONLY_COLOR_2, projection = CORNER  }, //for parsing
    { M0CB_LT165, min_space = 0 }, //for parsing
    { M0CA_LT285, min_space_y = DM0OR_SC_MXX, space_extension_x = DMX1OR_SC_MXY, color_aware_to_fill = ONLY_COLOR_1 },
    { M0CA_LT285, min_space_y = DM0OR_SC_MXX, space_extension_x = DMX1OR_SC_MXY, color_aware_to_fill = ONLY_COLOR_1, projection = CORNER  }, //for parsing
    { M0CA_LT285, min_space = 0 }, //for parsing
    { M0CB_LT285, min_space_y = DM0OR_SC_MXX, space_extension_x = DMX1OR_SC_MXY, color_aware_to_fill = ONLY_COLOR_2 },
    { M0CB_LT285, min_space_y = DM0OR_SC_MXX, space_extension_x = DMX1OR_SC_MXY, color_aware_to_fill = ONLY_COLOR_2, projection = CORNER  }, //for parsing
    { M0CB_LT285, min_space = 0 }, //for parsing
#endif
#ifdef VERTICAL_M0
    { M0CA_LT405, min_space_x = DMX1_SC_W285, space_extension_y = DMX1OR_SC_MXY, color_aware_to_fill = ONLY_COLOR_1 },
    { M0CA_LT405, min_space_x = DMX1_SC_W285, space_extension_y = DMX1OR_SC_MXY, color_aware_to_fill = ONLY_COLOR_1, projection = CORNER  }, //for parsing
    { M0CA_LT405, min_space = 0 }, //for parsing
    { M0CB_LT405, min_space_x = DMX1_SC_W285, space_extension_y = DMX1OR_SC_MXY, color_aware_to_fill = ONLY_COLOR_2 },
    { M0CB_LT405, min_space_x = DMX1_SC_W285, space_extension_y = DMX1OR_SC_MXY, color_aware_to_fill = ONLY_COLOR_2, projection = CORNER  }, //for parsing
    { M0CB_LT405, min_space = 0 }, //for parsing
    { M0CA_LT160, min_space_x = DMX1_SC_W405, space_extension_y = DMX1OR_SC_MXY, color_aware_to_fill = ONLY_COLOR_1 },
    { M0CA_LT160, min_space_x = DMX1_SC_W405, space_extension_y = DMX1OR_SC_MXY, color_aware_to_fill = ONLY_COLOR_1, projection = CORNER  }, //for parsing
    { M0CA_LT160, min_space = 0 }, //for parsing
    { M0CB_LT160, min_space_x = DMX1_SC_W405, space_extension_y = DMX1OR_SC_MXY, color_aware_to_fill = ONLY_COLOR_2 },
    { M0CB_LT160, min_space_x = DMX1_SC_W405, space_extension_y = DMX1OR_SC_MXY, color_aware_to_fill = ONLY_COLOR_2, projection = CORNER  }, //for parsing
    { M0CB_LT160, min_space = 0 }, //for parsing
#else
    { M0CA_LT405, min_space_y = DMX1_SC_W285, space_extension_x = DMX1OR_SC_MXY, color_aware_to_fill = ONLY_COLOR_1 },
    { M0CA_LT405, min_space_y = DMX1_SC_W285, space_extension_x = DMX1OR_SC_MXY, color_aware_to_fill = ONLY_COLOR_1, projection = CORNER  }, //for parsing
    { M0CA_LT405, min_space = 0 }, //for parsing
    { M0CB_LT405, min_space_y = DMX1_SC_W285, space_extension_x = DMX1OR_SC_MXY, color_aware_to_fill = ONLY_COLOR_2 },
    { M0CB_LT405, min_space_y = DMX1_SC_W285, space_extension_x = DMX1OR_SC_MXY, color_aware_to_fill = ONLY_COLOR_2, projection = CORNER  }, //for parsing
    { M0CB_LT405, min_space = 0 }, //for parsing
    { M0CA_LT160, min_space_y = DMX1_SC_W405, space_extension_x = DMX1OR_SC_MXY, color_aware_to_fill = ONLY_COLOR_1 },
    { M0CA_LT160, min_space_y = DMX1_SC_W405, space_extension_x = DMX1OR_SC_MXY, color_aware_to_fill = ONLY_COLOR_1, projection = CORNER  }, //for parsing
    { M0CA_LT160, min_space = 0 }, //for parsing
    { M0CB_LT160, min_space_y = DMX1_SC_W405, space_extension_x = DMX1OR_SC_MXY, color_aware_to_fill = ONLY_COLOR_2 },
    { M0CB_LT160, min_space_y = DMX1_SC_W405, space_extension_x = DMX1OR_SC_MXY, color_aware_to_fill = ONLY_COLOR_2, projection = CORNER  }, //for parsing
    { M0CB_LT160, min_space = 0 }, //for parsing
#endif
    { M0CA_GE160, min_space_x = DMX1_SC_W160, space_extension_y = DMX1_SC_W160, min_space_y = DMX1_SC_W160, space_extension_x = DMX1_SC_W160, color_aware_to_fill = ONLY_COLOR_1},
    { M0CA_GE160, min_space = 0, color_aware_to_fill = ALL }, //for parsing
    { M0CB_GE160, min_space_x = DMX1_SC_W160, space_extension_y = DMX1_SC_W160, min_space_y = DMX1_SC_W160, space_extension_x = DMX1_SC_W160, color_aware_to_fill = ONLY_COLOR_2},
    { M0CB_GE160, min_space = 0, color_aware_to_fill = ALL }, //for parsing


#ifdef VERTICAL_M0
    { M0_LT165, min_space_x = DM0_DC_LEW16, min_space_y = DMX1OR_DC_MXY, space_extension_x = DM0_DC_LEW16, space_extension_y = DMX1OR_DC_MXY },
    { M0_LT285, min_space_x = DMX1OR_DC_MXX, min_space_y = DMX1OR_DC_MXY, space_extension_x = DMX1OR_DC_MXX, space_extension_y = DMX1OR_DC_MXY },
    { M0_LT405, min_space_x = DMX1OR_DC_MXX, min_space_y = DMX1OR_DC_MXY, space_extension_x = DMX1OR_DC_MXX, space_extension_y = DMX1OR_DC_MXY },
    { M0_LT160, min_space_x = DMX1_DC_W405, min_space_y = DMX1OR_DC_MXY, space_extension_x = DMX1_DC_W405, space_extension_y = DMX1OR_DC_MXY },
    { M0_GE160, min_space_x = DMX1_DC_W160, min_space_y = DMX1OR_DC_MXY, space_extension_x = DMX1_DC_W160, space_extension_y = DMX1OR_DC_MXY },
#else
    { M0_LT165, min_space_x = DMX1OR_DC_MXY, min_space_y = DM0_DC_LEW16, space_extension_x = DMX1OR_DC_MXY, space_extension_y = DM0_DC_LEW16 },
    { M0_LT285, min_space_x = DMX1OR_DC_MXY, min_space_y = DMX1OR_DC_MXX, space_extension_x = DMX1OR_DC_MXY, space_extension_y = DMX1OR_DC_MXX },
    { M0_LT405, min_space_x = DMX1OR_DC_MXY, min_space_y = DMX1OR_DC_MXX, space_extension_x = DMX1OR_DC_MXY, space_extension_y = DMX1OR_DC_MXX },
    { M0_LT160, min_space_x = DMX1OR_DC_MXY, min_space_y = DMX1_DC_W405, space_extension_x = DMX1OR_DC_MXY, space_extension_y = DMX1_DC_W405 },
    { M0_GE160, min_space_x = DMX1OR_DC_MXY, min_space_y = DMX1_DC_W160, space_extension_x = DMX1OR_DC_MXY, space_extension_y = DMX1_DC_W160 },
#endif
    { DM0_O, min_space_x = DMX1OR_DMX_O, min_space_y = DMX1OR_DMX_O, space_extension_x = DMX1OR_DMX_O, space_extension_y = DMX1OR_DMX_O },
    { DM0, min_space_x = DMX1OR_DMX, min_space_y = DMX1OR_DMX, space_extension_x = DMX1OR_DMX, space_extension_y = DMX1OR_DMX },
#ifdef VERTICAL_M0
    { M0_HVN_096V, min_space_x = DMX1_MX096V, min_space_y = DMX1OR_SC_MXY, space_extension_x = DMX1_MX096V, space_extension_y = DMX1OR_SC_MXY },
    { M0_HVN_132V, min_space_x = DMX1_MX132V, min_space_y = DMX1OR_SC_MXY, space_extension_x = DMX1_MX132V, space_extension_y = DMX1OR_SC_MXY },
    { M0_HVN_165V, min_space_x = DMX1_MX165V, min_space_y = DMX1OR_SC_MXY, space_extension_x = DMX1_MX165V, space_extension_y = DMX1OR_SC_MXY },
    { M0_HVN_198V, min_space_x = DMX1_MX198V, min_space_y = DMX1OR_SC_MXY, space_extension_x = DMX1_MX198V, space_extension_y = DMX1OR_SC_MXY },
    { M0_HVN_275V, min_space_x = DMX1_MX275V, min_space_y = DMX1OR_275V_MXY, space_extension_x = DMX1_MX275V, space_extension_y = DMX1OR_275V_MXY },
#else
    { M0_HVN_096V, min_space_x = DMX1OR_SC_MXY, min_space_y = DMX1_MX096V, space_extension_x = DMX1OR_SC_MXY, space_extension_y = DMX1_MX096V },
    { M0_HVN_132V, min_space_x = DMX1OR_SC_MXY, min_space_y = DMX1_MX132V, space_extension_x = DMX1OR_SC_MXY, space_extension_y = DMX1_MX132V },
    { M0_HVN_165V, min_space_x = DMX1OR_SC_MXY, min_space_y = DMX1_MX165V, space_extension_x = DMX1OR_SC_MXY, space_extension_y = DMX1_MX165V },
    { M0_HVN_198V, min_space_x = DMX1OR_SC_MXY, min_space_y = DMX1_MX198V, space_extension_x = DMX1OR_SC_MXY, space_extension_y = DMX1_MX198V },
    { M0_HVN_275V, min_space_x = DMX1OR_275V_MXY, min_space_y = DMX1_MX275V, space_extension_x = DMX1OR_275V_MXY, space_extension_y = DMX1_MX275V },
#endif
    { VIAMINUS_HVN_096V, min_space = DMX1_VX096V },
    { VIAMINUS_HVN_132V, min_space = DMX1_VX132V },
    { VIAMINUS_HVN_165V, min_space = DMX1_VX165V },
    { VIAMINUS_HVN_198V, min_space = DMX1_VX198V },
    { VIAMINUS_HVN_275V, min_space = DMX1_VX275V },
    { VIA0_HVN_096V, min_space = DMX1_VX096V },
    { VIA0_HVN_132V, min_space = DMX1_VX132V },
    { VIA0_HVN_165V, min_space = DMX1_VX165V },
    { VIA0_HVN_198V, min_space = DMX1_VX198V },
    { VIA0_HVN_275V, min_space = DMX1_VX275V },

#ifdef FILL_M0_VIA0_M1_BTCD
              { BTCD_M0_V0_M1_E, min_space = BTCD_DX1 },
#endif
#ifdef FILL_M0_BTCD2
              { BTCD_M0_E, min_space = BTCD_DX1 },
#endif
#ifdef VERTICAL_M0
       { WRAPPER_DM0_O_L, min_space_x = DM0OR_DMX_OX, min_space_y = DM0OR_DMX_OY, space_extension_x = DM0OR_DMX_OX, space_extension_y = DM0OR_DMX_OY },
#else
       { WRAPPER_DM0_O_L, min_space_x = DM0OR_DMX_OY, min_space_y = DM0OR_DMX_OX, space_extension_x = DM0OR_DMX_OY, space_extension_y = DM0OR_DMX_OX },
#endif
       { DM0_L, min_space = DMX1OR_DMX },
       { CM0CELL_E, min_space = DMX1OR_DMX_O },
    },
    shift = 2,
    repeat = 3,
    starting_point = CENTER
);
//=======================================================
PATTERN_SPEC_DM0_SHAPE_OR.adjustable_fill.dpt_spacing = {
            dpt_space_x = 0.056,
            dpt_space_y = 0.056,
            dpt_space_extension = INTERSECTION,
};

PATTERN_SPEC_DM0_SHAPE_OR.adjustable_fill.pattern_spec.pattern_spacing = {
    corner_extension_x = 0.07,
    corner_extension_y = 0.07,
    extension = INTERSECTION,
};



SPEC_DM0_OR = unified_fill(
	fill_patterns = {
        PATTERN_SPEC_DM0_SHAPE_OR,
    },
	fill_boundary = {
	    layer = CHIP_snps,
	    type = LAYER,
	},
    boundary = ALIGN,
	grid = vGRID
);

DM0_O_A_C   = SPEC_DM0_OR["OUTPUT_DM0_OR"][1];
DM0_O_B_C   = SPEC_DM0_OR["OUTPUT_DM0_OR"][2];
DM0_O_L     = SPEC_DM0_OR["OUTPUT_DM0_OR"][0];

//=======================================================
// DUMMY SPEC : DM0_OW_x1
PATTERN_SPEC_DM0_SHAPE_OW = get_single_adjustable_pattern(
    adj_type = SHRINK,
#ifdef VERTICAL_M0
    min_bound = { DMX1OW_W, DMX1OW_L },
    max_bound = { DMX1OW_W_MAX, DMX1OW_L },
#else
    min_bound = { DMX1OW_L, DMX1OW_W },
    max_bound = { DMX1OW_L, DMX1OW_W_MAX },
#endif
    color = true,
    color_scheme = UF_LINE_SIDE,
#ifdef VERTICAL_M0
    cell_prefix = "DMOW0V", output = "OUTPUT_DM0_OW",
    spacing = { DMX1OW_SX, DMX1OW_SY },
#else
    cell_prefix = "DMOW0H", output = "OUTPUT_DM0_OW",
    spacing = { DMX1OW_SY, DMX1OW_SX },
#endif
    FSS = {
#ifdef FULL_CHIP
    { CHIP_snps, min_space = 0.07, context = INTERIOR },
    { CHIP_BOUNDARY, min_space_x = 0.07, min_space_y = 0.078, context = INTERIOR },
#else
    { PRBOUNDARY, min_space_x = 0.07, min_space_y = 0.078, context = INTERIOR },
#endif
    { CHIP_snps, min_space = 0, context = INTERIOR }, //RD CONFIRM
#ifdef FULL_CHIP
    { CHIP_BOUNDARY, min_space = 0, context = INTERIOR }, //RD CONFIRM
    { CHIP_FILLREGION_X1, min_space = 0, context = INTERIOR },
#else
#endif
    { M0FORBIDDEN_CHIP, min_space = 0 },
    { MX1FORBIDDEN_CHIPMH, min_space = 0 },
    { BEOLBLK_FINAL, min_space = 0 },
    { DM0EXCL_FINAL, min_space = 0 },
    { CSR66_3485, min_space_x = DMX1_BEOLBLKE, min_space_y = DM0_BEOLBLKR, space_extension_x = DMX1_BEOLBLKE, space_extension_y = DM0_BEOLBLKR }, 
    { INDDMY, min_space = DM_INDDMY },
    { TCDDMY_M0, min_space = DMX1_TCDDMY_MX },
    { M0_HOLE, min_space = 0 },
    { CM0, min_space = M0_CUT },
    { M0_45, min_space = 0 },
    { ICOVL_SINGLE, min_space = DMX1_ICOVL },
    { SRM, min_space = DMX1_SRM_OUT, min_space_inside = DMX1_SRM_IN, context = EXTERIOR_INTERIOR },
    { SRAMDMY, min_space = DMX1_SRM_OUT, min_space_inside = DMX1_SRM_IN, context = EXTERIOR_INTERIOR },
    { M0_JUMP, min_space = DMX1_O_SRMJUMP },
    { VD2, min_space = DM0_VD2 },
    { ALL_STD_20, min_space = DM0_STD, context = EXTERIOR_INTERIOR },
    { VDR, min_space = DM0_VD2 },
    

    { ALL_STD_20, min_space = DM0O_ALLSTD, context = EXTERIOR_INTERIOR },

#ifdef VERTICAL_M0
    { M0_MAIN, min_space_x = DMX1OW_DC_MXX, min_space_y = DMX1OW_DC_MXY, space_extension_x = DMX1OW_DC_MXX, space_extension_y = DMX1OW_DC_MXY },
#else
    { M0_MAIN, min_space_x = DMX1OW_DC_MXY, min_space_y = DMX1OW_DC_MXX, space_extension_x = DMX1OW_DC_MXY, space_extension_y = DMX1OW_DC_MXX },
#endif
#ifdef VERTICAL_M0
    { M0_LT165, min_space_x = DMX1OW_DC_MXX, min_space_y = DMX1OW_DC_MXY, space_extension_x = DMX1OW_DC_MXX, space_extension_y = DMX1OW_DC_MXY },
#else
    { M0_LT165, min_space_x = DMX1OW_DC_MXY, min_space_y = DMX1OW_DC_MXX, space_extension_x = DMX1OW_DC_MXY, space_extension_y = DMX1OW_DC_MXX },
#endif

#ifdef VERTICAL_M0
    { M0CA_LT165, min_space_x = DMX1OW_SC_W16, space_extension_y = DMX1OW_SC_MXY, color_aware_to_fill = ONLY_COLOR_1 },
    { M0CA_LT165, min_space_x = DMX1OW_SC_W16, space_extension_y = DMX1OW_SC_MXY, color_aware_to_fill = ONLY_COLOR_1, projection = CORNER  }, //for parsing
    { M0CA_LT165, min_space = 0 }, //for parsing
    { M0CB_LT165, min_space_x = DMX1OW_SC_W16, space_extension_y = DMX1OW_SC_MXY, color_aware_to_fill = ONLY_COLOR_2 },
    { M0CB_LT165, min_space_x = DMX1OW_SC_W16, space_extension_y = DMX1OW_SC_MXY, color_aware_to_fill = ONLY_COLOR_2, projection = CORNER  }, //for parsing
    { M0CB_LT165, min_space = 0 }, //for parsing
#else
    { M0CA_LT165, min_space_y = DMX1OW_SC_W16, space_extension_x = DMX1OW_SC_MXY, color_aware_to_fill = ONLY_COLOR_1 },
    { M0CA_LT165, min_space_y = DMX1OW_SC_W16, space_extension_x = DMX1OW_SC_MXY, color_aware_to_fill = ONLY_COLOR_1, projection = CORNER  }, //for parsing
    { M0CA_LT165, min_space = 0 }, //for parsing
    { M0CB_LT165, min_space_y = DMX1OW_SC_W16, space_extension_x = DMX1OW_SC_MXY, color_aware_to_fill = ONLY_COLOR_2 },
    { M0CB_LT165, min_space_y = DMX1OW_SC_W16, space_extension_x = DMX1OW_SC_MXY, color_aware_to_fill = ONLY_COLOR_2, projection = CORNER  }, //for parsing
    { M0CB_LT165, min_space = 0 }, //for parsing
#endif

#ifdef VERTICAL_M0
    { M0_MAIN_CA, min_space_x = DMX1OW_SC_MXX, space_extension_y = DMX1OW_SC_MXY, color_aware_to_fill = ONLY_COLOR_1 },
    { M0_MAIN_CA, min_space_x = DMX1OW_SC_MXX, space_extension_y = DMX1OW_SC_MXY, color_aware_to_fill = ONLY_COLOR_1, projection = CORNER  }, //for parsing
    { M0_MAIN_CA, min_space = 0 }, //for parsing
    { M0_MAIN_CB, min_space_x = DMX1OW_SC_MXX, space_extension_y = DMX1OW_SC_MXY, color_aware_to_fill = ONLY_COLOR_2 },
    { M0_MAIN_CB, min_space_x = DMX1OW_SC_MXX, space_extension_y = DMX1OW_SC_MXY, color_aware_to_fill = ONLY_COLOR_2, projection = CORNER  }, //for parsing
    { M0_MAIN_CB, min_space = 0 }, //for parsing
#else
    { M0_MAIN_CA, min_space_y = DMX1OW_SC_MXX, space_extension_x = DMX1OW_SC_MXY, color_aware_to_fill = ONLY_COLOR_1 },
    { M0_MAIN_CA, min_space_y = DMX1OW_SC_MXX, space_extension_x = DMX1OW_SC_MXY, color_aware_to_fill = ONLY_COLOR_1, projection = CORNER  }, //for parsing
    { M0_MAIN_CA, min_space = 0 }, //for parsing
    { M0_MAIN_CB, min_space_y = DMX1OW_SC_MXX, space_extension_x = DMX1OW_SC_MXY, color_aware_to_fill = ONLY_COLOR_2 },
    { M0_MAIN_CB, min_space_y = DMX1OW_SC_MXX, space_extension_x = DMX1OW_SC_MXY, color_aware_to_fill = ONLY_COLOR_2, projection = CORNER  }, //for parsing
    { M0_MAIN_CB, min_space = 0 }, //for parsing
#endif


    { DM0_O, min_space_x = DMX1OW_DMX_O, min_space_y = DMX1OW_DMX_O, space_extension_x = DMX1OW_DMX_O, space_extension_y = DMX1OW_DMX_O },
    { DM0, min_space_x = DMX1OW_DMX, min_space_y = DMX1OW_DMX, space_extension_x = DMX1OW_DMX, space_extension_y = DMX1OW_DMX },
#ifdef VERTICAL_M0
    { M0_HVN_096V, min_space_x = DMX1_MX096V, min_space_y = DMX1OR_SC_MXY, space_extension_x = DMX1_MX096V, space_extension_y = DMX1OR_SC_MXY },
    { M0_HVN_132V, min_space_x = DMX1_MX132V, min_space_y = DMX1OR_SC_MXY, space_extension_x = DMX1_MX132V, space_extension_y = DMX1OR_SC_MXY },
    { M0_HVN_165V, min_space_x = DMX1_MX165V, min_space_y = DMX1OR_SC_MXY, space_extension_x = DMX1_MX165V, space_extension_y = DMX1OR_SC_MXY },
    { M0_HVN_198V, min_space_x = DMX1_MX198V, min_space_y = DMX1OR_SC_MXY, space_extension_x = DMX1_MX198V, space_extension_y = DMX1OR_SC_MXY },
    { M0_HVN_275V, min_space_x = DMX1_MX275V, min_space_y = DMX1OR_275V_MXY, space_extension_x = DMX1_MX275V, space_extension_y = DMX1OR_275V_MXY },
#else
    { M0_HVN_096V, min_space_x = DMX1OR_SC_MXY, min_space_y = DMX1_MX096V, space_extension_x = DMX1OR_SC_MXY, space_extension_y = DMX1_MX096V },
    { M0_HVN_132V, min_space_x = DMX1OR_SC_MXY, min_space_y = DMX1_MX132V, space_extension_x = DMX1OR_SC_MXY, space_extension_y = DMX1_MX132V },
    { M0_HVN_165V, min_space_x = DMX1OR_SC_MXY, min_space_y = DMX1_MX165V, space_extension_x = DMX1OR_SC_MXY, space_extension_y = DMX1_MX165V },
    { M0_HVN_198V, min_space_x = DMX1OR_SC_MXY, min_space_y = DMX1_MX198V, space_extension_x = DMX1OR_SC_MXY, space_extension_y = DMX1_MX198V },
    { M0_HVN_275V, min_space_x = DMX1OR_275V_MXY, min_space_y = DMX1_MX275V, space_extension_x = DMX1OR_275V_MXY, space_extension_y = DMX1_MX275V },
#endif
    { VIAMINUS_HVN_096V, min_space = DMX1_VX096V },
    { VIAMINUS_HVN_132V, min_space = DMX1_VX132V },
    { VIAMINUS_HVN_165V, min_space = DMX1_VX165V },
    { VIAMINUS_HVN_198V, min_space = DMX1_VX198V },
    { VIAMINUS_HVN_275V, min_space = DMX1_VX275V },
    { VIA0_HVN_096V, min_space = DMX1_VX096V },
    { VIA0_HVN_132V, min_space = DMX1_VX132V },
    { VIA0_HVN_165V, min_space = DMX1_VX165V },
    { VIA0_HVN_198V, min_space = DMX1_VX198V },
    { VIA0_HVN_275V, min_space = DMX1_VX275V },

    { BEOLBLK_FINAL, min_space = 0 },
    { DM0EXCL_FINAL, min_space = 0 },
    { BEOLBLK_FINAL_NOM0, min_space_x = 0.07, min_space_y = 0.078, space_extension_x = 0.07, space_extension_y = 0.078 },
    { DM0EXCL_FINAL_NOM0, min_space_x = 0.07, min_space_y = 0.078, space_extension_x = 0.07, space_extension_y = 0.078 },


#ifdef FILL_M0_VIA0_M1_BTCD
              { BTCD_M0_V0_M1_E, min_space = BTCD_DX1 },
#endif
#ifdef FILL_M0_BTCD2
              { BTCD_M0_E, min_space = BTCD_DX1 },
#endif
       { WRAPPER_DM0_O_L, min_space = DMX1OW_DMX_O },
       { DM0_L, min_space = DMX1OW_DMX },
       { DM0_O_L, min_space = DMX1OW_DMX_O },
       { CM0CELL_E, min_space = DMX1OW_DMX_O },

    },
    shift = 2,
    repeat = 3,
    starting_point = CENTER
);
//=======================================================
PATTERN_SPEC_DM0_SHAPE_OW.adjustable_fill.pattern_spec.pattern_spacing = {
      corner_extension_x = 0.07,
      corner_extension_y = 0.07,
      extension = INTERSECTION,
};
PATTERN_SPEC_DM0_SHAPE_OW.adjustable_fill.boundary_alignment = { inside = { CHIP_snps, {0.35, 0.35, 0.35, 0.35} }};


SPEC_DM0_OW = unified_fill(
	fill_patterns = {
        PATTERN_SPEC_DM0_SHAPE_OW
    },
	fill_boundary = {
	    layer = CHIP_snps,
	    type = LAYER,
	},
    boundary = ALIGN,
	grid = vGRID

);

//***** fill *******************************************************************
DM0_OW_A_C = SPEC_DM0_OW["OUTPUT_DM0_OW"][1];
DM0_OW_B_C = SPEC_DM0_OW["OUTPUT_DM0_OW"][2];
DM0_OW_L = SPEC_DM0_OW["OUTPUT_DM0_OW"][0];

//=======================================================

// DUMMY SPEC : DM0_OW2_x1
PATTERN_SPEC_DM0_OW2 = get_single_polygon_pattern(
#ifdef VERTICAL_M0
	"DMOW0V2", "OUTPUT_DM0_OW2", DMX1OW2_W, DMX1OW2_L,
	step_x = DMX1OW2_SX, step_y = DMX1OW2_SY,
#else
	"DMOW0H2", "OUTPUT_DM0_OW2", DMX1OW2_L, DMX1OW2_W,
	step_x = DMX1OW2_SY, step_y = DMX1OW2_SX,
#endif

    FSS = {
#ifdef FULL_CHIP
    { CHIP_snps, min_space = 0.07, context = INTERIOR },
    { CHIP_BOUNDARY, min_space_x = 0.07, min_space_y = 0.078, context = INTERIOR },
#else
#ifdef VERTICAL_M0
    { PRBOUNDARY, min_space_x = 0.078, min_space_y = 0.07, context = INTERIOR },
#else
    { PRBOUNDARY, min_space_x = 0.07, min_space_y = 0.078, context = INTERIOR },
#endif
#endif
    { CHIP_snps, min_space = 0, context = INTERIOR }, //RD CONFIRM
#ifdef FULL_CHIP
    { CHIP_BOUNDARY, min_space = 0, context = INTERIOR }, //RD CONFIRM
    { CHIP_FILLREGION_X1, min_space = 0, context = INTERIOR },
#else
#endif
    { M0FORBIDDEN_CHIP, min_space = 0 },
    { MX1FORBIDDEN_CHIPMH, min_space = 0 },
    { BEOLBLK_FINAL, min_space = 0 },
    { DM0EXCL_FINAL, min_space = 0 },
    { CSR66_3485, min_space_x = DMX1_BEOLBLKE, min_space_y = DM0_BEOLBLKR, space_extension_x = DMX1_BEOLBLKE, space_extension_y = DM0_BEOLBLKR }, 
    { INDDMY, min_space = DM_INDDMY },
    { TCDDMY_M0, min_space = DMX1_TCDDMY_MX },
    { M0_HOLE, min_space = 0 },
    { CM0, min_space = M0_CUT },
    { M0_45, min_space = 0 },
    { ICOVL_SINGLE, min_space = DMX1_ICOVL },
    { SRM, min_space = DMX1_SRM_OUT, min_space_inside = DMX1_SRM_IN, context = EXTERIOR_INTERIOR },
    { SRAMDMY, min_space = DMX1_SRM_OUT, min_space_inside = DMX1_SRM_IN, context = EXTERIOR_INTERIOR },
    { M0_JUMP, min_space = DMX1_O_SRMJUMP },
    { VD2, min_space = DM0_VD2 },
    { ALL_STD_20, min_space = DM0_STD, context = EXTERIOR_INTERIOR },
    { VDR, min_space = DM0_VD2 },
    

    { ALL_STD_20, min_space = DM0O_ALLSTD, context = EXTERIOR_INTERIOR },

#ifdef VERTICAL_M0
    { M0_MAIN, min_space_x = DMX1OW2_DC_MXX, min_space_y = DMX1OW2_DC_MXY, space_extension_x = DMX1OW2_DC_MXX, space_extension_y = DMX1OW2_DC_MXY },
#else
    { M0_MAIN, min_space_x = DMX1OW2_DC_MXY, min_space_y = DMX1OW2_DC_MXX, space_extension_x = DMX1OW2_DC_MXY, space_extension_y = DMX1OW2_DC_MXX },
#endif
#ifdef VERTICAL_M0
    { M0_LT165, min_space_x = DMX1OW2_DC_MXY, min_space_y = DMX1OW2_DC_MXY, space_extension_x = DMX1OW2_DC_MXY, space_extension_y = DMX1OW2_DC_MXY },
    { M0_LT285, min_space_x = DMX1OW2_DC_MXX, min_space_y = DMX1OW2_DC_MXY, space_extension_x = DMX1OW2_DC_MXX, space_extension_y = DMX1OW2_DC_MXY },
    { M0_LT405, min_space_x = DMX1OW2_DC_MXX, min_space_y = DMX1OW2_DC_MXY, space_extension_x = DMX1OW2_DC_MXX, space_extension_y = DMX1OW2_DC_MXY },
    { M0_LT160, min_space_x = DMX1OW2_DC_MXX, min_space_y = DMX1OW2_DC_MXY, space_extension_x = DMX1OW2_DC_MXX, space_extension_y = DMX1OW2_DC_MXY },
    { M0_GE160, min_space_x = DMX1OW2_DC_MXY, min_space_y = DMX1OW2_DC_MXY, space_extension_x = DMX1OW2_DC_MXY, space_extension_y = DMX1OW2_DC_MXY },
#else
    { M0_LT165, min_space_x = DMX1OW2_DC_MXY, min_space_y = DMX1OW2_DC_MXY, space_extension_x = DMX1OW2_DC_MXY, space_extension_y = DMX1OW2_DC_MXY },
    { M0_LT285, min_space_x = DMX1OW2_DC_MXY, min_space_y = DMX1OW2_DC_MXX, space_extension_x = DMX1OW2_DC_MXY, space_extension_y = DMX1OW2_DC_MXX },
    { M0_LT405, min_space_x = DMX1OW2_DC_MXY, min_space_y = DMX1OW2_DC_MXX, space_extension_x = DMX1OW2_DC_MXY, space_extension_y = DMX1OW2_DC_MXX },
    { M0_LT160, min_space_x = DMX1OW2_DC_MXY, min_space_y = DMX1OW2_DC_MXX, space_extension_x = DMX1OW2_DC_MXY, space_extension_y = DMX1OW2_DC_MXX },
    { M0_GE160, min_space_x = DMX1OW2_DC_MXY, min_space_y = DMX1OW2_DC_MXY, space_extension_x = DMX1OW2_DC_MXY, space_extension_y = DMX1OW2_DC_MXY },
#endif

#ifdef VERTICAL_M0
    { DM0_O, min_space_x = DMX1OW2_DMX_OX, min_space_y = DMX1OW2_DMX_OY, space_extension_x = DMX1OW2_DMX_OX, space_extension_y = DMX1OW2_DMX_OY },
#else
    { DM0_O, min_space_x = DMX1OW2_DMX_OY, min_space_y = DMX1OW2_DMX_OX, space_extension_x = DMX1OW2_DMX_OY, space_extension_y = DMX1OW2_DMX_OX },
#endif
    { DM0, min_space_x = DMX1OW2_DMX, min_space_y = DMX1OW2_DMX, space_extension_x = DMX1OW2_DMX, space_extension_y = DMX1OW2_DMX },
#ifdef VERTICAL_M0
    { M0_HVN_096V, min_space_x = DMX1_MX096V, min_space_y = DMX1OR_SC_MXY, space_extension_x = DMX1_MX096V, space_extension_y = DMX1OR_SC_MXY },
    { M0_HVN_132V, min_space_x = DMX1_MX132V, min_space_y = DMX1OR_SC_MXY, space_extension_x = DMX1_MX132V, space_extension_y = DMX1OR_SC_MXY },
    { M0_HVN_165V, min_space_x = DMX1_MX165V, min_space_y = DMX1OR_SC_MXY, space_extension_x = DMX1_MX165V, space_extension_y = DMX1OR_SC_MXY },
    { M0_HVN_198V, min_space_x = DMX1_MX198V, min_space_y = DMX1OR_SC_MXY, space_extension_x = DMX1_MX198V, space_extension_y = DMX1OR_SC_MXY },
    { M0_HVN_275V, min_space_x = DMX1_MX275V, min_space_y = DMX1OR_275V_MXY, space_extension_x = DMX1_MX275V, space_extension_y = DMX1OR_275V_MXY },
#else
    { M0_HVN_096V, min_space_x = DMX1OR_SC_MXY, min_space_y = DMX1_MX096V, space_extension_x = DMX1OR_SC_MXY, space_extension_y = DMX1_MX096V },
    { M0_HVN_132V, min_space_x = DMX1OR_SC_MXY, min_space_y = DMX1_MX132V, space_extension_x = DMX1OR_SC_MXY, space_extension_y = DMX1_MX132V },
    { M0_HVN_165V, min_space_x = DMX1OR_SC_MXY, min_space_y = DMX1_MX165V, space_extension_x = DMX1OR_SC_MXY, space_extension_y = DMX1_MX165V },
    { M0_HVN_198V, min_space_x = DMX1OR_SC_MXY, min_space_y = DMX1_MX198V, space_extension_x = DMX1OR_SC_MXY, space_extension_y = DMX1_MX198V },
    { M0_HVN_275V, min_space_x = DMX1OR_275V_MXY, min_space_y = DMX1_MX275V, space_extension_x = DMX1OR_275V_MXY, space_extension_y = DMX1_MX275V },
#endif
    { VIAMINUS_HVN_096V, min_space = DMX1_VX096V },
    { VIAMINUS_HVN_132V, min_space = DMX1_VX132V },
    { VIAMINUS_HVN_165V, min_space = DMX1_VX165V },
    { VIAMINUS_HVN_198V, min_space = DMX1_VX198V },
    { VIAMINUS_HVN_275V, min_space = DMX1_VX275V },
    { VIA0_HVN_096V, min_space = DMX1_VX096V },
    { VIA0_HVN_132V, min_space = DMX1_VX132V },
    { VIA0_HVN_165V, min_space = DMX1_VX165V },
    { VIA0_HVN_198V, min_space = DMX1_VX198V },
    { VIA0_HVN_275V, min_space = DMX1_VX275V },

    { BEOLBLK_FINAL, min_space = 0 },
    { DM0EXCL_FINAL, min_space = 0 },
#ifdef VERTICAL_M0
    { BEOLBLK_FINAL_NOM0, min_space_x = 0.078, min_space_y = 0.07, space_extension_x = 0.078, space_extension_y = 0.07 },
    { DM0EXCL_FINAL_NOM0, min_space_x = 0.078, min_space_y = 0.07, space_extension_x = 0.078, space_extension_y = 0.07 },
    { CSR66_3485, min_space_x = 0.078, min_space_y = 0.07, space_extension_x = 0.078, space_extension_y = 0.07 },
#else
    { BEOLBLK_FINAL_NOM0, min_space_x = 0.07, min_space_y = 0.078, space_extension_x = 0.07, space_extension_y = 0.078 },
    { DM0EXCL_FINAL_NOM0, min_space_x = 0.07, min_space_y = 0.078, space_extension_x = 0.07, space_extension_y = 0.078 },
    { CSR66_3485, min_space_x = 0.07, min_space_y = 0.078, space_extension_x = 0.07, space_extension_y = 0.078 },
#endif



#ifdef FILL_M0_VIA0_M1_BTCD
              { BTCD_M0_V0_M1_E, min_space = BTCD_DX1 },
#endif
#ifdef FILL_M0_BTCD2
              { BTCD_M0_E, min_space = BTCD_DX1 },
#endif
       { WRAPPER_DM0_O_L, min_space = DMX1OW2_DMX_O },
       { DM0_L, min_space = DMX1OW2_DMX },
       { DM0_O_L, min_space = DMX1OW2_DMX_O },
       { DM0_OW_L, min_space = DMX1OW2_DMX_O },
       { CM0CELL_E, min_space = 0.07 },
    },
    shift = 2,
    repeat = 3,
    starting_point = CENTER
);

//=======================================================

PATTERN_SPEC_DM0_OW2.polygon_fill.color = true;
PATTERN_SPEC_DM0_OW2.polygon_fill.boundary_alignment = { inside = { CHIP_snps, {0.35, 0.35, 0.35, 0.35} }};
PATTERN_SPEC_DM0_OW2.polygon_fill.pattern_spec.pattern_spacing = {
            corner_extension_x = 0.06,
            corner_extension_y = 0.06,
            extension = INTERSECTION,
};


PATTERN_SPEC_DM0_OW2.polygon_fill.dpt_spacing = {
            dpt_space_x = 0.06,
            dpt_space_y = 0.06,
            dpt_space_extension = INTERSECTION,
};

SPEC_DM0_OW2 = unified_fill(
    fill_boundary = {
        layer = CHIP_snps,
        type = LAYER
    },
    fill_patterns = {
        PATTERN_SPEC_DM0_OW2,
    },
    boundary = ALIGN,
	grid = vGRID

);


//***** fill *******************************************************************
DM0_OW2_A_C = SPEC_DM0_OW2["OUTPUT_DM0_OW2"][1];
DM0_OW2_B_C = SPEC_DM0_OW2["OUTPUT_DM0_OW2"][2];

#endif

#ifdef FILL_DM1



// DUMMY SPEC : DM1

PATTERN_SPEC_DM1_SHAPE = get_single_adjustable_pattern(
    adj_type = GROW,
#ifdef VERTICAL_M1
    min_bound = { DMX1B_W, DMX1B_L },
    max_bound = { 0.09, DMX1B_L },
//#ifdef HIGHMETALDN
    valid_widths = { == 0.06, == 0.07, == 0.08, == 0.09 }, 
//#endif
#else
    min_bound = { DMX1B_L, DMX1B_W },
    max_bound = { DMX1B_L, 0.09 },
//#ifdef HIGHMETALDN
    valid_heights = { == 0.06, == 0.07, == 0.08, == 0.09 }, 
//#endif
#endif

#ifdef VERTICAL_M1
    cell_prefix = "DMB1V", output = "OUTPUT_DM1",
    spacing = { DMX1B_SY, DMX1B_SY },
#else
    cell_prefix = "DMB1H", output = "OUTPUT_DM1", 
    spacing = { DMX1B_SY, DMX1B_SY },
#endif
    FSS = {
    { CHIP_snps, min_space = DMX1_CHIP, context = INTERIOR },
#ifdef FULL_CHIP
    { CHIP_BOUNDARY, min_space_x = DMX1O_CHIPR, min_space_y = DMX1O_CHIPE, context = INTERIOR },
#else
    { PRBOUNDARY, min_space = 4, context = INTERIOR },
#endif
    { INDDMY, min_space = DM_INDDMY },
    { M1_HOLE, min_space = 0 },
    { BEOLBLK_FINAL, min_space = DMX1B_MX },
    { DM1EXCL_FINAL, min_space = DMX1B_MX },
    { CSR66_3485, min_space = DMX1B_MX },
    { M1_MAIN, min_space = DMX1B_MX },
    { DM1_GE91, min_space = DMX1_DMW091 },
    { DM1_O, min_space = DMX1B_DMX_O },
    { DM1, min_space = DMX1B_DMX },
    { SRM, min_space = 2 },
    { SRAMDMY, min_space = 2 },
    { M1_JUMP, min_space = DMX1_SRMJUMP },
    { ICOVL_SINGLE, min_space = 5 },
    { TCDDMY_M1, min_space = BTCD_DX1B },
#ifdef FILL_M0_VIA0_M1_BTCD
              { BTCD_M0_V0_M1_E, min_space = BTCD_DX1B },
#endif
#ifdef FILL_M1_VIA1_M2_BTCD
              { BTCD_M1_V1_M2_E, min_space = BTCD_DX1B },
#endif
#ifdef FILL_M1_BTCD2
              { BTCD_M1_E, min_space = BTCD_DX1B },
#endif
              { WRAPPER_DM1_O_L, min_space = DMX1B_DMX_O },
    },
    shift = 2,
    repeat = 3,
    starting_point = CENTER
);
PATTERN_SPEC_DM1_SHAPE.adjustable_fill.density_optimization = NONE;

PATTERN_SPEC_DM1_SHAPE.adjustable_fill.dpt_spacing = {
            dpt_space_x = DMX1B_DMX,
            dpt_space_y = DMX1B_DMX,
            dpt_space_extension = INTERSECTION,
};

SPEC_DM1 = unified_fill(
	fill_patterns = {
        PATTERN_SPEC_DM1_SHAPE,
    },
	fill_boundary = {
	    layer = CHIP_snps,
	    type = LAYER,
	},
    boundary = ALIGN,
	grid = vGRID
);

DM1_A_C   = SPEC_DM1["OUTPUT_DM1"][0];
DM1_L     = SPEC_DM1["OUTPUT_DM1"][0];


//=======================================================


// DUMMY SPEC : DM1_shape_OR
PATTERN_SPEC_DM1_SHAPE_OR = get_single_adjustable_pattern(
    adj_type = SHRINK,
#ifdef VERTICAL_M1
    min_bound = { DMX1OR_W_P48, DMX1OR_L_P48 },
    max_bound = { DMX1OR_W_P48, DMX1OR_L_MAX_P48 },
#else
    min_bound = { DMX1OR_L_P48, DMX1OR_W_P48 },
    max_bound = { DMX1OR_L_MAX_P48, DMX1OR_W_P48 },
#endif
#ifdef VERTICAL_M1
    cell_prefix = "WDM1V", output = "OUTPUT_DM1_OR",
    spacing = { 0.026, DMX1OR_SY_SC_P48 },
#else
    cell_prefix = "WDM1H", output = "OUTPUT_DM1_OR",
    spacing = { DMX1OR_SY_SC_P48, 0.026},
#endif
    FSS = {
#ifdef VERTICAL_M1
    { M1_MAIN_EDGE_END, min_space_y = 0.06, space_extension_x = 0.06, projection = CORNER },
#else
    { M1_MAIN_EDGE_END, min_space_x = 0.06, space_extension_y = 0.06, projection = CORNER }, 
#endif        
#ifdef VERTICAL_M1
      { M1_096V_LE, min_space_y = 0.07, space_extension_x = 0.042, projection = CORNER, color_aware_to_fill = ALL },
#else
      { M1_096V_LE, min_space_x = 0.07, space_extension_y = 0.042, projection = CORNER, color_aware_to_fill = ALL },
#endif
#ifdef VERTICAL_M1
      { M1_096V_LE, min_space_y = 0.042, space_extension_x = 0.07, projection = CORNER, color_aware_to_fill = ALL },
#else
      { M1_096V_LE, min_space_x = 0.042, space_extension_y = 0.07, projection = CORNER, color_aware_to_fill = ALL },
#endif

#ifdef VERTICAL_M1
      { M1_198V_LE, min_space_y = 0.07, space_extension_x = 0.061, projection = CORNER, color_aware_to_fill = ALL },
#else
      { M1_198V_LE, min_space_x = 0.07, space_extension_y = 0.061, projection = CORNER, color_aware_to_fill = ALL },
#endif

#ifdef VERTICAL_M1
      { M1_198V_LE, min_space_y = 0.061, space_extension_x = 0.07, projection = CORNER, color_aware_to_fill = ALL },
#else
      { M1_198V_LE, min_space_x = 0.061, space_extension_y = 0.07, projection = CORNER, color_aware_to_fill = ALL },
#endif
//====================================================================
// DUMMY SPEC : DM1_OR
    { CHIP_snps, min_space = 0, context = INTERIOR }, //RD CONFIRM
#ifdef FULL_CHIP
    { CHIP_BOUNDARY, min_space = 0, context = INTERIOR }, //RD CONFIRM
    { CHIP_FILLREGION_X1, min_space = 0, context = INTERIOR },
#else
    { PRBOUNDARY, min_space_x = DMX1O_CHIPR, min_space_y = DMX1O_CHIPE, context = INTERIOR }, 
#endif
    { MX1FORBIDDEN_CHIPMV, min_space = 0 },
    { BEOLBLK_FINAL, min_space = 0 },
    { DM1EXCL_FINAL, min_space = 0 },
    { BEOLBLK_FINAL_NOM1, min_space_x = DMX1_BEOLBLKR, min_space_y = DMX1_BEOLBLKE, space_extension_x = DMX1_BEOLBLKR, space_extension_y = DMX1_BEOLBLKE }, 
    { DM1EXCL_FINAL_NOM1, min_space_x = DMX1_DMXEXCLR, min_space_y = DMX1_DMXEXCLE, space_extension_x = DMX1_DMXEXCLR, space_extension_y = DMX1_DMXEXCLE }, 
    { CSR66_3485, min_space_x = DMX1_DMXEXCLR, min_space_y = DMX1_DMXEXCLE, space_extension_x = DMX1_DMXEXCLR, space_extension_y = DMX1_DMXEXCLE },
    { INDDMY, min_space = DM_INDDMY },
    { TCDDMY_M1, min_space = DMX1_TCDDMY_MX },
    { M1_HOLE, min_space = 0 },
    { M1_45, min_space = 0 },
    { ICOVL_SINGLE, min_space = DMX1_ICOVL },
    { SRM, min_space = DMX1_SRM_OUT, min_space_inside = DMX1_SRM_IN, context = EXTERIOR_INTERIOR },
    { SRAMDMY, min_space = DMX1_SRM_OUT, min_space_inside = DMX1_SRM_IN, context = EXTERIOR_INTERIOR },
    { M1_JUMP, min_space = DMX1_O_SRMJUMP },

#ifdef VERTICAL_M1
    { M1_MAIN, min_space_x = DMX1OR_SC_MXX_P48, min_space_y = DMX1OR_SC_MXY_P48, space_extension_x = DMX1OR_SC_MXX_P48, space_extension_y = DMX1OR_SC_MXY_P48 },
#else
    { M1_MAIN, min_space_x = DMX1OR_SC_MXY_P48, min_space_y = DMX1OR_SC_MXX_P48, space_extension_x = DMX1OR_SC_MXY_P48, space_extension_y = DMX1OR_SC_MXX_P48 },
#endif


#ifdef VERTICAL_M1
    { M1_LT285, min_space_x = DMX1OR_SC_MXX_P48, min_space_y = DMX1OR_SC_MXY, space_extension_x = DMX1OR_SC_MXX_P48, space_extension_y = DMX1OR_SC_MXY },
    { M1_LT405, min_space_x = DMX1_SC_W285, min_space_y = DMX1OR_SC_MXY, space_extension_x = DMX1_SC_W285, space_extension_y = DMX1OR_SC_MXY },
    { M1_LT160, min_space_x = DMX1_SC_W405, min_space_y = DMX1OR_SC_MXY, space_extension_x = DMX1_SC_W405, space_extension_y = DMX1OR_SC_MXY },
    { M1_GE160, min_space_x = DMX1_SC_W160, min_space_y = DMX1OR_SC_MXY, space_extension_x = DMX1_SC_W160, space_extension_y = DMX1OR_SC_MXY },
#else
    { M1_LT285, min_space_x = DMX1OR_SC_MXY, min_space_y = DMX1OR_SC_MXX_P48, space_extension_x = DMX1OR_SC_MXY, space_extension_y = DMX1OR_SC_MXX_P48 },
    { M1_LT405, min_space_x = DMX1OR_SC_MXY, min_space_y = DMX1_SC_W285, space_extension_x = DMX1OR_SC_MXY, space_extension_y = DMX1_SC_W285 },
    { M1_LT160, min_space_x = DMX1OR_SC_MXY, min_space_y = DMX1_SC_W405, space_extension_x = DMX1OR_SC_MXY, space_extension_y = DMX1_SC_W405 },
    { M1_GE160, min_space_x = DMX1OR_SC_MXY, min_space_y = DMX1_SC_W160, space_extension_x = DMX1OR_SC_MXY, space_extension_y = DMX1_SC_W160 },
#endif
    { DM1_O, min_space_x = DMX1OR_DMX_O_P48, min_space_y = DMX1OR_DMX_O_P48, space_extension_x = DMX1OR_DMX_O_P48, space_extension_y = DMX1OR_DMX_O_P48 },
    { DM1, min_space_x = DMX1OR_DMX_P48, min_space_y = DMX1OR_DMX_P48, space_extension_x = DMX1OR_DMX_P48, space_extension_y = DMX1OR_DMX_P48 },
#ifdef VERTICAL_M1
    { M1_HVN_096V, min_space_x = DM1_MX096V, min_space_y = DMX1OR_SC_MXY, space_extension_x = DM1_MX096V, space_extension_y = DMX1OR_SC_MXY },
    { M1_HVN_132V, min_space_x = DMX1_MX132V, min_space_y = DMX1OR_SC_MXY, space_extension_x = DMX1_MX132V, space_extension_y = DMX1OR_SC_MXY },
    { M1_HVN_165V, min_space_x = DMX1_MX165V, min_space_y = DMX1OR_SC_MXY, space_extension_x = DMX1_MX165V, space_extension_y = DMX1OR_SC_MXY },
    { M1_HVN_198V, min_space_x = DMX1_MX198V, min_space_y = DMX1OR_SC_MXY, space_extension_x = DMX1_MX198V, space_extension_y = DMX1OR_SC_MXY },
    { M1_HVN_275V, min_space_x = DMX1_MX275V, min_space_y = DMX1OR_275V_MXY, space_extension_x = DMX1_MX275V, space_extension_y = DMX1OR_275V_MXY },
#else
    { M1_HVN_096V, min_space_x = DMX1OR_SC_MXY, min_space_y = DM1_MX096V, space_extension_x = DMX1OR_SC_MXY, space_extension_y = DM1_MX096V },
    { M1_HVN_132V, min_space_x = DMX1OR_SC_MXY, min_space_y = DMX1_MX132V, space_extension_x = DMX1OR_SC_MXY, space_extension_y = DMX1_MX132V },
    { M1_HVN_165V, min_space_x = DMX1OR_SC_MXY, min_space_y = DMX1_MX165V, space_extension_x = DMX1OR_SC_MXY, space_extension_y = DMX1_MX165V },
    { M1_HVN_198V, min_space_x = DMX1OR_SC_MXY, min_space_y = DMX1_MX198V, space_extension_x = DMX1OR_SC_MXY, space_extension_y = DMX1_MX198V },
    { M1_HVN_275V, min_space_x = DMX1OR_275V_MXY, min_space_y = DMX1_MX275V, space_extension_x = DMX1OR_275V_MXY, space_extension_y = DMX1_MX275V },
#endif
    { VIA0_HVN_096V, min_space = DMX1_VX096V },
    { VIA0_HVN_132V, min_space = DMX1_VX132V },
    { VIA0_HVN_165V, min_space = DMX1_VX165V },
    { VIA0_HVN_198V, min_space = DMX1_VX198V },
    { VIA0_HVN_275V, min_space = DMX1_VX275V },
    { VIA1_HVN_096V, min_space = DMX1_VX096V },
    { VIA1_HVN_132V, min_space = DMX1_VX132V },
    { VIA1_HVN_165V, min_space = DMX1_VX165V },
    { VIA1_HVN_198V, min_space = DMX1_VX198V },
    { VIA1_HVN_275V, min_space = DMX1_VX275V },


#ifdef FILL_M0_VIA0_M1_BTCD
              { BTCD_M0_V0_M1_E, min_space = BTCD_DX1 },
#endif
#ifdef FILL_M1_VIA1_M2_BTCD
              { BTCD_M1_V1_M2_E, min_space = BTCD_DX1 },
#endif
#ifdef FILL_M1_BTCD2
              { BTCD_M1_E, min_space = BTCD_DX1 },
#endif
#ifdef VERTICAL_M1
       { WRAPPER_DM1_O_L, min_space_x = DM1OR_DMX_OX, min_space_y = DM1OR_DMX_OY, space_extension_x = DM1OR_DMX_OX, space_extension_y = DM1OR_DMX_OY },
#else
       { WRAPPER_DM1_O_L, min_space_x = DM1OR_DMX_OY, min_space_y = DM1OR_DMX_OX, space_extension_x = DM1OR_DMX_OY, space_extension_y = DM1OR_DMX_OX },
#endif
       { DM1_L, min_space = DMX1OR_DMX },
    },
    shift = 2,
    repeat = 3,
    starting_point = CENTER
);

#ifndef FULL_CHIP
PATTERN_SPEC_DM1_SHAPE_OR.adjustable_fill.boundary_alignment = { inside = { CHIP_snps, {0.35, 0.35, 0.35, 0.35} }};
#endif

#ifdef VERTICAL_M1
PATTERN_SPEC_DM1_SHAPE_OR.adjustable_fill.layer_spec.fill_to_fill_spacing = {
    corner_extension_x = 0.026,
    corner_extension_y = DMX1OR_SY_SC_P48,
    extension = INTERSECTION,
};
#else
PATTERN_SPEC_DM1_SHAPE_OR.adjustable_fill.layer_spec.fill_to_fill_spacing = {
    corner_extension_x = DMX1OR_SY_SC_P48,
    corner_extension_y = 0.026,
    extension = INTERSECTION,
};
#endif



SPEC_DM1_OR = unified_fill(
	fill_patterns = {
        PATTERN_SPEC_DM1_SHAPE_OR,
    },
	fill_boundary = {
	    layer = CHIP_snps,
	    type = LAYER,
	},
    boundary = ALIGN,
	grid = vGRID
);

DM1_O_A_C   = SPEC_DM1_OR["OUTPUT_DM1_OR"][0];
DM1_O_L     = SPEC_DM1_OR["OUTPUT_DM1_OR"][0];

//=======================================================
// DUMMY SPEC : DM1_shape_OW
PATTERN_SPEC_DM1_SHAPE_OW = get_single_adjustable_pattern(
    adj_type = SHRINK,
#ifdef VERTICAL_M1
    min_bound = { DMX1OW_W, DMX1OW_L },
    max_bound = { DMX1OW_W_MAX, DMX1OW_L },
#else
    min_bound = { DMX1OW_L, DMX1OW_W },
    max_bound = { DMX1OW_L, DMX1OW_W_MAX },
#endif
    color = false,
    color_scheme = UF_LINE_SIDE,
#ifdef VERTICAL_M1
    cell_prefix = "DMOW1V", output = "OUTPUT_DM1_OW",
    spacing = { DMX1OW_SX, DMX1OW_SY },
#else
    cell_prefix = "DMOW1H", output = "OUTPUT_DM1_OW",
    spacing = { DMX1OW_SY, DMX1OW_SX },
#endif
    FSS = {
#ifdef VERTICAL_M1
    { M1_096V_OE, min_space_y = 0.07, space_extension_x = 0.042, projection = CORNER }, 
#else
    { M1_096V_OE, min_space_x = 0.07, space_extension_y = 0.042, projection = CORNER }, 
#endif
#ifdef VERTICAL_M1
    { M1_096V_OE, min_space_y = 0.042, space_extension_x = 0.07, projection = CORNER }, 
#else
    { M1_096V_OE, min_space_x = 0.042, space_extension_y = 0.07, projection = CORNER }, 
#endif

#ifdef VERTICAL_M1
    { M1_198V_OE, min_space_y = 0.07, space_extension_x = 0.061, projection = CORNER },
#else
    { M1_198V_OE, min_space_x = 0.07, space_extension_y = 0.061, projection = CORNER }, 
#endif
#ifdef VERTICAL_M1
    { M1_198V_OE, min_space_y = 0.061, space_extension_x = 0.07, projection = CORNER },
#else
    { M1_198V_OE, min_space_x = 0.061, space_extension_y = 0.07, projection = CORNER }, 
#endif

//====================================================================
// DUMMY SPEC : DM1_OW
    { CHIP_snps, min_space = 0, context = INTERIOR }, //RD CONFIRM
#ifdef FULL_CHIP
    { CHIP_BOUNDARY, min_space = 0, context = INTERIOR }, //RD CONFIRM
    { CHIP_FILLREGION_X1, min_space = 0, context = INTERIOR },
#else
    { PRBOUNDARY, min_space_x = DMX1O_CHIPR, min_space_y = DMX1O_CHIPE, context = INTERIOR }, 
#endif
    { MX1FORBIDDEN_CHIPMV, min_space = 0 },
    { BEOLBLK_FINAL, min_space = 0 },
    { DM1EXCL_FINAL, min_space = 0 },
    { BEOLBLK_FINAL_NOM1, min_space_x = DMX1_BEOLBLKR, min_space_y = DMX1_BEOLBLKE, space_extension_x = DMX1_BEOLBLKR, space_extension_y = DMX1_BEOLBLKE }, 
    { DM1EXCL_FINAL_NOM1, min_space_x = DMX1_DMXEXCLR, min_space_y = DMX1_DMXEXCLE, space_extension_x = DMX1_DMXEXCLR, space_extension_y = DMX1_DMXEXCLE }, 
    { CSR66_3485, min_space_x = DMX1_DMXEXCLR, min_space_y = DMX1_DMXEXCLE, space_extension_x = DMX1_DMXEXCLR, space_extension_y = DMX1_DMXEXCLE },
    { INDDMY, min_space = DM_INDDMY },
    { TCDDMY_M1, min_space = DMX1_TCDDMY_MX },
    { M1_HOLE, min_space = 0 },
    { M1_45, min_space = 0 },
    { ICOVL_SINGLE, min_space = DMX1_ICOVL },
    { SRM, min_space = DMX1_SRM_OUT, min_space_inside = DMX1_SRM_IN, context = EXTERIOR_INTERIOR },
    { SRAMDMY, min_space = DMX1_SRM_OUT, min_space_inside = DMX1_SRM_IN, context = EXTERIOR_INTERIOR },
    { M1_JUMP, min_space = DMX1_O_SRMJUMP },

#ifdef VERTICAL_M1
    { M1_MAIN, min_space_x = DMX1OW_DC_MXX, min_space_y = DMX1OW_DC_MXY, space_extension_x = DMX1OW_DC_MXX, space_extension_y = DMX1OW_DC_MXY },
#else
    { M1_MAIN, min_space_x = DMX1OW_DC_MXY, min_space_y = DMX1OW_DC_MXX, space_extension_x = DMX1OW_DC_MXY, space_extension_y = DMX1OW_DC_MXX },
#endif
    { DM1_O, min_space_x = DMX1OW_DMX_O, min_space_y = DMX1OW_DMX_O, space_extension_x = DMX1OW_DMX_O, space_extension_y = DMX1OW_DMX_O },
    { DM1, min_space_x = DMX1OW_DMX, min_space_y = DMX1OW_DMX, space_extension_x = DMX1OW_DMX, space_extension_y = DMX1OW_DMX },
#ifdef VERTICAL_M1
    { M1_HVN_096V, min_space_x = DM1_MX096V, min_space_y = DMX1OR_SC_MXY, space_extension_x = DM1_MX096V, space_extension_y = DMX1OR_SC_MXY },
    { M1_HVN_132V, min_space_x = DMX1_MX132V, min_space_y = DMX1OR_SC_MXY, space_extension_x = DMX1_MX132V, space_extension_y = DMX1OR_SC_MXY },
    { M1_HVN_165V, min_space_x = DMX1_MX165V, min_space_y = DMX1OR_SC_MXY, space_extension_x = DMX1_MX165V, space_extension_y = DMX1OR_SC_MXY },
    { M1_HVN_198V, min_space_x = DMX1_MX198V, min_space_y = DMX1OR_SC_MXY, space_extension_x = DMX1_MX198V, space_extension_y = DMX1OR_SC_MXY },
    { M1_HVN_275V, min_space_x = DMX1_MX275V, min_space_y = DMX1OR_275V_MXY, space_extension_x = DMX1_MX275V, space_extension_y = DMX1OR_275V_MXY },
#else
    { M1_HVN_096V, min_space_x = DMX1OR_SC_MXY, min_space_y = DM1_MX096V, space_extension_x = DMX1OR_SC_MXY, space_extension_y = DM1_MX096V },
    { M1_HVN_132V, min_space_x = DMX1OR_SC_MXY, min_space_y = DMX1_MX132V, space_extension_x = DMX1OR_SC_MXY, space_extension_y = DMX1_MX132V },
    { M1_HVN_165V, min_space_x = DMX1OR_SC_MXY, min_space_y = DMX1_MX165V, space_extension_x = DMX1OR_SC_MXY, space_extension_y = DMX1_MX165V },
    { M1_HVN_198V, min_space_x = DMX1OR_SC_MXY, min_space_y = DMX1_MX198V, space_extension_x = DMX1OR_SC_MXY, space_extension_y = DMX1_MX198V },
    { M1_HVN_275V, min_space_x = DMX1OR_275V_MXY, min_space_y = DMX1_MX275V, space_extension_x = DMX1OR_275V_MXY, space_extension_y = DMX1_MX275V },
#endif
    { VIA0_HVN_096V, min_space = DMX1_VX096V },
    { VIA0_HVN_132V, min_space = DMX1_VX132V },
    { VIA0_HVN_165V, min_space = DMX1_VX165V },
    { VIA0_HVN_198V, min_space = DMX1_VX198V },
    { VIA0_HVN_275V, min_space = DMX1_VX275V },
    { VIA1_HVN_096V, min_space = DMX1_VX096V },
    { VIA1_HVN_132V, min_space = DMX1_VX132V },
    { VIA1_HVN_165V, min_space = DMX1_VX165V },
    { VIA1_HVN_198V, min_space = DMX1_VX198V },
    { VIA1_HVN_275V, min_space = DMX1_VX275V },

#ifdef FILL_M0_VIA0_M1_BTCD
              { BTCD_M0_V0_M1_E, min_space = BTCD_DX1 },
#endif
#ifdef FILL_M1_VIA1_M2_BTCD
              { BTCD_M1_V1_M2_E, min_space = BTCD_DX1 },
#endif
#ifdef FILL_M1_BTCD2
              { BTCD_M1_E, min_space = BTCD_DX1 },
#endif
       { WRAPPER_DM1_O_L, min_space = DMX1OW_DMX_O },
       { DM1_L, min_space = DMX1OW_DMX },
       { DM1_O_L, min_space = DMX1OW_DMX_O },
        
    },
    shift = 2,
    repeat = 3,
    starting_point = CENTER
);

PATTERN_SPEC_DM1_SHAPE_OW.adjustable_fill.pattern_spec.pattern_spacing = {
    corner_extension_x = 0.07,
    corner_extension_y = 0.07,
    extension = INTERSECTION,

};
PATTERN_SPEC_DM1_SHAPE_OW.adjustable_fill.boundary_alignment = { inside = { CHIP_snps, {0.35, 0.35, 0.35, 0.35} }};


SPEC_DM1_OW = unified_fill(
	fill_patterns = {
        PATTERN_SPEC_DM1_SHAPE_OW
    },
	fill_boundary = {
	    layer = CHIP_snps,
	    type = LAYER,
	},
    boundary = ALIGN,
	grid = vGRID

);

//***** fill *******************************************************************
DM1_OW_A_C = SPEC_DM1_OW["OUTPUT_DM1_OW"][0];
DM1_OW_L   = SPEC_DM1_OW["OUTPUT_DM1_OW"][0];

//=======================================================

// DUMMY SPEC : DM1_OW2

PATTERN_SPEC_DM1_OW2 = get_single_polygon_pattern(
#ifdef VERTICAL_M1
	"DMOW1V2", "OUTPUT_DM1_OW2", DMX1OW2_W, DMX1OW2_L,
    step_x = DM1OW2_SX, step_y = DM1OW2_SY,
#else
	"DMOW1H2", "OUTPUT_DM1_OW2", DMX1OW2_L, DMX1OW2_W,
	step_x = DM1OW2_SY, step_y = DM1OW2_SX,
#endif


    FSS = {
    { CHIP_snps, min_space = 0, context = INTERIOR }, //RD CONFIRM
#ifdef FULL_CHIP
    { CHIP_BOUNDARY, min_space = 0, context = INTERIOR }, //RD CONFIRM
    { CHIP_FILLREGION_X1, min_space = 0, context = INTERIOR },
#else
    { PRBOUNDARY, min_space_x = DMX1O_CHIPR, min_space_y = DMX1O_CHIPE, context = INTERIOR }, 
#endif
    { MX1FORBIDDEN_CHIPMV, min_space = 0 },
    { BEOLBLK_FINAL, min_space = 0 },
    { DM1EXCL_FINAL, min_space = 0 },
    { BEOLBLK_FINAL_NOM1, min_space_x = DMX1_BEOLBLKR, min_space_y = DMX1_BEOLBLKE, space_extension_x = DMX1_BEOLBLKR, space_extension_y = DMX1_BEOLBLKE }, 
    { DM1EXCL_FINAL_NOM1, min_space_x = DMX1_DMXEXCLR, min_space_y = DMX1_DMXEXCLE, space_extension_x = DMX1_DMXEXCLR, space_extension_y = DMX1_DMXEXCLE }, 
    { CSR66_3485, min_space_x = DMX1_DMXEXCLR, min_space_y = DMX1_DMXEXCLE, space_extension_x = DMX1_DMXEXCLR, space_extension_y = DMX1_DMXEXCLE },
    { INDDMY, min_space = DM_INDDMY },
    { TCDDMY_M1, min_space = DMX1_TCDDMY_MX },
    { M1_HOLE, min_space = 0 },
    { M1_45, min_space = 0 },
    { ICOVL_SINGLE, min_space = DMX1_ICOVL },
    { SRM, min_space = DMX1_SRM_OUT, min_space_inside = DMX1_SRM_IN, context = EXTERIOR_INTERIOR },
    { SRAMDMY, min_space = DMX1_SRM_OUT, min_space_inside = DMX1_SRM_IN, context = EXTERIOR_INTERIOR },
    { M1_JUMP, min_space = DMX1_O_SRMJUMP },

#ifdef VERTICAL_M1
    { M1_MAIN, min_space_x = DMX1OW2_DC_MXX, min_space_y = DMX1OW2_DC_MXY, space_extension_x = DMX1OW2_DC_MXX, space_extension_y = DMX1OW2_DC_MXY },
    { M1_LT285, min_space_x = DMX1OW2_DC_MXX, min_space_y = DMX1OW2_DC_MXY, space_extension_x = DMX1OW2_DC_MXX, space_extension_y = DMX1OW2_DC_MXY },
    { M1_LT405, min_space_x = DMX1OW2_DC_MXX, min_space_y = DMX1OW2_DC_MXY, space_extension_x = DMX1OW2_DC_MXX, space_extension_y = DMX1OW2_DC_MXY },
    { M1_LT160, min_space_x = DMX1OW2_DC_MXX, min_space_y = DMX1OW2_DC_MXY, space_extension_x = DMX1OW2_DC_MXX, space_extension_y = DMX1OW2_DC_MXY },
    { M1_GE160, min_space_x = DMX1OW2_DC_MXY, min_space_y = DMX1OW2_DC_MXY, space_extension_x = DMX1OW2_DC_MXY, space_extension_y = DMX1OW2_DC_MXY },
    { DM1_O, min_space_x = DMX1OW2_DMX_OX, min_space_y = DMX1OW2_DMX_OY, space_extension_x = DMX1OW2_DMX_OX, space_extension_y = DMX1OW2_DMX_OY },
#else
    { M1_MAIN, min_space_x = DMX1OW2_DC_MXY, min_space_y = DMX1OW2_DC_MXX, space_extension_x = DMX1OW2_DC_MXY, space_extension_y = DMX1OW2_DC_MXX },
    { M1_LT285, min_space_x = DMX1OW2_DC_MXY, min_space_y = DMX1OW2_DC_MXX, space_extension_x = DMX1OW2_DC_MXY, space_extension_y = DMX1OW2_DC_MXX },
    { M1_LT405, min_space_x = DMX1OW2_DC_MXY, min_space_y = DMX1OW2_DC_MXX, space_extension_x = DMX1OW2_DC_MXY, space_extension_y = DMX1OW2_DC_MXX },
    { M1_LT160, min_space_x = DMX1OW2_DC_MXY, min_space_y = DMX1OW2_DC_MXX, space_extension_x = DMX1OW2_DC_MXY, space_extension_y = DMX1OW2_DC_MXX },
    { M1_GE160, min_space_x = DMX1OW2_DC_MXY, min_space_y = DMX1OW2_DC_MXY, space_extension_x = DMX1OW2_DC_MXY, space_extension_y = DMX1OW2_DC_MXY },
    { DM1_O, min_space_x = DMX1OW2_DMX_OY, min_space_y = DMX1OW2_DMX_OX, space_extension_x = DMX1OW2_DMX_OY, space_extension_y = DMX1OW2_DMX_OX },
#endif
    { DM1, min_space_x = DMX1OW2_DMX, min_space_y = DMX1OW2_DMX, space_extension_x = DMX1OW2_DMX, space_extension_y = DMX1OW2_DMX },
#ifdef VERTICAL_M1
    { M1_HVN_096V, min_space_x = DM1_MX096V, min_space_y = DMX1OR_SC_MXY, space_extension_x = DM1_MX096V, space_extension_y = DMX1OR_SC_MXY },
    { M1_HVN_132V, min_space_x = DMX1_MX132V, min_space_y = DMX1OR_SC_MXY, space_extension_x = DMX1_MX132V, space_extension_y = DMX1OR_SC_MXY },
    { M1_HVN_165V, min_space_x = DMX1_MX165V, min_space_y = DMX1OR_SC_MXY, space_extension_x = DMX1_MX165V, space_extension_y = DMX1OR_SC_MXY },
    { M1_HVN_198V, min_space_x = DMX1_MX198V, min_space_y = DMX1OR_SC_MXY, space_extension_x = DMX1_MX198V, space_extension_y = DMX1OR_SC_MXY },
    { M1_HVN_275V, min_space_x = DMX1_MX275V, min_space_y = DMX1OR_275V_MXY, space_extension_x = DMX1_MX275V, space_extension_y = DMX1OR_275V_MXY },
#else
    { M1_HVN_096V, min_space_x = DMX1OR_SC_MXY, min_space_y = DM1_MX096V, space_extension_x = DMX1OR_SC_MXY, space_extension_y = DM1_MX096V },
    { M1_HVN_132V, min_space_x = DMX1OR_SC_MXY, min_space_y = DMX1_MX132V, space_extension_x = DMX1OR_SC_MXY, space_extension_y = DMX1_MX132V },
    { M1_HVN_165V, min_space_x = DMX1OR_SC_MXY, min_space_y = DMX1_MX165V, space_extension_x = DMX1OR_SC_MXY, space_extension_y = DMX1_MX165V },
    { M1_HVN_198V, min_space_x = DMX1OR_SC_MXY, min_space_y = DMX1_MX198V, space_extension_x = DMX1OR_SC_MXY, space_extension_y = DMX1_MX198V },
    { M1_HVN_275V, min_space_x = DMX1OR_275V_MXY, min_space_y = DMX1_MX275V, space_extension_x = DMX1OR_275V_MXY, space_extension_y = DMX1_MX275V },
#endif
    { VIA0_HVN_096V, min_space = DMX1_VX096V },
    { VIA0_HVN_132V, min_space = DMX1_VX132V },
    { VIA0_HVN_165V, min_space = DMX1_VX165V },
    { VIA0_HVN_198V, min_space = DMX1_VX198V },
    { VIA0_HVN_275V, min_space = DMX1_VX275V },
    { VIA1_HVN_096V, min_space = DMX1_VX096V },
    { VIA1_HVN_132V, min_space = DMX1_VX132V },
    { VIA1_HVN_165V, min_space = DMX1_VX165V },
    { VIA1_HVN_198V, min_space = DMX1_VX198V },
    { VIA1_HVN_275V, min_space = DMX1_VX275V },


#ifdef FILL_M0_VIA0_M1_BTCD
              { BTCD_M0_V0_M1_E, min_space = BTCD_DX1 },
#endif
#ifdef FILL_M1_VIA1_M2_BTCD
              { BTCD_M1_V1_M2_E, min_space = BTCD_DX1 },
#endif
#ifdef FILL_M1_BTCD2
              { BTCD_M1_E, min_space = BTCD_DX1 },
#endif
#ifdef VERTICAL_M1
       { M1_HVN_096V, min_space_y = 0.07, space_extension_x = 0.042 },
       { M1_HVN_096V, min_space_y = 0.042, space_extension_x = 0.07 },
       { M1_HVN_198V, min_space_y = 0.07, space_extension_x = 0.061 },
       { M1_HVN_198V, min_space_y = 0.061, space_extension_x = 0.07 },
#else
       { M1_HVN_096V, min_space_x = 0.07, space_extension_y = 0.042 },
       { M1_HVN_096V, min_space_x = 0.042, space_extension_y = 0.07 },
       { M1_HVN_198V, min_space_x = 0.07, space_extension_y = 0.061 },
       { M1_HVN_198V, min_space_x = 0.061, space_extension_y = 0.07 },
#endif
       { WRAPPER_DM1_O_L, min_space = 0.07 },
       { DM1_L, min_space = 0.07 },
       { DM1_O_L, min_space = 0.07 },
       { DM1_OW_L, min_space = 0.07 },
    },
    shift = 2,
    repeat = 3,
    starting_point = CENTER
);


PATTERN_SPEC_DM1_OW2.polygon_fill.boundary_alignment = { inside = { CHIP_snps, {0.35, 0.35, 0.35, 0.35} }};
PATTERN_SPEC_DM1_OW2.polygon_fill.pattern_spec.pattern_spacing = {
    corner_extension_x = 0.06,
    corner_extension_y = 0.06,
    extension = INTERSECTION,
};


SPEC_DM1_OW2 = unified_fill(
    fill_boundary = {
        layer = CHIP_snps,
        type = LAYER
    },
    fill_patterns = {
        PATTERN_SPEC_DM1_OW2,
    },
    boundary = ALIGN,
	grid = vGRID

);

DM1_OW2_C   = SPEC_DM1_OW2["OUTPUT_DM1_OW2"][0];
//=======================================================

#endif

//***** DM *********************************************************************
#ifdef FILL_DM2




PATTERN_SPEC_DM2_SHAPE = get_single_adjustable_pattern(
    adj_type = GROW,
#ifdef VERTICAL_M2
    min_bound = { DMX1B_W, DMX1B_L },
    max_bound = { 0.09, DMX1B_L },
//#ifdef HIGHMETALDN
    valid_widths = { == 0.06, == 0.07, == 0.08, == 0.09 }, 
//#endif
#else
    min_bound = { DMX1B_L, DMX1B_W },
    max_bound = { DMX1B_L, 0.09 },
//#ifdef HIGHMETALDN
    valid_heights = { == 0.06, == 0.07, == 0.08, == 0.09 }, 
//#endif
#endif
    color = true,
    color_scheme = UF_CHECKERED,

#ifdef VERTICAL_M2
    cell_prefix = "DMB2V", output = "OUTPUT_DM2",
    spacing = { DMX1B_SX, DMX1B_SY },
#else
    cell_prefix = "DMB2H", output = "OUTPUT_DM2", 
    spacing = { DMX1B_SY, DMX1B_SX },
#endif
// DUMMY SPEC : DM2_x1
    FSS = {
    { CHIP_snps, min_space = DMX1_CHIP, context = INTERIOR },
#ifdef FULL_CHIP
    { CHIP_BOUNDARY, min_space_x = DMX1O_CHIPE, min_space_y = DMX1O_CHIPR, context = INTERIOR },
#else
    { PRBOUNDARY, min_space = 4, context = INTERIOR },
#endif
    { INDDMY, min_space = DM_INDDMY },
    { M2_HOLE, min_space = 0 },
    { BEOLBLK_FINAL, min_space = DMX1B_MX },
    { DM2EXCL_FINAL, min_space = DMX1B_MX },
    { CSR66_3485, min_space = DMX1B_MX },
    { M2_MAIN, min_space = DMX1B_MX },
    { DM2_GE91, min_space = DMX1_DMW091 },
    { DM2_O, min_space = DMX1B_DMX_O },
    { DM2, min_space = DMX1B_DMX },
    { FLOATING_M2_JUMP, min_space = 2 },
    { M2_JUMP, min_space = DMX1_SRMJUMP },
    { ICOVL_SINGLE, min_space = 5 },
    { TCDDMY_M2, min_space = BTCD_DX1B },
#ifdef FILL_M1_VIA1_M2_BTCD
              { BTCD_M1_V1_M2_E, min_space = BTCD_DX1B },
#endif
#ifdef FILL_M2_VIA2_M3_BTCD
              { BTCD_M2_V2_M3_E, min_space = BTCD_DX1B },
#endif
#ifdef FILL_M2_BTCD2
              { BTCD_M2_E, min_space = BTCD_DX1B },
#endif
              { WRAPPER_DM2_O_L, min_space = DMX1B_DMX_O },
    },
    shift = 2,
    repeat = 3,
    starting_point = CENTER
);
//=======================================================
PATTERN_SPEC_DM2_SHAPE.adjustable_fill.density_optimization = NONE;

PATTERN_SPEC_DM2_SHAPE.adjustable_fill.dpt_spacing = {
            dpt_space_x = DMX1B_DMX,
            dpt_space_y = DMX1B_DMX,
            dpt_space_extension = INTERSECTION,
};

SPEC_DM2 = unified_fill(
	fill_patterns = {
        PATTERN_SPEC_DM2_SHAPE,
    },
	fill_boundary = {
	    layer = CHIP_snps,
	    type = LAYER,
	},
    boundary = ALIGN,
	grid = vGRID
);

DM2_A_C   = SPEC_DM2["OUTPUT_DM2"][1];
DM2_B_C   = SPEC_DM2["OUTPUT_DM2"][2];
DM2_L     = SPEC_DM2["OUTPUT_DM2"][0];


//=======================================================


// DUMMY SPEC : DM2_shape_OR
PATTERN_SPEC_DM2_SHAPE_OR = get_single_adjustable_pattern(
    adj_type = SHRINK,
#ifdef VERTICAL_M2
    min_bound = { DMX1OR_W, DMXOR_L },
#ifdef HIGHMETALDN
    max_bound = { 0.028, DMX1OR_L_MAX },
    valid_widths = { == 0.020, == 0.024, == 0.028 },
#else
    max_bound = { DMX1OR_W, DMX1OR_L_MAX },
#endif

#else
    min_bound = { DMXOR_L,  DMX1OR_W },
#ifdef HIGHMETALDN
    max_bound = { DMX1OR_L_MAX, 0.028 },
    valid_heights = { == 0.020, == 0.024, == 0.028 },
#else
    max_bound = { DMX1OR_L_MAX, DMX1OR_W },
#endif
#endif
    color = true,
    color_scheme = UF_LINE_SIDE,
#ifdef VERTICAL_M2
    cell_prefix = "WDM2V", output = "OUTPUT_DM2_OR",
    spacing = { DMX1OR_SX, DMX1OR_SY },
#else
    cell_prefix = "WDM2H", output = "OUTPUT_DM2_OR",
    spacing = { DMX1OR_SY, DMX1OR_SX },
#endif
    FSS = {
#ifdef VERTICAL_M2
        { M2CA_LE, min_space_y = 0.06, space_extension_x = 0.06, projection = CORNER, color_aware_to_fill = ONLY_COLOR_1 },
#else
        { M2CA_LE, min_space_x = 0.06, space_extension_y = 0.06, projection = CORNER, color_aware_to_fill = ONLY_COLOR_1 },
#endif
      

#ifdef VERTICAL_M2
        { M2CB_LE, min_space_y = 0.06, space_extension_x = 0.06, projection = CORNER, color_aware_to_fill = ONLY_COLOR_2 },
#else
        { M2CB_LE, min_space_x = 0.06, space_extension_y = 0.06, projection = CORNER, color_aware_to_fill = ONLY_COLOR_2 },
#endif


 
        { M2CA_LE, min_space = 0 }, //for parsing
        { M2CB_LE, min_space = 0 }, //for parsing
//=======================================================

// DUMMY SPEC : DM2_OR_x1
    { CHIP_snps, min_space = 0, context = INTERIOR }, //RD CONFIRM
#ifdef FULL_CHIP
    { CHIP_BOUNDARY, min_space = 0, context = INTERIOR }, //RD CONFIRM
    { CHIP_FILLREGION_X1, min_space = 0, context = INTERIOR },
#else
    { PRBOUNDARY, min_space_x = DMX1O_CHIPE, min_space_y = DMX1O_CHIPR, context = INTERIOR },
#endif
    { MX1FORBIDDEN_CHIPMH, min_space = 0 },
    { BEOLBLK_FINAL, min_space = 0 },
    { DM2EXCL_FINAL, min_space = 0 },
    { BEOLBLK_FINAL_NOM2, min_space_x = DMX1_BEOLBLKE, min_space_y = DMX1_BEOLBLKR, space_extension_x = DMX1_BEOLBLKE, space_extension_y = DMX1_BEOLBLKR }, 
    { DM2EXCL_FINAL_NOM2, min_space_x = DMX1_DMXEXCLE, min_space_y = DMX1_DMXEXCLR, space_extension_x = DMX1_DMXEXCLE, space_extension_y = DMX1_DMXEXCLR }, 
    { CSR66_3485, min_space_x = DMX1_DMXEXCLE, min_space_y = DMX1_DMXEXCLR, space_extension_x = DMX1_DMXEXCLE, space_extension_y = DMX1_DMXEXCLR },
    { INDDMY, min_space = DM_INDDMY },
    { TCDDMY_M2, min_space = DMX1_TCDDMY_MX },
    { M2_HOLE, min_space = 0 },
    { M2_45, min_space = 0 },
    { ICOVL_SINGLE, min_space = DMX1_ICOVL },
    { FLOATING_M2_JUMP, min_space = 0.08 },
    { M2_JUMP, min_space = DMX1_O_SRMJUMP },

#ifdef VERTICAL_M2
    { M2_MAIN, min_space_x = DMX1OR_DC_MXX, min_space_y = DMX1OR_DC_MXY, space_extension_x = DMX1OR_DC_MXX, space_extension_y = DMX1OR_DC_MXY },
#else
    { M2_MAIN, min_space_x = DMX1OR_DC_MXY, min_space_y = DMX1OR_DC_MXX, space_extension_x = DMX1OR_DC_MXY, space_extension_y = DMX1OR_DC_MXX },
#endif

#ifdef VERTICAL_M2
    { M2CA_LT285, min_space_x = DMX1OR_SC_MXX, space_extension_y = DMX1OR_SC_MXY, color_aware_to_fill = ONLY_COLOR_1 },
    { M2CA_LT285, min_space_x = DMX1OR_SC_MXX, space_extension_y = DMX1OR_SC_MXY, color_aware_to_fill = ONLY_COLOR_1, projection = CORNER  }, //for parsing
    { M2CA_LT285, min_space = 0 }, //for parsing
    { M2CB_LT285, min_space_x = DMX1OR_SC_MXX, space_extension_y = DMX1OR_SC_MXY, color_aware_to_fill = ONLY_COLOR_2 },
    { M2CB_LT285, min_space_x = DMX1OR_SC_MXX, space_extension_y = DMX1OR_SC_MXY, color_aware_to_fill = ONLY_COLOR_2, projection = CORNER  }, //for parsing
    { M2CB_LT285, min_space = 0 }, //for parsing
#else
    { M2CA_LT285, min_space_y = DMX1OR_SC_MXX, space_extension_x = DMX1OR_SC_MXY, color_aware_to_fill = ONLY_COLOR_1 },
    { M2CA_LT285, min_space_y = DMX1OR_SC_MXX, space_extension_x = DMX1OR_SC_MXY, color_aware_to_fill = ONLY_COLOR_1, projection = CORNER  }, //for parsing
    { M2CA_LT285, min_space = 0 }, //for parsing
    { M2CB_LT285, min_space_y = DMX1OR_SC_MXX, space_extension_x = DMX1OR_SC_MXY, color_aware_to_fill = ONLY_COLOR_2 },
    { M2CB_LT285, min_space_y = DMX1OR_SC_MXX, space_extension_x = DMX1OR_SC_MXY, color_aware_to_fill = ONLY_COLOR_2, projection = CORNER  }, //for parsing
    { M2CB_LT285, min_space = 0 }, //for parsing
#endif

#ifdef VERTICAL_M2
    { M2CA_LT405, min_space_x = DMX1_SC_W285, space_extension_y = DMX1OR_SC_MXY, color_aware_to_fill = ONLY_COLOR_1 },
    { M2CA_LT405, min_space_x = DMX1_SC_W285, space_extension_y = DMX1OR_SC_MXY, color_aware_to_fill = ONLY_COLOR_1, projection = CORNER  }, //for parsing
    { M2CA_LT405, min_space = 0 }, //for parsing
    { M2CB_LT405, min_space_x = DMX1_SC_W285, space_extension_y = DMX1OR_SC_MXY, color_aware_to_fill = ONLY_COLOR_2 },
    { M2CB_LT405, min_space_x = DMX1_SC_W285, space_extension_y = DMX1OR_SC_MXY, color_aware_to_fill = ONLY_COLOR_2, projection = CORNER  }, //for parsing
    { M2CB_LT405, min_space = 0 }, //for parsing
    { M2CA_LT160, min_space_x = DMX1_SC_W405, space_extension_y = DMX1OR_SC_MXY, color_aware_to_fill = ONLY_COLOR_1 },
    { M2CA_LT160, min_space_x = DMX1_SC_W405, space_extension_y = DMX1OR_SC_MXY, color_aware_to_fill = ONLY_COLOR_1, projection = CORNER  }, //for parsing
    { M2CA_LT160, min_space = 0 }, //for parsing
    { M2CB_LT160, min_space_x = DMX1_SC_W405, space_extension_y = DMX1OR_SC_MXY, color_aware_to_fill = ONLY_COLOR_2 },
    { M2CB_LT160, min_space_x = DMX1_SC_W405, space_extension_y = DMX1OR_SC_MXY, color_aware_to_fill = ONLY_COLOR_2, projection = CORNER  }, //for parsing
    { M2CB_LT160, min_space = 0 }, //for parsing
#else
    { M2CA_LT405, min_space_y = DMX1_SC_W285, space_extension_x = DMX1OR_SC_MXY, color_aware_to_fill = ONLY_COLOR_1 },
    { M2CA_LT405, min_space_y = DMX1_SC_W285, space_extension_x = DMX1OR_SC_MXY, color_aware_to_fill = ONLY_COLOR_1, projection = CORNER  }, //for parsing
    { M2CA_LT405, min_space = 0 }, //for parsing
    { M2CB_LT405, min_space_y = DMX1_SC_W285, space_extension_x = DMX1OR_SC_MXY, color_aware_to_fill = ONLY_COLOR_2 },
    { M2CB_LT405, min_space_y = DMX1_SC_W285, space_extension_x = DMX1OR_SC_MXY, color_aware_to_fill = ONLY_COLOR_2, projection = CORNER  }, //for parsing
    { M2CB_LT405, min_space = 0 }, //for parsing
    { M2CA_LT160, min_space_y = DMX1_SC_W405, space_extension_x = DMX1OR_SC_MXY, color_aware_to_fill = ONLY_COLOR_1 },
    { M2CA_LT160, min_space_y = DMX1_SC_W405, space_extension_x = DMX1OR_SC_MXY, color_aware_to_fill = ONLY_COLOR_1, projection = CORNER  }, //for parsing
    { M2CA_LT160, min_space = 0 }, //for parsing
    { M2CB_LT160, min_space_y = DMX1_SC_W405, space_extension_x = DMX1OR_SC_MXY, color_aware_to_fill = ONLY_COLOR_2 },
    { M2CB_LT160, min_space_y = DMX1_SC_W405, space_extension_x = DMX1OR_SC_MXY, color_aware_to_fill = ONLY_COLOR_2, projection = CORNER  }, //for parsing
    { M2CB_LT160, min_space = 0 }, //for parsing
#endif
    { M2CA_GE160, min_space_x = DMX1_SC_W160, space_extension_y = DMX1_SC_W160, min_space_y = DMX1_SC_W160, space_extension_x = DMX1_SC_W160, color_aware_to_fill = ONLY_COLOR_1},
    { M2CA_GE160, min_space = 0, color_aware_to_fill = ALL }, //for parsing
    { M2CB_GE160, min_space_x = DMX1_SC_W160, space_extension_y = DMX1_SC_W160, min_space_y = DMX1_SC_W160, space_extension_x = DMX1_SC_W160, color_aware_to_fill = ONLY_COLOR_2},
    { M2CB_GE160, min_space = 0, color_aware_to_fill = ALL }, //for parsing


#ifdef VERTICAL_M2
    { M2_LT285, min_space_x = DMX1OR_DC_MXX, min_space_y = DMX1OR_DC_MXY, space_extension_x = DMX1OR_DC_MXX, space_extension_y = DMX1OR_DC_MXY },
    { M2_LT405, min_space_x = DMX1OR_DC_MXX, min_space_y = DMX1OR_DC_MXY, space_extension_x = DMX1OR_DC_MXX, space_extension_y = DMX1OR_DC_MXY },
    { M2_LT160, min_space_x = DMX1_DC_W405, min_space_y = DMX1OR_DC_MXY, space_extension_x = DMX1_DC_W405, space_extension_y = DMX1OR_DC_MXY },
    { M2_GE160, min_space_x = DMX1_DC_W160, min_space_y = DMX1OR_DC_MXY, space_extension_x = DMX1_DC_W160, space_extension_y = DMX1OR_DC_MXY },
#else
    { M2_LT285, min_space_x = DMX1OR_DC_MXY, min_space_y = DMX1OR_DC_MXX, space_extension_x = DMX1OR_DC_MXY, space_extension_y = DMX1OR_DC_MXX },
    { M2_LT405, min_space_x = DMX1OR_DC_MXY, min_space_y = DMX1OR_DC_MXX, space_extension_x = DMX1OR_DC_MXY, space_extension_y = DMX1OR_DC_MXX },
    { M2_LT160, min_space_x = DMX1OR_DC_MXY, min_space_y = DMX1_DC_W405, space_extension_x = DMX1OR_DC_MXY, space_extension_y = DMX1_DC_W405 },
    { M2_GE160, min_space_x = DMX1OR_DC_MXY, min_space_y = DMX1_DC_W160, space_extension_x = DMX1OR_DC_MXY, space_extension_y = DMX1_DC_W160 },
#endif
    { DM2_O, min_space_x = DMX1OR_DMX_O, min_space_y = DMX1OR_DMX_O, space_extension_x = DMX1OR_DMX_O, space_extension_y = DMX1OR_DMX_O },
    { DM2, min_space_x = DMX1OR_DMX, min_space_y = DMX1OR_DMX, space_extension_x = DMX1OR_DMX, space_extension_y = DMX1OR_DMX },
#ifdef VERTICAL_M2
    { M2_HVN_096V, min_space_x = DMX1_MX096V, min_space_y = DMX1OR_SC_MXY, space_extension_x = DMX1_MX096V, space_extension_y = DMX1OR_SC_MXY },
    { M2_HVN_132V, min_space_x = DMX1_MX132V, min_space_y = DMX1OR_SC_MXY, space_extension_x = DMX1_MX132V, space_extension_y = DMX1OR_SC_MXY },
    { M2_HVN_165V, min_space_x = DMX1_MX165V, min_space_y = DMX1OR_SC_MXY, space_extension_x = DMX1_MX165V, space_extension_y = DMX1OR_SC_MXY },
    { M2_HVN_198V, min_space_x = DMX1_MX198V, min_space_y = DMX1OR_SC_MXY, space_extension_x = DMX1_MX198V, space_extension_y = DMX1OR_SC_MXY },
    { M2_HVN_275V, min_space_x = DMX1_MX275V, min_space_y = DMX1OR_275V_MXY, space_extension_x = DMX1_MX275V, space_extension_y = DMX1OR_275V_MXY },
#else
    { M2_HVN_096V, min_space_x = DMX1OR_SC_MXY, min_space_y = DMX1_MX096V, space_extension_x = DMX1OR_SC_MXY, space_extension_y = DMX1_MX096V },
    { M2_HVN_132V, min_space_x = DMX1OR_SC_MXY, min_space_y = DMX1_MX132V, space_extension_x = DMX1OR_SC_MXY, space_extension_y = DMX1_MX132V },
    { M2_HVN_165V, min_space_x = DMX1OR_SC_MXY, min_space_y = DMX1_MX165V, space_extension_x = DMX1OR_SC_MXY, space_extension_y = DMX1_MX165V },
    { M2_HVN_198V, min_space_x = DMX1OR_SC_MXY, min_space_y = DMX1_MX198V, space_extension_x = DMX1OR_SC_MXY, space_extension_y = DMX1_MX198V },
    { M2_HVN_275V, min_space_x = DMX1OR_275V_MXY, min_space_y = DMX1_MX275V, space_extension_x = DMX1OR_275V_MXY, space_extension_y = DMX1_MX275V },
#endif
    { VIA1_HVN_096V, min_space = DMX1_VX096V },
    { VIA1_HVN_132V, min_space = DMX1_VX132V },
    { VIA1_HVN_165V, min_space = DMX1_VX165V },
    { VIA1_HVN_198V, min_space = DMX1_VX198V },
    { VIA1_HVN_275V, min_space = DMX1_VX275V },
    { VIA2_HVN_096V, min_space = DMX1_VX096V },
    { VIA2_HVN_132V, min_space = DMX1_VX132V },
    { VIA2_HVN_165V, min_space = DMX1_VX165V },
    { VIA2_HVN_198V, min_space = DMX1_VX198V },
    { VIA2_HVN_275V, min_space = DMX1_VX275V },

#ifdef FILL_M1_VIA1_M2_BTCD
              { BTCD_M1_V1_M2_E, min_space = BTCD_DX1 },
#endif
#ifdef FILL_M2_VIA2_M3_BTCD
              { BTCD_M2_V2_M3_E, min_space = BTCD_DX1 },
#endif
#ifdef FILL_M2_BTCD2
              { BTCD_M2_E, min_space = BTCD_DX1 },
#endif
#ifdef VERTICAL_M2
       { WRAPPER_DM2_O_L, min_space_x = DMX1OR_DMX_OX, min_space_y = DMX1OR_DMX_OY, space_extension_x = DMX1OR_DMX_OX, space_extension_y = DMX1OR_DMX_OY },
#else
       { WRAPPER_DM2_O_L, min_space_x = DMX1OR_DMX_OY, min_space_y = DMX1OR_DMX_OX, space_extension_x = DMX1OR_DMX_OY, space_extension_y = DMX1OR_DMX_OX },
#endif
       { DM2_L, min_space = DMX1OR_DMX },
    },
    shift = 2,
    repeat = 3,
    starting_point = CENTER
);
//=======================================================
PATTERN_SPEC_DM2_SHAPE_OR.adjustable_fill.dpt_spacing = {
            dpt_space_x = 0.056,
            dpt_space_y = 0.056,
            dpt_space_extension = INTERSECTION,
};

PATTERN_SPEC_DM2_SHAPE_OR.adjustable_fill.pattern_spec.pattern_spacing = {
    corner_extension_x = 0.07,
    corner_extension_y = 0.07,
    extension = INTERSECTION,
};



SPEC_DM2_OR = unified_fill(
	fill_patterns = {
        PATTERN_SPEC_DM2_SHAPE_OR,
    },
	fill_boundary = {
	    layer = CHIP_snps,
	    type = LAYER,
	},
    boundary = ALIGN,
	grid = vGRID
);

DM2_O_A_C   = SPEC_DM2_OR["OUTPUT_DM2_OR"][1];
DM2_O_B_C   = SPEC_DM2_OR["OUTPUT_DM2_OR"][2];
DM2_O_L     = SPEC_DM2_OR["OUTPUT_DM2_OR"][0];

//=======================================================
// DUMMY SPEC : DM2_OW_x1
PATTERN_SPEC_DM2_SHAPE_OW = get_single_adjustable_pattern(
    adj_type = SHRINK,
#ifdef VERTICAL_M2
    min_bound = { DMX1OW_W, DMX1OW_L },
    max_bound = { DMX1OW_W_MAX, DMX1OW_L },
#else
    min_bound = { DMX1OW_L, DMX1OW_W },
    max_bound = { DMX1OW_L, DMX1OW_W_MAX },
#endif
    color = true,
    color_scheme = UF_LINE_SIDE,
#ifdef VERTICAL_M2
    cell_prefix = "DMOW2V", output = "OUTPUT_DM2_OW",
    spacing = { DMX1OW_SX, DMX1OW_SY },
#else
    cell_prefix = "DMOW2H", output = "OUTPUT_DM2_OW",
    spacing = { DMX1OW_SY, DMX1OW_SX },
#endif
    FSS = {
    { CHIP_snps, min_space = 0, context = INTERIOR }, //RD CONFIRM
#ifdef FULL_CHIP
    { CHIP_BOUNDARY, min_space = 0, context = INTERIOR }, //RD CONFIRM
    { CHIP_FILLREGION_X1, min_space = 0, context = INTERIOR },
#else
    { PRBOUNDARY, min_space_x = DMX1O_CHIPE, min_space_y = DMX1O_CHIPR, context = INTERIOR },
#endif
    { MX1FORBIDDEN_CHIPMH, min_space = 0 },
    { BEOLBLK_FINAL, min_space = 0 },
    { DM2EXCL_FINAL, min_space = 0 },
    { BEOLBLK_FINAL_NOM2, min_space_x = DMX1_BEOLBLKE, min_space_y = DMX1_BEOLBLKR, space_extension_x = DMX1_BEOLBLKE, space_extension_y = DMX1_BEOLBLKR }, 
    { DM2EXCL_FINAL_NOM2, min_space_x = DMX1_DMXEXCLE, min_space_y = DMX1_DMXEXCLR, space_extension_x = DMX1_DMXEXCLE, space_extension_y = DMX1_DMXEXCLR }, 
    { CSR66_3485, min_space_x = DMX1_DMXEXCLE, min_space_y = DMX1_DMXEXCLR, space_extension_x = DMX1_DMXEXCLE, space_extension_y = DMX1_DMXEXCLR },
    { INDDMY, min_space = DM_INDDMY },
    { TCDDMY_M2, min_space = DMX1_TCDDMY_MX },
    { M2_HOLE, min_space = 0 },
    { M2_45, min_space = 0 },
    { ICOVL_SINGLE, min_space = DMX1_ICOVL },
    { FLOATING_M2_JUMP, min_space = 0.08 },
    { M2_JUMP, min_space = DMX1_O_SRMJUMP },

#ifdef VERTICAL_M2
    { M2_MAIN, min_space_x = DMX1OW_DC_MXX, min_space_y = DMX1OW_DC_MXY, space_extension_x = DMX1OW_DC_MXX, space_extension_y = DMX1OW_DC_MXY },
#else
    { M2_MAIN, min_space_x = DMX1OW_DC_MXY, min_space_y = DMX1OW_DC_MXX, space_extension_x = DMX1OW_DC_MXY, space_extension_y = DMX1OW_DC_MXX },
#endif

#ifdef VERTICAL_M2
    { M2_MAIN_CA, min_space_x = DMX1OW_SC_MXX, space_extension_y = DMX1OW_SC_MXY, color_aware_to_fill = ONLY_COLOR_1 },
    { M2_MAIN_CA, min_space_x = DMX1OW_SC_MXX, space_extension_y = DMX1OW_SC_MXY, color_aware_to_fill = ONLY_COLOR_1, projection = CORNER  }, //for parsing
    { M2_MAIN_CA, min_space = 0 }, //for parsing
    { M2_MAIN_CB, min_space_x = DMX1OW_SC_MXX, space_extension_y = DMX1OW_SC_MXY, color_aware_to_fill = ONLY_COLOR_2 },
    { M2_MAIN_CB, min_space_x = DMX1OW_SC_MXX, space_extension_y = DMX1OW_SC_MXY, color_aware_to_fill = ONLY_COLOR_2, projection = CORNER  }, //for parsing
    { M2_MAIN_CB, min_space = 0 }, //for parsing
#else
    { M2_MAIN_CA, min_space_y = DMX1OW_SC_MXX, space_extension_x = DMX1OW_SC_MXY, color_aware_to_fill = ONLY_COLOR_1 },
    { M2_MAIN_CA, min_space_y = DMX1OW_SC_MXX, space_extension_x = DMX1OW_SC_MXY, color_aware_to_fill = ONLY_COLOR_1, projection = CORNER  }, //for parsing
    { M2_MAIN_CA, min_space = 0 }, //for parsing
    { M2_MAIN_CB, min_space_y = DMX1OW_SC_MXX, space_extension_x = DMX1OW_SC_MXY, color_aware_to_fill = ONLY_COLOR_2 },
    { M2_MAIN_CB, min_space_y = DMX1OW_SC_MXX, space_extension_x = DMX1OW_SC_MXY, color_aware_to_fill = ONLY_COLOR_2, projection = CORNER  }, //for parsing
    { M2_MAIN_CB, min_space = 0 }, //for parsing
#endif


    { DM2_O, min_space_x = DMX1OW_DMX_O, min_space_y = DMX1OW_DMX_O, space_extension_x = DMX1OW_DMX_O, space_extension_y = DMX1OW_DMX_O },
    { DM2, min_space_x = DMX1OW_DMX, min_space_y = DMX1OW_DMX, space_extension_x = DMX1OW_DMX, space_extension_y = DMX1OW_DMX },
#ifdef VERTICAL_M2
    { M2_HVN_096V, min_space_x = DMX1_MX096V, min_space_y = DMX1OR_SC_MXY, space_extension_x = DMX1_MX096V, space_extension_y = DMX1OR_SC_MXY },
    { M2_HVN_132V, min_space_x = DMX1_MX132V, min_space_y = DMX1OR_SC_MXY, space_extension_x = DMX1_MX132V, space_extension_y = DMX1OR_SC_MXY },
    { M2_HVN_165V, min_space_x = DMX1_MX165V, min_space_y = DMX1OR_SC_MXY, space_extension_x = DMX1_MX165V, space_extension_y = DMX1OR_SC_MXY },
    { M2_HVN_198V, min_space_x = DMX1_MX198V, min_space_y = DMX1OR_SC_MXY, space_extension_x = DMX1_MX198V, space_extension_y = DMX1OR_SC_MXY },
    { M2_HVN_275V, min_space_x = DMX1_MX275V, min_space_y = DMX1OR_275V_MXY, space_extension_x = DMX1_MX275V, space_extension_y = DMX1OR_275V_MXY },
#else
    { M2_HVN_096V, min_space_x = DMX1OR_SC_MXY, min_space_y = DMX1_MX096V, space_extension_x = DMX1OR_SC_MXY, space_extension_y = DMX1_MX096V },
    { M2_HVN_132V, min_space_x = DMX1OR_SC_MXY, min_space_y = DMX1_MX132V, space_extension_x = DMX1OR_SC_MXY, space_extension_y = DMX1_MX132V },
    { M2_HVN_165V, min_space_x = DMX1OR_SC_MXY, min_space_y = DMX1_MX165V, space_extension_x = DMX1OR_SC_MXY, space_extension_y = DMX1_MX165V },
    { M2_HVN_198V, min_space_x = DMX1OR_SC_MXY, min_space_y = DMX1_MX198V, space_extension_x = DMX1OR_SC_MXY, space_extension_y = DMX1_MX198V },
    { M2_HVN_275V, min_space_x = DMX1OR_275V_MXY, min_space_y = DMX1_MX275V, space_extension_x = DMX1OR_275V_MXY, space_extension_y = DMX1_MX275V },
#endif
    { VIA1_HVN_096V, min_space = DMX1_VX096V },
    { VIA1_HVN_132V, min_space = DMX1_VX132V },
    { VIA1_HVN_165V, min_space = DMX1_VX165V },
    { VIA1_HVN_198V, min_space = DMX1_VX198V },
    { VIA1_HVN_275V, min_space = DMX1_VX275V },
    { VIA2_HVN_096V, min_space = DMX1_VX096V },
    { VIA2_HVN_132V, min_space = DMX1_VX132V },
    { VIA2_HVN_165V, min_space = DMX1_VX165V },
    { VIA2_HVN_198V, min_space = DMX1_VX198V },
    { VIA2_HVN_275V, min_space = DMX1_VX275V },



#ifdef FILL_M1_VIA1_M2_BTCD
              { BTCD_M1_V1_M2_E, min_space = BTCD_DX1 },
#endif
#ifdef FILL_M2_VIA2_M3_BTCD
              { BTCD_M2_V2_M3_E, min_space = BTCD_DX1 },
#endif
#ifdef FILL_M2_BTCD2
              { BTCD_M2_E, min_space = BTCD_DX1 },
#endif
       { WRAPPER_DM2_O_L, min_space = DMX1OW_DMX_O },
       { DM2_L, min_space = DMX1OW_DMX },
       { DM2_O_L, min_space = DMX1OW_DMX_O },

    },
    shift = 2,
    repeat = 3,
    starting_point = CENTER
);
//=======================================================
PATTERN_SPEC_DM2_SHAPE_OW.adjustable_fill.pattern_spec.pattern_spacing = {
      corner_extension_x = 0.07,
      corner_extension_y = 0.07,
      extension = INTERSECTION,
};
PATTERN_SPEC_DM2_SHAPE_OW.adjustable_fill.boundary_alignment = { inside = { CHIP_snps, {0.35, 0.35, 0.35, 0.35} }};


SPEC_DM2_OW = unified_fill(
	fill_patterns = {
        PATTERN_SPEC_DM2_SHAPE_OW
    },
	fill_boundary = {
	    layer = CHIP_snps,
	    type = LAYER,
	},
    boundary = ALIGN,
	grid = vGRID

);

//***** fill *******************************************************************
DM2_OW_A_C = SPEC_DM2_OW["OUTPUT_DM2_OW"][1];
DM2_OW_B_C = SPEC_DM2_OW["OUTPUT_DM2_OW"][2];
DM2_OW_L = SPEC_DM2_OW["OUTPUT_DM2_OW"][0];

//=======================================================

// DUMMY SPEC : DM2_OW2_x1
PATTERN_SPEC_DM2_OW2 = get_single_polygon_pattern(
#ifdef VERTICAL_M2
	"DMOW2V2", "OUTPUT_DM2_OW2", DMX1OW2_W, DMX1OW2_L,
	step_x = DMXAOW2_SX, step_y = DMXAOW2_SY,
#else
	"DMOW2H2", "OUTPUT_DM2_OW2", DMX1OW2_L, DMX1OW2_W,
	step_x = DMXAOW2_SY, step_y = DMXAOW2_SX,
#endif

    FSS = {
    { CHIP_snps, min_space = 0, context = INTERIOR }, //RD CONFIRM
#ifdef FULL_CHIP
    { CHIP_BOUNDARY, min_space = 0, context = INTERIOR }, //RD CONFIRM
    { CHIP_FILLREGION_X1, min_space = 0, context = INTERIOR },
#else
    { PRBOUNDARY, min_space_x = DMX1O_CHIPE, min_space_y = DMX1O_CHIPR, context = INTERIOR },
#endif
    { MX1FORBIDDEN_CHIPMH, min_space = 0 },
    { BEOLBLK_FINAL, min_space = 0 },
    { DM2EXCL_FINAL, min_space = 0 },
    { BEOLBLK_FINAL_NOM2, min_space_x = DMX1_BEOLBLKE, min_space_y = DMX1_BEOLBLKR, space_extension_x = DMX1_BEOLBLKE, space_extension_y = DMX1_BEOLBLKR }, 
    { DM2EXCL_FINAL_NOM2, min_space_x = DMX1_DMXEXCLE, min_space_y = DMX1_DMXEXCLR, space_extension_x = DMX1_DMXEXCLE, space_extension_y = DMX1_DMXEXCLR }, 
    { CSR66_3485, min_space_x = DMX1_DMXEXCLE, min_space_y = DMX1_DMXEXCLR, space_extension_x = DMX1_DMXEXCLE, space_extension_y = DMX1_DMXEXCLR },
    { INDDMY, min_space = DM_INDDMY },
    { TCDDMY_M2, min_space = DMX1_TCDDMY_MX },
    { M2_HOLE, min_space = 0 },
    { M2_45, min_space = 0 },
    { ICOVL_SINGLE, min_space = DMX1_ICOVL },
    { FLOATING_M2_JUMP, min_space = 0.08 },
    { M2_JUMP, min_space = DMX1_O_SRMJUMP },

#ifdef VERTICAL_M2
    { M2_MAIN, min_space_x = DMX1OW2_DC_MXX, min_space_y = DMX1OW2_DC_MXY, space_extension_x = DMX1OW2_DC_MXX, space_extension_y = DMX1OW2_DC_MXY },
#else
    { M2_MAIN, min_space_x = DMX1OW2_DC_MXY, min_space_y = DMX1OW2_DC_MXX, space_extension_x = DMX1OW2_DC_MXY, space_extension_y = DMX1OW2_DC_MXX },
#endif
#ifdef VERTICAL_M2
    { M2_LT285, min_space_x = DMX1OW2_DC_MXY, min_space_y = DMX1OW2_DC_MXY, space_extension_x = DMX1OW2_DC_MXY, space_extension_y = DMX1OW2_DC_MXY },
    { M2_LT405, min_space_x = DMX1OW2_DC_MXX, min_space_y = DMX1OW2_DC_MXY, space_extension_x = DMX1OW2_DC_MXX, space_extension_y = DMX1OW2_DC_MXY },
    { M2_LT160, min_space_x = DMX1OW2_DC_MXX, min_space_y = DMX1OW2_DC_MXY, space_extension_x = DMX1OW2_DC_MXX, space_extension_y = DMX1OW2_DC_MXY },
    { M2_GE160, min_space_x = DMX1OW2_DC_MXY, min_space_y = DMX1OW2_DC_MXY, space_extension_x = DMX1OW2_DC_MXY, space_extension_y = DMX1OW2_DC_MXY },
#else
    { M2_LT285, min_space_x = DMX1OW2_DC_MXY, min_space_y = DMX1OW2_DC_MXY, space_extension_x = DMX1OW2_DC_MXY, space_extension_y = DMX1OW2_DC_MXY },
    { M2_LT405, min_space_x = DMX1OW2_DC_MXY, min_space_y = DMX1OW2_DC_MXX, space_extension_x = DMX1OW2_DC_MXY, space_extension_y = DMX1OW2_DC_MXX },
    { M2_LT160, min_space_x = DMX1OW2_DC_MXY, min_space_y = DMX1OW2_DC_MXX, space_extension_x = DMX1OW2_DC_MXY, space_extension_y = DMX1OW2_DC_MXX },
    { M2_GE160, min_space_x = DMX1OW2_DC_MXY, min_space_y = DMX1OW2_DC_MXY, space_extension_x = DMX1OW2_DC_MXY, space_extension_y = DMX1OW2_DC_MXY },
#endif

#ifdef VERTICAL_M2
    { DM2_O, min_space_x = DMX1OW2_DMX_OX, min_space_y = DMX1OW2_DMX_OY, space_extension_x = DMX1OW2_DMX_OX, space_extension_y = DMX1OW2_DMX_OY },
#else
    { DM2_O, min_space_x = DMX1OW2_DMX_OY, min_space_y = DMX1OW2_DMX_OX, space_extension_x = DMX1OW2_DMX_OY, space_extension_y = DMX1OW2_DMX_OX },
#endif
    { DM2, min_space_x = DMX1OW2_DMX, min_space_y = DMX1OW2_DMX, space_extension_x = DMX1OW2_DMX, space_extension_y = DMX1OW2_DMX },
#ifdef VERTICAL_M2
    { M2_HVN_096V, min_space_x = DMX1_MX096V, min_space_y = DMX1OR_SC_MXY, space_extension_x = DMX1_MX096V, space_extension_y = DMX1OR_SC_MXY },
    { M2_HVN_132V, min_space_x = DMX1_MX132V, min_space_y = DMX1OR_SC_MXY, space_extension_x = DMX1_MX132V, space_extension_y = DMX1OR_SC_MXY },
    { M2_HVN_165V, min_space_x = DMX1_MX165V, min_space_y = DMX1OR_SC_MXY, space_extension_x = DMX1_MX165V, space_extension_y = DMX1OR_SC_MXY },
    { M2_HVN_198V, min_space_x = DMX1_MX198V, min_space_y = DMX1OR_SC_MXY, space_extension_x = DMX1_MX198V, space_extension_y = DMX1OR_SC_MXY },
    { M2_HVN_275V, min_space_x = DMX1_MX275V, min_space_y = DMX1OR_275V_MXY, space_extension_x = DMX1_MX275V, space_extension_y = DMX1OR_275V_MXY },
#else
    { M2_HVN_096V, min_space_x = DMX1OR_SC_MXY, min_space_y = DMX1_MX096V, space_extension_x = DMX1OR_SC_MXY, space_extension_y = DMX1_MX096V },
    { M2_HVN_132V, min_space_x = DMX1OR_SC_MXY, min_space_y = DMX1_MX132V, space_extension_x = DMX1OR_SC_MXY, space_extension_y = DMX1_MX132V },
    { M2_HVN_165V, min_space_x = DMX1OR_SC_MXY, min_space_y = DMX1_MX165V, space_extension_x = DMX1OR_SC_MXY, space_extension_y = DMX1_MX165V },
    { M2_HVN_198V, min_space_x = DMX1OR_SC_MXY, min_space_y = DMX1_MX198V, space_extension_x = DMX1OR_SC_MXY, space_extension_y = DMX1_MX198V },
    { M2_HVN_275V, min_space_x = DMX1OR_275V_MXY, min_space_y = DMX1_MX275V, space_extension_x = DMX1OR_275V_MXY, space_extension_y = DMX1_MX275V },
#endif
    { VIA1_HVN_096V, min_space = DMX1_VX096V },
    { VIA1_HVN_132V, min_space = DMX1_VX132V },
    { VIA1_HVN_165V, min_space = DMX1_VX165V },
    { VIA1_HVN_198V, min_space = DMX1_VX198V },
    { VIA1_HVN_275V, min_space = DMX1_VX275V },
    { VIA2_HVN_096V, min_space = DMX1_VX096V },
    { VIA2_HVN_132V, min_space = DMX1_VX132V },
    { VIA2_HVN_165V, min_space = DMX1_VX165V },
    { VIA2_HVN_198V, min_space = DMX1_VX198V },
    { VIA2_HVN_275V, min_space = DMX1_VX275V },

    { BEOLBLK_FINAL, min_space = 0 },
    { DM2EXCL_FINAL, min_space = 0 },
#ifdef VERTICAL_M2
    { BEOLBLK_FINAL_NOM2, min_space_x = 0.07, min_space_y = 0.07, space_extension_x = 0.07, space_extension_y = 0.07 },
    { DM2EXCL_FINAL_NOM2, min_space_x = 0.07, min_space_y = 0.07, space_extension_x = 0.07, space_extension_y = 0.07 },
    { CSR66_3485, min_space_x = 0.07, min_space_y = 0.07, space_extension_x = 0.07, space_extension_y = 0.07 },
#else
    { BEOLBLK_FINAL_NOM2, min_space_x = 0.07, min_space_y = 0.07, space_extension_x = 0.07, space_extension_y = 0.07 },
    { DM2EXCL_FINAL_NOM2, min_space_x = 0.07, min_space_y = 0.07, space_extension_x = 0.07, space_extension_y = 0.07 },
    { CSR66_3485, min_space_x = 0.07, min_space_y = 0.07, space_extension_x = 0.07, space_extension_y = 0.07 }, 
#endif



#ifdef FILL_M1_VIA1_M2_BTCD
              { BTCD_M1_V1_M2_E, min_space = BTCD_DX1 },
#endif
#ifdef FILL_M2_VIA2_M3_BTCD
              { BTCD_M2_V2_M3_E, min_space = BTCD_DX1 },
#endif
#ifdef FILL_M2_BTCD2
              { BTCD_M2_E, min_space = BTCD_DX1 },
#endif
       { WRAPPER_DM2_O_L, min_space = DMX1OW2_DMX_O },
       { DM2_L, min_space = DMX1OW2_DMX },
       { DM2_O_L, min_space = DMX1OW2_DMX_O },
       { DM2_OW_L, min_space = DMX1OW2_DMX_O },
    },
    shift = 2,
    repeat = 3,
    starting_point = CENTER
);

//=======================================================

PATTERN_SPEC_DM2_OW2.polygon_fill.color = true;
PATTERN_SPEC_DM2_OW2.polygon_fill.boundary_alignment = { inside = { CHIP_snps, {0.35, 0.35, 0.35, 0.35} }};
PATTERN_SPEC_DM2_OW2.polygon_fill.pattern_spec.pattern_spacing = {
            corner_extension_x = 0.06,
            corner_extension_y = 0.06,
            extension = INTERSECTION,
};


PATTERN_SPEC_DM2_OW2.polygon_fill.dpt_spacing = {
            dpt_space_x = 0.06,
            dpt_space_y = 0.06,
            dpt_space_extension = INTERSECTION,
};

SPEC_DM2_OW2 = unified_fill(
    fill_boundary = {
        layer = CHIP_snps,
        type = LAYER
    },
    fill_patterns = {
        PATTERN_SPEC_DM2_OW2,
    },
    boundary = ALIGN,
	grid = vGRID

);


//***** fill *******************************************************************
DM2_OW2_A_C = SPEC_DM2_OW2["OUTPUT_DM2_OW2"][1];
DM2_OW2_B_C = SPEC_DM2_OW2["OUTPUT_DM2_OW2"][2];

#endif

#ifdef FILL_DM3





// DUMMY SPEC : DM3_x2

PATTERN_SPEC_DM3 = get_single_polygon_pattern(
#ifdef VERTICAL_M3
    cell_prefix = "DMB3V", output = "OUTPUT_DM3", width = DMX2B_W, height = DMX2B_L,
    step_x = DMX2B_SX, step_y = DMX2B_SY,
#else
    cell_prefix = "DMB3H", output = "OUTPUT_DM3", width = DMX2B_L, height = DMX2B_W,
    step_x = DMX2B_SY, step_y = DMX2B_SX,
#endif
    setback = DMX2B_DMX_Y,
    setback_type = INTERSECTION,
    FSS = {
    { CHIP_snps, min_space = DMX2_CHIP, context = INTERIOR },
#ifdef FULL_CHIP
    { CHIP_BOUNDARY, min_space = 0.07, context = INTERIOR },
#else
    { PRBOUNDARY, min_space = 4, context = INTERIOR },
#endif
    { CHIP_FILLREGION_X2, min_space = 0, context = INTERIOR },
    { M3_HOLE, min_space = 0 },
    { INDDMY, min_space = DM_INDDMY },
    { ICOVL_SINGLE, min_space = DMX2_ICOVL },
    { BEOLBLK_FINAL, min_space = DMX2B_MX },
    { DM3EXCL_FINAL, min_space = DMX2B_MX },
    { CSR66_3485, min_space = DMX2B_MX },
    { M3_MAIN, min_space = DMX2B_MX },
    { DM3_GE91, min_space = DMX2B_DMW91 },
#ifdef VERTICAL_M3
    { DM3_O, min_space_x = DMX2B_DMX_O_X, min_space_y = DMX2B_DMX_O_Y, space_extension_x = DMX2B_DMX_O_X, space_extension_y = DMX2B_DMX_O_Y },
    { DM3, min_space_x = DMX2B_DMX_X, min_space_y = DMX2B_DMX_Y, space_extension_x = DMX2B_DMX_X, space_extension_y = DMX2B_DMX_Y },
#else
    { DM3_O, min_space_x = DMX2B_DMX_O_Y, min_space_y = DMX2B_DMX_O_X, space_extension_x = DMX2B_DMX_O_Y, space_extension_y = DMX2B_DMX_O_X },
    { DM3, min_space_x = DMX2B_DMX_Y, min_space_y = DMX2B_DMX_X, space_extension_x = DMX2B_DMX_Y, space_extension_y = DMX2B_DMX_X },
#endif
    { TCDDMY_M3, min_space = BTCD_DX2 },
#ifdef FILL_M2_VIA2_M3_BTCD
              { BTCD_M2_V2_M3_E, min_space = BTCD_DX2B },
#endif
#ifdef FILL_M3_VIA3_M4_BTCD
              { BTCD_M3_V3_M4_E, min_space = BTCD_DX2B },
#endif

#ifdef FILL_M3_BTCD2
              { BTCD_M3_E, min_space = BTCD_DX2B },
#endif
#ifdef VERTICAL_M3
              { WRAPPER_DM3_O_L, min_space_x = DMX2B_DMX_O_X, min_space_y = DMX2B_DMX_O_Y, space_extension_x = DMX2B_DMX_O_X, space_extension_y = DMX2B_DMX_O_Y },
#else
              { WRAPPER_DM3_O_L, min_space_x = DMX2B_DMX_O_Y, min_space_y = DMX2B_DMX_O_X, space_extension_x = DMX2B_DMX_O_Y, space_extension_y = DMX2B_DMX_O_X },
#endif
    },
    repeat = 3,
    shift = 2,
    starting_point  = CENTER
);
//=======================================================


SPEC_DM3 = unified_fill( 
	fill_patterns = {
        PATTERN_SPEC_DM3
    },
	fill_boundary = {
	    layer = CHIP_snps,
	    type = LAYER,
	},
    boundary = ALIGN,
	grid = vGRID
);

DM3_C     = SPEC_DM3["OUTPUT_DM3"][0];
DM3_L     = SPEC_DM3["OUTPUT_DM3"][0];

//=======================================================



PATTERN_SPEC_DM3_SHAPE_OR_0 = get_single_adjustable_pattern(
    adj_type = SHRINK,
#ifdef VERTICAL_M3
    min_bound = { DMX2OR_W, DMX2OR_L },
    max_bound = { DMX2OR_W, DMX2OR_L_MAX_BOUND },
#else
    min_bound = { DMX2OR_L, DMX2OR_W },
    max_bound = { DMX2OR_L_MAX_BOUND, DMX2OR_W },
#endif
    color = false,
#ifdef VERTICAL_M3
    cell_prefix = "WDM3VC", output = "OUTPUT_DM3_OR",
    spacing = { 0.020, DMX2OR_SY },
#else
    cell_prefix = "WDM3HC", output = "OUTPUT_DM3_OR",
    spacing = { DMX2OR_SY, 0.020 },
#endif
    FSS = {
// DUMMY SPEC : DM3_shape_OR_bound
#ifdef VERTICAL_M3
    { M3_MAIN_LE, min_space_y = 0.06, space_extension_x = 0.06, projection = CORNER },
#else
    { M3_MAIN_LE, min_space_x = 0.06, space_extension_y = 0.06, projection = CORNER },
#endif
//=======================================================
// DUMMY SPEC : DM3_OR_x2
          { CHIP_BOUND_REG_M3, min_space = 0, context = INTERIOR },
    { CHIP_snps, min_space = 0, context = INTERIOR }, //RD CONFIRM
#ifdef FULL_CHIP
    { CHIP_BOUNDARY, min_space = 0, context = INTERIOR }, //RD CONFIRM
    { CHIP_FILLREGION_X2, min_space = 0, context = INTERIOR },
#else
    { PRBOUNDARY, min_space_x = DMX2O_CHIPR, min_space_y = DMX2O_CHIPE, context = INTERIOR },
#endif
    { MX2FORBIDDEN_CHIPMV, min_space = 0 },
    { BEOLBLK_FINAL, min_space_x = DMX2_BEOLBLKR, min_space_y = DMX2_BEOLBLKE, space_extension_x = DMX2_BEOLBLKR, space_extension_y = DMX2_BEOLBLKE }, 
    { DM3EXCL_FINAL, min_space_x = DMX2_DMXEXCLR, min_space_y = DMX2_DMXEXCLE, space_extension_x = DMX2_DMXEXCLR, space_extension_y = DMX2_DMXEXCLE }, 
    { CSR66_3485, min_space_x = DMX2_BEOLBLKR, min_space_y = DMX2_BEOLBLKE, space_extension_x = DMX2_BEOLBLKR, space_extension_y = DMX2_BEOLBLKE },
    { INDDMY, min_space = DM_INDDMY },
    { TCDDMY_M3, min_space = DMX2_TCDDMY_MX },
    { M3_HOLE, min_space = 0 },
    { M3_45, min_space = 0 },
    { ICOVL_SINGLE, min_space = DMX2_ICOVL },
#ifdef VERTICAL_M3
    { M3_MAIN, min_space_x = DMX2OR_SC_MXX, min_space_y = DMX2OR_SC_MXY, space_extension_x = DMX2OR_SC_MXX, space_extension_y = DMX2OR_SC_MXY },
#else
    { M3_MAIN, min_space_x = DMX2OR_SC_MXY, min_space_y = DMX2OR_SC_MXX, space_extension_x = DMX2OR_SC_MXY, space_extension_y = DMX2OR_SC_MXX },
#endif
#ifdef VERTICAL_M3
    { DM3_O, min_space_x = DMX2OR_DMX_O_X, min_space_y = DMX2OR_DMX_O_Y, space_extension_x = DMX2OR_DMX_O_X, space_extension_y = DMX2OR_DMX_O_Y },
    { DM3, min_space_x = DMX2OR_DMX_X, min_space_y = DMX2OR_DMX_Y, space_extension_x = DMX2OR_DMX_X, space_extension_y = DMX2OR_DMX_Y },
#else
    { DM3_O, min_space_x = DMX2OR_DMX_O_Y, min_space_y = DMX2OR_DMX_O_X, space_extension_x = DMX2OR_DMX_O_Y, space_extension_y = DMX2OR_DMX_O_X },
    { DM3, min_space_x = DMX2OR_DMX_Y, min_space_y = DMX2OR_DMX_X, space_extension_x = DMX2OR_DMX_Y, space_extension_y = DMX2OR_DMX_X },
#endif
    { VIA2, min_space = 0.06 },
#ifdef VERTICAL_M3
    { M3_HVN_096V, min_space_x = DMX2_MX096V, min_space_y = DMX2OR_SC_MXY, space_extension_x = DMX2_MX096V, space_extension_y = DMX2OR_SC_MXY },
    { M3_HVN_132V, min_space_x = DMX2_MX132V, min_space_y = DMX2OR_SC_MXY, space_extension_x = DMX2_MX132V, space_extension_y = DMX2OR_SC_MXY },
    { M3_HVN_165V, min_space_x = DMX2_MX165V, min_space_y = DMX2OR_SC_MXY, space_extension_x = DMX2_MX165V, space_extension_y = DMX2OR_SC_MXY },
    { M3_HVN_198V, min_space_x = DMX2_MX198V, min_space_y = DMX2OR_SC_MXY, space_extension_x = DMX2_MX198V, space_extension_y = DMX2OR_SC_MXY },
    { M3_HVN_275V, min_space_x = DMX2_MX275V, min_space_y = DMX2OR_SC_MXY, space_extension_x = DMX2_MX275V, space_extension_y = DMX2OR_SC_MXY },
#else
    { M3_HVN_096V, min_space_x = DMX2OR_SC_MXY, min_space_y = DMX2_MX096V, space_extension_x = DMX2OR_SC_MXY, space_extension_y = DMX2_MX096V },
    { M3_HVN_132V, min_space_x = DMX2OR_SC_MXY, min_space_y = DMX2_MX132V, space_extension_x = DMX2OR_SC_MXY, space_extension_y = DMX2_MX132V },
    { M3_HVN_165V, min_space_x = DMX2OR_SC_MXY, min_space_y = DMX2_MX165V, space_extension_x = DMX2OR_SC_MXY, space_extension_y = DMX2_MX165V },
    { M3_HVN_198V, min_space_x = DMX2OR_SC_MXY, min_space_y = DMX2_MX198V, space_extension_x = DMX2OR_SC_MXY, space_extension_y = DMX2_MX198V },
    { M3_HVN_275V, min_space_x = DMX2OR_SC_MXY, min_space_y = DMX2_MX275V, space_extension_x = DMX2OR_SC_MXY, space_extension_y = DMX2_MX275V },
#endif
    { VIA2_HVN_096V, min_space = DMX2_VX096V },
    { VIA2_HVN_132V, min_space = DMX2_VX132V },
    { VIA2_HVN_165V, min_space = DMX2_VX165V },
    { VIA2_HVN_198V, min_space = DMX2_VX198V },
    { VIA2_HVN_275V, min_space = DMX2_VX275V },
    { VIA3_HVN_096V, min_space = DMX2_VX096V },
    { VIA3_HVN_132V, min_space = DMX2_VX132V },
    { VIA3_HVN_165V, min_space = DMX2_VX165V },
    { VIA3_HVN_198V, min_space = DMX2_VX198V },
    { VIA3_HVN_275V, min_space = DMX2_VX275V },

         
        
//**** corner space for voltage pattern
              { M3_HVN_096V, min_space_x = 0.09, space_extension_y = 0.042, projection = CORNER },
              { M3_HVN_198V, min_space_x = 0.09, space_extension_y = 0.061, projection = CORNER },
              { M3_HVN_096V, min_space_y = 0.09, space_extension_x = 0.042, projection = CORNER },
              { M3_HVN_198V, min_space_y = 0.09, space_extension_x = 0.061, projection = CORNER },
//**** end corner check
#ifdef FILL_M2_VIA2_M3_BTCD
              { BTCD_M2_V2_M3_E, min_space = BTCD_DX2 },
#endif
#ifdef FILL_M3_VIA3_M4_BTCD
              { BTCD_M3_V3_M4_E, min_space = BTCD_DX2 },
#endif

#ifdef FILL_M3_BTCD2
              { BTCD_M3_E, min_space = BTCD_DX2 },
#endif
#ifdef VERTICAL_M3
       { WRAPPER_DM3_O_L, min_space_x = DMX2OR_DMX_O_X, min_space_y = DMX2OR_DMX_O_Y, space_extension_x = DMX2OR_DMX_O_X, space_extension_y = DMX2OR_DMX_O_Y },
       { DM3_L, min_space_x = DMX2OR_DMX_X, min_space_y = DMX2OR_DMX_Y, space_extension_x = DMX2OR_DMX_X, space_extension_y = DMX2OR_DMX_Y },
#else
       { WRAPPER_DM3_O_L, min_space_x = DMX2OR_DMX_O_Y, min_space_y = DMX2OR_DMX_O_X, space_extension_x = DMX2OR_DMX_O_Y, space_extension_y = DMX2OR_DMX_O_X },
       { DM3_L, min_space_x = DMX2OR_DMX_Y, min_space_y = DMX2OR_DMX_X, space_extension_x = DMX2OR_DMX_Y, space_extension_y = DMX2OR_DMX_X },
#endif
    },
    shift = 2,
    repeat = 3,
    starting_point = CENTER
);
//=======================================================

#ifdef VERTICAL_M3
PATTERN_SPEC_DM3_SHAPE_OR_0.adjustable_fill.layer_spec.fill_to_fill_spacing = {
    allowed_spacing_x = { == 0.02, == 0.062, >= 0.083  },
    allowed_spacing_y = { >= DMX2OR_SY },
    corner_extension_x = DMX2OR_SX_SC,
    corner_extension_y = DMX2OR_SY_SC,
    extension = INTERSECTION,
};
#else
PATTERN_SPEC_DM3_SHAPE_OR_0.adjustable_fill.layer_spec.fill_to_fill_spacing = {
    allowed_spacing_y = { == 0.02, == 0.062, >= 0.083  },
    allowed_spacing_x = { >= DMX2OR_SY },
    corner_extension_x = DMX2OR_SY_SC,
    corner_extension_y = DMX2OR_SX_SC,
    extension = INTERSECTION,
};
#endif


PATTERN_SPEC_DM3_SHAPE_OR_1 = get_single_adjustable_pattern(
    adj_type = SHRINK,
#ifdef VERTICAL_M3
    min_bound = { DMX2OR_W, DMX2OR_L },
    max_bound = { DMX2OR_W, DMX2OR_L_MAX },
#else
    min_bound = { DMX2OR_L, DMX2OR_W },
    max_bound = { DMX2OR_L_MAX, DMX2OR_W },
#endif
    color = false,
#ifdef VERTICAL_M3
    cell_prefix = "WDM3V", output = "OUTPUT_DM3_OR",
    spacing = { 0.020, DMX2OR_SY },
#else
    cell_prefix = "WDM3H", output = "OUTPUT_DM3_OR",
    spacing = { DMX2OR_SY, 0.020 },
#endif

    FSS = {
// DUMMY SPEC : DM3_shape_OR       
#ifdef VERTICAL_M3
    { M3_MAIN_LE, min_space_y = 0.06, space_extension_x = 0.06, projection = CORNER },
#else
    { M3_MAIN_LE, min_space_x = 0.06, space_extension_y = 0.06, projection = CORNER },
#endif
//=======================================================
    { CHIP_snps, min_space = 0, context = INTERIOR }, //RD CONFIRM
#ifdef FULL_CHIP
    { CHIP_BOUNDARY, min_space = 0, context = INTERIOR }, //RD CONFIRM
    { CHIP_FILLREGION_X2, min_space = 0, context = INTERIOR },
#else
    { PRBOUNDARY, min_space_x = DMX2O_CHIPR, min_space_y = DMX2O_CHIPE, context = INTERIOR },
#endif
    { MX2FORBIDDEN_CHIPMV, min_space = 0 },
    { BEOLBLK_FINAL, min_space_x = DMX2_BEOLBLKR, min_space_y = DMX2_BEOLBLKE, space_extension_x = DMX2_BEOLBLKR, space_extension_y = DMX2_BEOLBLKE }, 
    { DM3EXCL_FINAL, min_space_x = DMX2_DMXEXCLR, min_space_y = DMX2_DMXEXCLE, space_extension_x = DMX2_DMXEXCLR, space_extension_y = DMX2_DMXEXCLE }, 
    { CSR66_3485, min_space_x = DMX2_BEOLBLKR, min_space_y = DMX2_BEOLBLKE, space_extension_x = DMX2_BEOLBLKR, space_extension_y = DMX2_BEOLBLKE },
    { INDDMY, min_space = DM_INDDMY },
    { TCDDMY_M3, min_space = DMX2_TCDDMY_MX },
    { M3_HOLE, min_space = 0 },
    { M3_45, min_space = 0 },
    { ICOVL_SINGLE, min_space = DMX2_ICOVL },
#ifdef VERTICAL_M3
    { M3_MAIN, min_space_x = DMX2OR_SC_MXX, min_space_y = DMX2OR_SC_MXY, space_extension_x = DMX2OR_SC_MXX, space_extension_y = DMX2OR_SC_MXY },
#else
    { M3_MAIN, min_space_x = DMX2OR_SC_MXY, min_space_y = DMX2OR_SC_MXX, space_extension_x = DMX2OR_SC_MXY, space_extension_y = DMX2OR_SC_MXX },
#endif
#ifdef VERTICAL_M3
    { DM3_O, min_space_x = DMX2OR_DMX_O_X, min_space_y = DMX2OR_DMX_O_Y, space_extension_x = DMX2OR_DMX_O_X, space_extension_y = DMX2OR_DMX_O_Y },
    { DM3, min_space_x = DMX2OR_DMX_X, min_space_y = DMX2OR_DMX_Y, space_extension_x = DMX2OR_DMX_X, space_extension_y = DMX2OR_DMX_Y },
#else
    { DM3_O, min_space_x = DMX2OR_DMX_O_Y, min_space_y = DMX2OR_DMX_O_X, space_extension_x = DMX2OR_DMX_O_Y, space_extension_y = DMX2OR_DMX_O_X },
    { DM3, min_space_x = DMX2OR_DMX_Y, min_space_y = DMX2OR_DMX_X, space_extension_x = DMX2OR_DMX_Y, space_extension_y = DMX2OR_DMX_X },
#endif
    { VIA2, min_space = 0.06 },
#ifdef VERTICAL_M3
    { M3_HVN_096V, min_space_x = DMX2_MX096V, min_space_y = DMX2OR_SC_MXY, space_extension_x = DMX2_MX096V, space_extension_y = DMX2OR_SC_MXY },
    { M3_HVN_132V, min_space_x = DMX2_MX132V, min_space_y = DMX2OR_SC_MXY, space_extension_x = DMX2_MX132V, space_extension_y = DMX2OR_SC_MXY },
    { M3_HVN_165V, min_space_x = DMX2_MX165V, min_space_y = DMX2OR_SC_MXY, space_extension_x = DMX2_MX165V, space_extension_y = DMX2OR_SC_MXY },
    { M3_HVN_198V, min_space_x = DMX2_MX198V, min_space_y = DMX2OR_SC_MXY, space_extension_x = DMX2_MX198V, space_extension_y = DMX2OR_SC_MXY },
    { M3_HVN_275V, min_space_x = DMX2_MX275V, min_space_y = DMX2OR_SC_MXY, space_extension_x = DMX2_MX275V, space_extension_y = DMX2OR_SC_MXY },
#else
    { M3_HVN_096V, min_space_x = DMX2OR_SC_MXY, min_space_y = DMX2_MX096V, space_extension_x = DMX2OR_SC_MXY, space_extension_y = DMX2_MX096V },
    { M3_HVN_132V, min_space_x = DMX2OR_SC_MXY, min_space_y = DMX2_MX132V, space_extension_x = DMX2OR_SC_MXY, space_extension_y = DMX2_MX132V },
    { M3_HVN_165V, min_space_x = DMX2OR_SC_MXY, min_space_y = DMX2_MX165V, space_extension_x = DMX2OR_SC_MXY, space_extension_y = DMX2_MX165V },
    { M3_HVN_198V, min_space_x = DMX2OR_SC_MXY, min_space_y = DMX2_MX198V, space_extension_x = DMX2OR_SC_MXY, space_extension_y = DMX2_MX198V },
    { M3_HVN_275V, min_space_x = DMX2OR_SC_MXY, min_space_y = DMX2_MX275V, space_extension_x = DMX2OR_SC_MXY, space_extension_y = DMX2_MX275V },
#endif
    { VIA2_HVN_096V, min_space = DMX2_VX096V },
    { VIA2_HVN_132V, min_space = DMX2_VX132V },
    { VIA2_HVN_165V, min_space = DMX2_VX165V },
    { VIA2_HVN_198V, min_space = DMX2_VX198V },
    { VIA2_HVN_275V, min_space = DMX2_VX275V },
    { VIA3_HVN_096V, min_space = DMX2_VX096V },
    { VIA3_HVN_132V, min_space = DMX2_VX132V },
    { VIA3_HVN_165V, min_space = DMX2_VX165V },
    { VIA3_HVN_198V, min_space = DMX2_VX198V },
    { VIA3_HVN_275V, min_space = DMX2_VX275V },


//**** corner space for voltage pattern
              { M3_HVN_096V, min_space_x = 0.09, space_extension_y = 0.042, projection = CORNER },
              { M3_HVN_198V, min_space_x = 0.09, space_extension_y = 0.061, projection = CORNER },
              { M3_HVN_096V, min_space_y = 0.09, space_extension_x = 0.042, projection = CORNER },
              { M3_HVN_198V, min_space_y = 0.09, space_extension_x = 0.061, projection = CORNER },
//**** end corner check
#ifdef FILL_M2_VIA2_M3_BTCD
              { BTCD_M2_V2_M3_E, min_space = BTCD_DX2 },
#endif
#ifdef FILL_M3_VIA3_M4_BTCD
              { BTCD_M3_V3_M4_E, min_space = BTCD_DX2 },
#endif

#ifdef FILL_M3_BTCD2
              { BTCD_M3_E, min_space = BTCD_DX2 },
#endif
#ifdef VERTICAL_M3
       { WRAPPER_DM3_O_L, min_space_x = DMX2OR_DMX_O_X, min_space_y = DMX2OR_DMX_O_Y, space_extension_x = DMX2OR_DMX_O_X, space_extension_y = DMX2OR_DMX_O_Y },
       { DM3_L, min_space_x = DMX2OR_DMX_X, min_space_y = DMX2OR_DMX_Y, space_extension_x = DMX2OR_DMX_X, space_extension_y = DMX2OR_DMX_Y },
#else
       { WRAPPER_DM3_O_L, min_space_x = DMX2OR_DMX_O_Y, min_space_y = DMX2OR_DMX_O_X, space_extension_x = DMX2OR_DMX_O_Y, space_extension_y = DMX2OR_DMX_O_X },
       { DM3_L, min_space_x = DMX2OR_DMX_Y, min_space_y = DMX2OR_DMX_X, space_extension_x = DMX2OR_DMX_Y, space_extension_y = DMX2OR_DMX_X },
#endif
    },
    shift = 2,
    repeat = 3,
    starting_point = CENTER
);

 
#ifdef VERTICAL_M3
PATTERN_SPEC_DM3_SHAPE_OR_1.adjustable_fill.layer_spec.fill_to_fill_spacing = {
    allowed_spacing_x = { == 0.02, == 0.062, >= 0.083  },
    allowed_spacing_y = { >= DMX2OR_SY },
    corner_extension_x = DMX2OR_SX_SC,
    corner_extension_y = DMX2OR_SY_SC,
    extension = INTERSECTION,
};
#else
PATTERN_SPEC_DM3_SHAPE_OR_1.adjustable_fill.layer_spec.fill_to_fill_spacing = {
    allowed_spacing_y = { == 0.02, == 0.062, >= 0.083  },
    allowed_spacing_x = { >= DMX2OR_SY },
    corner_extension_x = DMX2OR_SY_SC,
    corner_extension_y = DMX2OR_SX_SC,
    extension = INTERSECTION,
};
#endif

PATTERN_SPEC_DM3_SHAPE_OR_2 = PATTERN_SPEC_DM3_SHAPE_OR_1;

PATTERN_SPEC_DM3_SHAPE_OR_0.adjustable_fill.pattern_spec.other_pattern_spacing = {
    1 => > DMX2OR_DMX_O_X,
    2 => > DMX2OR_DMX_O_X,
};

PATTERN_SPEC_DM3_SHAPE_OR_1.adjustable_fill.pattern_spec.other_pattern_spacing = {
    0 => > DMX2OR_DMX_O_X,
    2 => > DMX2OR_DMX_O_X,
};

PATTERN_SPEC_DM3_SHAPE_OR_2.adjustable_fill.pattern_spec.other_pattern_spacing = {
    0 => > DMX2OR_DMX_O_X,
    1 => > DMX2OR_DMX_O_X,
};




SPEC_DM3_OR = unified_fill(
	fill_patterns = {
        PATTERN_SPEC_DM3_SHAPE_OR_0,
        PATTERN_SPEC_DM3_SHAPE_OR_1,
        PATTERN_SPEC_DM3_SHAPE_OR_2,
    },
	fill_boundary = {
	    layer = CHIP_snps,
	    type = LAYER,
	},
    boundary = ALIGN,
	grid = vGRID
);


DM3_O_C     = SPEC_DM3_OR["OUTPUT_DM3_OR"][0];
DM3_O_L     = SPEC_DM3_OR["OUTPUT_DM3_OR"][0];

//=======================================================
// DUMMY SPEC : DM3_shape_OW_x2
FSS_SPEC_DM3_SHAPE_OW : list of fill_to_signal_spacing_s = {
    { M3_MAIN_LE, min_space_y = 0.06, space_extension_x = 0.06, projection = CORNER },
    { M3_MAIN_LE, min_space_x = 0.06, space_extension_y = 0.06, projection = CORNER },

#ifdef VERTICAL_M3
    { M3_096V_OE, min_space_y = 0.09, space_extension_x = 0.042, projection = CORNER }, 
#else
    { M3_096V_OE, min_space_x = 0.09, space_extension_y = 0.042, projection = CORNER }, 
#endif
#ifdef VERTICAL_M3
    { M3_096V_OE, min_space_y = 0.042, space_extension_x = 0.09, projection = CORNER }, 
#else
    { M3_096V_OE, min_space_x = 0.042, space_extension_y = 0.09, projection = CORNER }, 
#endif

#ifdef VERTICAL_M3
    { M3_198V_OE, min_space_y = 0.09, space_extension_x = 0.061, projection = CORNER },
#else
    { M3_198V_OE, min_space_x = 0.09, space_extension_y = 0.061, projection = CORNER }, 
#endif
#ifdef VERTICAL_M3
    { M3_198V_OE, min_space_y = 0.061, space_extension_x = 0.09, projection = CORNER },
#else
    { M3_198V_OE, min_space_x = 0.061, space_extension_y = 0.09, projection = CORNER }, 
#endif
//=======================================================
// DUMMY SPEC : DM3_OW_x2
    { CHIP_snps, min_space = 0, context = INTERIOR }, //RD CONFIRM
#ifdef FULL_CHIP
    { CHIP_BOUNDARY, min_space = 0, context = INTERIOR }, //RD CONFIRM
    { CHIP_FILLREGION_X2, min_space = 0, context = INTERIOR },
#else
    { PRBOUNDARY, min_space_x = DMX2O_CHIPR, min_space_y = DMX2O_CHIPE, context = INTERIOR },
#endif
    { MX2FORBIDDEN_CHIPMV, min_space = 0 },
    { BEOLBLK_FINAL, min_space_x = DMX2_BEOLBLKR, min_space_y = DMX2_BEOLBLKE, space_extension_x = DMX2_BEOLBLKR, space_extension_y = DMX2_BEOLBLKE }, 
    { DM3EXCL_FINAL, min_space_x = DMX2_DMXEXCLR, min_space_y = DMX2_DMXEXCLE, space_extension_x = DMX2_DMXEXCLR, space_extension_y = DMX2_DMXEXCLE }, 
    { CSR66_3485, min_space_x = DMX2_BEOLBLKR, min_space_y = DMX2_BEOLBLKE, space_extension_x = DMX2_BEOLBLKR, space_extension_y = DMX2_BEOLBLKE },
    { INDDMY, min_space = DM_INDDMY },
    { TCDDMY_M3, min_space = DMX2_TCDDMY_MX },
    { M3_HOLE, min_space = 0 },
    { M3_45, min_space = 0 },
    { ICOVL_SINGLE, min_space = DMX2_ICOVL },
#ifdef VERTICAL_M3
    { M3_MAIN, min_space_x = DMX2OW_SC_MXX, min_space_y = DMX2OW_SC_MXY, space_extension_x = DMX2OW_SC_MXX, space_extension_y = DMX2OW_SC_MXY },
#else
    { M3_MAIN, min_space_x = DMX2OW_SC_MXY, min_space_y = DMX2OW_SC_MXX, space_extension_x = DMX2OW_SC_MXY, space_extension_y = DMX2OW_SC_MXX },
#endif
#ifdef VERTICAL_M3
    { DM3_O, min_space_x = DMX2OW_DMX_O_X, min_space_y = DMX2OW_DMX_O_Y, space_extension_x = DMX2OW_DMX_O_X, space_extension_y = DMX2OW_DMX_O_Y },
#else
    { DM3_O, min_space_x = DMX2OW_DMX_O_Y, min_space_y = DMX2OW_DMX_O_X, space_extension_x = DMX2OW_DMX_O_Y, space_extension_y = DMX2OW_DMX_O_X },
#endif
    { DM3, min_space = DMX2OW_DMX },
    { VIA2, min_space = 0.06 },
#ifdef VERTICAL_M3
    { M3_HVN_096V, min_space_x = DMX2_MX096V, min_space_y = DMX2OR_SC_MXY, space_extension_x = DMX2_MX096V, space_extension_y = DMX2OR_SC_MXY },
    { M3_HVN_132V, min_space_x = DMX2_MX132V, min_space_y = DMX2OR_SC_MXY, space_extension_x = DMX2_MX132V, space_extension_y = DMX2OR_SC_MXY },
    { M3_HVN_165V, min_space_x = DMX2_MX165V, min_space_y = DMX2OR_SC_MXY, space_extension_x = DMX2_MX165V, space_extension_y = DMX2OR_SC_MXY },
    { M3_HVN_198V, min_space_x = DMX2_MX198V, min_space_y = DMX2OR_SC_MXY, space_extension_x = DMX2_MX198V, space_extension_y = DMX2OR_SC_MXY },
    { M3_HVN_275V, min_space_x = DMX2_MX275V, min_space_y = DMX2OR_SC_MXY, space_extension_x = DMX2_MX275V, space_extension_y = DMX2OR_SC_MXY },
#else
    { M3_HVN_096V, min_space_x = DMX2OR_SC_MXY, min_space_y = DMX2_MX096V, space_extension_x = DMX2OR_SC_MXY, space_extension_y = DMX2_MX096V },
    { M3_HVN_132V, min_space_x = DMX2OR_SC_MXY, min_space_y = DMX2_MX132V, space_extension_x = DMX2OR_SC_MXY, space_extension_y = DMX2_MX132V },
    { M3_HVN_165V, min_space_x = DMX2OR_SC_MXY, min_space_y = DMX2_MX165V, space_extension_x = DMX2OR_SC_MXY, space_extension_y = DMX2_MX165V },
    { M3_HVN_198V, min_space_x = DMX2OR_SC_MXY, min_space_y = DMX2_MX198V, space_extension_x = DMX2OR_SC_MXY, space_extension_y = DMX2_MX198V },
    { M3_HVN_275V, min_space_x = DMX2OR_SC_MXY, min_space_y = DMX2_MX275V, space_extension_x = DMX2OR_SC_MXY, space_extension_y = DMX2_MX275V },
#endif
    { VIA2_HVN_096V, min_space = DMX2_VX096V },
    { VIA2_HVN_132V, min_space = DMX2_VX132V },
    { VIA2_HVN_165V, min_space = DMX2_VX165V },
    { VIA2_HVN_198V, min_space = DMX2_VX198V },
    { VIA2_HVN_275V, min_space = DMX2_VX275V },
    { VIA3_HVN_096V, min_space = DMX2_VX096V },
    { VIA3_HVN_132V, min_space = DMX2_VX132V },
    { VIA3_HVN_165V, min_space = DMX2_VX165V },
    { VIA3_HVN_198V, min_space = DMX2_VX198V },
    { VIA3_HVN_275V, min_space = DMX2_VX275V },

#ifdef VERTICAL_M3
              { M3_GROUP_W48_20, min_space_x = 0.087, min_space_y = 0.070, space_extension_x = 0.087, space_extension_y = 0.070 },
#else
              { M3_GROUP_W48_20, min_space_x = 0.070, min_space_y = 0.087, space_extension_x = 0.070, space_extension_y = 0.087 },
#endif


#ifdef FILL_M2_VIA2_M3_BTCD
              { BTCD_M2_V2_M3_E, min_space = BTCD_DX2 },
#endif
#ifdef FILL_M3_VIA3_M4_BTCD
              { BTCD_M3_V3_M4_E, min_space = BTCD_DX2 },
#endif

#ifdef FILL_M3_BTCD2
              { BTCD_M3_E, min_space = BTCD_DX2 },
#endif
//**** corner space for voltage pattern
//**** end corner check
#ifdef VERTICAL_M3
       { M3_LT22, min_space_x = DMX2OW_SC_LT22, min_space_y = DMX2OW_SC_MXY, space_extension_x = DMX2OW_SC_LT22, space_extension_y = DMX2OW_SC_MXY },
       { M3_GE22, min_space_x = DMX2OW_SC_MXX, min_space_y = DMX2OW_SC_MXY, space_extension_x = DMX2OW_SC_MXX, space_extension_y = DMX2OW_SC_MXY },
       { WRAPPER_DM3_O_L, min_space_x = DMX2OW_DMX_O_X, min_space_y = DMX2OW_DMX_O_Y, space_extension_x = DMX2OW_DMX_O_X, space_extension_y = DMX2OW_DMX_O_Y },
       { DM3_O_L, min_space_x = DMX2OW_DMX_O_X, min_space_y = DMX2OW_DMX_O_Y, space_extension_x = DMX2OW_DMX_O_X, space_extension_y = DMX2OW_DMX_O_Y },
#else
       { M3_LT22, min_space_x = DMX2OW_SC_MXY, min_space_y = DMX2OW_SC_LT22, space_extension_x = DMX2OW_SC_MXY, space_extension_y = DMX2OW_SC_LT22 },
       { M3_GE22, min_space_x = DMX2OW_SC_MXY, min_space_y = DMX2OW_SC_MXX, space_extension_x = DMX2OW_SC_MXY, space_extension_y = DMX2OW_SC_MXX },
       { WRAPPER_DM3_O_L, min_space_x = DMX2OW_DMX_O_Y, min_space_y = DMX2OW_DMX_O_X, space_extension_x = DMX2OW_DMX_O_Y, space_extension_y = DMX2OW_DMX_O_X },
       { DM3_O_L, min_space_x = DMX2OW_DMX_O_Y, min_space_y = DMX2OW_DMX_O_X, space_extension_x = DMX2OW_DMX_O_Y, space_extension_y = DMX2OW_DMX_O_X },
#endif
       { DM3_L, min_space = DMX2OW_DMX },

};
//=======================================================
PATTERN_SPEC_DM3_SHAPE_OW = get_single_adjustable_pattern(
    adj_type = SHRINK,
#ifdef VERTICAL_M3
    min_bound = { DMX2OW_W, DMX2OW_L },
    max_bound = { DMX2OW_W_MAX, DMX2OW_L },
#else
    min_bound = { DMX2OW_L, DMX2OW_W },
    max_bound = { DMX2OW_L, DMX2OW_W_MAX },
#endif
    color = false,
    color_scheme = UF_LINE_SIDE,
#ifdef VERTICAL_M3
    cell_prefix = "DMOW3V", output = "OUTPUT_DM3_OW",
    spacing = { DMX2OW_SX, DMX2OW_SY },
#else
    cell_prefix = "DMOW3H", output = "OUTPUT_DM3_OW",
    spacing = { DMX2OW_SY, DMX2OW_SX },
#endif
    FSS = FSS_SPEC_DM3_SHAPE_OW,
    shift = 2,
    repeat = 3,
    starting_point = CENTER
);

PATTERN_SPEC_DM3_SHAPE_OW_2 = get_single_adjustable_pattern(
    adj_type = SHRINK,
#ifdef VERTICAL_M3
    min_bound = { DMX2OW_W, DMX2OW_L },
    max_bound = { DMX2OW_W_MAX, DMX2OW_L },
#else
    min_bound = { DMX2OW_L, DMX2OW_W },
    max_bound = { DMX2OW_L, DMX2OW_W_MAX },
#endif
    color = false,
    color_scheme = UF_LINE_SIDE,
#ifdef VERTICAL_M3
    cell_prefix = "DMOW3V", output = "OUTPUT_DM3_OW",
    spacing = { DMX2OW_SX, DMX2OW_SY },
#else
    cell_prefix = "DMOW3H", output = "OUTPUT_DM3_OW",
    spacing = { DMX2OW_SY, DMX2OW_SX },
#endif
    FSS = FSS_SPEC_DM3_SHAPE_OW,
    shift = 2,
    repeat = 3,
    starting_point = CENTER
);


PATTERN_SPEC_DM3_SHAPE_OW.adjustable_fill.dpt_spacing = {
            dpt_space_x = 0.07,
            dpt_space_y = 0.07,
            dpt_space_extension = INTERSECTION,
};


PATTERN_SPEC_DM3_SHAPE_OW_2.adjustable_fill.dpt_spacing = {
            dpt_space_x = 0.07,
            dpt_space_y = 0.07,
            dpt_space_extension = INTERSECTION,
};
PATTERN_SPEC_DM3_SHAPE_OW.adjustable_fill.pattern_spec.other_pattern_spacing = {
    0 => >0.07,
    1 => >0.07,
};
PATTERN_SPEC_DM3_SHAPE_OW_2.adjustable_fill.pattern_spec.other_pattern_spacing = {
    0 => >0.07,
    1 => >0.07,
};

PATTERN_SPEC_DM3_SHAPE_OW.adjustable_fill.boundary_alignment = { inside = { CHIP_snps, {0.4, 0.4, 0.4, 0.4} }};


SPEC_DM3_OW = unified_fill(
	fill_patterns = {
        PATTERN_SPEC_DM3_SHAPE_OW,
        PATTERN_SPEC_DM3_SHAPE_OW_2,
    },
	fill_boundary = {
	    layer = CHIP_snps,
	    type = LAYER,
	},
    boundary = ALIGN,
	grid = vGRID
);

//***** fill *******************************************************************
DM3_OW_C   = SPEC_DM3_OW["OUTPUT_DM3_OW"][0];
DM3_OW_L   = SPEC_DM3_OW["OUTPUT_DM3_OW"][0];



DM3_OW_F = DM3_OW_C;

//=======================================================

#endif

#ifdef FILL_DM4





// DUMMY SPEC : DM4_x2

PATTERN_SPEC_DM4 = get_single_polygon_pattern(
#ifdef VERTICAL_M4
    cell_prefix = "DMB4V", output = "OUTPUT_DM4", width = DMX2B_W, height = DMX2B_L,
    step_x = DMX2B_SX, step_y = DMX2B_SY,
#else
    cell_prefix = "DMB4H", output = "OUTPUT_DM4", width = DMX2B_L, height = DMX2B_W,
    step_x = DMX2B_SY, step_y = DMX2B_SX,
#endif
    setback = DMX2B_DMX_Y,
    setback_type = INTERSECTION,
    FSS = {
    { CHIP_snps, min_space = DMX2_CHIP, context = INTERIOR },
#ifdef FULL_CHIP
    { CHIP_BOUNDARY, min_space = 0.07, context = INTERIOR },
#else
    { PRBOUNDARY, min_space = 4, context = INTERIOR },
#endif
    { CHIP_FILLREGION_X2, min_space = 0, context = INTERIOR },
    { M4_HOLE, min_space = 0 },
    { INDDMY, min_space = DM_INDDMY },
    { ICOVL_SINGLE, min_space = DMX2_ICOVL },
    { BEOLBLK_FINAL, min_space = DMX2B_MX },
    { DM4EXCL_FINAL, min_space = DMX2B_MX },
    { CSR66_3485, min_space = DMX2B_MX },
    { M4_MAIN, min_space = DMX2B_MX },
    { DM4_GE91, min_space = DMX2B_DMW91 },
#ifdef VERTICAL_M4
    { DM4_O, min_space_x = DMX2B_DMX_O_X, min_space_y = DMX2B_DMX_O_Y, space_extension_x = DMX2B_DMX_O_X, space_extension_y = DMX2B_DMX_O_Y },
    { DM4, min_space_x = DMX2B_DMX_X, min_space_y = DMX2B_DMX_Y, space_extension_x = DMX2B_DMX_X, space_extension_y = DMX2B_DMX_Y },
#else
    { DM4_O, min_space_x = DMX2B_DMX_O_Y, min_space_y = DMX2B_DMX_O_X, space_extension_x = DMX2B_DMX_O_Y, space_extension_y = DMX2B_DMX_O_X },
    { DM4, min_space_x = DMX2B_DMX_Y, min_space_y = DMX2B_DMX_X, space_extension_x = DMX2B_DMX_Y, space_extension_y = DMX2B_DMX_X },
#endif
    { TCDDMY_M4, min_space = BTCD_DX2 },
#ifdef FILL_M3_VIA3_M4_BTCD
              { BTCD_M3_V3_M4_E, min_space = BTCD_DX2B },
#endif
#ifdef FILL_M4_VIA4_M5_BTCD
              { BTCD_M4_V4_M5_E, min_space = BTCD_DX2B },
#endif

#ifdef FILL_M4_BTCD2
              { BTCD_M4_E, min_space = BTCD_DX2B },
#endif
#ifdef VERTICAL_M4
              { WRAPPER_DM4_O_L, min_space_x = DMX2B_DMX_O_X, min_space_y = DMX2B_DMX_O_Y, space_extension_x = DMX2B_DMX_O_X, space_extension_y = DMX2B_DMX_O_Y },
#else
              { WRAPPER_DM4_O_L, min_space_x = DMX2B_DMX_O_Y, min_space_y = DMX2B_DMX_O_X, space_extension_x = DMX2B_DMX_O_Y, space_extension_y = DMX2B_DMX_O_X },
#endif
    },
    repeat = 3,
    shift = 2,
    starting_point  = CENTER
);
//=======================================================


SPEC_DM4 = unified_fill( 
	fill_patterns = {
        PATTERN_SPEC_DM4
    },
	fill_boundary = {
	    layer = CHIP_snps,
	    type = LAYER,
	},
    boundary = ALIGN,
	grid = vGRID
);

DM4_C     = SPEC_DM4["OUTPUT_DM4"][0];
DM4_L     = SPEC_DM4["OUTPUT_DM4"][0];

//=======================================================



PATTERN_SPEC_DM4_SHAPE_OR_0 = get_single_adjustable_pattern(
    adj_type = SHRINK,
#ifdef VERTICAL_M4
    min_bound = { DMX2OR_W, DMX2OR_L },
    max_bound = { DMX2OR_W, DMX2OR_L_MAX_BOUND },
#else
    min_bound = { DMX2OR_L, DMX2OR_W },
    max_bound = { DMX2OR_L_MAX_BOUND, DMX2OR_W },
#endif
    color = false,
#ifdef VERTICAL_M4
    cell_prefix = "WDM4VC", output = "OUTPUT_DM4_OR",
    spacing = { 0.020, DMX2OR_SY },
#else
    cell_prefix = "WDM4HC", output = "OUTPUT_DM4_OR",
    spacing = { DMX2OR_SY, 0.020 },
#endif
    FSS = {
// DUMMY SPEC : DM4_shape_OR_bound
#ifdef VERTICAL_M4
    { M4_MAIN_LE, min_space_y = 0.06, space_extension_x = 0.06, projection = CORNER },
#else
    { M4_MAIN_LE, min_space_x = 0.06, space_extension_y = 0.06, projection = CORNER },
#endif
//=======================================================
// DUMMY SPEC : DM4_OR_x2
          { CHIP_BOUND_REG_M4, min_space = 0, context = INTERIOR },
    { CHIP_snps, min_space = 0, context = INTERIOR }, //RD CONFIRM
#ifdef FULL_CHIP
    { CHIP_BOUNDARY, min_space = 0, context = INTERIOR }, //RD CONFIRM
    { CHIP_FILLREGION_X2, min_space = 0, context = INTERIOR },
#else
    { PRBOUNDARY, min_space_x = DMX2O_CHIPE, min_space_y = DMX2O_CHIPR, context = INTERIOR },
#endif
    { MX2FORBIDDEN_CHIPMH, min_space = 0 },
    { BEOLBLK_FINAL, min_space_x = DMX2_BEOLBLKE, min_space_y = DMX2_BEOLBLKR, space_extension_x = DMX2_BEOLBLKE, space_extension_y = DMX2_BEOLBLKR }, 
    { DM4EXCL_FINAL, min_space_x = DMX2_DMXEXCLE, min_space_y = DMX2_DMXEXCLR, space_extension_x = DMX2_DMXEXCLE, space_extension_y = DMX2_DMXEXCLR },
    { CSR66_3485, min_space_x = DMX2_BEOLBLKE, min_space_y = DMX2_BEOLBLKR, space_extension_x = DMX2_BEOLBLKE, space_extension_y = DMX2_BEOLBLKR },
    { INDDMY, min_space = DM_INDDMY },
    { TCDDMY_M4, min_space = DMX2_TCDDMY_MX },
    { M4_HOLE, min_space = 0 },
    { M4_45, min_space = 0 },
    { ICOVL_SINGLE, min_space = DMX2_ICOVL },
#ifdef VERTICAL_M4
    { M4_MAIN, min_space_x = DMX2OR_SC_MXX, min_space_y = DMX2OR_SC_MXY, space_extension_x = DMX2OR_SC_MXX, space_extension_y = DMX2OR_SC_MXY },
#else
    { M4_MAIN, min_space_x = DMX2OR_SC_MXY, min_space_y = DMX2OR_SC_MXX, space_extension_x = DMX2OR_SC_MXY, space_extension_y = DMX2OR_SC_MXX },
#endif
#ifdef VERTICAL_M4
    { DM4_O, min_space_x = DMX2OR_DMX_O_X, min_space_y = DMX2OR_DMX_O_Y, space_extension_x = DMX2OR_DMX_O_X, space_extension_y = DMX2OR_DMX_O_Y },
    { DM4, min_space_x = DMX2OR_DMX_X, min_space_y = DMX2OR_DMX_Y, space_extension_x = DMX2OR_DMX_X, space_extension_y = DMX2OR_DMX_Y },
#else
    { DM4_O, min_space_x = DMX2OR_DMX_O_Y, min_space_y = DMX2OR_DMX_O_X, space_extension_x = DMX2OR_DMX_O_Y, space_extension_y = DMX2OR_DMX_O_X },
    { DM4, min_space_x = DMX2OR_DMX_Y, min_space_y = DMX2OR_DMX_X, space_extension_x = DMX2OR_DMX_Y, space_extension_y = DMX2OR_DMX_X },
#endif
    { VIA3, min_space = 0.06 },
#ifdef VERTICAL_M4
    { M4_HVN_096V, min_space_x = DMX2_MX096V, min_space_y = DMX2OR_SC_MXY, space_extension_x = DMX2_MX096V, space_extension_y = DMX2OR_SC_MXY },
    { M4_HVN_132V, min_space_x = DMX2_MX132V, min_space_y = DMX2OR_SC_MXY, space_extension_x = DMX2_MX132V, space_extension_y = DMX2OR_SC_MXY },
    { M4_HVN_165V, min_space_x = DMX2_MX165V, min_space_y = DMX2OR_SC_MXY, space_extension_x = DMX2_MX165V, space_extension_y = DMX2OR_SC_MXY },
    { M4_HVN_198V, min_space_x = DMX2_MX198V, min_space_y = DMX2OR_SC_MXY, space_extension_x = DMX2_MX198V, space_extension_y = DMX2OR_SC_MXY },
    { M4_HVN_275V, min_space_x = DMX2_MX275V, min_space_y = DMX2OR_SC_MXY, space_extension_x = DMX2_MX275V, space_extension_y = DMX2OR_SC_MXY },
#else
    { M4_HVN_096V, min_space_x = DMX2OR_SC_MXY, min_space_y = DMX2_MX096V, space_extension_x = DMX2OR_SC_MXY, space_extension_y = DMX2_MX096V },
    { M4_HVN_132V, min_space_x = DMX2OR_SC_MXY, min_space_y = DMX2_MX132V, space_extension_x = DMX2OR_SC_MXY, space_extension_y = DMX2_MX132V },
    { M4_HVN_165V, min_space_x = DMX2OR_SC_MXY, min_space_y = DMX2_MX165V, space_extension_x = DMX2OR_SC_MXY, space_extension_y = DMX2_MX165V },
    { M4_HVN_198V, min_space_x = DMX2OR_SC_MXY, min_space_y = DMX2_MX198V, space_extension_x = DMX2OR_SC_MXY, space_extension_y = DMX2_MX198V },
    { M4_HVN_275V, min_space_x = DMX2OR_SC_MXY, min_space_y = DMX2_MX275V, space_extension_x = DMX2OR_SC_MXY, space_extension_y = DMX2_MX275V },
#endif
    { VIA3_HVN_096V, min_space = DMX2_VX096V },
    { VIA3_HVN_132V, min_space = DMX2_VX132V },
    { VIA3_HVN_165V, min_space = DMX2_VX165V },
    { VIA3_HVN_198V, min_space = DMX2_VX198V },
    { VIA3_HVN_275V, min_space = DMX2_VX275V },
    { VIA4_HVN_096V, min_space = DMX2_VX096V },
    { VIA4_HVN_132V, min_space = DMX2_VX132V },
    { VIA4_HVN_165V, min_space = DMX2_VX165V },
    { VIA4_HVN_198V, min_space = DMX2_VX198V },
    { VIA4_HVN_275V, min_space = DMX2_VX275V },

         
        
//**** corner space for voltage pattern
              { M4_HVN_096V, min_space_x = 0.09, space_extension_y = 0.042, projection = CORNER },
              { M4_HVN_198V, min_space_x = 0.09, space_extension_y = 0.061, projection = CORNER },
              { M4_HVN_096V, min_space_y = 0.09, space_extension_x = 0.042, projection = CORNER },
              { M4_HVN_198V, min_space_y = 0.09, space_extension_x = 0.061, projection = CORNER },
//**** end corner check
#ifdef FILL_M3_VIA3_M4_BTCD
              { BTCD_M3_V3_M4_E, min_space = BTCD_DX2 },
#endif
#ifdef FILL_M4_VIA4_M5_BTCD
              { BTCD_M4_V4_M5_E, min_space = BTCD_DX2 },
#endif

#ifdef FILL_M4_BTCD2
              { BTCD_M4_E, min_space = BTCD_DX2 },
#endif
#ifdef VERTICAL_M4
       { WRAPPER_DM4_O_L, min_space_x = DMX2OR_DMX_O_X, min_space_y = DMX2OR_DMX_O_Y, space_extension_x = DMX2OR_DMX_O_X, space_extension_y = DMX2OR_DMX_O_Y },
       { DM4_L, min_space_x = DMX2OR_DMX_X, min_space_y = DMX2OR_DMX_Y, space_extension_x = DMX2OR_DMX_X, space_extension_y = DMX2OR_DMX_Y },
#else
       { WRAPPER_DM4_O_L, min_space_x = DMX2OR_DMX_O_Y, min_space_y = DMX2OR_DMX_O_X, space_extension_x = DMX2OR_DMX_O_Y, space_extension_y = DMX2OR_DMX_O_X },
       { DM4_L, min_space_x = DMX2OR_DMX_Y, min_space_y = DMX2OR_DMX_X, space_extension_x = DMX2OR_DMX_Y, space_extension_y = DMX2OR_DMX_X },
#endif
    },
    shift = 2,
    repeat = 3,
    starting_point = CENTER
);
//=======================================================

#ifdef VERTICAL_M4
PATTERN_SPEC_DM4_SHAPE_OR_0.adjustable_fill.layer_spec.fill_to_fill_spacing = {
    allowed_spacing_x = { == 0.02, == 0.062, >= 0.083  },
    allowed_spacing_y = { >= DMX2OR_SY },
    corner_extension_x = DMX2OR_SX_SC,
    corner_extension_y = DMX2OR_SY_SC,
    extension = INTERSECTION,
};
#else
PATTERN_SPEC_DM4_SHAPE_OR_0.adjustable_fill.layer_spec.fill_to_fill_spacing = {
    allowed_spacing_y = { == 0.02, == 0.062, >= 0.083  },
    allowed_spacing_x = { >= DMX2OR_SY },
    corner_extension_x = DMX2OR_SY_SC,
    corner_extension_y = DMX2OR_SX_SC,
    extension = INTERSECTION,
};
#endif


PATTERN_SPEC_DM4_SHAPE_OR_1 = get_single_adjustable_pattern(
    adj_type = SHRINK,
#ifdef VERTICAL_M4
    min_bound = { DMX2OR_W, DMX2OR_L },
    max_bound = { DMX2OR_W, DMX2OR_L_MAX },
#else
    min_bound = { DMX2OR_L, DMX2OR_W },
    max_bound = { DMX2OR_L_MAX, DMX2OR_W },
#endif
    color = false,
#ifdef VERTICAL_M4
    cell_prefix = "WDM4V", output = "OUTPUT_DM4_OR",
    spacing = { 0.020, DMX2OR_SY },
#else
    cell_prefix = "WDM4H", output = "OUTPUT_DM4_OR",
    spacing = { DMX2OR_SY, 0.020 },
#endif

    FSS = {
// DUMMY SPEC : DM4_shape_OR       
#ifdef VERTICAL_M4
    { M4_MAIN_LE, min_space_y = 0.06, space_extension_x = 0.06, projection = CORNER },
#else
    { M4_MAIN_LE, min_space_x = 0.06, space_extension_y = 0.06, projection = CORNER },
#endif
//=======================================================
    { CHIP_snps, min_space = 0, context = INTERIOR }, //RD CONFIRM
#ifdef FULL_CHIP
    { CHIP_BOUNDARY, min_space = 0, context = INTERIOR }, //RD CONFIRM
    { CHIP_FILLREGION_X2, min_space = 0, context = INTERIOR },
#else
    { PRBOUNDARY, min_space_x = DMX2O_CHIPE, min_space_y = DMX2O_CHIPR, context = INTERIOR },
#endif
    { MX2FORBIDDEN_CHIPMH, min_space = 0 },
    { BEOLBLK_FINAL, min_space_x = DMX2_BEOLBLKE, min_space_y = DMX2_BEOLBLKR, space_extension_x = DMX2_BEOLBLKE, space_extension_y = DMX2_BEOLBLKR }, 
    { DM4EXCL_FINAL, min_space_x = DMX2_DMXEXCLE, min_space_y = DMX2_DMXEXCLR, space_extension_x = DMX2_DMXEXCLE, space_extension_y = DMX2_DMXEXCLR },
    { CSR66_3485, min_space_x = DMX2_BEOLBLKE, min_space_y = DMX2_BEOLBLKR, space_extension_x = DMX2_BEOLBLKE, space_extension_y = DMX2_BEOLBLKR },
    { INDDMY, min_space = DM_INDDMY },
    { TCDDMY_M4, min_space = DMX2_TCDDMY_MX },
    { M4_HOLE, min_space = 0 },
    { M4_45, min_space = 0 },
    { ICOVL_SINGLE, min_space = DMX2_ICOVL },
#ifdef VERTICAL_M4
    { M4_MAIN, min_space_x = DMX2OR_SC_MXX, min_space_y = DMX2OR_SC_MXY, space_extension_x = DMX2OR_SC_MXX, space_extension_y = DMX2OR_SC_MXY },
#else
    { M4_MAIN, min_space_x = DMX2OR_SC_MXY, min_space_y = DMX2OR_SC_MXX, space_extension_x = DMX2OR_SC_MXY, space_extension_y = DMX2OR_SC_MXX },
#endif
#ifdef VERTICAL_M4
    { DM4_O, min_space_x = DMX2OR_DMX_O_X, min_space_y = DMX2OR_DMX_O_Y, space_extension_x = DMX2OR_DMX_O_X, space_extension_y = DMX2OR_DMX_O_Y },
    { DM4, min_space_x = DMX2OR_DMX_X, min_space_y = DMX2OR_DMX_Y, space_extension_x = DMX2OR_DMX_X, space_extension_y = DMX2OR_DMX_Y },
#else
    { DM4_O, min_space_x = DMX2OR_DMX_O_Y, min_space_y = DMX2OR_DMX_O_X, space_extension_x = DMX2OR_DMX_O_Y, space_extension_y = DMX2OR_DMX_O_X },
    { DM4, min_space_x = DMX2OR_DMX_Y, min_space_y = DMX2OR_DMX_X, space_extension_x = DMX2OR_DMX_Y, space_extension_y = DMX2OR_DMX_X },
#endif
    { VIA3, min_space = 0.06 },
#ifdef VERTICAL_M4
    { M4_HVN_096V, min_space_x = DMX2_MX096V, min_space_y = DMX2OR_SC_MXY, space_extension_x = DMX2_MX096V, space_extension_y = DMX2OR_SC_MXY },
    { M4_HVN_132V, min_space_x = DMX2_MX132V, min_space_y = DMX2OR_SC_MXY, space_extension_x = DMX2_MX132V, space_extension_y = DMX2OR_SC_MXY },
    { M4_HVN_165V, min_space_x = DMX2_MX165V, min_space_y = DMX2OR_SC_MXY, space_extension_x = DMX2_MX165V, space_extension_y = DMX2OR_SC_MXY },
    { M4_HVN_198V, min_space_x = DMX2_MX198V, min_space_y = DMX2OR_SC_MXY, space_extension_x = DMX2_MX198V, space_extension_y = DMX2OR_SC_MXY },
    { M4_HVN_275V, min_space_x = DMX2_MX275V, min_space_y = DMX2OR_SC_MXY, space_extension_x = DMX2_MX275V, space_extension_y = DMX2OR_SC_MXY },
#else
    { M4_HVN_096V, min_space_x = DMX2OR_SC_MXY, min_space_y = DMX2_MX096V, space_extension_x = DMX2OR_SC_MXY, space_extension_y = DMX2_MX096V },
    { M4_HVN_132V, min_space_x = DMX2OR_SC_MXY, min_space_y = DMX2_MX132V, space_extension_x = DMX2OR_SC_MXY, space_extension_y = DMX2_MX132V },
    { M4_HVN_165V, min_space_x = DMX2OR_SC_MXY, min_space_y = DMX2_MX165V, space_extension_x = DMX2OR_SC_MXY, space_extension_y = DMX2_MX165V },
    { M4_HVN_198V, min_space_x = DMX2OR_SC_MXY, min_space_y = DMX2_MX198V, space_extension_x = DMX2OR_SC_MXY, space_extension_y = DMX2_MX198V },
    { M4_HVN_275V, min_space_x = DMX2OR_SC_MXY, min_space_y = DMX2_MX275V, space_extension_x = DMX2OR_SC_MXY, space_extension_y = DMX2_MX275V },
#endif
    { VIA3_HVN_096V, min_space = DMX2_VX096V },
    { VIA3_HVN_132V, min_space = DMX2_VX132V },
    { VIA3_HVN_165V, min_space = DMX2_VX165V },
    { VIA3_HVN_198V, min_space = DMX2_VX198V },
    { VIA3_HVN_275V, min_space = DMX2_VX275V },
    { VIA4_HVN_096V, min_space = DMX2_VX096V },
    { VIA4_HVN_132V, min_space = DMX2_VX132V },
    { VIA4_HVN_165V, min_space = DMX2_VX165V },
    { VIA4_HVN_198V, min_space = DMX2_VX198V },
    { VIA4_HVN_275V, min_space = DMX2_VX275V },


//**** corner space for voltage pattern
              { M4_HVN_096V, min_space_x = 0.09, space_extension_y = 0.042, projection = CORNER },
              { M4_HVN_198V, min_space_x = 0.09, space_extension_y = 0.061, projection = CORNER },
              { M4_HVN_096V, min_space_y = 0.09, space_extension_x = 0.042, projection = CORNER },
              { M4_HVN_198V, min_space_y = 0.09, space_extension_x = 0.061, projection = CORNER },
//**** end corner check
#ifdef FILL_M3_VIA3_M4_BTCD
              { BTCD_M3_V3_M4_E, min_space = BTCD_DX2 },
#endif
#ifdef FILL_M4_VIA4_M5_BTCD
              { BTCD_M4_V4_M5_E, min_space = BTCD_DX2 },
#endif

#ifdef FILL_M4_BTCD2
              { BTCD_M4_E, min_space = BTCD_DX2 },
#endif
#ifdef VERTICAL_M4
       { WRAPPER_DM4_O_L, min_space_x = DMX2OR_DMX_O_X, min_space_y = DMX2OR_DMX_O_Y, space_extension_x = DMX2OR_DMX_O_X, space_extension_y = DMX2OR_DMX_O_Y },
       { DM4_L, min_space_x = DMX2OR_DMX_X, min_space_y = DMX2OR_DMX_Y, space_extension_x = DMX2OR_DMX_X, space_extension_y = DMX2OR_DMX_Y },
#else
       { WRAPPER_DM4_O_L, min_space_x = DMX2OR_DMX_O_Y, min_space_y = DMX2OR_DMX_O_X, space_extension_x = DMX2OR_DMX_O_Y, space_extension_y = DMX2OR_DMX_O_X },
       { DM4_L, min_space_x = DMX2OR_DMX_Y, min_space_y = DMX2OR_DMX_X, space_extension_x = DMX2OR_DMX_Y, space_extension_y = DMX2OR_DMX_X },
#endif
    },
    shift = 2,
    repeat = 3,
    starting_point = CENTER
);

 
#ifdef VERTICAL_M4
PATTERN_SPEC_DM4_SHAPE_OR_1.adjustable_fill.layer_spec.fill_to_fill_spacing = {
    allowed_spacing_x = { == 0.02, == 0.062, >= 0.083  },
    allowed_spacing_y = { >= DMX2OR_SY },
    corner_extension_x = DMX2OR_SX_SC,
    corner_extension_y = DMX2OR_SY_SC,
    extension = INTERSECTION,
};
#else
PATTERN_SPEC_DM4_SHAPE_OR_1.adjustable_fill.layer_spec.fill_to_fill_spacing = {
    allowed_spacing_y = { == 0.02, == 0.062, >= 0.083  },
    allowed_spacing_x = { >= DMX2OR_SY },
    corner_extension_x = DMX2OR_SY_SC,
    corner_extension_y = DMX2OR_SX_SC,
    extension = INTERSECTION,
};
#endif

PATTERN_SPEC_DM4_SHAPE_OR_2 = PATTERN_SPEC_DM4_SHAPE_OR_1;

PATTERN_SPEC_DM4_SHAPE_OR_0.adjustable_fill.pattern_spec.other_pattern_spacing = {
    1 => > DMX2OR_DMX_O_X,
    2 => > DMX2OR_DMX_O_X,
};

PATTERN_SPEC_DM4_SHAPE_OR_1.adjustable_fill.pattern_spec.other_pattern_spacing = {
    0 => > DMX2OR_DMX_O_X,
    2 => > DMX2OR_DMX_O_X,
};

PATTERN_SPEC_DM4_SHAPE_OR_2.adjustable_fill.pattern_spec.other_pattern_spacing = {
    0 => > DMX2OR_DMX_O_X,
    1 => > DMX2OR_DMX_O_X,
};




SPEC_DM4_OR = unified_fill(
	fill_patterns = {
        PATTERN_SPEC_DM4_SHAPE_OR_0,
        PATTERN_SPEC_DM4_SHAPE_OR_1,
        PATTERN_SPEC_DM4_SHAPE_OR_2,
    },
	fill_boundary = {
	    layer = CHIP_snps,
	    type = LAYER,
	},
    boundary = ALIGN,
	grid = vGRID
);


DM4_O_C     = SPEC_DM4_OR["OUTPUT_DM4_OR"][0];
DM4_O_L     = SPEC_DM4_OR["OUTPUT_DM4_OR"][0];

//=======================================================
// DUMMY SPEC : DM4_shape_OW_x2
FSS_SPEC_DM4_SHAPE_OW : list of fill_to_signal_spacing_s = {
    { M4_MAIN_LE, min_space_y = 0.06, space_extension_x = 0.06, projection = CORNER },
    { M4_MAIN_LE, min_space_x = 0.06, space_extension_y = 0.06, projection = CORNER },

#ifdef VERTICAL_M4
    { M4_096V_OE, min_space_y = 0.09, space_extension_x = 0.042, projection = CORNER }, 
#else
    { M4_096V_OE, min_space_x = 0.09, space_extension_y = 0.042, projection = CORNER }, 
#endif
#ifdef VERTICAL_M4
    { M4_096V_OE, min_space_y = 0.042, space_extension_x = 0.09, projection = CORNER }, 
#else
    { M4_096V_OE, min_space_x = 0.042, space_extension_y = 0.09, projection = CORNER }, 
#endif

#ifdef VERTICAL_M4
    { M4_198V_OE, min_space_y = 0.09, space_extension_x = 0.061, projection = CORNER },
#else
    { M4_198V_OE, min_space_x = 0.09, space_extension_y = 0.061, projection = CORNER }, 
#endif
#ifdef VERTICAL_M4
    { M4_198V_OE, min_space_y = 0.061, space_extension_x = 0.09, projection = CORNER },
#else
    { M4_198V_OE, min_space_x = 0.061, space_extension_y = 0.09, projection = CORNER }, 
#endif
//=======================================================
// DUMMY SPEC : DM4_OW_x2
    { CHIP_snps, min_space = 0, context = INTERIOR }, //RD CONFIRM
#ifdef FULL_CHIP
    { CHIP_BOUNDARY, min_space = 0, context = INTERIOR }, //RD CONFIRM
    { CHIP_FILLREGION_X2, min_space = 0, context = INTERIOR },
#else
    { PRBOUNDARY, min_space_x = DMX2O_CHIPE, min_space_y = DMX2O_CHIPR, context = INTERIOR },
#endif
    { MX2FORBIDDEN_CHIPMH, min_space = 0 },
    { BEOLBLK_FINAL, min_space_x = DMX2_BEOLBLKE, min_space_y = DMX2_BEOLBLKR, space_extension_x = DMX2_BEOLBLKE, space_extension_y = DMX2_BEOLBLKR }, 
    { DM4EXCL_FINAL, min_space_x = DMX2_DMXEXCLE, min_space_y = DMX2_DMXEXCLR, space_extension_x = DMX2_DMXEXCLE, space_extension_y = DMX2_DMXEXCLR },
    { CSR66_3485, min_space_x = DMX2_BEOLBLKE, min_space_y = DMX2_BEOLBLKR, space_extension_x = DMX2_BEOLBLKE, space_extension_y = DMX2_BEOLBLKR },
    { INDDMY, min_space = DM_INDDMY },
    { TCDDMY_M4, min_space = DMX2_TCDDMY_MX },
    { M4_HOLE, min_space = 0 },
    { M4_45, min_space = 0 },
    { ICOVL_SINGLE, min_space = DMX2_ICOVL },
#ifdef VERTICAL_M4
    { M4_MAIN, min_space_x = DMX2OW_SC_MXX, min_space_y = DMX2OW_SC_MXY, space_extension_x = DMX2OW_SC_MXX, space_extension_y = DMX2OW_SC_MXY },
#else
    { M4_MAIN, min_space_x = DMX2OW_SC_MXY, min_space_y = DMX2OW_SC_MXX, space_extension_x = DMX2OW_SC_MXY, space_extension_y = DMX2OW_SC_MXX },
#endif
#ifdef VERTICAL_M4
    { DM4_O, min_space_x = DMX2OW_DMX_O_X, min_space_y = DMX2OW_DMX_O_Y, space_extension_x = DMX2OW_DMX_O_X, space_extension_y = DMX2OW_DMX_O_Y },
#else
    { DM4_O, min_space_x = DMX2OW_DMX_O_Y, min_space_y = DMX2OW_DMX_O_X, space_extension_x = DMX2OW_DMX_O_Y, space_extension_y = DMX2OW_DMX_O_X },
#endif
    { DM4, min_space = DMX2OW_DMX },
    { VIA3, min_space = 0.06 },
#ifdef VERTICAL_M4
    { M4_HVN_096V, min_space_x = DMX2_MX096V, min_space_y = DMX2OR_SC_MXY, space_extension_x = DMX2_MX096V, space_extension_y = DMX2OR_SC_MXY },
    { M4_HVN_132V, min_space_x = DMX2_MX132V, min_space_y = DMX2OR_SC_MXY, space_extension_x = DMX2_MX132V, space_extension_y = DMX2OR_SC_MXY },
    { M4_HVN_165V, min_space_x = DMX2_MX165V, min_space_y = DMX2OR_SC_MXY, space_extension_x = DMX2_MX165V, space_extension_y = DMX2OR_SC_MXY },
    { M4_HVN_198V, min_space_x = DMX2_MX198V, min_space_y = DMX2OR_SC_MXY, space_extension_x = DMX2_MX198V, space_extension_y = DMX2OR_SC_MXY },
    { M4_HVN_275V, min_space_x = DMX2_MX275V, min_space_y = DMX2OR_SC_MXY, space_extension_x = DMX2_MX275V, space_extension_y = DMX2OR_SC_MXY },
#else
    { M4_HVN_096V, min_space_x = DMX2OR_SC_MXY, min_space_y = DMX2_MX096V, space_extension_x = DMX2OR_SC_MXY, space_extension_y = DMX2_MX096V },
    { M4_HVN_132V, min_space_x = DMX2OR_SC_MXY, min_space_y = DMX2_MX132V, space_extension_x = DMX2OR_SC_MXY, space_extension_y = DMX2_MX132V },
    { M4_HVN_165V, min_space_x = DMX2OR_SC_MXY, min_space_y = DMX2_MX165V, space_extension_x = DMX2OR_SC_MXY, space_extension_y = DMX2_MX165V },
    { M4_HVN_198V, min_space_x = DMX2OR_SC_MXY, min_space_y = DMX2_MX198V, space_extension_x = DMX2OR_SC_MXY, space_extension_y = DMX2_MX198V },
    { M4_HVN_275V, min_space_x = DMX2OR_SC_MXY, min_space_y = DMX2_MX275V, space_extension_x = DMX2OR_SC_MXY, space_extension_y = DMX2_MX275V },
#endif
    { VIA3_HVN_096V, min_space = DMX2_VX096V },
    { VIA3_HVN_132V, min_space = DMX2_VX132V },
    { VIA3_HVN_165V, min_space = DMX2_VX165V },
    { VIA3_HVN_198V, min_space = DMX2_VX198V },
    { VIA3_HVN_275V, min_space = DMX2_VX275V },
    { VIA4_HVN_096V, min_space = DMX2_VX096V },
    { VIA4_HVN_132V, min_space = DMX2_VX132V },
    { VIA4_HVN_165V, min_space = DMX2_VX165V },
    { VIA4_HVN_198V, min_space = DMX2_VX198V },
    { VIA4_HVN_275V, min_space = DMX2_VX275V },



#ifdef FILL_M3_VIA3_M4_BTCD
              { BTCD_M3_V3_M4_E, min_space = BTCD_DX2 },
#endif
#ifdef FILL_M4_VIA4_M5_BTCD
              { BTCD_M4_V4_M5_E, min_space = BTCD_DX2 },
#endif

#ifdef FILL_M4_BTCD2
              { BTCD_M4_E, min_space = BTCD_DX2 },
#endif
//**** corner space for voltage pattern
//**** end corner check
#ifdef VERTICAL_M4
       { M4_LT22, min_space_x = DMX2OW_SC_LT22, min_space_y = DMX2OW_SC_MXY, space_extension_x = DMX2OW_SC_LT22, space_extension_y = DMX2OW_SC_MXY },
       { M4_GE22, min_space_x = DMX2OW_SC_MXX, min_space_y = DMX2OW_SC_MXY, space_extension_x = DMX2OW_SC_MXX, space_extension_y = DMX2OW_SC_MXY },
       { WRAPPER_DM4_O_L, min_space_x = DMX2OW_DMX_O_X, min_space_y = DMX2OW_DMX_O_Y, space_extension_x = DMX2OW_DMX_O_X, space_extension_y = DMX2OW_DMX_O_Y },
       { DM4_O_L, min_space_x = DMX2OW_DMX_O_X, min_space_y = DMX2OW_DMX_O_Y, space_extension_x = DMX2OW_DMX_O_X, space_extension_y = DMX2OW_DMX_O_Y },
#else
       { M4_LT22, min_space_x = DMX2OW_SC_MXY, min_space_y = DMX2OW_SC_LT22, space_extension_x = DMX2OW_SC_MXY, space_extension_y = DMX2OW_SC_LT22 },
       { M4_GE22, min_space_x = DMX2OW_SC_MXY, min_space_y = DMX2OW_SC_MXX, space_extension_x = DMX2OW_SC_MXY, space_extension_y = DMX2OW_SC_MXX },
       { WRAPPER_DM4_O_L, min_space_x = DMX2OW_DMX_O_Y, min_space_y = DMX2OW_DMX_O_X, space_extension_x = DMX2OW_DMX_O_Y, space_extension_y = DMX2OW_DMX_O_X },
       { DM4_O_L, min_space_x = DMX2OW_DMX_O_Y, min_space_y = DMX2OW_DMX_O_X, space_extension_x = DMX2OW_DMX_O_Y, space_extension_y = DMX2OW_DMX_O_X },
#endif
       { DM4_L, min_space = DMX2OW_DMX },

};
//=======================================================
PATTERN_SPEC_DM4_SHAPE_OW = get_single_adjustable_pattern(
    adj_type = SHRINK,
#ifdef VERTICAL_M4
    min_bound = { DMX2OW_W, DMX2OW_L },
    max_bound = { DMX2OW_W_MAX, DMX2OW_L },
#else
    min_bound = { DMX2OW_L, DMX2OW_W },
    max_bound = { DMX2OW_L, DMX2OW_W_MAX },
#endif
    color = false,
    color_scheme = UF_LINE_SIDE,
#ifdef VERTICAL_M4
    cell_prefix = "DMOW4V", output = "OUTPUT_DM4_OW",
    spacing = { DMX2OW_SX, DMX2OW_SY },
#else
    cell_prefix = "DMOW4H", output = "OUTPUT_DM4_OW",
    spacing = { DMX2OW_SY, DMX2OW_SX },
#endif
    FSS = FSS_SPEC_DM4_SHAPE_OW,
    shift = 2,
    repeat = 3,
    starting_point = CENTER
);

PATTERN_SPEC_DM4_SHAPE_OW_2 = get_single_adjustable_pattern(
    adj_type = SHRINK,
#ifdef VERTICAL_M4
    min_bound = { DMX2OW_W, DMX2OW_L },
    max_bound = { DMX2OW_W_MAX, DMX2OW_L },
#else
    min_bound = { DMX2OW_L, DMX2OW_W },
    max_bound = { DMX2OW_L, DMX2OW_W_MAX },
#endif
    color = false,
    color_scheme = UF_LINE_SIDE,
#ifdef VERTICAL_M4
    cell_prefix = "DMOW4V", output = "OUTPUT_DM4_OW",
    spacing = { DMX2OW_SX, DMX2OW_SY },
#else
    cell_prefix = "DMOW4H", output = "OUTPUT_DM4_OW",
    spacing = { DMX2OW_SY, DMX2OW_SX },
#endif
    FSS = FSS_SPEC_DM4_SHAPE_OW,
    shift = 2,
    repeat = 3,
    starting_point = CENTER
);


PATTERN_SPEC_DM4_SHAPE_OW.adjustable_fill.dpt_spacing = {
            dpt_space_x = 0.07,
            dpt_space_y = 0.07,
            dpt_space_extension = INTERSECTION,
};


PATTERN_SPEC_DM4_SHAPE_OW_2.adjustable_fill.dpt_spacing = {
            dpt_space_x = 0.07,
            dpt_space_y = 0.07,
            dpt_space_extension = INTERSECTION,
};
PATTERN_SPEC_DM4_SHAPE_OW.adjustable_fill.pattern_spec.other_pattern_spacing = {
    0 => >0.07,
    1 => >0.07,
};
PATTERN_SPEC_DM4_SHAPE_OW_2.adjustable_fill.pattern_spec.other_pattern_spacing = {
    0 => >0.07,
    1 => >0.07,
};

PATTERN_SPEC_DM4_SHAPE_OW.adjustable_fill.boundary_alignment = { inside = { CHIP_snps, {0.4, 0.4, 0.4, 0.4} }};


SPEC_DM4_OW = unified_fill(
	fill_patterns = {
        PATTERN_SPEC_DM4_SHAPE_OW,
        PATTERN_SPEC_DM4_SHAPE_OW_2,
    },
	fill_boundary = {
	    layer = CHIP_snps,
	    type = LAYER,
	},
    boundary = ALIGN,
	grid = vGRID
);

//***** fill *******************************************************************
DM4_OW_C   = SPEC_DM4_OW["OUTPUT_DM4_OW"][0];
DM4_OW_L   = SPEC_DM4_OW["OUTPUT_DM4_OW"][0];



DM4_OW_F = DM4_OW_C;

//=======================================================

#endif

#ifdef FILL_DM5

// DUMMY SPEC : DM5_x3
//***DM5***
PATTERN_SPEC_DM5_0 = get_single_polygon_pattern (
#ifdef VERTICAL_M5
    cell_prefix = "DMB5V", output = "OUTPUT_DM5", width = DMX3B_W, height = DMX3B_L,
    step_x = DMX3B_SX, step_y = DMX3B_SY,
#else
    cell_prefix = "DMB5H", output = "OUTPUT_DM5", width = DMX3B_L, height = DMX3B_W,
    step_x = DMX3B_SY, step_y = DMX3B_SX,
#endif
    setback = DMX3B_DMX,
    setback_type = INTERSECTION,
    FSS = {
#ifdef FULL_CHIP
    { CHIP_BOUNDARY, min_space = DMX3B_CHIP, context = INTERIOR },
#else
    { PRBOUNDARY, min_space = DMX3B_CHIP, context = INTERIOR },
#endif
    { CHIP_snps, min_space = DMX3B_CHIP, context = INTERIOR },
    { TCDDMY_M5, min_space = DM_TCDDMY_MX },
    { INDDMY, min_space = DM_INDDMY },
    { ICOVL_SINGLE, min_space = DMX3_ICOVL },
    { BEOLBLK_FINAL, min_space = DMX3B_MX },
    { CSR66_3485, min_space = DMX3B_MX },
    { DM5EXCL_FINAL, min_space = DMX3B_MX },
    { M5_MAIN, min_space = DMX3B_MX },
    { DM5_O, min_space = 0.26 },
    { DM5, min_space = 0.26 },
#ifdef FILL_M4_VIA4_M5_BTCD
              { BTCD_M4_V4_M5_E, min_space = BTCD_DX3 },
#endif
#ifdef FILL_M5_VIA5_M6_BTCD
              { BTCD_M5_V5_M6_E, min_space = BTCD_DX3 },
#endif

#ifdef FILL_M5_BTCD2
              { BTCD_M5_E, min_space = BTCD_DX3 },
#endif
              { WRAPPER_DM5_O_L, min_space = DMX3B_DMXO },
    },
    shift = 2,
    repeat = 3,
    starting_point = CENTER
);

PATTERN_SPEC_DM5_0.polygon_fill.color = true;
//***DM5_O_R***
PATTERN_SPEC_DM5_1 = get_single_adjustable_pattern (
    adj_type = SHRINK,
#ifdef VERTICAL_M5
    min_bound = { DMX3OR_W, DMX3OR_L },
    max_bound = { DMX3OR_W, DMX3OR_L_MAX },
#else
    min_bound = { DMX3OR_L, DMX3OR_W },
    max_bound = { DMX3OR_L_MAX, DMX3OR_W },
#endif
    color = true,
    color_scheme = UF_LINE_SIDE,
#ifdef VERTICAL_M5
    cell_prefix = "WDM5V", output = "OUTPUT_DM5_O",
    spacing = { DMX3OR_SX, DMX3OR_SY },
#else
    cell_prefix = "WDM5H", output = "OUTPUT_DM5_O",
    spacing = { DMX3OR_SY, DMX3OR_SX },
#endif
    FSS = {
    { CHIP_snps, min_space = DMX3O_PRBOUNDARY, context = INTERIOR },
#ifdef FULL_CHIP
    { CHIP_BOUNDARY, min_space = DMX3O_CHIP, context = INTERIOR },
    { CHIP_FILLREGION_X3, min_space = 0, context = INTERIOR },
#else
    { PRBOUNDARY, min_space = DMX3O_PRBOUNDARY, context = INTERIOR },
#endif
    { BEOLBLK_FINAL, min_space = DM_BEOLBLK },
    { INDDMY, min_space = DM_INDDMY },

    { DM5EXCL_FINAL, min_space = DM_DMXEXCL },
    { CSR66_3485, min_space = DM_BEOLBLK },
    { TCDDMY_M5, min_space = DM_TCDDMY_MX },

    { M5_HOLE, min_space = 0 },
    { M5_LT180, min_space = DMX3_DC_W140 },
    { M5_LT260, min_space = DMX3_DC_W180 },
    { M5_260_SIZE, min_space = 0 },
    { M5_45, min_space = 0 },
    { ICOVL_SINGLE, min_space = DMX3_ICOVL },
{ M5_LT245, min_space = DMX3_DC_W20 },
//+++Mxd 1P1E+++
#ifdef VERTICAL_M5
    { M5_LT245, min_space_y = MX3_END_END, space_extension_x = DMX3_SC_W20 }, //RD CONFIRM # EXTENDABLE used
    { M5_LT60, min_space_y = DMX3_SC_W245, space_extension_x = DMX3_SC_W245 },
    { M5_LT100, min_space_y = DMX3_SC_W60, space_extension_x = DMX3_SC_W60 },
    { M5_LT140, min_space_y = DMX3_SC_W100, space_extension_x = DMX3_SC_W100 },
    { M5_MAIN_CA, min_space_y = MX3_SC_END_END, space_extension_x = MX3_SC_END_PRL },
    { M5_MAIN_CB, min_space_y = MX3_SC_END_END, space_extension_x = MX3_SC_END_PRL },

#else
    { M5_LT245, min_space_x = MX3_END_END, space_extension_y = DMX3_SC_W20 },//RD CONFIRM
    { M5_LT60, min_space_x = DMX3_SC_W245, space_extension_y = DMX3_SC_W245 },
    { M5_LT100, min_space_x = DMX3_SC_W60, space_extension_y = DMX3_SC_W60 },
    { M5_LT140, min_space_x = DMX3_SC_W100, space_extension_y = DMX3_SC_W100 },
    { M5_MAIN_CA, min_space_x = MX3_SC_END_END, space_extension_y = MX3_SC_END_PRL },
    { M5_MAIN_CB, min_space_x = MX3_SC_END_END, space_extension_y = MX3_SC_END_PRL },

#endif
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    { M5_LT60, min_space = DMX3_DC_W245 },
    { M5_LT100, min_space = DMX3_DC_W60 },
    { M5_LT140, min_space = DMX3_DC_W100 },
    { M5CA_LT245, min_space = DMX3_SC_W20, color_aware_to_fill = ONLY_COLOR_1},
    { M5CA_LT245, min_space = 0, color_aware_to_fill = ALL }, //for parsing
    { M5CB_LT245, min_space = DMX3_SC_W20, color_aware_to_fill = ONLY_COLOR_2},
    { M5CB_LT245, min_space = 0, color_aware_to_fill = ALL }, //for parsing
    { M5CA_LT60, min_space = DMX3_SC_W245, color_aware_to_fill = ONLY_COLOR_1},
    { M5CA_LT60, min_space = 0, color_aware_to_fill = ALL }, //for parsing
    { M5CB_LT60, min_space = DMX3_SC_W245, color_aware_to_fill = ONLY_COLOR_2},
    { M5CB_LT60, min_space = 0, color_aware_to_fill = ALL }, //for parsing
    { M5CA_LT100, min_space_x = DMX3_SC_W60, space_extension_y = DMX3_SC_W60, min_space_y = DMX3_SC_W60, space_extension_x = DMX3_SC_W60, color_aware_to_fill = ONLY_COLOR_1}, //RD CONFIRM
    { M5CA_LT100, min_space = 0, color_aware_to_fill = ALL }, //for parsing
    { M5CB_LT100, min_space_x = DMX3_SC_W60, space_extension_y = DMX3_SC_W60, min_space_y = DMX3_SC_W60, space_extension_x = DMX3_SC_W60, color_aware_to_fill = ONLY_COLOR_2}, //RD CONFIRM
    { M5CB_LT100, min_space = 0, color_aware_to_fill = ALL }, //for parsing
    { M5CA_LT140, min_space_x = DMX3_SC_W100, space_extension_y = DMX3_SC_W100, min_space_y = DMX3_SC_W100, space_extension_x = DMX3_SC_W100, color_aware_to_fill = ONLY_COLOR_1}, //RD CONFIRM
    { M5CA_LT140, min_space = 0, color_aware_to_fill = ALL }, //for parsing
    { M5CB_LT140, min_space_x = DMX3_SC_W100, space_extension_y = DMX3_SC_W100, min_space_y = DMX3_SC_W100, space_extension_x = DMX3_SC_W100, color_aware_to_fill = ONLY_COLOR_2}, //RD CONFIRM
    { M5CB_LT140, min_space = 0, color_aware_to_fill = ALL }, //for parsing

#ifdef VERTICAL_M5
    { M5_MAIN, min_space_x = DMX3OR_MX, min_space_y = MX3_SC_END_END, space_extension_x = DMX3OR_MX, space_extension_y = MX3_SC_END_END },
#else
    { M5_MAIN, min_space_x = MX3_SC_END_END, min_space_y = DMX3OR_MX, space_extension_x = MX3_SC_END_END, space_extension_y = DMX3OR_MX },
#endif
    { DM5_O_S, min_space = 0.13 },
    { DM5_O_B, min_space = 0.26 },
    { DM5, min_space = 0.26 },
    { M5_HVN_180V, min_space = DMX3_MX180V },
    { M5_S42, min_space = 0 },
#ifdef FILL_M4_VIA4_M5_BTCD
              { BTCD_M4_V4_M5_E, min_space = BTCD_DX3 },
#endif
#ifdef FILL_M5_VIA5_M6_BTCD
              { BTCD_M5_V5_M6_E, min_space = BTCD_DX3 },
#endif

#ifdef FILL_M5_BTCD2
              { BTCD_M5_E, min_space = BTCD_DX3 },
#endif
#ifdef VERTICAL_M5
              { M5_MAIN, min_space_y = 0.06, space_extension_x = 0.1 }, //RD CONFIRM
#else
              { M5_MAIN, min_space_x = 0.06, space_extension_y = 0.1 }, //RD CONFIRM
#endif
              { WRAPPER_DM5_O_L, min_space = 0.128 },
    },
    shift = 2,
    repeat = 3,
    starting_point = CENTER
);
//=======================================================
PATTERN_SPEC_DM5_1.adjustable_fill.dpt_spacing = {
    dpt_space_x = MX3RTOR_G0,
    dpt_space_y = MX3RTOR_G0,
    dpt_space_extension = INTERSECTION,
};


PATTERN_SPEC_DM5_1.adjustable_fill.pattern_spec.pattern_spacing = {
    min_space_corner = SQRT2 * 0.06,
    extension = RADIAL_INTERSECTION,
};

PATTERN_SPEC_DM5_0.polygon_fill.pattern_spec.other_pattern_spacing = {
    1 => > find_max( { DMX3B_DMX, DMX3OR_SC_DMX } )
};
PATTERN_SPEC_DM5_1.adjustable_fill.pattern_spec.other_pattern_spacing = {
    0 => > find_max( { DMX3B_DMX, DMX3OR_SC_DMX } )
};



 
//***** spec *******************************************************************
SPEC_DM5 = unified_fill(
	fill_patterns = {
        PATTERN_SPEC_DM5_0,
        PATTERN_SPEC_DM5_1,
    },
	fill_boundary = {
	    layer = CHIP_snps,
	    type = LAYER,
	},
    boundary = ALIGN,
	grid = vGRID
);
//-----------------------------------------------------



//***** fill *******************************************************************
DM5_A_C    = SPEC_DM5["OUTPUT_DM5"][1];
DM5_B_C    = SPEC_DM5["OUTPUT_DM5"][2];
DM5_O_A_C  = SPEC_DM5["OUTPUT_DM5_O"][1];
DM5_O_B_C  = SPEC_DM5["OUTPUT_DM5_O"][2];
DM5_L      = SPEC_DM5["OUTPUT_DM5"][0];
DM5_O_L    = SPEC_DM5["OUTPUT_DM5_O"][0];
DM5_O_A_L  = SPEC_DM5["OUTPUT_DM5_O"][1];
DM5_O_B_L  = SPEC_DM5["OUTPUT_DM5_O"][2];

//=======================================================
// DUMMY SPEC : DM5_OW_x3
PATTERN_SPEC_DM5_OW = get_single_polygon_pattern(
#ifdef VERTICAL_M5
    cell_prefix = "DMOW5V", output = "OUTPUT_DM5_OW", width = DMX3OW_W, height = DMX3OW_L,
    step_x = DMX3OW_SX, step_y = DMX3OW_SY,
    offset_x = DMX3OW_OX, offset_y = DMX3OW_OY,
#else
    cell_prefix = "DMOW5H", output = "OUTPUT_DM5_OW", width = DMX3OW_L, height = DMX3OW_W,
    step_x = DMX3OW_SY, step_y = DMX3OW_SX,
    offset_x = DMX3OW_OY, offset_y = DMX3OW_OX,
#endif
    setback = 0.13,
    setback_type = INTERSECTION,
    FSS = {
    { CHIP_snps, min_space = DMX3O_PRBOUNDARY, context = INTERIOR },
#ifdef FULL_CHIP
    { CHIP_BOUNDARY, min_space = DMX3O_CHIP, context = INTERIOR },
    { CHIP_FILLREGION_X3, min_space = 0, context = INTERIOR },
#else
    { PRBOUNDARY, min_space = DMX3O_PRBOUNDARY, context = INTERIOR },
#endif
    { BEOLBLK_FINAL, min_space = DM_BEOLBLK },
    { INDDMY, min_space = DM_INDDMY },

    { DM5EXCL_FINAL, min_space = DM_DMXEXCL },
    { CSR66_3485, min_space = DM_BEOLBLK },
    { TCDDMY_M5, min_space = DM_TCDDMY_MX },

    { M5_HOLE, min_space = 0 },
    { M5_LT180, min_space = DMX3_DC_W140 },
    { M5_LT260, min_space = DMX3_DC_W180 },
    { M5_260_SIZE, min_space = 0 },
    { M5_45, min_space = 0 },
    { ICOVL_SINGLE, min_space = DMX3_ICOVL },
    { M5_LT140, min_space = DMX3_SC_W100 },
    { M5_MAIN, min_space = DMX3OW_MX },
    { DM5_O_S, min_space = 0.13 },
    { DM5_O_B, min_space = 0.26 },
    { DM5, min_space = 0.26 },
    { M5_S42, min_space = 0 },
    { M5_180_OW, min_space = DMX3_DC_W180 },
    { M5_260_OW, min_space = DMX3_DC_W260 },

#ifdef FILL_M4_VIA4_M5_BTCD
              { BTCD_M4_V4_M5_E, min_space = BTCD_DX3 },
#endif
#ifdef FILL_M5_VIA5_M6_BTCD
              { BTCD_M5_V5_M6_E, min_space = BTCD_DX3 },
#endif

#ifdef FILL_M5_BTCD2
              { BTCD_M5_E, min_space = BTCD_DX3 },
#endif
              { WRAPPER_DM5_O_L, min_space = 0.13 },
              { DM5_O_L, min_space = 0.13 },
              { DM5_L, min_space = 0.16 },
    },
    repeat = 3,
    shift = 2,
    starting_point  = CENTER
);
//=======================================================

PATTERN_SPEC_DM5_OW.polygon_fill.color = true;
SPEC_DM5_OW = unified_fill(
	fill_patterns = {
        PATTERN_SPEC_DM5_OW
    },
	fill_boundary = {
	    layer = CHIP_snps,
	    type = LAYER,
	},
    boundary = ALIGN,
	grid = vGRID
);


//***** fill *******************************************************************
DM5_OW_A_C = SPEC_DM5_OW["OUTPUT_DM5_OW"][1];
DM5_OW_B_C = SPEC_DM5_OW["OUTPUT_DM5_OW"][2];
DM5_OW_L =  SPEC_DM5_OW["OUTPUT_DM5_OW"][0];
//=======================================================

#endif

#ifdef FILL_DM6

#pragma PXL encrypted begin
2E5,* #CX%A*R"C[VC]^RM;(%584QRPU)^85QY#!'CS+*T3'#ZB#.X$Z,P(/+@&>9PIG<&8N
G8WC+,56*ER=P+W-/Z_G1^C %K5=46C%$:06OT6X+).M(G2_
#pragma PXL encrypted end


LAYER_DM6_MYBCELL_H : polygon_layer_s = {
    layer_spec = {
        output_layer_key = "OUTPUT_DM6_DMB_CONNECT"
    },
    polygons = MYBCELL_H
};

LAYER_DM6_MYBCELL_V : polygon_layer_s = {
    layer_spec = {
        output_layer_key = "OUTPUT_DM6_DMB_CONNECT"
    },
    polygons = MYBCELL_V
};

LAYER_DM6_MYBCELL_HEXT : polygon_layer_s = {
    layer_spec = {
        output_layer_key = "OUTPUT_DM6_DMB_CONNECT"
    },
    polygons = MYBCELL_HEXT
};

LAYER_DM6_MYBCELL_VEXT : polygon_layer_s = {
    layer_spec = {
        output_layer_key = "OUTPUT_DM6_DMB_CONNECT"
    },
    polygons = MYBCELL_VEXT 
};

// DUMMY SPEC : DM6_DMB_Connect
SPEC_DM6_DMB_CONNECT = unified_fill(
    fill_patterns = {
    {
        type = UF_POLYGON,
        polygon_fill = {
            insertion = {
                iterations = 3,
                shift_factor = 2,    
            },
            pattern_spec = {
#ifdef VERTICAL_M6
                space_x = DMY1B_SX,
                space_y = DMY1B_SY,
                stagger_x = DMY1B_OX,
                stagger_y = DMY1B_OY,
#else
                space_x = DMY1B_SY,
                space_y = DMY1B_SX,
                stagger_x = DMY1B_OY,
                stagger_y = DMY1B_OX,
#endif
            },
            layers = {
#ifdef VERTICAL_M6
                LAYER_DM6_MYBCELL_V
#else
                LAYER_DM6_MYBCELL_H
#endif
            },
#ifdef CONTROL_MAX_METAL_LENGTH
#else
            merging_layers = {
#ifdef VERTICAL_M6
                LAYER_DM6_MYBCELL_VEXT
#else
                LAYER_DM6_MYBCELL_HEXT
#endif
            },
#endif
#ifdef ANTPrevention                
#ifndef CONTROL_MAX_METAL_LENGTH
            merging_blockage_layer_list = {
                FORBIDDEN_RING
            },
#endif
#endif
#ifdef CONTROL_MAX_METAL_LENGTH
#else
#ifdef VERTICAL_M6     
            merging_direction = VERTICAL,
#else
            merging_direction = HORIZONTAL,
#endif   
            merging_length_limit = 500*(DMY1OR_L + DMY1B_SY) - DMY1B_SY, 
#endif
            fill_to_signal_spacing = {
    { CHIP_snps, min_space = DMY1B_CHIP, context = INTERIOR },
#ifdef FULL_CHIP
    { CHIP_BOUNDARY, min_space = DMY1B_CHIP, context = INTERIOR },
#else
    { PRBOUNDARY, min_space = DMY1B_CHIP, context = INTERIOR },
#endif
    { ICOVL_SINGLE, min_space = DMY1_ICOVL },
    { INDDMY, min_space = DM_INDDMY },
    { TCDDMY_M6, min_space = DM_TCDDMY_MX },

	{ BEOLBLK_FINAL, min_space = DMY1B_MY1 },
    { DM6EXCL_FINAL, min_space = DMY1B_MY1 },
    { CSR66_3485, min_space = DMY1B_MY1 },
    { M6_MAIN, min_space = DMY1B_MY1 },
    { DM6_O, min_space = 0.26 },
    { DM6, min_space = 0.26 },
    { DM6_GT1350, min_space = 0.45 },
    { M6_GT76, min_space = DMY1_MY1W1 },
    { M6_GT114, min_space = DMY1_MY1W2 },
    { M6_GT152, min_space = DMY1_MY1W3 },
    { M6_GT180, min_space = DMY1_MY1W4 },
    { M6_GT240, min_space = DMY1_MY1W5 },
    { M6_GT280, min_space = DMY1_MY1W6 },
    { M6_GT500, min_space = DMY1_MY1W7 },
    { M6_GT1350, min_space = DMY1_MY1W8 },
#ifdef FILL_M5_VIA5_M6_BTCD
              { BTCD_M5_V5_M6_E, min_space = BTCD_D },
#endif
#ifdef FILL_M6_VIA6_M7_BTCD
              { BTCD_M6_V6_M7_E, min_space = BTCD_D },
#endif

#ifdef FILL_M6_BTCD2
              { BTCD_M6_E, min_space = BTCD_D },
#endif
              { WRAPPER_DM6_O_L, min_space = DMY1B_DMY1O },
#pragma PXL encrypted begin
UWV17D!)-"[7"#)6W:F^()@(!@4!4S4M',0&KX21TS#J*R2OLI,FIWE 4SBRV&2VT,*B> S8
L(UJ9$]@U>6PJ#<_-FQQX:BH3/4=+L_4Y_=,E]!&?]S0O,.7:[OJC02I[R)KD>IO'O,*+=*1
Q@$K[R-K\8_&3X]2YQYCO&Y/R0Y@^S"V-UW)=_-&YRTL?85W+5<@U!"&BDDM?QV?B267[A]_
V16M?#NZFZ[9[.VY,SW%BZ_L*]19B"^2P.PK,#E2JI\/6W(P
#pragma PXL encrypted end

                            
            },
            hierarchical_fill = false,
#ifdef VERTICAL_M6     
            cell_prefix = "DMB6VNEW"
#else
            cell_prefix = "DMB6HNEW"
#endif   
        }
    }
    },
    extents_output = {
        {
            output_layer_key = "OUTPUT_DM6_DMB_CONNECT_EXTENT"
        },
    },
    fill_boundary = {
        layer = CHIP_snps, 
        type = LAYER 
    },
	grid = vGRID
);
//=======================================================
DM6NEW_C     = SPEC_DM6_DMB_CONNECT["OUTPUT_DM6_DMB_CONNECT"][0];
DM6NEW_L     = SPEC_DM6_DMB_CONNECT["OUTPUT_DM6_DMB_CONNECT"][0];
//***** spec *******************************************************************
#pragma PXL encrypted begin
E3\()N\'ASV5B$>2E7LR9CJ(]^^75?YFF6SWX,:![%6%E ;@<[J@=(N 8 =S.V'[PF$M35L[
*!X?-VU9Q1HHUOW_)XF^==?6
#pragma PXL encrypted end

//***DM6_DMB***
// DUMMY SPEC : DM6_y1
PATTERN_SPEC_DM6_0 = get_single_polygon_pattern(
#ifdef VERTICAL_M6
	"DMB6V", "OUTPUT_DM6", DMY1B_W, DMY1B_L,
	step_x = DMY1B_SX, step_y = DMY1B_SY,
	offset_x = DMY1B_OX, offset_y = DMY1B_OY,
#else
	"DMB6H", "OUTPUT_DM6", DMY1B_L, DMY1B_W,
	step_x = DMY1B_SY, step_y = DMY1B_SX,
	offset_x = DMY1B_OY, offset_y = DMY1B_OX,
#endif
    FSS = {
    { CHIP_snps, min_space = DMY1B_CHIP, context = INTERIOR },
#ifdef FULL_CHIP
    { CHIP_BOUNDARY, min_space = DMY1B_CHIP, context = INTERIOR },
#else
    { PRBOUNDARY, min_space = DMY1B_CHIP, context = INTERIOR },
#endif
    { ICOVL_SINGLE, min_space = DMY1_ICOVL },
    { INDDMY, min_space = DM_INDDMY },
    { TCDDMY_M6, min_space = DM_TCDDMY_MX },

	{ BEOLBLK_FINAL, min_space = DMY1B_MY1 },
    { DM6EXCL_FINAL, min_space = DMY1B_MY1 },
    { CSR66_3485, min_space = DMY1B_MY1 },
    { M6_MAIN, min_space = DMY1B_MY1 },
    { DM6_O, min_space = 0.26 },
    { DM6, min_space = 0.26 },
    { DM6_GT1350, min_space = 0.45 },
    { M6_GT76, min_space = DMY1_MY1W1 },
    { M6_GT114, min_space = DMY1_MY1W2 },
    { M6_GT152, min_space = DMY1_MY1W3 },
    { M6_GT180, min_space = DMY1_MY1W4 },
    { M6_GT240, min_space = DMY1_MY1W5 },
    { M6_GT280, min_space = DMY1_MY1W6 },
    { M6_GT500, min_space = DMY1_MY1W7 },
    { M6_GT1350, min_space = DMY1_MY1W8 },
#ifdef FILL_M5_VIA5_M6_BTCD
              { BTCD_M5_V5_M6_E, min_space = BTCD_DY1 },
#endif
#ifdef FILL_M6_VIA6_M7_BTCD
              { BTCD_M6_V6_M7_E, min_space = BTCD_DY1 },
#endif

#ifdef FILL_M6_BTCD2
              { BTCD_M6_E, min_space = BTCD_DY1 },
#endif
              { WRAPPER_DM6_O_L, min_space = DMY1B_DMY1O },
#pragma PXL encrypted begin
Y1J2#C:\>1CE>&)6[B?601EX-/?,%#T_0-DT:5I*T/+PHI-I&@5 OV0R,UL:_=$;=/ UC5K]
]"#.2CF^X(KT%I *Z7/$IWT6 ?3+)Z3E#9@!THC?<QX<._72
#pragma PXL encrypted end

              { DM6NEW_L, min_space = DMY1B_DMY1 },
#pragma PXL encrypted begin
W@(%+3LW7!/>_EZT1N@1 C/^'Q9=1'![$>L?7%3E_,0G7VE<X^=V0=;F,'CC?=FBE1:B,I9]
81#743[-?]]AT),V6_O(+E;0
#pragma PXL encrypted end

    },
	shift = 2,
	repeat = 3,
    starting_point = CENTER
); //end of get_single_polygon_pattern


//-------------------------------------------------------------------------------

//***DM6_DMS***
PATTERN_SPEC_DM6_1 = get_single_polygon_pattern(
#ifdef VERTICAL_M6
	"DMS6V", "OUTPUT_DM6", DMY1S_W, DMY1S_L,
	step_x = DMY1S_SX, step_y = DMY1S_SY,
	offset_x = DMY1S_OX, offset_y = DMY1S_OY,
#else
	"DMS6H", "OUTPUT_DM6", DMY1S_L, DMY1S_W,
	step_x = DMY1S_SY, step_y = DMY1S_SX,
	offset_x = DMY1S_OY, offset_y = DMY1S_OX,
#endif
    FSS = {
    { CHIP_snps, min_space = DMY1S_CHIP, context = INTERIOR },
#ifdef FULL_CHIP
    { CHIP_BOUNDARY, min_space = DMY1S_CHIP, context = INTERIOR },
#else
    { PRBOUNDARY, min_space = DMY1S_CHIP, context = INTERIOR },
#endif
    { ICOVL_SINGLE, min_space = DMY1_ICOVL },
    { INDDMY, min_space = DM_INDDMY },
    { TCDDMY_M6, min_space = DM_TCDDMY_MX },

	{ BEOLBLK_FINAL, min_space = DMY1S_MY1 },
    { DM6EXCL_FINAL, min_space = DMY1S_MY1 },
    { CSR66_3485, min_space = DMY1S_MY1 },
    { M6_MAIN, min_space = DMY1S_MY1 },
    { DM6_O, min_space = 0.26 },
    { DM6, min_space = 0.26 },
    { DM6_GT1350, min_space = 0.45 },
    { M6_GT76, min_space = DMY1_MY1W1 },
    { M6_GT114, min_space = DMY1_MY1W2 },
    { M6_GT152, min_space = DMY1_MY1W3 },
    { M6_GT180, min_space = DMY1_MY1W4 },
    { M6_GT240, min_space = DMY1_MY1W5 },
    { M6_GT280, min_space = DMY1_MY1W6 },
    { M6_GT500, min_space = DMY1_MY1W7 },
    { M6_GT1350, min_space = DMY1_MY1W8 },
#ifdef FILL_M5_VIA5_M6_BTCD
              { BTCD_M5_V5_M6_E, min_space = BTCD_DY1 },
#endif
#ifdef FILL_M6_VIA6_M7_BTCD
              { BTCD_M6_V6_M7_E, min_space = BTCD_DY1 },
#endif

#ifdef FILL_M6_BTCD2
              { BTCD_M6_E, min_space = BTCD_DY1 },
#endif
              { WRAPPER_DM6_O_L, min_space = DMY1S_DMY1O },
#pragma PXL encrypted begin
":MH4U, #E<)*!\\69N09;$H5IF4T]?C[R%6W!:QSD==:,7<LCW0Y,9D_=^R=0=-;!LEG5!U
_B8.A3FL( +^$4-+X1_[6,01)381%@NY?#PEL,C[4IAKNXZP
#pragma PXL encrypted end

              { DM6NEW_L, min_space = DMY1S_DMY1 },
#pragma PXL encrypted begin
\5*+1%)A 0_QUSD<ZE:YC3;7U7K(RI=!8LS5"2S6ZY12@>$)*8$M88A["GPIOW(#]AZX(ON_
76ZSG3<'NU-=,D0MIX2M'$@R
#pragma PXL encrypted end

    },
	shift = 2,
	repeat = 3
);


//***DM6_O_R***
PATTERN_SPEC_DM6_2 = get_single_polygon_pattern(
#ifdef VERTICAL_M6
	"DMOR6V", "OUTPUT_DM6_O", DMY1OR_W, DMY1OR_L,
	step_x = DMY1OR_SX, step_y = DMY1OR_SY,
	offset_x = DMY1OR_OX, offset_y = DMY1OR_OY,
	setback = DMY1OR_SC,
	setback_type = INTERSECTION,
#else
	"DMOR6H", "OUTPUT_DM6_O", DMY1OR_L, DMY1OR_W,
	step_x = DMY1OR_SY, step_y = DMY1OR_SX,
	offset_x = DMY1OR_OY, offset_y = DMY1OR_OX,
	setback = DMY1OR_SC,
	setback_type = INTERSECTION,
#endif
    FSS = {
    { CHIP_snps, min_space = DMY1_CHIP, context = INTERIOR },
#ifdef FULL_CHIP
    { CHIP_BOUNDARY, min_space = DMY1_CHIP, context = INTERIOR },
#else
    { PRBOUNDARY, min_space = DMY1_CHIP, context = INTERIOR },
#endif
    { ICOVL_SINGLE, min_space = DMY1_ICOVL },
    { BEOLBLK_FINAL, min_space = DM_BEOLBLK },
    { CSR66_3485, min_space = DM_BEOLBLK },
    { INDDMY, min_space = DM_INDDMY },
    { DM6EXCL_FINAL, min_space = DM_DMXEXCL },
    { TCDDMY_M6, min_space = DM_TCDDMY_MX },
    { M6_MAIN, min_space = DMY1OR_MY1 },
    { DM6_O, min_space = DMY1OR_DMY1O },
    { DM6, min_space = 0.2 }, //DMn.S.3.5
    { DM6_GT1350, min_space = 0.45 },
    { M6_HOLE, min_space = 0 },
    { M6_GT76, min_space = DMY1_MY1W1 },
    { M6_GT114, min_space = DMY1_MY1W2 },
    { M6_GT152, min_space = DMY1_MY1W3 },
    { M6_GT180, min_space = DMY1_MY1W4 },
    { M6_GT240, min_space = DMY1_MY1W5 },
    { M6_GT280, min_space = DMY1_MY1W6 },
    { M6_GT500, min_space = DMY1_MY1W7 },
    { M6_GT1350, min_space = DMY1_MY1W8 },
    { M6_45, min_space = 0 },
    { VIA5_HVN_5V, min_space = DMY1_VY15V },
    { M6_HVN_5V, min_space = DMY1_MY15V },
    { VIA6_HVN_5V, min_space = DMY1_VY15V },

              { R7_VIA5_CHK_REGION, min_space = 0 },
              { S164_M6_REGION, min_space = 0 },
              { R15_VIA6_CHK_REGION, min_space = 0 },

              { S22_M6_REGION, min_space = 0 },
#ifdef FILL_M5_VIA5_M6_BTCD
              { BTCD_M5_V5_M6_E, min_space = BTCD_DY1 },
#endif
#ifdef FILL_M6_VIA6_M7_BTCD
              { BTCD_M6_V6_M7_E, min_space = BTCD_DY1 },
#endif

#ifdef FILL_M6_BTCD2
              { BTCD_M6_E, min_space = BTCD_DY1 },
#endif
              { WRAPPER_DM6_O_L, min_space = DMY1OR_DMY1O },
#pragma PXL encrypted begin
OU12.0@Z1&&_E3+^6?TO:KZ5BXHP\6X(<^V+.#2-59A/"!<X!@1#/A;$:7D&$S."*EO(2D(3
Q2O61W%4?@'%85G26(("**5A]O?!;;O']/SVUQJW8N5P[PO7
#pragma PXL encrypted end

              { DM6NEW_L, min_space = DMY1OR_DMY1 },
#pragma PXL encrypted begin
.Q:(2YV0UF0[_)/HSVV@D8W\3E(E-J7#;=).+@W7W_JI9V(N>G9%<?O O=EZG$/0?TS\1VR<
6W:&F*@PJVE;&G7MNB'LM<\:
#pragma PXL encrypted end

	},
    shift = 2,
	repeat = 3,
    starting_point = CENTER
);

#ifdef VERTICAL_M6
PATTERN_SPEC_DM6_2.polygon_fill.pattern_spec.pattern_spacing = {
    allowed_spacing_x = { >= DMY1OR_SXA2 },
    allowed_spacing_y = { >= DMY1OR_SY },
    extension = INTERSECTION
};
#else
PATTERN_SPEC_DM6_2.polygon_fill.pattern_spec.pattern_spacing = {
    allowed_spacing_y = { >= DMY1OR_SXA2 },
    allowed_spacing_x = { >= DMY1OR_SY },
    extension = INTERSECTION
};
#endif




//-------------------------------------------------------------------------------
//***DM6_O_W***

PATTERN_SPEC_DM6_3 = get_single_polygon_pattern(
#ifdef VERTICAL_M6
	"DMOW6V", "OUTPUT_DM6_O", DMY1OW_W, DMY1OW_L,
	step_x = DMY1OW_SY, step_y = DMY1OW_SX,
	offset_x = DMY1OW_OY, offset_y = DMY1OW_OX,
	setback = 0.114,
	setback_type = INTERSECTION,
#else
	"DMOW6H", "OUTPUT_DM6_O", DMY1OW_L, DMY1OW_W,
	step_x = DMY1OW_SX, step_y = DMY1OW_SY,
	offset_x = DMY1OW_OX, offset_y = DMY1OW_OY,
	setback = 0.114,
	setback_type = INTERSECTION,
#endif
    FSS = {
    { CHIP_snps, min_space = DMY1_CHIP, context = INTERIOR },
#ifdef FULL_CHIP
    { CHIP_BOUNDARY, min_space = DMY1_CHIP, context = INTERIOR },
#else
    { PRBOUNDARY, min_space = DMY1_CHIP, context = INTERIOR },
#endif
    { ICOVL_SINGLE, min_space = DMY1_ICOVL },
    { BEOLBLK_FINAL, min_space = DM_BEOLBLK },
    { INDDMY, min_space = DM_INDDMY },

    { DM6EXCL_FINAL, min_space = DM_DMXEXCL },
    { CSR66_3485, min_space = DM_BEOLBLK },
    { TCDDMY_M6, min_space = DM_TCDDMY_MX },

    { M6_MAIN, min_space = DMY1OW_MY1 },
    { DM6_O, min_space = DMY1OW_DMY1O },
    { DM6, min_space = 0.2 }, //DMn.S.3.5
    { DM6_GT1350, min_space = 0.45 },
    { M6_HOLE, min_space = 0 },
    { M6_GT76, min_space = DMY1_MY1W1 },
    { M6_GT114, min_space = DMY1_MY1W2 },
    { M6_GT152, min_space = DMY1_MY1W3 },
    { M6_GT180, min_space = DMY1_MY1W4 },
    { M6_GT240, min_space = DMY1_MY1W5 },
    { M6_GT280, min_space = DMY1_MY1W6 },
    { M6_GT500, min_space = DMY1_MY1W7 },
    { M6_GT1350, min_space = DMY1_MY1W8 },
    { M6_45, min_space = 0 },
    { VIA5_HVN_5V, min_space = DMY1_VY15V },
    { M6_HVN_5V, min_space = DMY1_MY15V },
    { VIA6_HVN_5V, min_space = DMY1_VY15V },

              { R7_VIA5_CHK_REGION, min_space = 0 },
              { S164_M6_REGION, min_space = 0 },
              { R15_VIA6_CHK_REGION, min_space = 0 },

              { S22_M6_REGION, min_space = 0 },
#ifdef FILL_M5_VIA5_M6_BTCD
              { BTCD_M5_V5_M6_E, min_space = BTCD_DY1 },
#endif
#ifdef FILL_M6_VIA6_M7_BTCD
              { BTCD_M6_V6_M7_E, min_space = BTCD_DY1 },
#endif

#ifdef FILL_M6_BTCD2
              { BTCD_M6_E, min_space = BTCD_DY1 },
#endif
              { WRAPPER_DM6_O_L, min_space = DMY1OW_DMY1O },
#pragma PXL encrypted begin
"1A/0%-I&3<);9/)Z]6=\I9M8'9*3V(-<Z)@,6+T'&V1:24Q8\+^4BEP>P)C+"]O&=--6WLL
7:@JFJV N&%=+*:BY2J.^"LLK[#3AOR _:&O'_Z4GQ22IAP?
#pragma PXL encrypted end

              { DM6NEW_L, min_space = DMY1OW_DMY1 },
#pragma PXL encrypted begin
NTS[01W%VQ2["!;U<R.G;(0(^D"3X 0[*XKZ2\'3H0F4I.Y+;%[C(R'1EH1L$0/QBM-AU (1
S1:OF+++*_[-H6#0K1B1SPZA
#pragma PXL encrypted end

	},
    shift = 2,
	repeat = 3,
    starting_point = CENTER
);
//=======================================================
PATTERN_SPEC_DM6_0.polygon_fill.pattern_spec.other_pattern_spacing = {
    1 => > DMY1B_DMY1,
    2 => > DMY1B_DMY1,
    3 => > DMY1B_DMY1,
};

PATTERN_SPEC_DM6_1.polygon_fill.pattern_spec.other_pattern_spacing = {
    0 => > DMY1S_DMY1,
    2 => > DMY1S_DMY1,
    3 => > DMY1S_DMY1,
};

PATTERN_SPEC_DM6_2.polygon_fill.pattern_spec.other_pattern_spacing = {
    0 => > DMY1OR_DMY1,
    1 => > DMY1OR_DMY1,
    3 => > DMY1OR_DMY1O,
};

PATTERN_SPEC_DM6_3.polygon_fill.pattern_spec.other_pattern_spacing = {
    0 => > DMY1OW_DMY1,
    1 => > DMY1OW_DMY1,
    2 => > DMY1OW_DMY1,
};

SPEC_DM6 = unified_fill(
    fill_boundary = {
        layer = CHIP_snps,
        type = LAYER
    },
    fill_patterns = {
        PATTERN_SPEC_DM6_0,
        PATTERN_SPEC_DM6_1,
        PATTERN_SPEC_DM6_2,
        PATTERN_SPEC_DM6_3,
    },
    boundary = ALIGN,
	grid = vGRID
);

//***** fill *******************************************************************
DM6_C   = SPEC_DM6["OUTPUT_DM6"][0];
DM6_O_C = SPEC_DM6["OUTPUT_DM6_O"][0];

#pragma PXL encrypted begin
5X[1+L!/3AY7Q@]0*2^5E ;&G%A\"' P2IB</@EQ\X7UL8P^;JO!YOW@,DENE*O0VI$S7<*4
)[I(I@OB45LGF#C4#K'R<\J80GA#Y*:E8=M"MNEUQ(,*FC^V
#pragma PXL encrypted end

#pragma PXL encrypted begin
4'9$3<7*,!E0A#U@9[.B=*:$[0GSA,-ZDT?MXES#[#BS;@#B.#!'N'6[%G4X_90MH%<+K#/]
I?D(<B^V_VZE<E0VP6.A X)RT=2YX0SU3#'1/L9=K%>("?P^
#pragma PXL encrypted end
#pragma PXL encrypted begin
S#=Z7UHAPQS,=MO2[V0[&;UVA3D^5'681 R%+QF!L+L5EP<O,#V%FD2MC@@P7:23"*1&945=
/Z[Y7,NH>D\_JB8G<]>?X@BJ!N99;PJ=7=(&15$ZNH-2<PE%_VG(*-TQ?C;_[[S Q5CM=,+O
#pragma PXL encrypted end
#pragma PXL encrypted begin
?FPF821]A7I^('0(,78]XY4@#!L_C7^'QBD,BM1('2'F++N*NRY8@_#\VIB[X*94YCK\7 _@
E2%NG(=AD=B5
#pragma PXL encrypted end
DM6_O_L = SPEC_DM6["OUTPUT_DM6_O"][0];
#pragma PXL encrypted begin
P[KE X7.YR/#)\DDFX?82_PG&+,( +/.+RX8?WWIFGU<KH1_CJ]!,P*%[4&.U9S-HPTT+P/5
SQEO_ :2G>3/#?,-_S!,K>P-
#pragma PXL encrypted end
#pragma PXL encrypted begin
" FE)N8?2DT(L^0BLM7Y/0&SL9"-CD,A%FBQZAW%'J>^(ROJ<0$P5?LYT-UQX:.@ (03K</A
#59;PDS:B)$-O;,!_^C[XDB]2(,G;*@>[TE(K;Y.3)[ITQFMEJ,\&6[R_P.6DR4L91[$/U63
)A]&LMA][84F
#pragma PXL encrypted end
#pragma PXL encrypted begin
@\K:.'QVW%"#_]ZEHU19@S?_[NZFO!DVYN_NZ0+>8Q3E5JSIZWN9823'O/_K?7FWU-.[V^Q]
52C:CKZ OG%5CWSD#JZOR"F/Y8J]U/R=<'7EQI2LL%]1EYW&
#pragma PXL encrypted end
DM6_L1   = SPEC_DM6["OUTPUT_DM6"][0];
DM6_L = DM6_L1 or DM6NEW_L;
#pragma PXL encrypted begin
_XL02Q'-;E3_OPC_J'M"-^Z_65F87QGB8"E9&F4P)W/%(U8:_OD\%3,94C3^RQ!">(^FY1++
Y4<J8-[9I</EQ.]E10T!LF_$>Z2W*8>% 95[IE CK!,6>.BFFXX;4J3(P]B;^I?5KN765IGZ
%;<,7+7@0 05
#pragma PXL encrypted end


#pragma PXL encrypted begin
L<"\3-LH,3*QAI<HC4%U$!*&SI>FQYB! #K.NBNI-\ZDM76ZG2 '3 IO[4&=Q$;56&E4<J3$
KNZ0U-H2'N2N64=VUY+*JXE9>7M[,K%0N1AYXN)5&.*V:(;B
#pragma PXL encrypted end
#pragma PXL encrypted begin
]@Y\;SQZDUOV["_A*3;B@^SLE&>7S+ N*M.4U;/^ V',*535D9QQ9.0O05"1\&_1>Y+SQK+P
H(UE97>F5]V@Y%? U9'BP5KD=:85!=G#1?9U%P,4^'CPC847>ZVP-+AAH>-[PT!TI9=A5$K#
H2IO(I7>@]:AUV6%K]](#I_7RS-==!0X")_+\ E='W6$_<'P4$(WJ8PH/^A02Z-A1@]+6F=+
]L)Z?B%0C&KV"63/%;+ZN@L)RP0O!*Z:653+XRJIK:*1!>3CH&C_CY=AM>Z@0&8]E" O^<E 
.#^)4ZE-BAHX]EKHFB=;!:?V+^+B]8-VZV8O7?HDY))%0HM=U[T$3WO>F%37Z1N\IR9K@#CI
Q]=2*P98Q\O' WPBN#J+'?L#R%(J3Y7[5"_(O[8;I-B19B2_=2V)KW-$\09U*J+CE0*%G)0J
@5. P1*3^7>!L;CK6OWQM5RQ&-T(VT.5"$48R%(J3Y7[5"_(:;FX#^#M(=!I=2V)KW-$\09U
M,R4@\\Z'T:T!ZG@>99W]X\'9HA4B"!Z$2MFHC(+T]@EB5NBYWA_QU^W,6;GRA:YTL[0?/_*
H9V<1B2FN':A$'_*.]Y,F$@0NY @[/,:(-"[0&8]E" O^<E .#^)4ZE-BAHX<FP%[AEV 9QR
1.(,XH3Q_8)$ 140^@?0<'D!XDE%B]Z9'+7B[]Z.K=>",R3OHJ,?= C=H6*BL^3I3U*H1N:S
-9Y"F'KH\28U&0.7_,[S,GH92B>!>#5X98I*&Y+5':<8&U$;7?HDY))%0HM=\C+&/&9B"OGR
GU[!R;$O -:?<FP%[AEV 9QR1.(,XH3Q_8)$ 140^@?0<'D!+Z="]=TL8P@O[]Z.K=>",R3O
HJ,?= C=H6*BL^3I3U*H1N:S-9Y"F'KH\28U&0.7_,[S,GH92B>!>#5X98I*00I9%\TYZ8!!
7?HDY))%0HM=I2;5_0S&92RE.#(1I>J*M+PX=XGQPR:[3'QW0,X+^\@  7Y AS\0HH3%O$V'
YG/FD@J)-'[F6\-B--M5_,);E;SZKTZX[,.5(L(7/^N>5!LBE4+=,#$#&"^58+;LQ!X84S-@
9P1M6GAI%@UG35:W>+P734A--M 5V_Z;VMDV$?%X<APCF'$1YU>V4G8"W WGT>!+=K-TX\#1
:W(>!H1>AJEK*2YO*IY;H?DI%+#Z]I>KDV,4WH$B93R>7TS>-):.))D"(^XTNRC^+"=^XZ^[
M)6  BW7X[JTH/*7)PF*.)2@6\-B--M5_,);E;SZKTZX[,.5(L(7/^N>5!LBE4+=,#$#&"^5
8+;LQ!X84S-@DPX"4B:E]7J3YZR\7%=%)Z#GR52<JJT5-^')\),==<_D.:WP6\-B--M5_,);
)L1."6WZ9-0F%5[/RGSB6Y<5UI9ANR0/PRC6(R D@LY2_Y\CT4X4&-HFLIW1SN(CM52) HK.
(\_RB-ZRM@<CXF8J.8;;)VSBS@=W#\GQ?XO.L%R7%_T0$C6PT>!+=K-TX\#1KE?#MF)OUSRN
A3TY]0MB/VF%8IFID+FL:)QBAT=T1QO(B\F'T>!+=K-TX\#1*<]@96@]X&TIB^UOT^&$WEF+
_ CT#F,:G5K\QU],:X'A@3C'K4$;4#_2U2.M_';_I(!:X6#\C<5P##+2GO:- ^P6V1"3[),#
#Z^WX2!?+!,/U/P?W<>94Y[4&Q I&9*M#),;ZJ8.#2/2M&7JN]48L%8"[F2[LQN&XW Y"6FS
=H<(W)>8=6EVT4X4&-HFLIW1SN(CM52) HK. )C$6,@18_\ &X#I8XH.K:T;_ CT#F,:G5K\
_)(ID=,2$+O\_';_I(!:X6#\=(*0GRIU&H=TK:5]OY][IPZM ]69( "H5R0#M"?;SQ)"O<&T
JUM'KT@ U;>K+FS*H9Y%DJHN+?"G1RB.<RDMY/AJF*Y_*,[DS2 E8E "A-K-$Q)E"=B<B,T3
:1FC%B&8]QUI,3Z=_JHQ:'(Q_HW:*I?&IX?^1;7/U!*#H@Y%"(GSL,PU&O<(OK#ZG44?:[>^
_HW:*I?&IX?^-IG[HF&4EILV"(GSL,PU&O<(X_M#<'9HLKKC8GJ9,2I,>BQB46LO)@C;2/I1
HGRCO25]C^>BD_3F-00-4G23:1FC%B&8]QUI_]?>ZLF1'X[_2E'=!)5.C]5*F/(^&9KT/<B8
A:M#N"[!VOB%&Q I&9*M#),;W,!C/)NK%$K<IQIV()RB%!:G_HW:*I?&IX?^2/$_$Z?8SZ-(
<^@WK&+C>/YSJU4A4*_4=,RK\.64P%#&&H[PLQN&XW Y"6FSI\[A0;(&%V&G''& \_ ZTVH<
6\-B--M5_,);N(E$VPABW0.X3I#<:5IOBN!.HGRCO25]C^>B\<O:*-C&1W#Q:1FC%B&8]QUI
_]?>ZLF1'X[_% SNU2.]9H 4F/(^&9KT/<B8CN"Z/76PI(>.&Q I&9*M#),;W,!C/)NK%$K<
80MA/%#_R?-A_HW:*I?&IX?^;".ERR=C2_5LT4X4&-HFLIW1SN(CM52) HK.-8_U IVOTM0U
XF8J.8;;)VSB/@@ (T+UY/T^<^@WK&+C>/YSE8+J56]BMKF5)FY\<Q))T)XFV6Q 8X\ 5(O9
&Q I&9*M#),;92Y]RL_FA49E&!'-+^87'<08$Z8Q13D&FLT3T'BBI&=Y5430)T#F:J_O"PPG
0W2HT.3G1G-#"(GSL,PU&O<(X_M#<'9HLKKC8GJ9,2I,>BQB@@P</A--BZ^":,7G$X]T0^-H
IDT2N,KCOZRFPC;UCVMB/8'"*Q3MDX@5??0K&Q I&9*M#),;W,!C/)NK%$K<J%:>&*/RS>FH
_HW:*I?&IX?^E&F;'J_X9:"4T4X4&-HFLIW1SN(CM52) HK.%56AA[=,N5D5XF8J.8;;)VSB
24X*F#\F"KI)*Q3MDX@5??0K&Q I&9*M#),;W,!C/)NK%$K<J%:>&*/RS>FH(:W 6K@M+K(A
, _'OU1XO<8P7FC(_%X+IX]>U(4^":I\Z8O4<^@WK&+C>/YS_R6-IL.9._;_7?HDY))%0HM=
G;+6'L1+_:&="(GSL,PU&O<("1#L4$URGZL) )C$6,@18_\ ][P=C5G^)3?WP_**X:8.N@+#
6:-9SC@XE5I9=V(2+2^IBM9W7?HDY))%0HM=G;+6'L1+_:&=6%"6*^2IACQ8%:[[6"9^7*$5
9*@B0Q05R<YD8GJ9,2I,>BQB5:Z2] O/M[%5LQN&XW Y"6FS.+P0HUZSP^4X<^@WK&+C>/YS
_R6-IL.9._;_7?HDY))%0HM=G;+6'L1+_:&="(GSL,PU&O<("1#L4$URGZL) )C$6,@18_\ 
][P=C5G^)3?WP_**X:8.N@+#6:-9SC@XE5I9=V(2+2^IBM9W7?HDY))%0HM=G;+6'L1+_:&=
6%"6*^2IACQ8%:[[6"9^7*$59*@B0Q05R<YD8GJ9,2I,>BQB5:Z2] O/M[%5-):.))D"(^XT
_HW:*I?&IX?^]0]YG<B7F KUF'DHZ-%5*(N8,C"6P?^LA_HR8GJ9,2I,>BQB+;58*UKL%T<M
<^@WK&+C>/YSZLJ_4L+1C.SJ7?HDY))%0HM=G;+6'L1+_:&=6%"6*^2IACQ8%:[[6"9^7*$5
,C"6P?^LA_HR8GJ9,2I,>BQB+;58*UKL%T<MX,9"&3^JXR#@#'5O(TMW7)0,?"!>&#^P[1)\
0&%:!,#*+\) MG6*=#R9S;&V*RKV>L@M_/$K=#@LRS\)-(ITF'DHZ-%5*(N8,C"6P?^LA_HR
8GJ9,2I,>BQB+;58*UKL%T<M<^@WK&+C>/YSZLJ_4L+1C.SJ7?HDY))%0HM=G;+6'L1+_:&=
6%"6*^2IACQ8%:[[6"9^7*$5,C"6P?^LA_HR8GJ9,2I,>BQB+;58*UKL%T<MX,9"&3^JXR#@
#'5O(TMW7)0,?"!>&#^P[1)\0&%:!,#*+\) MG6*=#R9S;&VDPX"4B:E]7J3KKA@80BH1G2N
O1MO_%-^!LZ];DNFG&<;B/MNT4X4&-HFLIW1^E4'.O,:');Z.$L.C2AOV2<XKKA@80BH1G2N
EB=*_PN;;=V62^1<"/*8\@Y+!-:N_Z\L4A0$%4$[%(2JK9$5JUM'KT@ U;>KXF8J.8;;)VSB
KKA@80BH1G2NTUM<74\9=Q?3$#JXJ'906>,0QP+0W3R/!DK'_';_I(!:X6#\Z2'D?HVPBI;I
KKA@80BH1G2N=4-Q)VTX@'UU#!N(%NMO*A0,Z,N9&2"G&VGHT4X4&-HFLIW1/>MOE*+*J;4]
_NPKLRR="Z#^KKA@80BH1G2NTVUJ[R$#:0_3;93U[!F1A>5M%4$[%(2JK9$5JUM'KT@ U;>K
@+RLHS)WY+2 $6$D+2Y]8/H15V2]N:?P\_]7)#Y4'&K[_Z$DKKA@80BH1G2N%S#1F=B+XW@7
Q-Q.>2!>"%?$H'[*'W[N,/^@<^@WK&+C>/YS%]!C=UTQ_8,7'2X.<>;OYBX=3J;\O@-X)EM.
9P1M6GAI%@UG*B4?5L_6LFDJ1%Y"XR(P499$XI#T$UZS>VKBKKA@80BH1G2N :P])0,_QJ$!
V$; <E S&.?8]S@ZXFYB2E;W:1FC%B&8]QUI@>@RMK\0A0Z!_\K6ACE&X6S_))CB#&9NYW,D
]DA.:"9@IVOVW-8VYR]%V?O<.=?EAL(TWEDYKKA@80BH1G2NT=\&LD,%.?#1!=-?A!/-#M %
:1FC%B&8]QUI@>@RMK\0A0Z!_\K6ACE&X6S_(G7\O[BO.N@BKKA@80BH1G2N.7]\E#1H["LY
1+8 @+R+-I)$ ZH"5G-;*4 #_';_I(!:X6#\=(*0GRIU&H=TK:5]OY][IPZMKKA@80BH1G2N
OQT1 -S.3DJ_/!/4!)Y>?!L\<^@WK&+C>/YSJU4A4*_4=,RK*+6BX9P,0.LHB60-$!/C[^2)
KKA@80BH1G2N@2F)]<QSCZ&!,H=(W/_\Z1(R6\-B--M5_,);XC[G]"WL #_B!/!U=W2K+R4$
-C%5NG2.8^PV(*=[<CTL$04@Q+N9P&WRC(K$KKA@80BH1G2NM$Y#3T9S<V2T<^@WK&+C>/YS
/B?)E#E.0_P^7ECTCS)(D#Y> [?T94QJH;8#($=7Z R=990@.M&V,Q@&MXLZS7-&#\AE2W'-
8(;)5SUT[_U@9[WA$]31P#%G?0UW\F%J@M%]E*?YN"KFW=J4?MHIPWBAR:E^PB#IVM?)'M;"
_"/"H!*\\2S\V86J[2&3>+#9G7?%:B-ZNF2==^[G,93 >O!WV@[I1\#FR#_:3QK,"XU_*XE/
3("1B3)G!99,<FX/?0%<2F9R5F9-WO7UOE]65F9-WO7UOE]65F9-WO7UOE]65F9-WO7UOE]6
5F9-WO7UOE]65F9-WO7UOE]6! 5"5&QVNZ8$:ZY^ ".OWW-K0>7VVY\W"9I!^)W^4Z!XD<_X
(S7Y):MC\VTC-5WB"E[>;_4U]@\N(/E9023VVOIZ_F,2/)O: IJ"4A'6_=0"&Z:D /QY1$P;
3T'( W697<U/T4,%.9$WN)31O%M9P@/+7K>\7J[%L=E%>"->C,AI3<M&64N,> E+&/CK\S)X
7?HDY))%0HM=*A/;)%U>SF8JP&"QT2^Y!%; $5ZW']4-CM017**^B$R:J;1<):PM1SZ>24<E
F1V>8U.9"5>9GU<:OWLR<#6?P&"QT2^Y!%; N/1Q-(KE6PFX&H.NP&Q0:.X:87S3:R%,C(5A
3@]#=N9AODM.JM71>)HJ-BVJ1LLSI"(12 ]&UMMI]?"P5N[67**^B$R:J;1<):PM1SZ>24<E
F1V>8U.9"5>9GHN'9L8(UM:>P&"QT2^Y!%; U++)SDW=F*742B>!>#5X98I*EV+%@\>1N;Z7
*+Z>>]*:XX,H2RNA@9@D@^!+MQ][>6_7$AJW%:[[6"9^7*$5,C"6P?^LA_HR;%:A80R)^OEL
7?U[HBKK&0Q=?4@/\A$TJ]%][:)6TQW[=D#M92Y]RL_FA49E>X%023,VP*)[,.)2(//CQ%\P
B:6^U8&-5I^)*?%%T-H39Z\I ?_4.V$+)2 !U6=R8;1.=GO5:A$A[EJB0:1JO@Z51P:Z^$J^
Z4)^0!J-I6WI$!L(8!?SY>D0H:"&-;7EWIZA_?F)>\D),O']&_#F4=O!9$H;GAI=1QIC/LN>
97L#P"Y&<GUE/5K+4_0L."\]/MB@&X"3G#<^R2;Z_:B"V)3)+9OX'<$) 9<MW0!2T#,0W([=
D=M,$ES4PQJ1]HNWUX#9XXKV$->&]_B3K?P0^B$+3O,J@>;ZU1H'&!K3*5#5&$V?K_S+ H<8
R"*I#>^:+?C(.*Y20BW238DX!]&-%W#<&U\')JD^XJ442RDF:9ZU'2+$I0QI/U,XX(COEM4_
DCW$'_A!@CZ28*%C;O/UZ:Q@X05JK9D%7"SAX2KBE'4.=&#A?&#*1"E:/+5\YWN-B.[]C8_G
+!Y:CUT4"HPLZ[JRKZ+Z;/SK8T"\65(#Q;EC>#1)6M2_3(!XN*WQPS3EY9.XDMNM(N*Z70>2
V7P64MZ'S'?9U&7X0?6ZGH+4"X/YWO!VTG4+&N;YHM<CN_H:3:!GWGZ_JB1-Q9:QI.TLB4S%
4!B>SM^4WGE0,L.>+GF/I1$RY".P.UR@H';DZA2U+S:/&2?J,L.>+GF/I1$RH&C_CY=AM>Z@
HF#@@ )#Y;*BI]U9FNX4$!VG\H1&TL+7@!7RQ<HAK)Z6V"+%%D[:S=J7_9 6[DGK,PQ5#B7N
)X/X;0BEWH GU)RJ$G9_*Y34\8.W$ZG+4WGQI.2&*=Z8[32D8\W,)LZU*8UC?IOF$)?*N:U^
'(?#"O"8!_ <W@U3%CWA*^?>;/52M=*=G%QL@Y^1MG(:"+F#4MXDP)8H"=%2LES<X?+!NAJR
-_KDA0#<ZK8WCOU<-W[+X$6.M)5_FKSA8.:TX82?5A9KW-?A2+9^+G2Z=%)(@I>E/.U%\;2"
$:Y/BMI@,_01"DO12OIR#-@*PN@S%A7IR/K"KFM0'MFJ96VNKFM0'MFJ96VNKFM0'MFJ96VN
KFM0'MFJ96VNKFM0'MFJ96VNKFM0'MFJ96VNKFM0'MFJ96VN+"HSUDG4[!XLE?)@@2FE6(^5
"F[K[;OY ?@*G(9LX%?:QCB<"B&"<&!0KSL*:9ZU'2+$I0QI/U,XX(COEM4_$@(C^K.J7W<2
HG8N[:OCK26BCJYLWE<C,CF.SRE6FL\<X/G/"Y+Z%37\5!8+%K((=7[%'TD6591<EI0Y@WA5
@:<<]':$FK*!Y=[4BU]L1<+E$\,B1X-DA7L3EC!B6R+Z%@:6I;20)E79G#NEP0F!62%?RQ/!
5$=2K#_+[GM4IC'<(S=5M/FF)1%0%KT!L70E196P$@>WTQ=%W"K,#&:(O$[<^UB31]SXA*7[
+)7?'$UATX$LZZJM5)\Y)F[KU[;JKU7#)EG7H$X%RO\9U#&@@\--TMS,0(&#!GW;K29(9Y\&
-#HX'W>^NHXTZK'J.O,RR'3JGX5;[]<*6H*?PY1_(Z69UWO#S&,!-.#/U5;,DK</1-OH8:&2
E?)@@2FE6(^5XD3@"+^FK(WBG[J&2]DHK[F?:JMJ\C8E$Z)J69UR;8BCCY-9:$!F72%+;I]H
Q8XY7O--2X'%Q.>WINY>U,O$]-)-$.!<3Z'T=?"&'0..^O%U%D[:S=J7_9 6UG.3M+6\IYG6
3:EG6<\%&(1-UQII,WM:3^;7Q3UPWB;?T^W%$'P&5?UO!2X0>>$-8D!]]JYY-\4N;%@W[UHW
]K_WM H@=B'VL8U]5'@K))^Q>>$-8D!]]JYY\%J+/6A-:K[P6;>N16:S?DU9D7\Y+6E5:#R1
\& VEAZ1E-3P:GT_0(+0,IAJ)6DKS_!L0WHE91)10+3SL99EV]W_ZO8'[3;;LK2O#A'N?+NR
,5BTYBW4LKXQ+7UK;5Y-L5 M=E;/S?P?#UEV10NJJ53#+P-%D$]%9"UB?8:0(J031QE +_LB
U)B;[QWOG?34U$Y*HU'+@O'44T?I2]=[C/)3<>I%>BRW;\QQWB-FM$- 9TO>H31C9)0GYB&A
10NJJ53#+P-%]F :KH+VMD?V(J031QE +_LBU)B;[QWOG?34!BLI5G>2%A8&4T?I2]=[C/)3
<>I%>BRW;\QQWB-FM$- 9TO>H31C9)0GYB&A#?C/N+)=1$H-F+<H^>9-Q(N8[ST='[=L%FSO
]S)XHX!K;#KW73#74T!W&+9=!J(;[XT["N@&@<UW+M=.$'>!4"9[-\D_K3U0WQ*R37*$DH/?
IH:X9<G&MU2F_]A89&)5%K7_GM8ZQH.\! :>]D]]1 -]UBKVQV]/0 +K&F;'38(I&4(Q<^Q-
0?8]J -7 +=!+NIA.<Q/WEXN-Z R8**XV_0W+A='!4XG@(<N G;PDZ1_D0(" X*]UXP/CKH#
*W;& JI#[U,K\],I= !B,$/SQX)_M5C&T@+'HH2S4_+S0%&B^S-'+)G/7S/[KKA@80BH1G2N
L22I_\B7/^FQ\32#+'N3S6CQ^25SV$UI:T[Y=TPD:(_]@C9W715KA+GWU-Q=INZW$TRAH)NF
@&%+/6/1I%V T/WC1D#,=BK0N^:#7  N%+V[KKA@80BH1G2NKKA@80BH1G2N8[)]8D:HD99C
J&H[H'$M4<"H61_U6[AXL_A9T;8XN;C9C9C1<@U\\7,?:+-R.8OCZN19/]8YKKA@80BH1G2N
LU77B2IE!?.S3U0GR_Q4O/5/>.D,D&ULH.-X-8C$0\8GY;4UEU/U7S$1&^^7Z )V+%'*@='H
D7\Y+6E5:#R1Y.#4L&\VIQKDL,6O"--IQZ:P5A8PAQ)O7M%691)10+3SL99E:ZH:_0*^8M9K
[R9G53KL *?OKKA@80BH1G2N"G%$[A?CY+0*##95R[::FM<,9>"?F=TEA9=EKKA@80BH1G2N
4&=^.0OUMK]0?B\'9@.\/UA^08GK7FSA"J9!K247?.1_5EJMF=#&\>W*QWF9\S+,^>BHOD3S
XF8J.8;;)VSBKKA@80BH1G2NSYUQ/\B_P,3/I=]<<++@9>>E)%D)]1_<B.DD .'LAJ1!(?, 
4Y1F,1K#C4-350C]UJ2E2J]5KKA@80BH1G2N9@5-"QDN##IFAZ\3NM&Q2R"'D=<S;"*QO>:1
>S827/+/1UQ[.U[Y[2M^3@L[YS7RJ@];)5'G)O/V80VSAQ0F!HW:);&WOM8&T%C2*?W4D"+0
H?10 L-QG!^A4\&5I,T4HP)340F6^J=G.191GI>9 *:++H^>R(B.JOBJ;Q[(X9F$MI,78PKA
V,M2WFE$(=K8%9WTX78V);T5G[J&2]DHK[F?G>W'[.JKM1"=!=E^PJO[U>8%NU%^Q'/7?N>[
#XEI0 +G-PT//K<!FX!;H.$^XR6Y+(QG*+SC-NH7!=(K+J8V"A:65W7@S&8**5BZ_(2C9R(I
AMT%UODT786&":^6R>>,*-H)\XZPA#,2%ICS5!U!Q4<$QV]4^QE2:3R_Q'?[\XZPA#,2%ICS
:V[_?O-1W8!KZEI>P3*I$QKJWG7T 41/R/7>QN6@&82(U/W&LK2O#A'N?+NR D!_2B:.$4T"
[>59@C)9:;+MJS-&J$@I862K33EASOA'+"%- _@6/B ( R8#&AHOADI]E<T:DNA0#(=FS<62
/<N@-QX(8S4]#Y2;J#Z^9_</F1#59C9J/6R90T>)B:#=8')#X2KBE'4.=&#A?&#*1"E:/+5\
YWN-B.[]C8_G+!Y:CUT4"HPLZ[JRKZ+Z;/SK8T"\65(#Q;ECGSE>O]GIUP*?1,"I$-DSN)1$
J'N.="^F>#RHUBYOQ#D2_C'69N)Q1P%\EF=FY'%?\J)G4_ODGJ3C":2-JRB>)Z+M$'V(8"(G
;LJ73+(U@_MN %@JXA?]#MP ?A2-'@9'/=U^)Y!)T5PQ;APGK0/RM:WV@!&M']V)".AUA6D?
?A2-'@9'/=U^)Y!)T5PQ;APGUQII,WM:3^;7Q3UPWB;?T^W%$'P&5?UO!2X0>>$-8D!]]JYY
-\4N;%@W[UHW]K_WM H@=B'VL8U]5'@K))^Q>>$-8D!]]JYY\%J+/6A-:K[P6;>N16:S?DU9
D7\Y+6E5:#R1\& VEAZ1E-3P:GT_0(+0,IAJ)6DKS_!L0WHE91)10+3SL99EV]W_ZO8'[3;;
LK2O#A'N?+NR,5BTYBW4LKXQ+7UK;5Y-L5 M=E;/S?P?#UEV10NJJ53#+P-%D$]%9"UB?8:0
(J031QE +_LBU)B;[QWOG?34U$Y*HU'+@O'44T?I2]=[C/)3<>I%>BRW;\QQWB-FM$- 9TO>
H31C9)0GYB&A10NJJ53#+P-%]F :KH+VMD?V(J031QE +_LBU)B;[QWOG?34!BLI5G>2%A8&
4T?I2]=[C/)3<>I%>BRW;\QQWB-FM$- 9TO>H31C9)0GYB&A#?C/N+)=1$H-F+<H^>9-Q(N8
[ST='[=L%FSO]S)XHX!K;#KW73#74T!W&+9=!J(;[XT["N@&@<UW+M=.$'>!4"9[-\D_K3U0
WQ*R37*$DH/?IH:X9<G&MU2F_]A89&)5%K7_GM8ZQH.\! :>]D]]1 -]UBKVQV]/0 +K&F;'
38(I&4(Q<^Q-0?8]J -7 +=!+NIA.<Q/WEXN-Z R8**XV_0W+A='!4XG@(<N G;PDZ1_D0("
 X*]UXP/CKH#*W;& JI#[U,K\],I= !B,$/SQX)_M5C&T@+'HH2S4_+S0%&B^S-'+)G/7S/[
KKA@80BH1G2NL22I_\B7/^FQ\32#+'N3S6CQ^25SV$UI:T[Y=TPD:(_]@C9W715KA+GWU-Q=
INZW$TRAH)NF@&%+/6/1I%V T/WC1D#,=BK0N^:#7  N%+V[KKA@80BH1G2NKKA@80BH1G2N
8[)]8D:HD99CJ&H[H'$M4<"H61_U6[AXL_A9T;8XN;C9C9C1<@U\\7,?:+-R.8OCZN19/]8Y
KKA@80BH1G2NLU77B2IE!?.S3U0GR_Q4O/5/>.D,D&ULH.-X-8C$0\8GY;4UEU/U7S$1&^^7
Z )V+%'*@='HD7\Y+6E5:#R1Y.#4L&\VIQKDL,6O"--IQZ:P5A8PAQ)O7M%691)10+3SL99E
:ZH:_0*^8M9K[R9G53KL *?OKKA@80BH1G2N"G%$[A?CY+0*##95R[::FM<,9>"?F=TEA9=E
KKA@80BH1G2N4&=^.0OUMK]0?B\'9@.\/UA^08GK7FSA"J9!K247?.1_5EJMF=#&\>W*QWF9
\S+,^>BHOD3SXF8J.8;;)VSBKKA@80BH1G2NSYUQ/\B_P,3/I=]<<++@9>>E)%D)]1_<B.DD
 .'LAJ1!(?, 4Y1F,1K#C4-350C]UJ2E2J]5KKA@80BH1G2N9@5-"QDN##IFAZ\3NM&Q2R"'
D=<S;"*QO>:1>S827/+/1UQ[.U[Y[2M^3@L[YS7RJ@];)5'G)O/V80VSAQ0F!HW:);&WOM8&
T%C2*?W4D"+0H?10 L-QG!^A4\&5I,T4HP)340F6^J=G.191DO.6N>TZD!R242[-6NG\E,I1
TTTN!W3WF\S3/\;%U'/$ =$_<TS)YA/50C)SGJ3C":2-JRB>GI $OI#_)C6>-' R#$&A(?@T
8LTJ/;.I7Q-BN8B#5^VO)K>YV(=_%-BNTL78O-@PT[%D (>\JYG)>1(WSE>K/>XXY1B36KL]
/C4_YD#(/D@^?];%JG# W[A_B^[?.H%WA[&+4@R0,OG+T[Q2. ;J&H1/$)DXB^[?.H%WA[&+
4@R0,OG+T[Q2M)5_FKSA8.:TRX=_RBD:/$;+AZX< ONG&C6'C284W1>^A0:-?DK"&5OJ@N]^
#+6*-6-.2&8,F0T]<P8XR>*956 G))7B@RA5*Q>)N#IJ.A<KIO,TD%X7"+FFY@S/'] @6FGF
KFM0'MFJ96VNKFM0'MFJ96VNKFM0'MFJ96VNKFM0'MFJ96VNKFM0'MFJ96VNKFM0'MFJ96VN
KFM0'MFJ96VNKFM0'MFJ96VN20H!LP!"Y2U)2X4FU3P,[$=+@?(^:9Q4R)B!2*KZ^/PV.9I(
DWM:M^T#>7&3_(;?]H2\.C?\2"765..UC>-(:ZY^ ".OWW-K0>7VVY\W"9I!K_AP$]^/#:&O
(9!,C?B/@&TA-/YCD4Q*;V,T(S7Y):MC\VTCZ-].W"C["?_HV/I>8VH#3U;8/K*O_,GFN%4^
Y >1%E=Y*V/D(:W 6K@M+K(A, _'OU1XO<8P7FC(_%X+IX]>L$ VU/9[4S2PAFE@5O#\= &&
 )C$6,@18_\ WF'6<)PL$B_>2^4*Z0?8N 1+;"ITOXSB,Q!LE++6FR(_4=:4TV6J\Q6?26W3
#,G2N0)GKE ,2B>!>#5X98I*/J1:9"7\Y*P^%%B>_D,[G#P45ONPY]N*9@%6BVYIY-@F)OJ+
TV6J\Q6?26W37UY2-XPRQ'=?2B>!>#5X98I*$""C^AM9TD 0$0<*JGD#_D\1A::4BWB-PYJ%
5;HNY5Q?C+E5*J+CE0*%G)0JJLQ(]XQT)XVJ*O$$;1QD=*<JN!;7=IB+0\VX(:W 6K@M+K(A
, _'OU1XO<8P7FC(_%X+IX]>Y>&ZNT)*P3KEIS((B)72NY"G'_V?#^ J3Y\?0D9V*C);*$M"
 L*'3:X*F-("-(4SNL*4YT8T0^:3>4&ZE!9##A6-A$]YU@X.SFXN1Z/(4IC.HC(+T]@EB5NB
:'MQVMB\^GYH2B>!>#5X98I*5Y8QSEQYSR17D\AJOU+03":38.5C8J@:=D)@B:9\LB#ALT")
VHY(XZ\)_]/:)SH2)4SWR*(G"5EB@9 UFH\)WN%@=<<&7.3>%K((=7[%'TD6<@V0:Q60L7%R
2;JE4!%-.]E)8 K&:RUIB:Q@P&"QT2^Y!%; 9@5QBVL3 H5F )C$6,@18_\ =8-00+'S?TYU
+@)R8;BWJB8NH$X%$O:02QN@-M 5V_Z;VMDVOQ,)!X :0)Z_T4X4&-HFLIW1SN(CM52) HK.
BZ*18"_<H/6+I(D>*R"HNW*DZQ\"YI%LC'3K.B;_V3OY(JTZWW<CW(FWHG_?'OZ(4'AMSCH>
7N,*-Y[+MD=>G#'='B\^+H"<U^WBOXYQB6_7:1FC%B&8]QUIB-CMW^'+U**(:ZD%]00"'2IK
BW% BV&[HIJ+J5):0G;!?<RI"J@3&67+M,0*Z+K:@9GVG+OHFVT$['#,$]*;T4X4&-HFLIW1
SN(CM52) HK.BZ*18"_<H/6+I(D>*R"HNW*DZQ\"YI%LC'3K.B;_V3OY(JTZ.#(1I>J*M+PX
EE4C![&80;F6=E]^"T#+^R5VT4X4&-HFLIW1SN(CM52) HK.M/GGE^;,P06TXF8J.8;;)VSB
P1"R[QI,.,W!=4)X&WY:,01U<^@WK&+C>/YSM<O@*2"Y3LNUOC>13>Q6E^>^LQN&XW Y"6FS
1;R.HE/FAP1%LBPBXH'YALRR:1FC%B&8]QUI2W1ICNG#E#!+@+[PNMW</5: 9&R-H'ZWUT%D
_G\>3>@PL8[^:1FC%B&8]QUIC0/ U:A&CXV-^O794$.#L_;Z/Q*K6#V#:J<_7[6>65"D1=Y?
,H=(W/_\Z1(R6\-B--M5_,);"9<>)5&LKO()%5[/RGSB6Y<5&3YF)!%S)S\9.[E@K#+-JD4[
T>!+=K-TX\#1U.--&D>D$F_4D2SXSW@'GTZ1)FY\<Q))T)XF<YA;: 0GOD!S<^@WK&+C>/YS
JU4A4*_4=,RK0&%:!,#*+\) HW3I/32-QBNC@2F)]<QSCZ&!.2>59@.GI$DY6\-B--M5_,);
XC[G]"WL #_B:UK_OBS6SG9K_ CT#F,:G5K\T4X4&-HFLIW1^E4'.O,:');Z[A60A*!_RZ3N
/OK)E8NPW+L^M>1!C!"\"UJU&>4-Z47R)#P9Q#!3W:34Z'_$_';_I(!:X6#\>NK=UX]UD\YZ
*RKV>L@M_/$K6O245=Q^N51:&Q I&9*M#),;:B-XT_;]T/MJ*RKV>L@M_/$K0?K=AWS?6[Y!
&Q I&9*M#),;92Y]RL_FA49E&!'-+^87'<08XF8J.8;;)VSBL-?S_'T)5]"PT:U#WW<A0(31
_';_I(!:X6#\RGX<"/ ?OI7*V@2. FB,X;S:*+L6S=S,GZ@HU-/5_@?=QQS4T>!+=K-TX\#1
5KQ&;2,^1J!6XR\][:0'Z)?C*RKV>L@M_/$K8#NM)$%1>A!@"(GSL,PU&O<(X_M#<'9HLKKC
*/1?Y569?BPH)FY\<Q))T)XFYU5C<XNR%,'GT4X4&-HFLIW1SN(CM52) HK.XHU7@72RHS'B
XF8J.8;;)VSBU/P=;+XM?-[4UF=;02LME^W6_';_I(!:X6#\RGX<"/ ?OI7*R5U1M$A#4PS)
*+L6S=S,GZ@H22J0_Z_Y.4-)T>!+=K-TX\#15KQ&;2,^1J!6I,-O#@*KY4>D*RKV>L@M_/$K
O85%IU3(6@"]<^@WK&+C>/YSJU4A4*_4=,RK17P4@:[$1$-%LQN&XW Y"6FSIN-1<S'+K2"F
"(GSL,PU&O<(OK#ZG44?:[>^_HW:*I?&IX?^0DWVD<W(8L1"T>!+=K-TX\#1:#;B^YU;KJ!H
(%GGYE(68^@@WHIE;-S#+P#>1D?MS=/ME2=&E1,5:9OH],65D+Y5U'+KBOF0&Q I&9*M#),;
92Y]RL_FA49E&!'-+^87'<08$Z8Q13D&FLT3T'BBI&=Y5430)T#F:J_O"PPG7$N*A4_S_]]<
^4I<(8EM6%'YT>!+=K-TX\#1L4=QR;UA*+RQC7RG;/7;ME2-*RKV>L@M_/$K7'M;2J]WZZ5<
<^@WK&+C>/YSJU4A4*_4=,RK,UBJC'66D'PSLQN&XW Y"6FS=1\2T5P^!==U^4I<(8EM6%'Y
T>!+=K-TX\#1L4=QR;UA*+RQC7RG;/7;ME2-F+L4?@Y:TO68XY[ 2,W%"?SC('07;'4^C"4@
=B5?7V>FV6UV"(GSL,PU&O<(-G\#AT1J5DXV )C$6,@18_\ 6G1&24&TA<I:&Q I&9*M#),;
?"!>&#^P[1)\0&%:!,#*+\) JME*0(I$UZ*J;7XXU%MJ#B-MRI_?&0O&R!;*GT'D'=J4S"F?
 )C$6,@18_\ M''N<,0P4S>T/1"<XYVUNC ][:)6TQW[=D#M92Y]RL_FA49E&!'-+^87'<08
3[C[$7J)/,U/)FY\<Q))T)XFY"C3[9"-P,/D"(GSL,PU&O<(-G\#AT1J5DXV )C$6,@18_\ 
6G1&24&TA<I:&Q I&9*M#),;?"!>&#^P[1)\0&%:!,#*+\) JME*0(I$UZ*J;7XXU%MJ#B-M
RI_?&0O&R!;*GT'D'=J4S"F? )C$6,@18_\ M''N<,0P4S>T/1"<XYVUNC ][:)6TQW[=D#M
92Y]RL_FA49E&!'-+^87'<083[C[$7J)/,U/"J@3&67+M,0**RKV>L@M_/$KY3D>0F=XELGE
TGT2L9(38IK292Y]RL_FA49E&!'-+^87'<08:W(H=L-;:RYK"(GSL,PU&O<("1#L4$URGZL)
 )C$6,@18_\ M''N<,0P4S>T/1"<XYVUNC ]VZ[6#%DLDU;;92Y]RL_FA49E&!'-+^87'<08
:W(H=L-;:RYK6%"6*^2IACQ8%:[[6"9^7*$59*@B0Q05R<YD8GJ9,2I,>BQBDQ'+ W"01Y63
F/(^&9KT/<B89!R!&J-,HN-DTGT2L9(38IK292Y]RL_FA49E&!'-+^87'<08:W(H=L-;:RYK
"(GSL,PU&O<("1#L4$URGZL) )C$6,@18_\ M''N<,0P4S>T/1"<XYVUNC ]VZ[6#%DLDU;;
92Y]RL_FA49E&!'-+^87'<08:W(H=L-;:RYK6%"6*^2IACQ8%:[[6"9^7*$59*@B0Q05R<YD
8GJ9,2I,>BQB$P$\\HCLXV(3.#(1I>J*M+PXKKA@80BH1G2N*RKV>L@M_/$KF%Z!T:FB3ZJ8
<^@WK&+C>/YS98<AOOM3IXME0<1;=153AF)!KKA@80BH1G2NCKUJ!X@H$7*.^!N3E5/C%MCX
Z,N9&2"G&VGHT4X4&-HFLIW1/>MOE*+*J;4]W25QOVJ25=K=KKA@80BH1G2NNF)*"SR(/FFZ
;93U[!F1A>5M%4$[%(2JK9$5JUM'KT@ U;>KXF8J.8;;)VSBKKA@80BH1G2NT<);<<;2&K31
DF!A  >S1?Z24V!;'!%;?&A3<^@WK&+C>/YSE8+J56]BMKF5WI+$5M4NJK3>KKA@80BH1G2N
J\E")%RFA7>K<\@ U<DTI"MST4X4&-HFLIW1/>MOE*+*J;4]CTCV;=XUA8F/7O!4-J4NCZE>
>\8_ 00Y:D=[_:"O_>7H>*K]KKA@80BH1G2NB8'&7Y?LCRR)LUT4F_F7SM6SBW3%O1%;>YB+
"(GSL,PU&O<(KPHU=A"\PZ^ON'UA_DGPD"6X")]&!YF'*:@(2FS(=0L3J>-*QSZ%DX!ZA4_'
+-I8)EPPMA LC4Y_J.;?TA:-KKA@80BH1G2NW_-W-4*(ZZ7?<N8!2T^#E-!R!T#OD5&==FL'
_';_I(!:X6#\)^YO"W9RBK(G*+Z>>]*:XX,HQQ'> ]PH9TC'$6$D+2Y]8/H12YQAEP!@.;M+
L,6O"--IQZ:PG%-2&".GK>V<G$*R$N:];8^<!T#OD5&==FL'_';_I(!:X6#\)^YO"W9RBK(G
*+Z>>]*:XX,HW6S#.J2RWY7=KKA@80BH1G2N[I[Z(@:T"J/NGX5;[]<*6H*?,H=(W/_\Z1(R
6\-B--M5_,);XC[G]"WL #_B:UK_OBS6SG9KKKA@80BH1G2N ]69( "H5R0#Z[JRKZ+Z;/SK
"(GSL,PU&O<(X_M#<'9HLKKC8&>5CT1"()9@XF8J.8;;)VSBKKA@80BH1G2N<4TJN5GYE.9Q
T4X4&-HFLIW1SN(CM52) HK.Y?Y"]M2ZH-OE46LO)@C;2/I1KKA@80BH1G2NH2C#C"@Y&0JA
][2.C**I5HGW"(GSL,PU&O<(X_M#<'9HLKKC8&>5CT1"()9@XF8J.8;;)VSBKKA@80BH1G2N
K=VSPFXM_P.M@]J<ZW.UQ;.#;YO@B]R9NLQO:1FC%B&8]QUI9/?B:$1G;?9DBW% BV&[HIJ+
J5):0G;!?<RIR>%WD]4L;##)3< <&77NU.A-*PW/ Q.31?4KALTSRI\M)H.&;.E^5FRK "UL
A?T, SXXWIZ%S**$INJ$+3_,D\AJOU+03":3\!Z?H&GH<T'P_8#OD\?6[]#].#(1I>J*M+PX
78L.Y5RSG[I=4[%>PI4U;+)3HM]N$)3L)7FB/KS.R37**80^1&GT][,3\N%$5F9-WO7UOE]6
5F9-WO7UOE]65F9-WO7UOE]65F9-WO7UOE]65F9-WO7UOE]65F9-WO7UOE]6JK#SH4'L>UZJ
\87+@;Q6O.3Q\87+@;Q6O.3Q\87+@;Q6O.3Q\87+@;Q6O.3Q\87+@;Q6O.3Q\87+@;Q6O.3Q
\87+@;Q6O.3Q\87+@;Q6O.3QB1LD;S^%);>)#]3 $X(9%\T/M$!R"<P:J9^TPM!S=FI$#TW"
2Z-A1@]+6F=+=_=E2.E6:;1W[ 9E%"-.\?_L]D>4L:ZJ/_CVCVL2R(.S<3F/2J;9SU5O"WM*
F+L4?@Y:TO68XY[ 2,W%"?SC+9@1QZ-$8/,M):PM1SZ>24<E8]>8D32@V;UCGHN'9L8(UM:>
P&"QT2^Y!%; U++)SDW=F*742B>!>#5X98I*EV+%@\>1N;Z7XF8J.8;;)VSB%;Z+1AE:2XX5
HJY<I$M\Z)>BC'I"?CB60EF,2B>!>#5X98I*5Y8QSEQYSR17D\AJOU+03":3$&WGZWJ^OC@0
;\H/Z\)F%,]OJ>2(RTZU5&:IBC*.+]K!JCN*+FFL""A#CD$NXF8J.8;;)VSB%;Z+1AE:2XX5
HJY<I$M\Z)>BVRM;]>RJK4[;2B>!>#5X98I*I*AV\*^K]VRD:#;B^YU;KJ!HRF[JA^61(7S*
BF28E.;97LN*(G7\O[BO.N@B_>@WTM,%)VC]#'5O(TMW7)0,@GBF_Z_W$J*"N6!<']7KNHFY
?3B@A-P%\_M]MQ][>6_7$AJW%:[[6"9^7*$59*@B0Q05R<YD;%:A80R)^OEL2X78J1)YQN]+
UK<B9Q&T%RO6#0PE["]NE ,-T*BZV5U ^430@:A;BU\;1PJ!/NLZMFLCAVP^Y7I[?.S]1Y'E
KFM0'MFJ96VNKFM0'MFJ96VNKFM0'MFJ96VNKFM0'MFJ96VNKFM0'MFJ96VNKFM0'MFJ96VN
KFM0'MFJ96VN5]+.&VIK4<]7# 3<2*;U0!(,1D5D W:DT0]&<C"8TTNA"3AR&( YAMK9(9<8
D9J1B$(!A#F1H:"&-;7EWIZA_?F)>\D),O']&_#F4=O!9$H;GAI=1QIC/LN>97L#P"Y&<GUE
63+'#]Q9)I=9<2,EMH=>N_%QEW=C8750(JF7T)+YF:Y0X(_0SWBH#.J$3KO/KKA@80BH1G2N
*4E)-A(M<?8IAS\0HH3%O$V'A*5$X(WR (2$LES<X?+!NAJR-_KDA0#<ZK8W8.M10/7\30M@
!]EEB"#. HP'@I>E/.U%\;2"=B5_TQ^.U*5VW-VZTI8;YU_<IIV%@TRTI[6F=<) >0U1EL%U
S4>W3X\2,$G-:9ZU'2+$I0QI5"5T!XS2,N]4Z*(ME%<B(@CH@:<<]':$FK*!"^QP7.@_"4@+
7_H/HJ!>OHE?/!/4!)Y>?!L\0;^KD("W?()!UBYOQ#D2_C'6*3U?-/-/.2$IYM=5DS\,;<OF
3J;\O@-X)EM.HLOEJ9V V!6B['&KJ"I82"'LKDXT;=L-@ "N4]:VP;@UUH93
#pragma PXL encrypted end
#pragma PXL encrypted begin
@GWH&]A3( *"C&+FRV<TI@6,- =/?<'2JP0T_H]@M)X[T7'^_&(53YS)9H?\/9;;= VM4:P]
Y W^8 4G1Z#D1MT]T.<-]2!&
#pragma PXL encrypted end







#endif

#ifdef FILL_DM7

#pragma PXL encrypted begin
'K^^"'O>D@L>F5I:KFQ?. :9+"4KXWML#$ LAO =YN+J_/^&HNAXU +G&-"BH74 92#MMZNA
C:%!,0R$/1&-U#EHDB3-/\#4*%]>)%2%,ALHC'9&4<.^8)N,
#pragma PXL encrypted end


LAYER_DM7_MYBCELL_H : polygon_layer_s = {
    layer_spec = {
        output_layer_key = "OUTPUT_DM7_DMB_CONNECT"
    },
    polygons = MYBCELL_H
};

LAYER_DM7_MYBCELL_V : polygon_layer_s = {
    layer_spec = {
        output_layer_key = "OUTPUT_DM7_DMB_CONNECT"
    },
    polygons = MYBCELL_V
};

LAYER_DM7_MYBCELL_HEXT : polygon_layer_s = {
    layer_spec = {
        output_layer_key = "OUTPUT_DM7_DMB_CONNECT"
    },
    polygons = MYBCELL_HEXT
};

LAYER_DM7_MYBCELL_VEXT : polygon_layer_s = {
    layer_spec = {
        output_layer_key = "OUTPUT_DM7_DMB_CONNECT"
    },
    polygons = MYBCELL_VEXT 
};

// DUMMY SPEC : DM7_DMB_Connect
SPEC_DM7_DMB_CONNECT = unified_fill(
    fill_patterns = {
    {
        type = UF_POLYGON,
        polygon_fill = {
            insertion = {
                iterations = 3,
                shift_factor = 2,    
            },
            pattern_spec = {
#ifdef VERTICAL_M7
                space_x = DMY1B_SX,
                space_y = DMY1B_SY,
                stagger_x = DMY1B_OX,
                stagger_y = DMY1B_OY,
#else
                space_x = DMY1B_SY,
                space_y = DMY1B_SX,
                stagger_x = DMY1B_OY,
                stagger_y = DMY1B_OX,
#endif
            },
            layers = {
#ifdef VERTICAL_M7
                LAYER_DM7_MYBCELL_V
#else
                LAYER_DM7_MYBCELL_H
#endif
            },
#ifdef CONTROL_MAX_METAL_LENGTH
#else
            merging_layers = {
#ifdef VERTICAL_M7
                LAYER_DM7_MYBCELL_VEXT
#else
                LAYER_DM7_MYBCELL_HEXT
#endif
            },
#endif
#ifdef ANTPrevention                
#ifndef CONTROL_MAX_METAL_LENGTH
            merging_blockage_layer_list = {
                FORBIDDEN_RING
            },
#endif
#endif
#ifdef CONTROL_MAX_METAL_LENGTH
#else
#ifdef VERTICAL_M7     
            merging_direction = VERTICAL,
#else
            merging_direction = HORIZONTAL,
#endif   
            merging_length_limit = 500*(DMY1OR_L + DMY1B_SY) - DMY1B_SY, 
#endif
            fill_to_signal_spacing = {
    { CHIP_snps, min_space = DMY1B_CHIP, context = INTERIOR },
#ifdef FULL_CHIP
    { CHIP_BOUNDARY, min_space = DMY1B_CHIP, context = INTERIOR },
#else
    { PRBOUNDARY, min_space = DMY1B_CHIP, context = INTERIOR },
#endif
    { ICOVL_SINGLE, min_space = DMY1_ICOVL },
    { INDDMY, min_space = DM_INDDMY },
    { TCDDMY_M7, min_space = DM_TCDDMY_MX },

	{ BEOLBLK_FINAL, min_space = DMY1B_MY1 },
    { DM7EXCL_FINAL, min_space = DMY1B_MY1 },
    { CSR66_3485, min_space = DMY1B_MY1 },
    { M7_MAIN, min_space = DMY1B_MY1 },
    { DM7_O, min_space = 0.26 },
    { DM7, min_space = 0.26 },
    { DM7_GT1350, min_space = 0.45 },
    { M7_GT76, min_space = DMY1_MY1W1 },
    { M7_GT114, min_space = DMY1_MY1W2 },
    { M7_GT152, min_space = DMY1_MY1W3 },
    { M7_GT180, min_space = DMY1_MY1W4 },
    { M7_GT240, min_space = DMY1_MY1W5 },
    { M7_GT280, min_space = DMY1_MY1W6 },
    { M7_GT500, min_space = DMY1_MY1W7 },
    { M7_GT1350, min_space = DMY1_MY1W8 },
#ifdef FILL_M6_VIA6_M7_BTCD
              { BTCD_M6_V6_M7_E, min_space = BTCD_D },
#endif
#ifdef FILL_M7_VIA7_M8_BTCD
              { BTCD_M7_V7_M8_E, min_space = BTCD_D },
#endif

#ifdef FILL_M7_BTCD2
              { BTCD_M7_E, min_space = BTCD_D },
#endif
              { WRAPPER_DM7_O_L, min_space = DMY1B_DMY1O },
#pragma PXL encrypted begin
^$U00Q8:9@_XO<;OBHV<>U:]OE&IDKA_J-^^S2H84]%YL$W-A.V%,KSG*1.$A$,MD6H=EPZ$
1 SZD/<<E"M$W!Q$+6SF5 C<9[S_U3"UV&-GTI=;L(JX-+'2O,T0A/7.\LN\U1A:5WA8C1;5
CZWHJ2>0*G6/$*J,+-_!@V80>9&1U\"8<@!Y$7UD?AAJEM41V9$XG@SQKG79.3*LQ)\>VJ,Y
4#R,9T 4*A-0*>]N+%XKJ'TI:YZL+L2ZNPUK%NJ!.#@&2[\6
#pragma PXL encrypted end

                            
            },
            hierarchical_fill = false,
#ifdef VERTICAL_M7     
            cell_prefix = "DMB7VNEW"
#else
            cell_prefix = "DMB7HNEW"
#endif   
        }
    }
    },
    extents_output = {
        {
            output_layer_key = "OUTPUT_DM7_DMB_CONNECT_EXTENT"
        },
    },
    fill_boundary = {
        layer = CHIP_snps, 
        type = LAYER 
    },
	grid = vGRID
);
//=======================================================
DM7NEW_C     = SPEC_DM7_DMB_CONNECT["OUTPUT_DM7_DMB_CONNECT"][0];
DM7NEW_L     = SPEC_DM7_DMB_CONNECT["OUTPUT_DM7_DMB_CONNECT"][0];
//***** spec *******************************************************************
#pragma PXL encrypted begin
I<]V7;^^R%NECL\][ C8T5*./G91R40XQAD^_S>0M;'73_[_;K]B?^AYOQ%N +Q[Y[+R/"0 
8:;4"&7"RF1A"?]VQ&MX<JD)
#pragma PXL encrypted end

//***DM7_DMB***
// DUMMY SPEC : DM7_y1
PATTERN_SPEC_DM7_0 = get_single_polygon_pattern(
#ifdef VERTICAL_M7
	"DMB7V", "OUTPUT_DM7", DMY1B_W, DMY1B_L,
	step_x = DMY1B_SX, step_y = DMY1B_SY,
	offset_x = DMY1B_OX, offset_y = DMY1B_OY,
#else
	"DMB7H", "OUTPUT_DM7", DMY1B_L, DMY1B_W,
	step_x = DMY1B_SY, step_y = DMY1B_SX,
	offset_x = DMY1B_OY, offset_y = DMY1B_OX,
#endif
    FSS = {
    { CHIP_snps, min_space = DMY1B_CHIP, context = INTERIOR },
#ifdef FULL_CHIP
    { CHIP_BOUNDARY, min_space = DMY1B_CHIP, context = INTERIOR },
#else
    { PRBOUNDARY, min_space = DMY1B_CHIP, context = INTERIOR },
#endif
    { ICOVL_SINGLE, min_space = DMY1_ICOVL },
    { INDDMY, min_space = DM_INDDMY },
    { TCDDMY_M7, min_space = DM_TCDDMY_MX },

	{ BEOLBLK_FINAL, min_space = DMY1B_MY1 },
    { DM7EXCL_FINAL, min_space = DMY1B_MY1 },
    { CSR66_3485, min_space = DMY1B_MY1 },
    { M7_MAIN, min_space = DMY1B_MY1 },
    { DM7_O, min_space = 0.26 },
    { DM7, min_space = 0.26 },
    { DM7_GT1350, min_space = 0.45 },
    { M7_GT76, min_space = DMY1_MY1W1 },
    { M7_GT114, min_space = DMY1_MY1W2 },
    { M7_GT152, min_space = DMY1_MY1W3 },
    { M7_GT180, min_space = DMY1_MY1W4 },
    { M7_GT240, min_space = DMY1_MY1W5 },
    { M7_GT280, min_space = DMY1_MY1W6 },
    { M7_GT500, min_space = DMY1_MY1W7 },
    { M7_GT1350, min_space = DMY1_MY1W8 },
#ifdef FILL_M6_VIA6_M7_BTCD
              { BTCD_M6_V6_M7_E, min_space = BTCD_DY1 },
#endif
#ifdef FILL_M7_VIA7_M8_BTCD
              { BTCD_M7_V7_M8_E, min_space = BTCD_DY1 },
#endif

#ifdef FILL_M7_BTCD2
              { BTCD_M7_E, min_space = BTCD_DY1 },
#endif
              { WRAPPER_DM7_O_L, min_space = DMY1B_DMY1O },
#pragma PXL encrypted begin
J42T0:J<.PBIKGR7AT[P8..NJAI6YT71LN6J;5J*+.M1,\AMK' TYEES"3*L'.]CCM)84?(<
?Q_,"G*AC+9_]VFK^?A_]57W[ZYMF7DBXGOOI3'[![*EZ72E
#pragma PXL encrypted end

              { DM7NEW_L, min_space = DMY1B_DMY1 },
#pragma PXL encrypted begin
6WE@0W3X_65;X,8!Z>5V\&;@LEO"P$?\JU:R,%[).5,Q0)PP3[>"*X3)\$-/45-I)=^(W:)1
4L41#_9^?K12>4FJI]CDLYIY
#pragma PXL encrypted end

    },
	shift = 2,
	repeat = 3,
    starting_point = CENTER
); //end of get_single_polygon_pattern


//-------------------------------------------------------------------------------

//***DM7_DMS***
PATTERN_SPEC_DM7_1 = get_single_polygon_pattern(
#ifdef VERTICAL_M7
	"DMS7V", "OUTPUT_DM7", DMY1S_W, DMY1S_L,
	step_x = DMY1S_SX, step_y = DMY1S_SY,
	offset_x = DMY1S_OX, offset_y = DMY1S_OY,
#else
	"DMS7H", "OUTPUT_DM7", DMY1S_L, DMY1S_W,
	step_x = DMY1S_SY, step_y = DMY1S_SX,
	offset_x = DMY1S_OY, offset_y = DMY1S_OX,
#endif
    FSS = {
    { CHIP_snps, min_space = DMY1S_CHIP, context = INTERIOR },
#ifdef FULL_CHIP
    { CHIP_BOUNDARY, min_space = DMY1S_CHIP, context = INTERIOR },
#else
    { PRBOUNDARY, min_space = DMY1S_CHIP, context = INTERIOR },
#endif
    { ICOVL_SINGLE, min_space = DMY1_ICOVL },
    { INDDMY, min_space = DM_INDDMY },
    { TCDDMY_M7, min_space = DM_TCDDMY_MX },

	{ BEOLBLK_FINAL, min_space = DMY1S_MY1 },
    { DM7EXCL_FINAL, min_space = DMY1S_MY1 },
    { CSR66_3485, min_space = DMY1S_MY1 },
    { M7_MAIN, min_space = DMY1S_MY1 },
    { DM7_O, min_space = 0.26 },
    { DM7, min_space = 0.26 },
    { DM7_GT1350, min_space = 0.45 },
    { M7_GT76, min_space = DMY1_MY1W1 },
    { M7_GT114, min_space = DMY1_MY1W2 },
    { M7_GT152, min_space = DMY1_MY1W3 },
    { M7_GT180, min_space = DMY1_MY1W4 },
    { M7_GT240, min_space = DMY1_MY1W5 },
    { M7_GT280, min_space = DMY1_MY1W6 },
    { M7_GT500, min_space = DMY1_MY1W7 },
    { M7_GT1350, min_space = DMY1_MY1W8 },
#ifdef FILL_M6_VIA6_M7_BTCD
              { BTCD_M6_V6_M7_E, min_space = BTCD_DY1 },
#endif
#ifdef FILL_M7_VIA7_M8_BTCD
              { BTCD_M7_V7_M8_E, min_space = BTCD_DY1 },
#endif

#ifdef FILL_M7_BTCD2
              { BTCD_M7_E, min_space = BTCD_DY1 },
#endif
              { WRAPPER_DM7_O_L, min_space = DMY1S_DMY1O },
#pragma PXL encrypted begin
=>%S/(:GP&9U2%!)3:3)O:5(+K-Y;&YLD%,NUA,*/6,_X&W6&M_%UDT\T'D:6)]>N^.)/D!8
A>=(!AN2GN:%2[+PE"_K^)U+1;4.V3"FY!5%7? T:2^M5BY=
#pragma PXL encrypted end

              { DM7NEW_L, min_space = DMY1S_DMY1 },
#pragma PXL encrypted begin
\:*I3AO^4FKQ&/ID/ KLFA<8C0K!!,\%EC>-<@![AXWS):MR>2>ZR.M5A#UY/QH15R!(DU8_
*?>LSO_J=%(I_"N->U:9JD+\
#pragma PXL encrypted end

    },
	shift = 2,
	repeat = 3
);


//***DM7_O_R***
PATTERN_SPEC_DM7_2 = get_single_polygon_pattern(
#ifdef VERTICAL_M7
	"DMOR7V", "OUTPUT_DM7_O", DMY1OR_W, DMY1OR_L,
	step_x = DMY1OR_SX, step_y = DMY1OR_SY,
	offset_x = DMY1OR_OX, offset_y = DMY1OR_OY,
	setback = DMY1OR_SC,
	setback_type = INTERSECTION,
#else
	"DMOR7H", "OUTPUT_DM7_O", DMY1OR_L, DMY1OR_W,
	step_x = DMY1OR_SY, step_y = DMY1OR_SX,
	offset_x = DMY1OR_OY, offset_y = DMY1OR_OX,
	setback = DMY1OR_SC,
	setback_type = INTERSECTION,
#endif
    FSS = {
    { CHIP_snps, min_space = DMY1_CHIP, context = INTERIOR },
#ifdef FULL_CHIP
    { CHIP_BOUNDARY, min_space = DMY1_CHIP, context = INTERIOR },
#else
    { PRBOUNDARY, min_space = DMY1_CHIP, context = INTERIOR },
#endif
    { ICOVL_SINGLE, min_space = DMY1_ICOVL },
    { BEOLBLK_FINAL, min_space = DM_BEOLBLK },
    { CSR66_3485, min_space = DM_BEOLBLK },
    { INDDMY, min_space = DM_INDDMY },
    { DM7EXCL_FINAL, min_space = DM_DMXEXCL },
    { TCDDMY_M7, min_space = DM_TCDDMY_MX },
    { M7_MAIN, min_space = DMY1OR_MY1 },
    { DM7_O, min_space = DMY1OR_DMY1O },
    { DM7, min_space = 0.2 }, //DMn.S.3.5
    { DM7_GT1350, min_space = 0.45 },
    { M7_HOLE, min_space = 0 },
    { M7_GT76, min_space = DMY1_MY1W1 },
    { M7_GT114, min_space = DMY1_MY1W2 },
    { M7_GT152, min_space = DMY1_MY1W3 },
    { M7_GT180, min_space = DMY1_MY1W4 },
    { M7_GT240, min_space = DMY1_MY1W5 },
    { M7_GT280, min_space = DMY1_MY1W6 },
    { M7_GT500, min_space = DMY1_MY1W7 },
    { M7_GT1350, min_space = DMY1_MY1W8 },
    { M7_45, min_space = 0 },
    { VIA6_HVN_5V, min_space = DMY1_VY15V },
    { M7_HVN_5V, min_space = DMY1_MY15V },
    { VIA7_HVN_5V, min_space = DMY1_VY15V },

              { R7_VIA6_CHK_REGION, min_space = 0 },
              { R15_VIA7_CHK_REGION, min_space = 0 },

              { S22_M7_REGION, min_space = 0 },
#ifdef FILL_M6_VIA6_M7_BTCD
              { BTCD_M6_V6_M7_E, min_space = BTCD_DY1 },
#endif
#ifdef FILL_M7_VIA7_M8_BTCD
              { BTCD_M7_V7_M8_E, min_space = BTCD_DY1 },
#endif

#ifdef FILL_M7_BTCD2
              { BTCD_M7_E, min_space = BTCD_DY1 },
#endif
              { WRAPPER_DM7_O_L, min_space = DMY1OR_DMY1O },
#pragma PXL encrypted begin
>/&I)I:W=1]X3TBD(/Z"L"Q/6-FP:Z94H.E8B'O-^T#K()*(??M:9D)_'>)]JB#VT!SZD?^J
YY:Q)L3EHC'GX]2A4@'1E5/C7Y?FSP*VW"A?)$$@<(2VC20D
#pragma PXL encrypted end

              { DM7NEW_L, min_space = DMY1OR_DMY1 },
#pragma PXL encrypted begin
*B96*& 3.'TJM=M&0+( MZ:U",Y J($*O_4(@-(>M2DE3[6 F\*KWH)EE[J;.CA@"L9(J[TZ
)UA(\5Q"V"@G:.#PC67?=[-H
#pragma PXL encrypted end

	},
    shift = 2,
	repeat = 3,
    starting_point = CENTER
);

#ifdef VERTICAL_M7
PATTERN_SPEC_DM7_2.polygon_fill.pattern_spec.pattern_spacing = {
    allowed_spacing_x = { >= DMY1OR_SXA2 },
    allowed_spacing_y = { >= DMY1OR_SY },
    extension = INTERSECTION
};
#else
PATTERN_SPEC_DM7_2.polygon_fill.pattern_spec.pattern_spacing = {
    allowed_spacing_y = { >= DMY1OR_SXA2 },
    allowed_spacing_x = { >= DMY1OR_SY },
    extension = INTERSECTION
};
#endif




//-------------------------------------------------------------------------------
//***DM7_O_W***

PATTERN_SPEC_DM7_3 = get_single_polygon_pattern(
#ifdef VERTICAL_M7
	"DMOW7V", "OUTPUT_DM7_O", DMY1OW_W, DMY1OW_L,
	step_x = DMY1OW_SY, step_y = DMY1OW_SX,
	offset_x = DMY1OW_OY, offset_y = DMY1OW_OX,
	setback = 0.114,
	setback_type = INTERSECTION,
#else
	"DMOW7H", "OUTPUT_DM7_O", DMY1OW_L, DMY1OW_W,
	step_x = DMY1OW_SX, step_y = DMY1OW_SY,
	offset_x = DMY1OW_OX, offset_y = DMY1OW_OY,
	setback = 0.114,
	setback_type = INTERSECTION,
#endif
    FSS = {
    { CHIP_snps, min_space = DMY1_CHIP, context = INTERIOR },
#ifdef FULL_CHIP
    { CHIP_BOUNDARY, min_space = DMY1_CHIP, context = INTERIOR },
#else
    { PRBOUNDARY, min_space = DMY1_CHIP, context = INTERIOR },
#endif
    { ICOVL_SINGLE, min_space = DMY1_ICOVL },
    { BEOLBLK_FINAL, min_space = DM_BEOLBLK },
    { INDDMY, min_space = DM_INDDMY },

    { DM7EXCL_FINAL, min_space = DM_DMXEXCL },
    { CSR66_3485, min_space = DM_BEOLBLK },
    { TCDDMY_M7, min_space = DM_TCDDMY_MX },

    { M7_MAIN, min_space = DMY1OW_MY1 },
    { DM7_O, min_space = DMY1OW_DMY1O },
    { DM7, min_space = 0.2 }, //DMn.S.3.5
    { DM7_GT1350, min_space = 0.45 },
    { M7_HOLE, min_space = 0 },
    { M7_GT76, min_space = DMY1_MY1W1 },
    { M7_GT114, min_space = DMY1_MY1W2 },
    { M7_GT152, min_space = DMY1_MY1W3 },
    { M7_GT180, min_space = DMY1_MY1W4 },
    { M7_GT240, min_space = DMY1_MY1W5 },
    { M7_GT280, min_space = DMY1_MY1W6 },
    { M7_GT500, min_space = DMY1_MY1W7 },
    { M7_GT1350, min_space = DMY1_MY1W8 },
    { M7_45, min_space = 0 },
    { VIA6_HVN_5V, min_space = DMY1_VY15V },
    { M7_HVN_5V, min_space = DMY1_MY15V },
    { VIA7_HVN_5V, min_space = DMY1_VY15V },

              { R7_VIA6_CHK_REGION, min_space = 0 },
              { R15_VIA7_CHK_REGION, min_space = 0 },

              { S22_M7_REGION, min_space = 0 },
#ifdef FILL_M6_VIA6_M7_BTCD
              { BTCD_M6_V6_M7_E, min_space = BTCD_DY1 },
#endif
#ifdef FILL_M7_VIA7_M8_BTCD
              { BTCD_M7_V7_M8_E, min_space = BTCD_DY1 },
#endif

#ifdef FILL_M7_BTCD2
              { BTCD_M7_E, min_space = BTCD_DY1 },
#endif
              { WRAPPER_DM7_O_L, min_space = DMY1OW_DMY1O },
#pragma PXL encrypted begin
FX& :[3["EZ;(3XG/9,C6L@AV6IQ4;(&[D?9W1FUHD+"KZ'=M )U8-QDR8FT^S:^ME]QY3K[
=II)HAU J@IV:-<L&?**ODEH0$4FCDRK0+- I/)#<5-9M6BD
#pragma PXL encrypted end

              { DM7NEW_L, min_space = DMY1OW_DMY1 },
#pragma PXL encrypted begin
7O9\&H1QO7Y>;T\0;I>[ZB9O"=AQG>6(8F0)[^)I6Y<Z\/_OI>HVU9SRR8.EV\PD]=+2;2O;
HNVDOIS)6F.BUSILB=<8GPC7
#pragma PXL encrypted end

	},
    shift = 2,
	repeat = 3,
    starting_point = CENTER
);
//=======================================================
PATTERN_SPEC_DM7_0.polygon_fill.pattern_spec.other_pattern_spacing = {
    1 => > DMY1B_DMY1,
    2 => > DMY1B_DMY1,
    3 => > DMY1B_DMY1,
};

PATTERN_SPEC_DM7_1.polygon_fill.pattern_spec.other_pattern_spacing = {
    0 => > DMY1S_DMY1,
    2 => > DMY1S_DMY1,
    3 => > DMY1S_DMY1,
};

PATTERN_SPEC_DM7_2.polygon_fill.pattern_spec.other_pattern_spacing = {
    0 => > DMY1OR_DMY1,
    1 => > DMY1OR_DMY1,
    3 => > DMY1OR_DMY1O,
};

PATTERN_SPEC_DM7_3.polygon_fill.pattern_spec.other_pattern_spacing = {
    0 => > DMY1OW_DMY1,
    1 => > DMY1OW_DMY1,
    2 => > DMY1OW_DMY1,
};

SPEC_DM7 = unified_fill(
    fill_boundary = {
        layer = CHIP_snps,
        type = LAYER
    },
    fill_patterns = {
        PATTERN_SPEC_DM7_0,
        PATTERN_SPEC_DM7_1,
        PATTERN_SPEC_DM7_2,
        PATTERN_SPEC_DM7_3,
    },
    boundary = ALIGN,
	grid = vGRID
);

//***** fill *******************************************************************
DM7_C   = SPEC_DM7["OUTPUT_DM7"][0];
DM7_O_C = SPEC_DM7["OUTPUT_DM7_O"][0];

#pragma PXL encrypted begin
U 0M1?D0\'#4O*WL7%*O=NF\\LE;ZN]>XE'R.!4;<[!IV8@XPLRYZ]U6"A?"@;8-^D4Z-4>!
BV<CR'*@>0V+Z-C%VK]@CPKH[F1"':+Y#.+NG$B8HN)B>26<
#pragma PXL encrypted end

#pragma PXL encrypted begin
4,9B5XYG@G10\C2O9P3G(A?RCHYY>C9];P:.ABNMYGV7T36&,QNGW@D/>L\S,@V[S?$#H9HR
KJU5W07[*^.NE"A<60%B*\V47R]A- VGQE1?5H-X) ,P #U6
#pragma PXL encrypted end
#pragma PXL encrypted begin
RX>8:22^%'C+5K'XB$S>G=E6QZXL3[L$&DO'E^P#RR.I:ZB7CBT!7D5)]O..4B6*+V)1G3-2
:T#:%XX]'IEKG7K96 )=2V"=FM>.R@E+.(2:L79;:]"[M9^Q">.WE]S-K>D).XKSE99+6(@[
#pragma PXL encrypted end
#pragma PXL encrypted begin
$-97#(4/=R$0OO;9+J:9!C"^,?,H]-8+^+LQ3Q?EB]B4^G9/(.""3A<A7%,@EI%&&_$9SQ>6
_.=)GT;CFZ;\
#pragma PXL encrypted end
DM7_O_L = SPEC_DM7["OUTPUT_DM7_O"][0];
#pragma PXL encrypted begin
'[&@/[%;J7 ?I\NJVNM^X*JGI)K^"$Z2M<NDXRR6NYG JD?C!7>CL+#G&V,%P)L<' R[Q_G 
?ERCLUE!BX5^Z:-AR^@137OI
#pragma PXL encrypted end
#pragma PXL encrypted begin
9/]?8A*M"QIDD$>5X9;:V'>0.ZRK4,71"Z$[J+P (Z..[0&H\'\EG>@A(>_P4+F:5U>P31!0
[C' A,=P:8#N4FY2+M "*%%2NY&_:3UBB,B[^, U)?H_6G7XH1["5&CPD46A;G.&R<%8#N)N
$T5_4@8QXJ83
#pragma PXL encrypted end
#pragma PXL encrypted begin
3*>"4Q$._E%,J\7O%%R"=.NKQE:D>NAJ+Z3&[=2XL'S2D,_M;8[PW\UL_A9MT\%#2<KKEO_3
F3PPETR*7HF90@.0FAR].1M""3BLV:O5K!T)<O]5,(*^6K]R
#pragma PXL encrypted end
DM7_L1   = SPEC_DM7["OUTPUT_DM7"][0];
DM7_L = DM7_L1 or DM7NEW_L;
#pragma PXL encrypted begin
6X++!CU:,"%;+U?S9?/>VXHO+.U-PX;0,BLLO];F_AV[9TZ_=7:#"N_7 L!UUP5?W7+]VV77
GLY4R:MSA_.>*RG[_9(0 _8KS9MWZ_*-"8_-(ZIG9$R=. XCXK\X#4B'AF3BE(,J5RZR%9R4
LRL5GYK9@>.S
#pragma PXL encrypted end


#pragma PXL encrypted begin
'??'-0[0XD$=QU;>U->7OT_'L-)<4S[<3@&P:^[*F[ZX],-K? LA_"EYO=Y\071?]_3T;.E!
!/:= Q=YL<,$*^QA=%P_UUHK *6H?VN37<$ 2*<Y??_T7WI(
#pragma PXL encrypted end
#pragma PXL encrypted begin
8D6'6&\A16MB@SY=SWBY_+&#S03ID*F1N0[-!1CC3R4:&W\%E<?KTQH7YV&5XYY3>RW=5VKC
INJ&)6@Z;A.F4V5]UB%&'AQ3G39(E3FKB?>=/R\7-?ATF?T_0,TG^W8NN<1 A%1SK!K(=P&$
QIL1^96RSP3&1S8N@LU=],!'P6\I1LP0K=+!6J2J?Y07WFA:'^Y[JN\D>4 ?U;=SA3"G*N35
%X2""]T5J(47#.WO!3Z'^4(,WC4R;'R +?C> L"9Y\F)!)$"]$&TM]TU<U3T_>>,K&N3I[S]
1("_NE+W"*Y$T9^*D^[R[K+1!\H(8-_AMR@'..M/4]W"&Y<X@X13@[(<'OB#"K04 ,G">ST*
M0N=B+'H7$NU#W[*&1Z#ZR8/3X[_IL45<@Y/_>))@1Q:8LG]V(.-EO['\9/8( 3@94U\*;<@
7T".NI$40_]?0CE[/H5]W_M"9]<+_28"&+]G3X[_IL45<@Y/S@M-I4PU:4[.V(.-EO['\9/8
Z_P<_OI[\.SK6OM@6U).(?9:Z?5C@%(Q#67I'O[U^ [F.BT>,+_;V=^"OW0P3!B9"O.$*"5,
PL!<ZE5A?KO"0;W' N@O]&Q!<WKICBOFIK1S_>>,K&N3I[S]1("_NE+W"*Y$0((*3'2<UC5 
? +5[D]LB--\Y@$S5T![(XWFY*SLK:N=^3SD,1-)N6*BY2HQI9ST1L#<9H2E,%C[]U8N?.LP
\F&<N4=T!%+RC:7$=FL&?1*-9QMO]X\C3VYGZ,175VYAJV/H..M/4]W"&Y<X)0"M0N;<[CLE
@C)'>7YX@_B"0((*3'2<UC5 ? +5[D]LB--\Y@$S5T![(XWF,F+]_T. 2VDR,1-)N6*BY2HQ
I9ST1L#<9H2E,%C[]U8N?.LP\F&<N4=T!%+RC:7$=FL&?1*-9QMO]X\C3VYG[]/F.P[WQR7O
..M/4]W"&Y<XS=V^@^>&&F[-#34+CS%\XVL-JAXAI[$]MT"J4./09*:<CE]03'NEEE\Q.5E,
N+T0'#5.>;^X2MD-TELKIXE*N^ZFDZOQWUZ[_S^+_Y<SQ=;_P%2U-'I6_D? ET< BU?@A*R7
_R4R56FE_^'_R@5FC4?3>03*4Q+R6O8A7K=39,5$GZ.+PU)D:K23J3?/J=9J730A)Z&,HH1=
%8.0WUC HY 5PQ:F_ )5B2K#;O4%V9^=4NMN$.<R5ZP#9CD0?O,O]SDP/1U^>4W[K8RO69)Y
ZW[HA7B*<L?KYUAY@IU6J('G2MD-TELKIXE*N^ZFDZOQWUZ[_S^+_Y<SQ=;_P%2U-'I6_D? 
ET< BU?@A*R7W<;6 ?7*+&7=)+P1#J.Q/(4DD5VTF@BE&8R1OR23+DATIEF_2MD-TELKIXE*
!:;9CP<>MNL% ;*P\\I:BY$!8D0?)LYR:'-BH-"@SD]UO V@8+H+I&@.HH5@2,8"8=#"/JM(
<C.?@^6.\DART.I?SBY2HL?0DEC%%CAIY'J2UQWT4KK/^9#7730A)Z&,HH1=W 6*Y&N7XRK<
G24*8[?OO&F=7QF:=[FJ9]A?[PA9='.P\P+O730A)Z&,HH1=YHAR >-"> 'F64W)1Z/7A/)9
-FDO$AV8(V<V6D"ONUA!>9):EURP^7_=.1&7SR0?  ^;_Z;/HK8.(PO&12NBOQ<#]/,.KUJ_
3E;AS^!X]Z!.5I['OZX]F2I62R?PL:X\>PQ+(S"R/ECE.E<C2'<A(]/6'IM(@H6_7"'-A)J"
% ]_7ZNP",X48+H+I&@.HH5@2,8"8=#"/JM(RW=@'=7P_T?+#^,!#0Z3([T/-FDO$AV8(V<V
R*>PGP!+GUG(SR0?  ^;_Z;/WXYV7LTB$EC?W4U[*W >WRG==]0$#$6% 4-W:;9BA,N3PI)I
[PW405I\BB?OOT$3]H&1&1J_J;:D: ,QE8BI:4YQ>I;5V3!IT1LIVJ4K%AK1?3N%TN4FKDI]
<,]+<#YG+I)P\7PK>%.%SA3QC 9L>@S)E .,B)62"/)T/U*(R0OV2'P,'7C)F53)<,=(,].9
C 9L>@S)E .,)?BYIC,$XYLER0OV2'P,'7C)RL-RW1EM'"[*8?ED@]K$-.%A>G26=09XRD5Z
W+U_A["]$]O<57S;CQ?N@TM5<,]+<#YG+I)P;?Y?Q8)Y9O%M&+]H(/7XXN@8F>.O,WD@\UN9
!*CC5#G)M L$2R?PL:X\>PQ+##00-U,5O*\, &AQIULT0,< C 9L>@S)E .,R]\JP)N7HT_+
+5*^76&[<V(M'/6P.+AFUN0<O7%K>S?B$PN]@H6_7"'-A)J"2&ABT5L+VO-(1J7P:,-W3M]&
2MD-TELKIXE*#9LO"["A'%4-%IH\5T#8%Y@6W+U_A["]$]O<=>_],\A%;@QU<,]+<#YG+I)P
;?Y?Q8)Y9O%M)$.E/#;9!^,DF>.O,WD@\UN9V&G,PV%1H8S82R?PL:X\>PQ+##00-U,5O*\,
CR0KD/%\?UR/C 9L>@S)E .,$AH: FU#E^@28+H+I&@.HH5@2,8"8=#"/JM(BVCV$ 0;4&.+
T.I?SBY2HL?09/*0GD"/K8YD+5*^76&[<V(MT\JSEYI>EHO3KYYP#IBSR9VO>8;/'!DMZ")Y
2R?PL:X\>PQ+DN6QYT9SIS62%@%XW1?(!KP66'>I)F'B(PU8)KSP98&SO]XF'I(IF>:Z"]H>
R]*P"044RWW+R0OV2'P,'7C)RL-RW1EM'"[*8?ED@]K$-.%AYL[BQ?0QZCOF75SX+:&WG[M=
\3X#(W5]UE_Q^1S:N=E\Y4/Y<:S!XK-R&N-Q2R?PL:X\>PQ+##00-U,5O*\,*$UVM[+0RKHH
C 9L>@S)E .,UDE 1"1:A$C68+H+I&@.HH5@2,8"8=#"/JM(QCOA)TT'N0;&T.I?SBY2HL?0
2>5<-J M8(=)<:S!XK-R&N-Q2R?PL:X\>PQ+##00-U,5O*\,*$UVM[+0RKHH6;MT7%:&^599
04ZLXDK;UBY!0A(5^6U$"[I"F!U$:80FBZ^8+5*^76&[<V(M1_<LYOXLB+-'..M/4]W"&Y<X
%KO+1H&.B"D6R0OV2'P,'7C)\Z#TDT \ @KSRW=@'=7P_T?+2 -C)GL7_"9(X&<=OINBVCW@
(6>"&:>EL)@A)U55&JUO4MLG..M/4]W"&Y<X%KO+1H&.B"D6:;1DX#$\-K%I]FAB&V^Q,)CV
SGJYCYX0!:3.8?ED@]K$-.%A6"E!44%$]W-8@H6_7"'-A)J"PC=Q@D2!H''"+5*^76&[<V(M
1_<LYOXLB+-'..M/4]W"&Y<X%KO+1H&.B"D6R0OV2'P,'7C)\Z#TDT \ @KSRW=@'=7P_T?+
2 -C)GL7_"9(X&<=OINBVCW@(6>"&:>EL)@A)U55&JUO4MLG..M/4]W"&Y<X%KO+1H&.B"D6
:;1DX#$\-K%I]FAB&V^Q,)CVSGJYCYX0!:3.8?ED@]K$-.%A6"E!44%$]W-8?O,O]SDP/1U^
C 9L>@S)E .,EI6:?J;]>O"6"_O"TK+4(>T+)D.1%5/?>KLF8?ED@]K$-.%A_]LMOY8TS>;_
+5*^76&[<V(M)Y3P26V"/ELG..M/4]W"&Y<X%KO+1H&.B"D6:;1DX#$\-K%I]FAB&V^Q,)CV
)D.1%5/?>KLF8?ED@]K$-.%A_]LMOY8TS>;_R(62)7L(D\[([WZU;)W?_6#O_-Z>)QTS! C\
,#TX8V4A=MHP1L6[-(A<*(A&=8"4NG C&&IU@%U(X9L_1,. "_O"TK+4(>T+)D.1%5/?>KLF
8?ED@]K$-.%A_]LMOY8TS>;_+5*^76&[<V(M)Y3P26V"/ELG..M/4]W"&Y<X%KO+1H&.B"D6
:;1DX#$\-K%I]FAB&V^Q,)CV)D.1%5/?>KLF8?ED@]K$-.%A_]LMOY8TS>;_R(62)7L(D\[(
[WZU;)W?_6#O_-Z>)QTS! C\,#TX8V4A=MHP1L6[-(A<*(A&W<;6 ?7*+&7= Z>Y"0:F_1H#
+.^0B%,^>5XL$>!^7@8/\'H18+H+I&@.HH5@8IE;-TJ_=_EBD/,=L5W=IDZ0 Z>Y"0:F_1H#
F(%4_/5:L1^8I9L^'X902G*E5=#$1#)(+/%5OW5,(KG[<D>_[PW405I\BB?OT.I?SBY2HL?0
 Z>Y"0:F_1H#-L5]P8 ,]E V]6(I9<$03IKU"H8'U)>XM/H*+5*^76&[<V(MT\JSEYI>EHO3
/C @PU'X4SL^ Z>Y"0:F_1H#WD_:[1(?'3;>&S=)2)84G%8;8+H+I&@.HH5@SD0HG03$2@_.
B%LE*:<AY2Z(\8[JI1_OR^SQ$9JUZ1+-F:(1*MU,WAK_%K8J Z>Y"0:F_1H#8C@E^<$&\L!B
NYI\JKZM.WV[3![<?CTJ6VI,R0OV2'P,'7C)&:BN;_QMK>09;LF(0;A[8Q!N6F(2@\[+9\M:
]&,GAY,\#/[T23XO.5+W].A)7 >^7CP;(0=<6(V_]R^9;?=8 Z>Y"0:F_1H#3J=2:23!ATY.
_TF_5&+OL3#_?@+J7P4)/(1^SR0?  ^;_Z;/@(K 2Z"3^$" F#Z=95#<1&:8Y&S<^:R6R:KD
E*0W;HY!JAR43@TZZ&'5B[)./M"Y:Y9G,Q4^=.-8>Q=VU^9T8&MXJR#^3 =@?@+J7P4)/(1^
SR0?  ^;_Z;/@(K 2Z"3^$" F#Z=95#<1&:8<KAXJ\@BE)-R Z>Y"0:F_1H#S5EXRUNG"<K-
K&<T\B0/4&&L:H_KXLSKL"-J2MD-TELKIXE*WHBNFSNIUT;>!]]GID"M>/D' Z>Y"0:F_1H#
=]0$#$6% 4-WQBC.:D)V(/[&R0OV2'P,'7C)RL-RW1EM'"[*[^YSC:*VA4+OT.I?SBY2HL?0
 Z>Y"0:F_1H#AV>LFE?NA&6'8+H+I&@.HH5@2,8"8=#"/JM(+_53A&M^C-@O*D$X!H;_43XJ
X-50::7XD'+@:*$*K29<QX-H4 9-/-$$C<%0=.-8>Q=VU^9T&0E1,YT&8-L9R0OV2'P,'7C)
LIZC[9TKQ56R!=PT/6VWSB0%QD*RFSDX@KK&_[-9RHG940K_E>K4%"W@"9*5T.I?SBY2HL?0
R&:! @ZW9_C(F.^H$94J@;28_U<8$*[Q7(K_W.T"M!7]%=S<0HY0V* :SRY"7XRT8 3S?:1?
AP 7U4I%H\*' 5[(:#IL.A4!ME8E]XL?W<BV2?9!>,;X<35) &"27@E&8N  M 0T[*]ORL2T
E"T1L7KBX(J4ZV*<CZ<)0>KKBJ>H!%DFA_B*BJ>H!%DFA_B*BJ>H!%DFA_B*BJ>H!%DFA_B*
BJ>H!%DFA_B*BJ>H!%DFA_B*QE8F]323H_+&!'2L&-X02@X$E*_0OP+'(W*41/6- +5U4F5$
C2P/=B' 'O"-K_Y:2=N[U$*OPV]*#9"ECV[#BAXG6&H;0K&*79:URM3E6<==@EE\J$%G43B"
9)52W8R!EG9D!0E#"/'W6,H% ^#"2<+,JI8#"_/< /S6R,4+';5T&-@A4^T=EH<X+%M/_\J6
RW=@'=7P_T?+.N/_,LNY0. Z..M/4]W"&Y<X08+[IK>/31]!I4(5/*@#+)NEN_KK1!Q*AK:[
*/&VE^$S?>LH77A<WKVFJ(!=..M/4]W"&Y<X)0"M0N;<[CLE@C)'>7YX@_B"_J^J;RZ+&ZK^
P!9!U6/B!2K Z7R:PE'1<9?IBU*QV:W/Q&^+LJ?;-Z;'FY.RI4(5/*@#+)NEN_KK1!Q*AK:[
*/&VE^$S?>LHOO=[,OU0H)V^..M/4]W"&Y<XDZSI@9CT]7B3_BC6R5T-+[?^KAVXX9-_(\JN
0;W' N@O]&Q!!Y7K[UIV$5D'T++<9$/_IS+0G5M7Q/B@2-N=DN6QYT9SIS62DG5X,:EK59&2
@%G^-Y["[[Z K!^;C$T@G(ZL5'6FABY[IH)4BU*QV:W/Q&^+\%F<+@%LU/[PT?\9M<F <)_1
HS,^!Z$=BCJCJS=F)5@ (!RK/*V"N+IYG H\"#&*09E@ H((IP^>A^N$:2"GS;+B(<O6ON+-
7T'Z]H]X@6)?'7WY"[X%A&X=;TOU# EQAF!OW>#SA=7]J S=)3_H/V>1%9\EU^S-RYA%*)S7
]92H+\7#Q:SUK+!&BS%$\1VLJ7B<,OY;A6BI'??GL.Q=]J<=KY'.6^;P)>"OPT@E"K%#0QG#
>$'6L9-SC91X[T".B5H72A?OQQB+9E5\$]S'<4;Y+O!G&,]QU$FHZCKQO<[4G>4O$WG(Y(R=
2%H*9X!TPIA(+V1!/>'Z<\ OZN>YWHL-+;GJS0FE4]GLL:K-I9ST1L#<9H2E,%C[]U8N?.LP
D4^<U;$'>>21Y(,]H*MP_%3D(DT1/B2 6ZPB% ]_7ZNP",X43Y&GW\S/8DU/7X5CZB\;G&Y?
-(BJ/E\G\TXT?"G[CJ@-6ZQ\$@4A9V,@N1P2%XCL'/R;FG 72]BZ64J<*B]+2TL:O5D"\"=+
7#]P#U5]W+Y<9"(+'K$JLD=DU>L?W*Q)_'/5>(.73 DB!X5X:*T89_2[?VQH<,A$BB5S'\1P
A1ELU@5>H("%%_\_IF9)RI47<,A$BB5S'\1PN(6J5*L+',ZX%_\_IF9)RI476;MT7%:&^599
Z>/8=L.7[+[IVO(.M-S5NO3:$U4^W4/TU6T3D+LL?IIG;^20TK&*:.?1ISG2LY1LDXF]B92S
64"M('4N+Z!9%'I(@2A91-$4RMN07WBH&BW*J$' =\P,K<&HD4]=3$4<T>Z1N_JEQM#-*&B[
C8;YF7X+2N&-\7#O)VD$@(OQ6EG@&L!]"/):Q8R\5<$Z!V7%U$0*)%^L(+/44,T.@8*#H0E0
WI8?-.C'6C?>##/%][*#],@,C8;YF7X+2N&-Z'$[L5^]/Q7H=!=0#OPJ'\ATCENC#M%;4<6.
OT,S)Y.=?IZ_?U<C]$;V#QI_IO* MZK,:I>F2U$(9MG6[I-+2U$(9MG6[I-+2U$(9MG6[I-+
2U$(9MG6[I-+2U$(9MG6[I-+2U$(9MG6[I-+2U$(9MG6[I-+FCMMMD#M@M.:I:DK39O<U3*E
@UOY\&PH8/V#1S8N@LU=],!'Y)"MMY+>WM+DI9ST1L#<9H2EKX1( S0*@+FO90&@W%L6CO1E
I[N6$/''X)JGA0)P\3SD&5"%9=A]1J!PXK!ETGDWZ9QGA$32-(+O>SB]A@PT$E;&;6$Y'I 2
A8&GUI3/>K6%[!*--LY4_3KLR;RV<DPXIVO)^3A%NP"JP0#Y[3'1+L@\N*3M?P42"D&\.GU_
U>*T">S7!F35P"'SR)"1ZR+ 9B7A25V5N;5F9/SS7>UJS$5DL^>5WW ]<*.SP.+R8O.TBN; 
/:T&&364LEP]5U)LG:V,V3Q7T^N^E/13PF_3?TQ%SM.*ZDQ_\P72G:$.C6#SVK1&UA>UC"#:
ULI'B&J3&V#6@_T9(CI65>Z#VY4^=L-0;,?;0_9"SO]ZUAY#HWGV[5/A:GVC0^V&$%/0UQY#
I:DK39O<U3*EYW"/?VA$Z"+G6ZC7@>N3GRI;D !EJ)=AU5B0"V2:%*;.KL\+P$WK50\>@'+ 
N),7=8]Z!<BXVN?Q7_N^6<#:/TDK"AV#8#X_*F0*VRK]("<JTK&*:.?1ISG2ZZ<*OEDC[Y?K
N 3 1;46^G2X;1- Z6X;SGIM..C@0&P/W!XX%:QP(:0$G@L5.N@-EV'C_X@Z8S<4B1HEL5!C
:A$>3W@MZ:YJ)(SJ8[<JRT$D='CDT *=<%]T=!H[E$:$^H5T[3-$!O,N-5WMLJ70ZRJ*SD^R
4=<%W=-$UGM1#R39!?%9+B,/$P#B[=!]U9L3]<0[1FK5#37U[L"'&RA=(]GN>:7 T4)=KSQY
F3&I6& X9(R92>QP03EV^-5)TS*5BT @FL_35:3FOVT8#NQ5Y:[03B5L4H7ER/1B>Y/Z/'G(
'<OJ5=XO.:@=FV<]1X;%E8*;HE&=^\7-HZBB85;C=F:W^C-A,Q+^>M&V1KLS\:E"V2U//^;Q
5:3FOVT8#NQ5:8U)E=L*7VEIR/1B>Y/Z/'G('<OJ5=XO.:@=N*A,\1-Z#9.XHE&=^\7-HZBB
85;C=F:W^C-A,Q+^>M&V1KLS\:E"V2U//^;QSPWV\DO]M>K/DQ0;JD=M=GZ3@A9A9"0 T^V"
0.1HAH"\X 5 !T]-&&W?TO,'0.1HAH"\X 5 +#6RI_BM,^\LJ<80B6%2\FNIVS-%;9@("?';
S+[9>NPY,W+,98MKA9MIIUME:P'A^A68,:9K>&9B1CL%/<-X*U7O&$)!<?LKJ0H:G;\%2D>I
;1- Z6X;SGIM343-O-2,=UI-:K99J?#M)49J6GPPH/.!;<I:\!W-J,,=1+_P5,]*.XQ#')=4
^PPJ?[,)$*#[P95;:CG[A6;!8N7B,(DS4V9B]"B"QV4RR4/T?IU3]/=7;A!^ Z>Y"0:F_1H#
JJ-01":[.OVJMB-FNRIR0+*V_CZKM,WV?QO^?PHS4/EBW_%_TX'ARN$(N#S3B"]:<K\P%X:(
*;_29Z"(/X@I9\72K8-]719G/M"Y:Y9G,Q4^ Z>Y"0:F_1H# Z>Y"0:F_1H# >WO<51.\<8!
"\/0,!145_T+^=-[$_7-]NSY(ZU=-Y;T;%DC8;O7UVQ8\,AA2;/$+S)OIJY) Z>Y"0:F_1H#
^E(PTQ>T?S;Z(X7:(< !.80CUOCP<#V-X)_6T"2O_OUUJ$S0I":\6H4;3-BD3?R9.M1<3WI-
LJ70ZRJ*SD^R+UDBPIX^ &TO Z>Y"0:F_1H#\E$E\Q8$8++R^;AQP Y:I3'YG_]GEU'#R9B?
H(*)<AY'A92@ Z>Y"0:F_1H#.JZ:,=[ &.<ZP<:[-?2MJG?!,TZ)J.EG7BTS Z>Y"0:F_1H#
6Z3(^,LP/BQ;L)'Y9_DK,7NPC#R;A$DDI?.,SYC9@Y9<7N'/&=08F48F_I\9PU</1-J6,R[#
_+@H!7C "O7\ Z>Y"0:F_1H#AY!\Z4A-(6^'&!,>!";5Z/<8.5K8O3;P&^@Y,^+!V#;:K4XS
5:1"N_.\ B)5.MCK,I.OEK(ZKG33&^1#J<:N4%B!E2"R7/!02OXP)<L,F%M*H]/T2 YF\0NC
!08N<"(N4,4%&ZQ7IG*TIX\;V7+LF)NP.@[9DC,20$+1L-:22-;S>0D"%[M(>B-G#?%B([EZ
K@9%*8^15.RNL(X.KC3BR*NP9J%W(T<TH95F:M+_WYKA">)JF7H(20'JK^.9P0HJ-;.XSS[!
)AE\9^ET:?$FM@/5*6D\W02V6ZC7@>N3GRI;U=_&T^7*:OW5IDVU=3:^A@VF_"C#NPHX*,'\
1?G>+:HFN3]%>+E\)DNG1-YX?)_J_Y//9YY\HVI<WQ;<I+VCR,_;O@:3@M#(#72VD"A6O7 -
W98R 3YF'Z;="=)JT!3"Q%8)?UBS-G!2PQY_'"1A1>:+IP8<BQH$/GZNT2&+?UBS-G!2PQY_
'\Q'R)GTP4P?&80F.6:.;<L97,U;9\$Q;G-<?/2O36H[*2A\D:^^4_LZ-9V1IZ+9C^OC!M6G
B"+Y4^N3LIF(K_82[GBM3=BO0I];,S24HA!"VN?Q7_N^6<#:"5AL#6QW1[ )^BA2<(>#H/+Z
//E*,\VGG\L\DF%5<$;;PN62\0[MS'HV! ;QW&^:)<<E"K'<% ]_7ZNP",X43Y&GW\S/8DU/
7X5CZB\;G&Y?-(BJ/E\G\TXT?"G[CJ@-6ZQ\$@4A9V,@N1P2HDEVNLO( 1:BE>**R)[1!">5
-EOS5L)Z&%TVEOROSC#E\AN6I\=;?FAEPBVG!%<!Z,*9*J8$ :._;K;/((4!#9&EA0_=<*\-
0J6TL)25XI!"[.A_5ZE(Y=7L19O2E:SU]I%% LL,4(1GLD,"V,C-VDWI"GO8CO]KQ()Y6 6.
19O2E:SU]I%% LL,4(1GLD,";1- Z6X;SGIM..C@0&P/W!XX%:QP(:0$G@L5.N@-EV'C_X@Z
8S<4B1HEL5!C:A$>3W@MZ:YJ)(SJ8[<JRT$D='CDT *=<%]T=!H[E$:$^H5T[3-$!O,N-5WM
LJ70ZRJ*SD^R4=<%W=-$UGM1#R39!?%9+B,/$P#B[=!]U9L3]<0[1FK5#37U[L"'&RA=(]GN
>:7 T4)=KSQYF3&I6& X9(R92>QP03EV^-5)TS*5BT @FL_35:3FOVT8#NQ5Y:[03B5L4H7E
R/1B>Y/Z/'G('<OJ5=XO.:@=FV<]1X;%E8*;HE&=^\7-HZBB85;C=F:W^C-A,Q+^>M&V1KLS
\:E"V2U//^;Q5:3FOVT8#NQ5:8U)E=L*7VEIR/1B>Y/Z/'G('<OJ5=XO.:@=N*A,\1-Z#9.X
HE&=^\7-HZBB85;C=F:W^C-A,Q+^>M&V1KLS\:E"V2U//^;QSPWV\DO]M>K/DQ0;JD=M=GZ3
@A9A9"0 T^V"0.1HAH"\X 5 !T]-&&W?TO,'0.1HAH"\X 5 +#6RI_BM,^\LJ<80B6%2\FNI
VS-%;9@("?';S+[9>NPY,W+,98MKA9MIIUME:P'A^A68,:9K>&9B1CL%/<-X*U7O&$)!<?LK
J0H:G;\%2D>I;1- Z6X;SGIM343-O-2,=UI-:K99J?#M)49J6GPPH/.!;<I:\!W-J,,=1+_P
5,]*.XQ#')=4^PPJ?[,)$*#[P95;:CG[A6;!8N7B,(DS4V9B]"B"QV4RR4/T?IU3]/=7;A!^
 Z>Y"0:F_1H#JJ-01":[.OVJMB-FNRIR0+*V_CZKM,WV?QO^?PHS4/EBW_%_TX'ARN$(N#S3
B"]:<K\P%X:(*;_29Z"(/X@I9\72K8-]719G/M"Y:Y9G,Q4^ Z>Y"0:F_1H# Z>Y"0:F_1H#
 >WO<51.\<8!"\/0,!145_T+^=-[$_7-]NSY(ZU=-Y;T;%DC8;O7UVQ8\,AA2;/$+S)OIJY)
 Z>Y"0:F_1H#^E(PTQ>T?S;Z(X7:(< !.80CUOCP<#V-X)_6T"2O_OUUJ$S0I":\6H4;3-BD
3?R9.M1<3WI-LJ70ZRJ*SD^R+UDBPIX^ &TO Z>Y"0:F_1H#\E$E\Q8$8++R^;AQP Y:I3'Y
G_]GEU'#R9B?H(*)<AY'A92@ Z>Y"0:F_1H#.JZ:,=[ &.<ZP<:[-?2MJG?!,TZ)J.EG7BTS
 Z>Y"0:F_1H#6Z3(^,LP/BQ;L)'Y9_DK,7NPC#R;A$DDI?.,SYC9@Y9<7N'/&=08F48F_I\9
PU</1-J6,R[#_+@H!7C "O7\ Z>Y"0:F_1H#AY!\Z4A-(6^'&!,>!";5Z/<8.5K8O3;P&^@Y
,^+!V#;:K4XS5:1"N_.\ B)5.MCK,I.OEK(ZKG33&^1#J<:N4%B!E2"R7/!02OXP)<L,F%M*
H]/T2 YF\0NC!08N<"(N4,4%&ZQ7IG*TIX\;V7+LF)NP.@[9DC,20$+1L-:22-;S>0D"%[M(
>B-G#?%B([EZK@9%*8^15.RNL(X.KC3BR*NP9J%W(T<TH95FLV^KKP!<:Y6S&#'F)"SIN&L8
02+Z5!/??Q)!]&GAIH\[MUST^*RPO&OD@C+X :._;K;/((4!_E[0PY@"8D+^FGCC<;A<QDV:
 )$GV)$D6%\ _N<]$YG/;$7^UM_95:YK46C6O)2P"48NJOZ\[.S$DF#KCPCL-GO!1!UJ<S(V
XA_BV3H.Y@KBR<,\Z[*(E';)$3?E75D'K]$1RTW*P[479K'+XO$D@%-; G/B$3?E75D'K]$1
RTW*P[479K'+C8;YF7X+2N&-]%324(;*U,WT_LTC\7'K=I?^'D,*_WW9Q9(>&+QQ3X7R+2<8
VSW"YTY2/PC;C5:JV2N([36-KQDD-[A:BNNODF;_!XI#%S.2$.X9VD:25)\0L!JQ,P,;^XRP
2U$(9MG6[I-+2U$(9MG6[I-+2U$(9MG6[I-+2U$(9MG6[I-+2U$(9MG6[I-+2U$(9MG6[I-+
2U$(9MG6[I-+*]-4'XWY.[8K>RSH+&E +N][&+RY*U]!-A08>)5Y6I&)235XH>*ZL?80^52A
,J39J2V7M+DRND,A_TJ1<MBZE+85P)[DTB.4!'2L&-X02@X$E*_0OP+'(W*48OR@&H8X!FMB
&N/D)SD!I_X:;POIYW_(5M=OC2P/=B' 'O"-;@=,1NW#I?=N?_O$@\ESE%=_Q^A*XKG%NNW'
31(=\>*+0T]-;S![N.#%!$UO-(/"WX'S"ITTBZB3B$-G@WR+9]<+_28"&+]G3X[_IL45<@Y/
_>))@1Q:8LG]V(.-EO['\9/8P-(/CS/7BGC 6OM@6U).(?9:Z?5C@%(Q#67I'O[U^ [F.BT>
Y\ MZT?GE+'G_BC6R5T-+[?^AB7VGQ# 3O2&?O,O]SDP/1U^NV#9I\'2 1N[Z?5C@%(Q#67I
'O[U^ [F.BT>*<+C].+,&.\I_BC6R5T-+[?^' X2L^:-I)<<1K;-__BH-4M&/$W/DXTAB7$\
9QMO]X\C3VYG8;V))#!?5R9AV(.-EO['\9/8Z_P<_OI[\.SK)Z'NAI?&S]0G;S![N.#%!$UO
-(/"WX'S"ITTQ[SH^G@<T(+'O3GLCH2ONO"]QUXJ#)I;!!O'Y\/[8R^;FWCG85* C'M P#MA
O9R&)3&[+P>]'Z?+M3"EE+<?_7])\K<)O G]+!%>;HW"P7\L^&E6JK0L/=;X@[(-1GA4O &#
C7#&^\M/5;V-_BC6R5T-+[?^QK[_55,S0IK&N@XH5@\S29&ZI@5*+EXV9."FLG[O+-,$N9NR
]_MS+@D6Y.'W\]T'@9GO_ 'SBZ+(>.^$:#"+TGDWZ9QGA$32-(+O>SB]A@PT -#6%1DB"'< 
4\TGQ?W(8,I3W"Z]:"W=74'<..M/4]W"&Y<XL3O8.,SQ3W^Q+(C']@U2"L0LLN_,U'#D1+>R
^;AH"A]F7\WYSCZTTC-YQ9#.3<38EAMNIUA-(*L:_Q:$W  @+5*^76&[<V(M'/6P.+AFUN0<
+,V[A*M%-\4L^XV_,4YL3O[[$UA&5WM,?$(3Z= =G*^$H@?IXN!=5WTXZI#BNYIF!^X/?+^[
@RVO**2#OW># V_96A.?.>8#=?F6Z'7YZ-9USR0?  ^;_Z;/FRK*:6 *F$*;@DUE[[!O^1."
+C%NXL-AM"4NI?7?W:GH+&:EE91AO6(90""5#)^N(]QQ#&T,:%.8F*X5\EIH+5*^76&[<V(M
'/6P.+AFUN0<+,V[A*M%-\4L^XV_,4YL3O[[$UA&5WM,?$(3XI.,<ROEL73B61;B'*6&",-9
VA-"%AQXB!S:-W4[CJQD^ 8W+5*^76&[<V(M'/6P.+AFUN0<DQQOA61B=!"3@H6_7"'-A)J"
=RDRA@(=:S]WCC5:5M4(XLF.R0OV2'P,'7C)Z]2#T7:L5[[KX0F9-P ]S/+AKYYP#IBSR9VO
6$\I'>\_SY%8589-EK"19GI5SR0?  ^;_Z;/>V:Z]YC/:>1['*"!@]_6TI <HPC(7U_-V7.C
+"8A"HPS= @LSR0?  ^;_Z;/QI.7AY@"-XO&N-$ROE?(7@ZXAT2[%2J-Q2B'RQ)<&N,:[!7+
8+H+I&@.HH5@2,8"8=#"/JM(DI.ZA.B]":N2T.I?SBY2HL?0U\U9ZD("EXO7<B-3&,B*?9]R
<,]+<#YG+I)PO"RPP8-_P#B\0I 8#2(B7%I"C 9L>@S)E .,-K@<389G#F4VR0OV2'P,'7C)
RL-RW1EM'"[*8?ED@]K$-.%A>G26=09XRD5ZC*)&%S]C8$R,8+H+I&@.HH5@2,8"8=#"/JM(
+_53A&M^C-@O"> .W6&Z-T0)DK,_=L%L'9:2+5*^76&[<V(MQU7P.>P'J,O'\ L!_%&89W?P
*/Z<*PJ?VI\H@Q3TW$DS-<J#L\J TWRA[+ZS1J7P:,-W3M]&[PW405I\BB?OJ:X8 @^V;Y&I
F>.O,WD@\UN97#VY::@1<?%<730A)Z&,HH1=J8GB_,WWE[NIF>.O,WD@\UN9&*N:HG8_E!X8
730A)Z&,HH1=BU*QV:W/Q&^+#-I5O#G4B:$,@H6_7"'-A)J"&RJZ&AQ,6/<;?B2$M7!81 1^
2MD-TELKIXE*#9LO"["A'%4-%=KB0XE]IOL5W+U_A["]$]O<@C#8"C)J^:R"<,]+<#YG+I)P
;?Y?Q8)Y9O%M&RB$.N[&0M<;F>.O,WD@\UN9N)%\ 15A12*X2R?PL:X\>PQ+##00-U,5O*\,
E2E-BM4B0B65C 9L>@S)E .,(NAPZPO>Y;\B+5*^76&[<V(M'/6P.+AFUN0<3*5EEKJ5+29,
@H6_7"'-A)J"T1OWK>'P\&O11J7P:,-W3M]&2MD-TELKIXE*#9LO"["A'%4-W["K(WFT# +?
W+U_A["]$]O<W+/AXB%'%AO<<,]+<#YG+I)P;?Y?Q8)Y9O%M%>ZNCM%V##<5F>.O,WD@\UN9
->.27U!B9,TUR0OV2'P,'7C)RL-RW1EM'"[*C[NI7W#(#(2/KYYP#IBSR9VOWOMB&I3J%-7>
2R?PL:X\>PQ+OROVZ$,X/M>_=8"4NG C&&IUL&46")#R#*2P<,]+<#YG+I)P9QMO]X\C3VYG
L_A&=NB1>PZSL#?C(GEEC,RP84C@N5V\3E)AC 9L>@S)E .,2ZCYF]\^N/Y+730A)Z&,HH1=
BU*QV:W/Q&^+8M/L)^;8.E!B%]7#,$0F1ST7V!D7O6^Y-,'81)@M>Z7E'N)$&VO%$<>+&?(;
SD;J61[=,(O.<,]+<#YG+I)PM&WZA547P/2TWC*:N8[&.OO>F>.O,WD@\UN9O*;;OW-=#MR\
R0OV2'P,'7C)RL-RW1EM'"[*D3J0M=H2K7F1KYYP#IBSR9VO_DXW.JU<Z:[^SD;J61[=,(O.
<,]+<#YG+I)PM&WZA547P/2T\)*U@MT5-3WP]MWS'G 5XAWV=%)U.P#4\W9T]0#!JTQJ/ SU
WR6+:'44Y 7?2R?PL:X\>PQ+(C&SK"N,38PB,#TX8V4A=MHP+>5>!B>IZBDM"_O"TK+4(>T+
SGJYCYX0!:3.8?ED@]K$-.%A_]LMOY8TS>;_R(62)7L(D\[([WZU;)W?_6#O(C&SK"N,38PB
,#TX8V4A=MHP7<@S#E),>4Q=3T&4",LVJ'Q/5'6FABY[IH)4BU*QV:W/Q&^+8M/L)^;8.E!B
(M9Z>U5IALDBC 9L>@S)E .,?7W4JF_G>1A]2R?PL:X\>PQ+(C&SK"N,38PB,#TX8V4A=MHP
+>5>!B>IZBDM"_O"TK+4(>T+SGJYCYX0!:3.8?ED@]K$-.%A_]LMOY8TS>;_R(62)7L(D\[(
[WZU;)W?_6#O(C&SK"N,38PB,#TX8V4A=MHP7<@S#E),>4Q=3T&4",LVJ'Q/5'6FABY[IH)4
BU*QV:W/Q&^+8M/L)^;8.E!B(M9Z>U5IALDBE91AO6(90""5F>.O,WD@\UN9\YC@^#6V6P'S
_<QWPYHP=/#]BU*QV:W/Q&^+8M/L)^;8.E!B_:'N%9_S5!7]2R?PL:X\>PQ+_-Z>)QTS! C\
,#TX8V4A=MHP7<@S#E),>4Q=3T&4",LVJ'Q/*UR83]*9W(HKBU*QV:W/Q&^+8M/L)^;8.E!B
0_ 8Q@[:C(5#UHKI#;R%!H36O @8^A1/@ZF\DN6QYT9SIS62%@%XW1?(!KP6+60Y(]%RJ:4M
K&N%_S C.KNLL)?"*;P8IQNP_<QWPYHP=/#]BU*QV:W/Q&^+8M/L)^;8.E!B_:'N%9_S5!7]
2R?PL:X\>PQ+_-Z>)QTS! C\,#TX8V4A=MHP7<@S#E),>4Q=3T&4",LVJ'Q/*UR83]*9W(HK
BU*QV:W/Q&^+8M/L)^;8.E!B0_ 8Q@[:C(5#UHKI#;R%!H36O @8^A1/@ZF\DN6QYT9SIS62
%@%XW1?(!KP6M1 !!_^OH3VU61;B'*6&",-9 Z>Y"0:F_1H#F>.O,WD@\UN9>85'I[HN>B%Y
R0OV2'P,'7C)%9^JKX:T0CH5I;=WU'J.N,BE Z>Y"0:F_1H##H_ENO;IMOP. P0#G'*(F]@#
"H8'U)>XM/H*+5*^76&[<V(MT\JSEYI>EHO3K&_$R1';>XVL Z>Y"0:F_1H#O \%='[SY=F\
M@SZ"KVM]VNV[+SQ@!*W!W/L2R?PL:X\>PQ+OROVZ$,X/M>_/M"Y:Y9G,Q4^=.-8>Q=VU^9T
<%YK[3NP;7)P+ &7Q_06/RLLR0OV2'P,'7C)F53)<,=(,].96;MT7%:&^599HDFTJ^!M2JJB
X"QW] .M1%K@ .I O 0#7O(  Z>Y"0:F_1H#9]QE=QKR:"UGS, .XZ*8K:/,S' !X-($L0_,
730A)Z&,HH1=C>PO.<MI2;:-=;Y0<&;W\V%UDC'&G_LR"3R2DNWE.I*7>E623Q2W24TTY91/
O#<=M7JA>7*\/M"Y:Y9G,Q4^=.-8>Q=VU^9T8&MXJR#^3 =@.E=6\H _ %XZ8+H+I&@.HH5@
1"!ZD&#V3EM$55+RF[36\#A5ME8E]XL?W<BVM]B(G,X!9I2W8U\VIQWP+#YC -B"I^H,/5L 
 Z>Y"0:F_1H#8C@E^<$&\L!B8)PUY=[PW"E@8+H+I&@.HH5@1"!ZD&#V3EM$55+RF[36\#A5
ME8E]XL?W<BV/M"Y:Y9G,Q4^6VXG]ZG4?!1;E>**R)[1!">5NA*I]"?;)'&Z+5*^76&[<V(M
'/6P.+AFUN0<@;;H@&PJ61J!=(LEZX9H/%]T Z>Y"0:F_1H#)N'&E<5QG0DF$F);J.7RO7T2
730A)Z&,HH1=BU*QV:W/Q&^+Y3(@,%7,LM#EK&_$R1';>XVL=.-8>Q=VU^9TY;! QHE5^:#E
R0OV2'P,'7C)RL-RW1EM'"[*;!_XIUCM[7IL_+@H!7C "O7\ Z>Y"0:F_1H#NQBHE*FS$/*[
U<=F#K)-6N'5730A)Z&,HH1=BU*QV:W/Q&^+Y3(@,%7,LM#EK&_$R1';>XVL=.-8>Q=VU^9T
+/"@IO@>,$TL-_6@(E<(6@0WOW5,(KG[<D>_[PW405I\BB?O_S^+_Y<SQ=;_P%2U-'I6_D? 
ET< BU?@A*R7T9&-QBD)#S/1RE:I'[X1,M7*"#XBS8ZJM6L(1$'&[A,SC>Q$(BX3!<3\&& B
MYE**::>W1*W<3:M4"2#@LYQ@C)'>7YX@_B"W&[V2THZM2G<8Y.$TU'K;0]C^;AH"A]F7\WY
8!"7$C"$Z[Y@6+%T7W&;!XA8AK0\ZDXK3EN&E'/I3!R5<!24BJ>H!%DFA_B*BJ>H!%DFA_B*
BJ>H!%DFA_B*BJ>H!%DFA_B*BJ>H!%DFA_B*BJ>H!%DFA_B*:^":98'!^SIK4W%/897N#M93
"=][;^)ASI\)"=][;^)ASI\)"=][;^)ASI\)"=][;^)ASI\)"=][;^)ASI\)"=][;^)ASI\)
"=][;^)ASI\)!\JT#WB_NM<'QIL1^96RSP3&1S8N@LU=],!'NKH7W.D*;WFZ++9""3,X"XXL
C2P/=B' 'O"-K_Y:2=N[U$*OPV]*#9"ECV[#BAXG6&H;0K&*79:URM3E6<==@EE\J$%G43B"
9)52W8R!EG9D!0E#"/'W6,H% ^#"2<+,JI8#"_/< /S6R,4+';5T&-@A4^T=EH<X+%M/_\J6
RW=@'=7P_T?+.N/_,LNY0. Z..M/4]W"&Y<X08+[IK>/31]!I4(5/*@#+)NEN_KK1!Q*AK:[
*/&VE^$S?>LH77A<WKVFJ(!=..M/4]W"&Y<X)0"M0N;<[CLE@C)'>7YX@_B"_J^J;RZ+&ZK^
P!9!U6/B!2K Z7R:PE'1<9?IBU*QV:W/Q&^+LJ?;-Z;'FY.RI4(5/*@#+)NEN_KK1!Q*AK:[
*/&VE^$S?>LHOO=[,OU0H)V^..M/4]W"&Y<XDZSI@9CT]7B3_BC6R5T-+[?^KAVXX9-_(\JN
0;W' N@O]&Q!!Y7K[UIV$5D'T++<9$/_IS+0G5M7Q/B@2-N=DN6QYT9SIS62DG5X,:EK59&2
@%G^-Y["[[Z K!^;C$T@G(ZL5'6FABY[IH)4BU*QV:W/Q&^+\%F<+@%LU/[PT?\9M<F <)_1
HS,^!Z$=BCJCJS=F)5@ (!RK/*V"N+IYG H\-ZAN8K1>$KPW=I, 3GCA83QV2U$(9MG6[I-+
2U$(9MG6[I-+2U$(9MG6[I-+2U$(9MG6[I-+2U$(9MG6[I-+2U$(9MG6[I-+2U$(9MG6[I-+
2U$(9MG6[I-+P16 Y"]X#>'!%\HA#U)D#VX71Z8]=!FL!^5'YGZ,$T1?Q(KFR,+"]=(>P"#(
<M[Z# ^[XU!R1-W)=3D!8H]$;#D/N$@GM?YL-\D05L1FB#TW?O8Z<M];F)!^Q5@CYPVJ&]O%
L$J!^&L$A ZP2ES(#K.YED-*>V.GLNP\'6)[Y%SR,X/?VB[DS<(_[UN%[LO-YK?]>[&+I +F
(+R'=(]55 0@(*L:_Q:$W  @/M"Y:Y9G,Q4^)B=T3.-1@J8F$-9)#39[.B<0J7B<,OY;A6BI
#IEV=^X)?9T.L+069/G,#@^P&F7I@^$HI4L:&3*;%94-T $9A0)P\3SD&5"%"RNC:SM4]0 +
#^W\)SH.63@/M+^4F^!E=G"T*),<H[.E ,DHE/6/RWA#XO^4S\)TGB5/KN;/?NS(I%!\N8%^
G .&H<X7'+><X&:^2#L)WL?@^3A%NP"JP0#Y3P?IQIKA6O1/@:2;*P?U,9*!X18)H_$Y3OKA
90Z#1TGG,(]EU9PG-8\X^J_5QB$^!U_\&F'&"Q/Y[_7I*9$+
#pragma PXL encrypted end
#pragma PXL encrypted begin
.AI "6?144 Z;[4$FT[/:F!OL[H<3ITC#D:S:'W91N#^J ]HZ4%?:Y@\=+SI.UFK.)KN ET[
=3>8%R%=(?EU\]IGUJCM(W7S
#pragma PXL encrypted end







#endif

#ifdef FILL_DM8

#pragma PXL encrypted begin
UUL6=@E<Q$G7Z,^NW1($52GH&[O<.GT[<8\;N/;J+[2SQ 6X9P6YB=YCN2YGSAB]^G7X[6S.
1;B.Z;.;9,U%0IGT.#WMEB]"UM*#7+IP!F'65W0.QAZ5,WA7
#pragma PXL encrypted end


LAYER_DM8_MYBCELL_H : polygon_layer_s = {
    layer_spec = {
        output_layer_key = "OUTPUT_DM8_DMB_CONNECT"
    },
    polygons = MYBCELL_H
};

LAYER_DM8_MYBCELL_V : polygon_layer_s = {
    layer_spec = {
        output_layer_key = "OUTPUT_DM8_DMB_CONNECT"
    },
    polygons = MYBCELL_V
};

LAYER_DM8_MYBCELL_HEXT : polygon_layer_s = {
    layer_spec = {
        output_layer_key = "OUTPUT_DM8_DMB_CONNECT"
    },
    polygons = MYBCELL_HEXT
};

LAYER_DM8_MYBCELL_VEXT : polygon_layer_s = {
    layer_spec = {
        output_layer_key = "OUTPUT_DM8_DMB_CONNECT"
    },
    polygons = MYBCELL_VEXT 
};

// DUMMY SPEC : DM8_DMB_Connect
SPEC_DM8_DMB_CONNECT = unified_fill(
    fill_patterns = {
    {
        type = UF_POLYGON,
        polygon_fill = {
            insertion = {
                iterations = 3,
                shift_factor = 2,    
            },
            pattern_spec = {
#ifdef VERTICAL_M8
                space_x = DMY1B_SX,
                space_y = DMY1B_SY,
                stagger_x = DMY1B_OX,
                stagger_y = DMY1B_OY,
#else
                space_x = DMY1B_SY,
                space_y = DMY1B_SX,
                stagger_x = DMY1B_OY,
                stagger_y = DMY1B_OX,
#endif
            },
            layers = {
#ifdef VERTICAL_M8
                LAYER_DM8_MYBCELL_V
#else
                LAYER_DM8_MYBCELL_H
#endif
            },
#ifdef CONTROL_MAX_METAL_LENGTH
#else
            merging_layers = {
#ifdef VERTICAL_M8
                LAYER_DM8_MYBCELL_VEXT
#else
                LAYER_DM8_MYBCELL_HEXT
#endif
            },
#endif
#ifdef ANTPrevention                
#ifndef CONTROL_MAX_METAL_LENGTH
            merging_blockage_layer_list = {
                FORBIDDEN_RING
            },
#endif
#endif
#ifdef CONTROL_MAX_METAL_LENGTH
#else
#ifdef VERTICAL_M8     
            merging_direction = VERTICAL,
#else
            merging_direction = HORIZONTAL,
#endif   
            merging_length_limit = 500*(DMY1OR_L + DMY1B_SY) - DMY1B_SY, 
#endif
            fill_to_signal_spacing = {
    { CHIP_snps, min_space = DMY1B_CHIP, context = INTERIOR },
#ifdef FULL_CHIP
    { CHIP_BOUNDARY, min_space = DMY1B_CHIP, context = INTERIOR },
#else
    { PRBOUNDARY, min_space = DMY1B_CHIP, context = INTERIOR },
#endif
    { ICOVL_SINGLE, min_space = DMY1_ICOVL },
    { INDDMY, min_space = DM_INDDMY },
    { TCDDMY_M8, min_space = DM_TCDDMY_MX },

	{ BEOLBLK_FINAL, min_space = DMY1B_MY1 },
    { DM8EXCL_FINAL, min_space = DMY1B_MY1 },
    { CSR66_3485, min_space = DMY1B_MY1 },
    { M8_MAIN, min_space = DMY1B_MY1 },
    { DM8_O, min_space = 0.26 },
    { DM8, min_space = 0.26 },
    { DM8_GT1350, min_space = 0.45 },
    { M8_GT76, min_space = DMY1_MY1W1 },
    { M8_GT114, min_space = DMY1_MY1W2 },
    { M8_GT152, min_space = DMY1_MY1W3 },
    { M8_GT180, min_space = DMY1_MY1W4 },
    { M8_GT240, min_space = DMY1_MY1W5 },
    { M8_GT280, min_space = DMY1_MY1W6 },
    { M8_GT500, min_space = DMY1_MY1W7 },
    { M8_GT1350, min_space = DMY1_MY1W8 },
#ifdef FILL_M7_VIA7_M8_BTCD
              { BTCD_M7_V7_M8_E, min_space = BTCD_D },
#endif
#ifdef FILL_M8_VIA8_M9_BTCD
              { BTCD_M8_V8_M9_E, min_space = BTCD_D },
#endif

#ifdef FILL_M8_BTCD2
              { BTCD_M8_E, min_space = BTCD_D },
#endif
              { WRAPPER_DM8_O_L, min_space = DMY1B_DMY1O },
#pragma PXL encrypted begin
5$0+?T*G)UQ4,R+SQC3O(/$SC$<\>='%X$V,X[AF35NS;UWCR11$2M.=.WK)=?DO';7<J?1U
J17\%Q1/#'"I^0/LAIR>=>7YB9N+5 XL?^*)]@AHLOMM)"KVX;&$ \Y:1F[A@6B*51?364:!
"G<'&>7Z**<*2ZLZ40L.L-5+?6'9>E8V<))]?M0L@Q9)1%-^0NLO5X< KJU"2SDP058,805+
0'[[NIE\WP% [#&Z285L%#SL[ZN2W<PWTD_O-FS7S0;%U\XV
#pragma PXL encrypted end

                            
            },
            hierarchical_fill = false,
#ifdef VERTICAL_M8     
            cell_prefix = "DMB8VNEW"
#else
            cell_prefix = "DMB8HNEW"
#endif   
        }
    }
    },
    extents_output = {
        {
            output_layer_key = "OUTPUT_DM8_DMB_CONNECT_EXTENT"
        },
    },
    fill_boundary = {
        layer = CHIP_snps, 
        type = LAYER 
    },
	grid = vGRID
);
//=======================================================
DM8NEW_C     = SPEC_DM8_DMB_CONNECT["OUTPUT_DM8_DMB_CONNECT"][0];
DM8NEW_L     = SPEC_DM8_DMB_CONNECT["OUTPUT_DM8_DMB_CONNECT"][0];
//***** spec *******************************************************************
#pragma PXL encrypted begin
-SFH""!1N@(W] [V/?*R*T'TOVH1<%%4=-^_0?*0%UK<1C-!V8Q;'T_]M6S9A[GQ^O1=AOZ'
Y%>M?74830KDR#S&-X,5X?S(
#pragma PXL encrypted end

//***DM8_DMB***
// DUMMY SPEC : DM8_y1
PATTERN_SPEC_DM8_0 = get_single_polygon_pattern(
#ifdef VERTICAL_M8
	"DMB8V", "OUTPUT_DM8", DMY1B_W, DMY1B_L,
	step_x = DMY1B_SX, step_y = DMY1B_SY,
	offset_x = DMY1B_OX, offset_y = DMY1B_OY,
#else
	"DMB8H", "OUTPUT_DM8", DMY1B_L, DMY1B_W,
	step_x = DMY1B_SY, step_y = DMY1B_SX,
	offset_x = DMY1B_OY, offset_y = DMY1B_OX,
#endif
    FSS = {
    { CHIP_snps, min_space = DMY1B_CHIP, context = INTERIOR },
#ifdef FULL_CHIP
    { CHIP_BOUNDARY, min_space = DMY1B_CHIP, context = INTERIOR },
#else
    { PRBOUNDARY, min_space = DMY1B_CHIP, context = INTERIOR },
#endif
    { ICOVL_SINGLE, min_space = DMY1_ICOVL },
    { INDDMY, min_space = DM_INDDMY },
    { TCDDMY_M8, min_space = DM_TCDDMY_MX },

	{ BEOLBLK_FINAL, min_space = DMY1B_MY1 },
    { DM8EXCL_FINAL, min_space = DMY1B_MY1 },
    { CSR66_3485, min_space = DMY1B_MY1 },
    { M8_MAIN, min_space = DMY1B_MY1 },
    { DM8_O, min_space = 0.26 },
    { DM8, min_space = 0.26 },
    { DM8_GT1350, min_space = 0.45 },
    { M8_GT76, min_space = DMY1_MY1W1 },
    { M8_GT114, min_space = DMY1_MY1W2 },
    { M8_GT152, min_space = DMY1_MY1W3 },
    { M8_GT180, min_space = DMY1_MY1W4 },
    { M8_GT240, min_space = DMY1_MY1W5 },
    { M8_GT280, min_space = DMY1_MY1W6 },
    { M8_GT500, min_space = DMY1_MY1W7 },
    { M8_GT1350, min_space = DMY1_MY1W8 },
#ifdef FILL_M7_VIA7_M8_BTCD
              { BTCD_M7_V7_M8_E, min_space = BTCD_DY1 },
#endif
#ifdef FILL_M8_VIA8_M9_BTCD
              { BTCD_M8_V8_M9_E, min_space = BTCD_DY1 },
#endif

#ifdef FILL_M8_BTCD2
              { BTCD_M8_E, min_space = BTCD_DY1 },
#endif
              { WRAPPER_DM8_O_L, min_space = DMY1B_DMY1O },
#pragma PXL encrypted begin
4:&[ 3( ? -1[6O]Z-YN<:7M<21"Z]#37@MQV0/)ZT6 5+O9?<B]M35;V3A]ANU>I=H H.N&
;BS=T3**$[QN'0_]TU7:>\<=AV-LZ\F*YJV'1_((1"K)"$5'
#pragma PXL encrypted end

              { DM8NEW_L, min_space = DMY1B_DMY1 },
#pragma PXL encrypted begin
 ]9G _Q;/V$#Q!L<N.]B'7K$A#%*+!"0B2F$_T\W3<; 5G;_>AS<1HM5$GIZ82^X:6# !==A
8M,9O$^P2,IBT7<EE2I&A9+1
#pragma PXL encrypted end

    },
	shift = 2,
	repeat = 3,
    starting_point = CENTER
); //end of get_single_polygon_pattern


//-------------------------------------------------------------------------------

//***DM8_DMS***
PATTERN_SPEC_DM8_1 = get_single_polygon_pattern(
#ifdef VERTICAL_M8
	"DMS8V", "OUTPUT_DM8", DMY1S_W, DMY1S_L,
	step_x = DMY1S_SX, step_y = DMY1S_SY,
	offset_x = DMY1S_OX, offset_y = DMY1S_OY,
#else
	"DMS8H", "OUTPUT_DM8", DMY1S_L, DMY1S_W,
	step_x = DMY1S_SY, step_y = DMY1S_SX,
	offset_x = DMY1S_OY, offset_y = DMY1S_OX,
#endif
    FSS = {
    { CHIP_snps, min_space = DMY1S_CHIP, context = INTERIOR },
#ifdef FULL_CHIP
    { CHIP_BOUNDARY, min_space = DMY1S_CHIP, context = INTERIOR },
#else
    { PRBOUNDARY, min_space = DMY1S_CHIP, context = INTERIOR },
#endif
    { ICOVL_SINGLE, min_space = DMY1_ICOVL },
    { INDDMY, min_space = DM_INDDMY },
    { TCDDMY_M8, min_space = DM_TCDDMY_MX },

	{ BEOLBLK_FINAL, min_space = DMY1S_MY1 },
    { DM8EXCL_FINAL, min_space = DMY1S_MY1 },
    { CSR66_3485, min_space = DMY1S_MY1 },
    { M8_MAIN, min_space = DMY1S_MY1 },
    { DM8_O, min_space = 0.26 },
    { DM8, min_space = 0.26 },
    { DM8_GT1350, min_space = 0.45 },
    { M8_GT76, min_space = DMY1_MY1W1 },
    { M8_GT114, min_space = DMY1_MY1W2 },
    { M8_GT152, min_space = DMY1_MY1W3 },
    { M8_GT180, min_space = DMY1_MY1W4 },
    { M8_GT240, min_space = DMY1_MY1W5 },
    { M8_GT280, min_space = DMY1_MY1W6 },
    { M8_GT500, min_space = DMY1_MY1W7 },
    { M8_GT1350, min_space = DMY1_MY1W8 },
#ifdef FILL_M7_VIA7_M8_BTCD
              { BTCD_M7_V7_M8_E, min_space = BTCD_DY1 },
#endif
#ifdef FILL_M8_VIA8_M9_BTCD
              { BTCD_M8_V8_M9_E, min_space = BTCD_DY1 },
#endif

#ifdef FILL_M8_BTCD2
              { BTCD_M8_E, min_space = BTCD_DY1 },
#endif
              { WRAPPER_DM8_O_L, min_space = DMY1S_DMY1O },
#pragma PXL encrypted begin
]PI5.N ?PDKWZ%1Q-LX/.T/H?:LT'71*8U-]_@-O?,G):!G^]Z:Z3&S ;U#WRA;:".76TB7*
\.3J=F*I58'P>,RZ*&5<I?)X$+:>MHN\6OL0E-WP'E(.<;R4
#pragma PXL encrypted end

              { DM8NEW_L, min_space = DMY1S_DMY1 },
#pragma PXL encrypted begin
J3\!/*I[A"BI0(,]]C74'?Q =*>G+BF'&-1T).98V@%L%J,DN+D+][:[ZQVX VCEV&1_-AD#
<3;&!:^4R;-QU8);N>7S8$S5
#pragma PXL encrypted end

    },
	shift = 2,
	repeat = 3
);


//***DM8_O_R***
PATTERN_SPEC_DM8_2 = get_single_polygon_pattern(
#ifdef VERTICAL_M8
	"DMOR8V", "OUTPUT_DM8_O", DMY1OR_W, DMY1OR_L,
	step_x = DMY1OR_SX, step_y = DMY1OR_SY,
	offset_x = DMY1OR_OX, offset_y = DMY1OR_OY,
	setback = DMY1OR_SC,
	setback_type = INTERSECTION,
#else
	"DMOR8H", "OUTPUT_DM8_O", DMY1OR_L, DMY1OR_W,
	step_x = DMY1OR_SY, step_y = DMY1OR_SX,
	offset_x = DMY1OR_OY, offset_y = DMY1OR_OX,
	setback = DMY1OR_SC,
	setback_type = INTERSECTION,
#endif
    FSS = {
    { CHIP_snps, min_space = DMY1_CHIP, context = INTERIOR },
#ifdef FULL_CHIP
    { CHIP_BOUNDARY, min_space = DMY1_CHIP, context = INTERIOR },
#else
    { PRBOUNDARY, min_space = DMY1_CHIP, context = INTERIOR },
#endif
    { ICOVL_SINGLE, min_space = DMY1_ICOVL },
    { BEOLBLK_FINAL, min_space = DM_BEOLBLK },
    { CSR66_3485, min_space = DM_BEOLBLK },
    { INDDMY, min_space = DM_INDDMY },
    { DM8EXCL_FINAL, min_space = DM_DMXEXCL },
    { TCDDMY_M8, min_space = DM_TCDDMY_MX },
    { M8_MAIN, min_space = DMY1OR_MY1 },
    { DM8_O, min_space = DMY1OR_DMY1O },
    { DM8, min_space = 0.2 }, //DMn.S.3.5
    { DM8_GT1350, min_space = 0.45 },
    { M8_HOLE, min_space = 0 },
    { M8_GT76, min_space = DMY1_MY1W1 },
    { M8_GT114, min_space = DMY1_MY1W2 },
    { M8_GT152, min_space = DMY1_MY1W3 },
    { M8_GT180, min_space = DMY1_MY1W4 },
    { M8_GT240, min_space = DMY1_MY1W5 },
    { M8_GT280, min_space = DMY1_MY1W6 },
    { M8_GT500, min_space = DMY1_MY1W7 },
    { M8_GT1350, min_space = DMY1_MY1W8 },
    { M8_45, min_space = 0 },
    { VIA7_HVN_5V, min_space = DMY1_VY15V },
    { M8_HVN_5V, min_space = DMY1_MY15V },
    { VIA8_HVN_5V, min_space = DMY1_VY15V },

              { R7_VIA7_CHK_REGION, min_space = 0 },
              { R15_VIA8_CHK_REGION, min_space = 0 },

              { S22_M8_REGION, min_space = 0 },
#ifdef FILL_M7_VIA7_M8_BTCD
              { BTCD_M7_V7_M8_E, min_space = BTCD_DY1 },
#endif
#ifdef FILL_M8_VIA8_M9_BTCD
              { BTCD_M8_V8_M9_E, min_space = BTCD_DY1 },
#endif

#ifdef FILL_M8_BTCD2
              { BTCD_M8_E, min_space = BTCD_DY1 },
#endif
              { WRAPPER_DM8_O_L, min_space = DMY1OR_DMY1O },
#pragma PXL encrypted begin
=T'(,&!4QWIWORF_ E<6/,F_%&L%+?%0IKT4CCDYC8JR!-".:%CG8U["-=)H#@L?*Z^36GT.
R-4@I_F;OT_(8-O%;I?M #%@:-)V][4VD AH$F!W%B(9VM02
#pragma PXL encrypted end

              { DM8NEW_L, min_space = DMY1OR_DMY1 },
#pragma PXL encrypted begin
*79T,BJPB5@IBG^%:V!1]B.*X>]3&YFYJ+;ANF!3$O4F=@*ZA?J-"1NF<[J%,+*$JCZJT"DP
K( Q  NL/J6L4**FTEX/+,Q0
#pragma PXL encrypted end

	},
    shift = 2,
	repeat = 3,
    starting_point = CENTER
);

#ifdef VERTICAL_M8
PATTERN_SPEC_DM8_2.polygon_fill.pattern_spec.pattern_spacing = {
    allowed_spacing_x = { >= DMY1OR_SXA2 },
    allowed_spacing_y = { >= DMY1OR_SY },
    extension = INTERSECTION
};
#else
PATTERN_SPEC_DM8_2.polygon_fill.pattern_spec.pattern_spacing = {
    allowed_spacing_y = { >= DMY1OR_SXA2 },
    allowed_spacing_x = { >= DMY1OR_SY },
    extension = INTERSECTION
};
#endif




//-------------------------------------------------------------------------------
//***DM8_O_W***

PATTERN_SPEC_DM8_3 = get_single_polygon_pattern(
#ifdef VERTICAL_M8
	"DMOW8V", "OUTPUT_DM8_O", DMY1OW_W, DMY1OW_L,
	step_x = DMY1OW_SY, step_y = DMY1OW_SX,
	offset_x = DMY1OW_OY, offset_y = DMY1OW_OX,
	setback = 0.114,
	setback_type = INTERSECTION,
#else
	"DMOW8H", "OUTPUT_DM8_O", DMY1OW_L, DMY1OW_W,
	step_x = DMY1OW_SX, step_y = DMY1OW_SY,
	offset_x = DMY1OW_OX, offset_y = DMY1OW_OY,
	setback = 0.114,
	setback_type = INTERSECTION,
#endif
    FSS = {
    { CHIP_snps, min_space = DMY1_CHIP, context = INTERIOR },
#ifdef FULL_CHIP
    { CHIP_BOUNDARY, min_space = DMY1_CHIP, context = INTERIOR },
#else
    { PRBOUNDARY, min_space = DMY1_CHIP, context = INTERIOR },
#endif
    { ICOVL_SINGLE, min_space = DMY1_ICOVL },
    { BEOLBLK_FINAL, min_space = DM_BEOLBLK },
    { INDDMY, min_space = DM_INDDMY },

    { DM8EXCL_FINAL, min_space = DM_DMXEXCL },
    { CSR66_3485, min_space = DM_BEOLBLK },
    { TCDDMY_M8, min_space = DM_TCDDMY_MX },

    { M8_MAIN, min_space = DMY1OW_MY1 },
    { DM8_O, min_space = DMY1OW_DMY1O },
    { DM8, min_space = 0.2 }, //DMn.S.3.5
    { DM8_GT1350, min_space = 0.45 },
    { M8_HOLE, min_space = 0 },
    { M8_GT76, min_space = DMY1_MY1W1 },
    { M8_GT114, min_space = DMY1_MY1W2 },
    { M8_GT152, min_space = DMY1_MY1W3 },
    { M8_GT180, min_space = DMY1_MY1W4 },
    { M8_GT240, min_space = DMY1_MY1W5 },
    { M8_GT280, min_space = DMY1_MY1W6 },
    { M8_GT500, min_space = DMY1_MY1W7 },
    { M8_GT1350, min_space = DMY1_MY1W8 },
    { M8_45, min_space = 0 },
    { VIA7_HVN_5V, min_space = DMY1_VY15V },
    { M8_HVN_5V, min_space = DMY1_MY15V },
    { VIA8_HVN_5V, min_space = DMY1_VY15V },

              { R7_VIA7_CHK_REGION, min_space = 0 },
              { R15_VIA8_CHK_REGION, min_space = 0 },

              { S22_M8_REGION, min_space = 0 },
#ifdef FILL_M7_VIA7_M8_BTCD
              { BTCD_M7_V7_M8_E, min_space = BTCD_DY1 },
#endif
#ifdef FILL_M8_VIA8_M9_BTCD
              { BTCD_M8_V8_M9_E, min_space = BTCD_DY1 },
#endif

#ifdef FILL_M8_BTCD2
              { BTCD_M8_E, min_space = BTCD_DY1 },
#endif
              { WRAPPER_DM8_O_L, min_space = DMY1OW_DMY1O },
#pragma PXL encrypted begin
F]&>=7V87#F;Y_\253OH6Z[G.5]$*+:L17TYK*C3-,W+W&&LOW/!BR7EX1R_(V"OP_TV&"XC
U1N>)1:HNWS5DGB];_]X->B2T2+UTTUS^BO19<JZVR'MW=%E
#pragma PXL encrypted end

              { DM8NEW_L, min_space = DMY1OW_DMY1 },
#pragma PXL encrypted begin
@WG!9GSY3G&#JV%I_+W<M[>KX#8=UMH;11#@0JD\,$'[:]-"F350U8I5YW.9H(6$"Z;,)C>@
!](VY3Z;-?$'?-:EU,ZP=G)\
#pragma PXL encrypted end

	},
    shift = 2,
	repeat = 3,
    starting_point = CENTER
);
//=======================================================
PATTERN_SPEC_DM8_0.polygon_fill.pattern_spec.other_pattern_spacing = {
    1 => > DMY1B_DMY1,
    2 => > DMY1B_DMY1,
    3 => > DMY1B_DMY1,
};

PATTERN_SPEC_DM8_1.polygon_fill.pattern_spec.other_pattern_spacing = {
    0 => > DMY1S_DMY1,
    2 => > DMY1S_DMY1,
    3 => > DMY1S_DMY1,
};

PATTERN_SPEC_DM8_2.polygon_fill.pattern_spec.other_pattern_spacing = {
    0 => > DMY1OR_DMY1,
    1 => > DMY1OR_DMY1,
    3 => > DMY1OR_DMY1O,
};

PATTERN_SPEC_DM8_3.polygon_fill.pattern_spec.other_pattern_spacing = {
    0 => > DMY1OW_DMY1,
    1 => > DMY1OW_DMY1,
    2 => > DMY1OW_DMY1,
};

SPEC_DM8 = unified_fill(
    fill_boundary = {
        layer = CHIP_snps,
        type = LAYER
    },
    fill_patterns = {
        PATTERN_SPEC_DM8_0,
        PATTERN_SPEC_DM8_1,
        PATTERN_SPEC_DM8_2,
        PATTERN_SPEC_DM8_3,
    },
    boundary = ALIGN,
	grid = vGRID
);

//***** fill *******************************************************************
DM8_C   = SPEC_DM8["OUTPUT_DM8"][0];
DM8_O_C = SPEC_DM8["OUTPUT_DM8_O"][0];

#pragma PXL encrypted begin
(+N74QZ$P7H@LXGE<07/A'>SIIRK2QI&126FBS5$L2N>O\>+N>^>:DVWJ3>YU-AT!]X'71W4
<NG1(S\E3W1RN$^PS .7)@*XB))WHD2S'W.(IE4*7]$1F+&F
#pragma PXL encrypted end

#pragma PXL encrypted begin
TN]#5>C?@UC2,_0:4*)<7><ST979$PMHC2/1TLIV:GP*])'2<9[O):06U[MQ2@Q:.X@TXF]*
"J$$Z7.@5^@*&O5<>V9X0?L:N@<"!JGZDKVZ/IKA%'-#$($^
#pragma PXL encrypted end
#pragma PXL encrypted begin
%SX#>$DQY@$7#_P(U!>5%?0/QV%5C.+,]GG'S#;)WT5+03W,ZX="@^LJL1WK(+,% 7^EWAT@
SMOX@K1,].;.O7<3>DQN,I:]E<SE/6(7]C65H,^Z9.=WE]N@*TVGOH,BZT8KBH?@IM \0:N*
#pragma PXL encrypted end
#pragma PXL encrypted begin
DO\X"M^'> 62"0Q%]EUP(S4)DQ]-,@-FH V3.BD*#1=<.M4ZZ'<.7CG%DU'HCA-XNJ, $I&.
#1A*%'P&>( -
#pragma PXL encrypted end
DM8_O_L = SPEC_DM8["OUTPUT_DM8_O"][0];
#pragma PXL encrypted begin
H=J!/0O4JE2A!HRS-<9:;%0&SH>E)!9B$JW..JT_\G24'TTZNWRU+3]"H2J[^XX=R"TDDK;[
UBS:S]&S9);6D-[.^8B8A*R0
#pragma PXL encrypted end
#pragma PXL encrypted begin
YBA!8&PE#7[FJ.P-G+=7GM6HMKGXLY0!P[.V=^XN>:]Z/3-WJMYGKPNO+NJJ"J:Y_VIGUTT*
T_WA> %CC_#3FE7YRQ6V8'":$G2G*&>:M"<22J)8$+PKY61*2#6_6]C>,H)(4E:%E*"C>DI2
L>@*>PGL4[^Q
#pragma PXL encrypted end
#pragma PXL encrypted begin
.[=0,-207VH[BWY=!EP%F7N+%O9O]?F@5;T6RDB]3YHJ!DW*$GTYDNO%-[ 2C#XR].31RUN,
U!)VW"9=E7?4#^$E@<T>RQ8/OOMCI.>8:J&^A+VQ=>F$X5V$
#pragma PXL encrypted end
DM8_L1   = SPEC_DM8["OUTPUT_DM8"][0];
DM8_L = DM8_L1 or DM8NEW_L;
#pragma PXL encrypted begin
MWB&0FGG\6VW=PYGGGB P/EWO<)YW%I#V-^]N3.(%WR# !.Y.V&-P:3/]R [QS1;K=N=MC_'
UP<OP72,J-#7N*.\KO>-X1^X;\,LV7_T*$)OO'#DIE?##]6\&C.8TQFDJ!P:G?SO]0W*+=*=
5/->8J*B&!]4
#pragma PXL encrypted end


#pragma PXL encrypted begin
GR"I,VA(Y"6?NA?E2BN7Y?JZAM**G.*:-+R&A?E$O@\3UZ"%I92RV;66B6JEDV.RQS3,U/63
V6"DL]C0@_'9B[:G(^G1M5J+6(3T_ZL_6D98RVLV:8"TQ9#+
#pragma PXL encrypted end
#pragma PXL encrypted begin
KOOQ9I24%G6N>%FP.^B26?-X' 0RTO("NZP<(B$(52FVUI$B+E/A31R'!W\NO??OX;K\P="]
%/I+ >3_PK,4Q>$="XAK'83%K6PK'9FS7>:M0G=;AC"4@8A"&NGMNYW27&T:7%'D=Y!P-AA<
+:I[BA@2%"XM_W$0]25S;_+_)YSCI.S:35@GCT<OO%.M*G"/0Q0=54JFC3Q#0+4G1[/:*[% 
E;PI2'S<M@:5-;6PI.M#5XTU()LZRL_[<8P@(L'&E$Y7Z1,BY8X'WVE8-Q/E._[T@=$#]*$[
>!X'*V((<7UX V4W 4G3E+H#/8I/ HN?WD(]NWSSQ]&=B2R[!Q#&('K*22D'(S^9!"44UY(C
9;;;IVBT:@IEM&+BHA"8K4NTQ[]X37HO%Y#'8I6\:0;1GBIB.^Q@'PZPN)D['X?VJ^FTC5\?
$Q%'1-18]"H35I1+QTWN7==68SEG!9D3P'5CQ[]X37HO%Y#'S^NN:DABZ-K/.^Q@'PZPN)D[
O0";YE^'J]V]!,&7S,Y>&7H$/TBH?WY'^RH_ QUA$V=UQWD#Y#N^>%Y;XW#DS=9;QGI,$$C-
34&/6[[P:-9-%:[R8-M!V'\5T5!;',O$8E'1._[T@=$#]*$[>!X'*V((<7UX]FHFN,!*+?'V
_D%U_VYUM$K^K3-F&X)FRY&M)R*KQH=V"!(GW5K5.+X[11C=]H;0Y*3%%D[V8=#+R+YF1?!A
D8V2SO,E],*1*M9(!1J)/=$J@Q/6 A"JF3:#R#Z1&Q**-=K(NWSSQ]&=B2R[@1((2Z$6A\:!
:#4L2(_DV*MH]FHFN,!*+?'V_D%U_VYUM$K^K3-F&X)FRY&MV8MB88X;%-W9W5K5.+X[11C=
]H;0Y*3%%D[V8=#+R+YF1?!AD8V2SO,E],*1*M9(!1J)/=$J@Q/6 A"JF3:#A#0XW++[T\Z$
NWSSQ]&=B2R[ZK9E^3:0-V'J<3BV%+S4O3YQT%3%J"[^"3C0'W%[(R")')\?]<T Q2R&\P+U
4FE/?+C$MX92ON;X^_\:.DF^/WYLX'-^1+(_RRV;:JHX7T_+_RV*DU(F)G;_B >P^B--"6B(
C N8&-?8B6B,_FVC^K=T?S_^I;\4W?;W^K6E11QB&_6^!\=%2U5Q5,0%MBQ+3@:5$WXW+Z5.
3/AN=<,_86I,384\M4D:BQI-F#O*?B4N@!.8Y><7RX8[I''EP,%[&Y=0^]S G6GTP+SFG5*=
($+8X\$.N;D@V)ZB[AC'GBK8ON;X^_\:.DF^/WYLX'-^1+(_RRV;:JHX7T_+_RV*DU(F)G;_
B >P^B--"6B(]%@,5DW9F3STLY./U%6GR<ZSEAK+@=)5F=B6YYG[\WSX%9SGON;X^_\:.DF^
O]$AXA"W,PR_QK]D.UM1B/G&L1Y#9PV(=!&Q=+A,SKYPE*1T0 YUX2/^/B5 EM7@M3%UC7>6
%JR9"XEU(V06RT!B5B.#>3G+ 93Y5WG8"M !%?4ZR10A[W053@:5$WXW+Z5.+,RQ0"D3- 4L
0!."KF+7;PM DZ.GC62N[A&3I9&T<K GXY:E3@:5$WXW+Z5.[CPABR9%#)'NM'OP&!! R4"T
%)S6. KV/544CZ8T?,3/>UZ/06.((VGLJ+!!E52+WJO<^ F51P[%>;Q[#?A'OUS6Z^4(0/Z_
LGR)[PT2>.>R!.J=6N!TULT$C2;OE)V.K&"-\;W9E2AIJ+OQ#V5*5E2_%^(/D@+0GFN4/]62
_%&/<B\[9H_\0 YUX2/^/B5 EM7@M3%UC7>6Q,,-^CR?+ ?$@@VO\<?24X:"%)S6. KV/544
Y5%7V'\W%DCEE52+WJO<^ F5\7/=#9[YYYKQVA]](Y%9/XS:#8GOW\Y@=GH- A[QAO&D.7P"
_,X/G\%3$W[\ ]BS%^8YM:@#8'"?:!W(9WI@!+_5\=$:S $$@CAO+SQ<X3^"D0XI MKK+OJ1
:O^+L2N[3BQJZY*<^OKS_%'KG]F&;48/=&R?\Q8ZA1ULT\WS05\T@,>YOQ1!".@SF!:NE6\(
G]F&;48/=&R?:N1O?K']O/]J05\T@,>YOQ1!-V[@SFLA*B(W0 _AFMELU,9 \'I&4[#$.<?P
Y6R'?:*!83/EOD((8%S/Z$J^:O^+L2N[3BQJ%NG!'L]S#IP6DQ1?JL>25D^3.,E1F<9[_F<X
%IH.SS!\D(06C2;OE)V.K&"-VF4%R/#:BX;:#VDIK[TQ@\L/G]F&;48/=&R?:PT9CW[S".UK
AY;W#;=WH2B'5)-)VE9D<O)47HM8\#Y9Z@I>D@+0GFN4/]62Z (VZ9VI$#WHL#;]OT,O&X2P
ON;X^_\:.DF^7KDV2QVE [=>L-BF=MH5C<6PY6R'?:*!83/E:RS@@.I>&!1K:O^+L2N[3BQJ
%NG!'L]S#IP6T273OY:K&@+1.,E1F<9[_F<XATJOIA,*356'C2;OE)V.K&"-VF4%R/#:BX;:
8G6X=F8E;^!BG]F&;48/=&R?_%Q>H]89,R;\0 YUX2/^/B5 EM7@M3%UC7>6?:V19PR*XK%]
RT!B5B.#>3G+M(L';Y9>6U:TAY;W#;=WH2B'W7; ]$P,&X_="E+F--Y^>O,*S6+L*9PS=\3-
C2;OE)V.K&"-&ES-U(>0U[(:F](Z4U$&<>N;':8>^/\/YQL=)KGO6(<CYXHFS*=NA2AH4+_,
S)L<X36=#A7,05\T@,>YOQ1!-V[@SFLA*B(W0 _AFMELU,9 R@7P89)DL^G*(VBO"'8'TJPC
X_%>ITC8]ECC,[=3.;W%UA$S374U#OEU-+1-C2;OE)V.K&"-VF4%R/#:BX;:%01?RXSD&4<5
G]F&;48/=&R?W!%?L"@6W(?<0 YUX2/^/B5 EM7@M3%UC7>64OV)O2!G0O12RT!B5B.#>3G+
($SKYI?E\@D@374U#OEU-+1-C2;OE)V.K&"-VF4%R/#:BX;:%01?RXSD&4<5K9^R]E3-H7"M
]*V 2=$XX8[T?H#W9<YOG\1^.K11@N9Z4/,ZAY;W#;=WH2B'_*^$A_^D2>S\NWSSQ]&=B2R[
Z(Y!A@=AJ)'H05\T@,>YOQ1!6(9&)AWB70=8Q,,-^CR?+ ?$L&H%*)0SW*2P_N5<O\.&EQ#^
:>K+8]>J$4MI4:GFTMAJH(51NWSSQ]&=B2R[Z(Y!A@=AJ)'H)B>HE0#[4<\F"LCM Q@@(Q(*
-JJ'^&?/]W4V0 _AFMELU,9 XW[7F#]=\>SCD@+0GFN4/]62 = ,;);P8+D!AY;W#;=WH2B'
_*^$A_^D2>S\NWSSQ]&=B2R[Z(Y!A@=AJ)'H05\T@,>YOQ1!6(9&)AWB70=8Q,,-^CR?+ ?$
L&H%*)0SW*2P_N5<O\.&EQ#^:>K+8]>J$4MI4:GFTMAJH(51NWSSQ]&=B2R[Z(Y!A@=AJ)'H
)B>HE0#[4<\F"LCM Q@@(Q(*-JJ'^&?/]W4V0 _AFMELU,9 XW[7F#]=\>SCP,%[&Y=0^]S 
G]F&;48/=&R?+!+5T(KW5P8LQ^2J.!M;;=_']GFD(B<KI?GV0 _AFMELU,9 DMD<6<A7Z3^2
AY;W#;=WH2B'.2L7HU2 #%0YNWSSQ]&=B2R[Z(Y!A@=AJ)'H)B>HE0#[4<\F"LCM Q@@(Q(*
]GFD(B<KI?GV0 _AFMELU,9 DMD<6<A7Z3^2!A]CF+&PZT\&7Q?IK7\13=I?F?4@%7MF\S>9
/X_+E\ACTSP_R32US70$N9')_;;':@;@FT+]HXH>??"RG-VCQ^2J.!M;;=_']GFD(B<KI?GV
0 _AFMELU,9 DMD<6<A7Z3^2AY;W#;=WH2B'.2L7HU2 #%0YNWSSQ]&=B2R[Z(Y!A@=AJ)'H
)B>HE0#[4<\F"LCM Q@@(Q(*]GFD(B<KI?GV0 _AFMELU,9 DMD<6<A7Z3^2!A]CF+&PZT\&
7Q?IK7\13=I?F?4@%7MF\S>9/X_+E\ACTSP_R32US70$N9')]%@,5DW9F3STJQBO2W$UM]NK
D=:RNYR@[+Z1VOW?)]8ON\#:0 YUX2/^/B5 ?A\7V8&EV'U^8YO=8N@B_5YCJQBO2W$UM]NK
BW0W]/'%7@R+7_3X<4M UT5?]8K@#^T(C[WU(]7^9[?2I7HC_,X/G\%3$W[\RT!B5B.#>3G+
JQBO2W$UM]NK0P43BYS/%H-#I'\F(AJ>!"6D:5@&YBGVQ:!IAY;W#;=WH2B'W7; ]$P,&X_=
5N&,RS@V:LI6JQBO2W$UM]NKDB1[GX*CGD62#@GN:L>>&1$.0 YUX2/^/B5 _I8;7(71]/7^
3NJ*V3BR]BA._>:Q2*>KC]#]*8EL"I!EX&HIO%HAZ[G_(X>\JQBO2W$UM]NKU1'WZT<QW'C5
*[5V@K.T-_ KL+PEDL"_[1&P05\T@,>YOQ1!,%CY!X&L,<8P+8]E@]<;YQXMLG''T^^*XK^R
LQHOCK6LEH*S70;:X?QX7(E=>_R0=Y;<V%%[FA#QI[*U.W":JQBO2W$UM]NKX;,#\EF5MH;A
,Y!"<#KFYNHSQ_S</<;7)A''E52+WJO<^ F5:]>HK3^37O!KS?9DY?WSYLS--MZ%<_/N%C(V
=R'MYM*SD:!W5QP"(/IDIR=7%_+<'FY9;&X76ZZ\"BM1O95;,P:%F[R!9>8SQ_S</<;7)A''
E52+WJO<^ F5:]>HK3^37O!KS?9DY?WSYLS-6L&TQNJ#PG1:JQBO2W$UM]NKDMKM),Q'2IN2
R8'G.,7_'K7)P?O2I>BE+8/!ON;X^_\:.DF^;4B72,PGN;)M/3/$)AOK^]X]JQBO2W$UM]NK
#8GOW\Y@=GH-%M7.NVGZ^3(605\T@,>YOQ1!-V[@SFLA*B(WHF<D5-W503:BRT!B5B.#>3G+
JQBO2W$UM]NKERM5GZI*9T270 YUX2/^/B5 EM7@M3%UC7>6A*99 U$7ZZ&$E([L,0HW '&4
;<&NDZ)=8FUMVL]*!_6(?EW:][GN!,'50V?W6ZZ\"BM1O95;R5PU"7YG>NO)05\T@,>YOQ1!
U)SC!CU]!<74>TG<21YT2H=[%_!F\A?OT? 7$Q?%4"]*&=X3*=F6+@:*4!LIRT!B5B.#>3G+
255/0' C@1Y)O*^?L1RR&_*\MNEA$JXR:6>V^IM*,?!#AW;ZA,/K0;DO(R.$ED<W6PB1^PJ6
I$K"&X)<0]BDD4<>:ZVS/K^1.H:75: TG5<Z#8D[55$BVZ4-Z653[=L24GCI*<+K?]SBAU I
 :J@6#P9AW4!:1U4.%4^:,5I8/EV%I $<2M@8/EV%I $<2M@8/EV%I $<2M@8/EV%I $<2M@
8/EV%I $<2M@8/EV%I $<2M@HS! <=QJV VCI?^N]0W:6"VE+(&R,##53V4LJ%#F$?<:$>&H
A_/R_8$?7W2'Y>:MT^FG5-+E8>#X'HR?U59A)SJW!RAK\IHG']ZW"C::^-8?^>MO O=#:H[Y
;B-^O,I$PLIN,1>-6,'^R>PQ2V\K+FR,*_!+T'8O  4SCJO0(/YZ]4$ :@8@\\74+UV1%;/S
Q,,-^CR?+ ?$('G/+.$H&]X@NWSSQ]&=B2R[GRR((XMH'>6?C_O=(#_"9SJ/LWS[4R($^K^S
M6?)Y-@H #BU<I0U^%=-NC5RNWSSQ]&=B2R[@1((2Z$6A\:!:#4L2(_DV*MHY6G=\7P,,;KE
+K9Y<84TK40NF^7QXK9!3NN; ,HT ) 4!:( ;!_<EM(RED-LC_O=(#_"9SJ/LWS[4R($^K^S
M6?)Y-@H #BU1U/@7O%D6K1'NWSSQ]&=B2R[%'3* 0*:_K@4LL^N:OO)C_*RQ@^TRR=TT 7&
%:[R8-M!V'\5C([>GD.P812,WY4/@J8\IIC?'<CB%(*P&^\=&ES-U(>0U[(:$&-^K O^Z5(0
ELN>A9NVT="6W5(@631C'M?=V@.DL6<+JC/: ,HT ) 4!:( (K;JNU&HP<\B;JU](^*6RY)N
1WK=9L6HLO='N?:V']FO.6:Y^!QZ%3(+9)3XD7:'"# 'I5N1M#PF[%%F7""TSEW4VQV#_H[.
"O U62G/1F8*>2"> 1HW+L9Y@S@RP#T9)8Z#=7&X/.#7V,EU'M#>$.Q<M"(>3E=H>ZL2HA5.
NH"+!. 4?PBZ[-PI($*54?#L00J/VY^IS<!!TF%O(Y!KGX[2\[ASXLBXI"GSY8"-3PX L(3E
R""S*E4FBBK(E*W!U2M*#V64M:LR+]H,C$2U!8!N0"6TA94%*-[A0Q$6S;8HVH>2FR.4V]':
-UDI2@/0^JPW;MELP#V:FW5N%2?"<^5)+:X5K]6BH0P$_7"O]H;0Y*3%%D[V8=#+R+YF1?!A
)CB5<$Y\ZI@FKR(O_;?7E7VOLNNI(3_]PLNR_%&/<B\[9H_\8Y=%YIQYB21C^X\())86N##[
@_IV\I&MG,Z#0LXJ!#+<GN)"S_"9&?AM&W?/J<4$FBU)_-:I"XF2)R!4@'<+P=WB$!6@CT[!
+OQ[95>3C^XN(>DNIM\PY-4AH1=[ 46K;S^A1>J\%)@29 E%G&K\2R^]S6R<6[D)N#?[,=A;
H?7L%D@J;4NAWK.D4L9,3O[>6[D)N#?[,=A;&:;?4!+8/I 9WK.D4L9,3O[>K9^R]E3-H7"M
QA35D_UD[\#&F>"EO8&[[FF9#V%"K#=<<10/]3V EJ3=JQCU436<:<UTCX91\=>(H=WIYC?Q
*.;OZ8:@;/THP&_'&]4W! ; PHI5?0'<LUS"744S7M[P[9E=.@0WD4*J'CTZ?3*,19'')(U]
N)S:D6AU#2:XT&1+QQI*8 30#YJ35;X#HW@/\9W/2>2(5H'QC&"WYM"+[K",*R&?)C%:IO$K
WWN3\CG[BTO?X2O6 AT\9$?AN)S:D6AU#2:X1?S;8FYU&!]%R2!@@3*;1!_)+/2%(7#(Y(4L
#-*BTSAJ;T\,#CFQ,%L;Q'T.NYTL69L?=/^[5IUAS-$^^QY65IUAS-$^^QY65IUAS-$^^QY6
5IUAS-$^^QY65IUAS-$^^QY65IUAS-$^^QY65IUAS-$^^QY6*9*\.KK9-4HI:&*<(J6T\8EH
/UL"1-4&:^$__W$0]25S;_+_>J#?P3<JP4IZ]H;0Y*3%%D[VJ_)^>8P3'6^KPE%FE6)&AEK"
5!2,SSCNTTA4J,,%>^ ?6+VH#8J_VI[I& T-%NVG$"A3.OP6&S8=!C 586P;P&MFU5[P4PW 
6*V*E%Y,"-98-4T2VM&=\)$UN4*?OD][Z]BYR)8C AIH(Q;(M?SF$G=:P4>UQ^H^.4D>PLC'
FB>7^II<SZZ:(H!@59@ZPTXB2V?O+AJ2ZBQ+2"F$A)$7)$E(45R]^U+F!_Q1AO%AGP>:=?F&
-QA!AG(JG#\W3@B)BM6% V!.IG&4<RJM B&F>_HVU9)I)HI[R#S)\J6EVQG(BS9[VU1_:'Z+
D>Y#(R7+9EB1!CWWDB^K,L4&?^D N5BA'K-_;:M83H\$R4!MF],6!>U/9H.;0 1E0D/,@C% 
:&*<(J6T\8EH.UC5,7&'S+D[FXL 9^ZT-YV;>)O] ]0HW.YX#&9SY%%.-4H,%ZW*WZ-U*R(7
W!0-R"[% ES<6-Q.8U&&%XE8'6<$8_0KT6T=.=+]9*!_1UXY436<:<UTCX91X]2]?C/&4?SC
SX$F[O%DT5//Z7WUKJ&'G>KIYX,LC*,$V3?GC^4OK;X0^]"/2L$O="RFO$Y*N;$,A>XK5:>Y
G=HAB2-JG/Z=W4H3 78-4NG=(*Q].YEJ)> @_6_\"HBS=N?]VHS.&7\H )/:0N;,!F0:%U!"
9)4%'?45TF!D>/CF85 U7_QX0W@.ILTCIRU#XY/(AV^ R@7CMIJGK KK@<BV/<,*>=F*1M\]
-Q,"--5;$9(WLG[B5K% _3:RJBT%(53#%VBJI>D]_WNF7/6E8,#Y,">,-[1@&YC<\_<<['H;
]*TF"1.Y=-WTT_Y[#\(F0H+3\HJ(/%4"_]/R&Y'1T;![LE<;L+VUUI"DI>&P+6&=7]WAL*@M
I>D]_WNF7/6EZN;QOW2SK^SJ&YC<\_<<['H;]*TF"1.Y=-WT&B=A_K^O@N8:\HJ(/%4"_]/R
&Y'1T;![LE<;L+VUUI"DI>&P+6&=7]WAL*@MVVIC1VG 0$/;]8;9Y<8JB0[UAM3L5&66Q:R&
B=T07+6O).:)HS/8<?*_:G*CB=T07+6O).:)L9+Y*)&"%\BQ&& 7U*P@"U 8_"3HDNM.&)O\
T^ =U>FUOP;32W;)A2T)>U=+>M.+[N,>D=!Z-SSJ+ AKAH,WNR2S=4K4]06['.C1PR*.3"$<
Z7WUKJ&'G>KI4%J&X?B\%+Y0+J);1](#:)<N1.RCC1U:&=E$AA./(2P(<A:&;<FX )]H5-EM
+X9+YVE5!M,O5[U6.-I6_9-7<+UC&#M+V59P@@+$Z"+## >"D3Y%%ZCJ6*&1JQBO2W$UM]NK
8A=OS'RQ)S%BWBFR-!^8WE?>UWC&?$GP&I#701T!I]5!$!]!,6[.E-Q0S"8QG*OO%/M$$N6<
;2/!>WN[KXIM<\[H,&_:DCIS%_+<'FY9;&X7JQBO2W$UM]NKJQBO2W$UM]NK5LI4KA+%0P16
U&<QI$23UR;4Q0*@/GW?I+3%4J?2E47<(KA24+ZK7@2%/Y!0+6.4%MT;]-XMJQBO2W$UM]NK
C<1*ZTKM>72-@6+&CC2;>XJ!;3PHZV8@6_MM;E=<&EHUAEUNLR,W8IZIW&>S=0[1=-#!W4]U
0N;,!F0:%U!">EH\+3/C<C]ZJQBO2W$UM]NK<>.YKVX9\X]QAY-\K5^3@4"'&PDJHPP?XI8;
JI(BC<$'Y>>JJQBO2W$UM]NKII%<,BR//GNF5B_0<T>H@D16('Q@^@57NO\@JQBO2W$UM]NK
809+52Q!>>)A:.8P))![<N-H.@>%RJ!84H@ZF:UP+<Z2NX>9'N\2%.<GMM<>5R\N&A>.BWA7
RX*8)4?9W";+JQBO2W$UM]NK>PB#7X[CH#1[7<%H>+Y8+91=[0$HD]-"7-;MUI2"]4>!L2?6
?EXRVQ][P'A^3?(/>6/%ESI-6:CE4 52&$!9-1E4JWE<SP$U*+KF1IWQA)\H?2& GED-G 9]
L[TA8-IG.Q*S']MUNJORKU<?3Y+E^TXD-E]/7P]\^-,2:[A?@-J 28*7<1> SG.OK?U%GNO.
J1*3G.UCQ@JI@D,&_U@"+#F"'20@[21VW'4=VHV5B+4(\%G:[E]_]Y1BO%;N?=I7N(O&3*M]
JD>)TL]H$]FJ6"/*O)!P49M8FXL 9^ZT-YV;:_[#?J(TRXYKO:>VI*R$7+*]0GBFT#WB,;%"
15FON< *RB=%WA&JL?Z=A6O>2BJ ?MDBCG]*<[<IJ$PZAS-S])*6M&>"88#T-PWJ*U;?<5<W
)=O[@ZU@Q\<EVR787&^H]%7;KG+E24RE'%>N3*BU+:<Z>>],PE8LJ)\4C37"KG+E24RE'%>N
T]C177Y8R:+3+=K=,&F/>0LMP%F/_N,EPD' 5D*#>+@E=MM6PV_7L+\+M53#(&2B8J.UPHH@
4*7,A"^K+4Y0>>A)00DNGJ-Y>#"8I1R4&XYX6-Q.8U&&%XE8Z_(T4U')_/#K(+B='/R@1V0@
B=\T!D$8SOJ)2*/3UJO+(DU(D9?+6E(?C1B122D8T214US))_%&/<B\[9H_\8Y=%YIQYB21C
^X\())86N##[@_IV\I&MG,Z#0LXJ!#+<GN)"S_"9&?AM&W?/T61.Y@TMXW71/)%Y !(Z/4P\
_#\JJ_?6? ;\SUVJTL;T7=K/>@,Q#&\/\%]Z>Y21FOH1_$-[)JFRBTT-"'@FY0;:S3]W&\+E
=PT'OH$I9.QWWO /BBN(;L+>]6) >=ULV*KU'%5MAL@R4AL<#S@878%8?]D/O9);M&XEH3&]
]6) >=ULV*KU'%5MAL@R4AL<Z7WUKJ&'G>KIYX,LC*,$V3?GC^4OK;X0^]"/2L$O="RFO$Y*
N;$,A>XK5:>YG=HAB2-JG/Z=W4H3 78-4NG=(*Q].YEJ)> @_6_\"HBS=N?]VHS.&7\H )/:
0N;,!F0:%U!"9)4%'?45TF!D>/CF85 U7_QX0W@.ILTCIRU#XY/(AV^ R@7CMIJGK KK@<BV
/<,*>=F*1M\]-Q,"--5;$9(WLG[B5K% _3:RJBT%(53#%VBJI>D]_WNF7/6E8,#Y,">,-[1@
&YC<\_<<['H;]*TF"1.Y=-WTT_Y[#\(F0H+3\HJ(/%4"_]/R&Y'1T;![LE<;L+VUUI"DI>&P
+6&=7]WAL*@MI>D]_WNF7/6EZN;QOW2SK^SJ&YC<\_<<['H;]*TF"1.Y=-WT&B=A_K^O@N8:
\HJ(/%4"_]/R&Y'1T;![LE<;L+VUUI"DI>&P+6&=7]WAL*@MVVIC1VG 0$/;]8;9Y<8JB0[U
AM3L5&66Q:R&B=T07+6O).:)HS/8<?*_:G*CB=T07+6O).:)L9+Y*)&"%\BQ&& 7U*P@"U 8
_"3HDNM.&)O\T^ =U>FUOP;32W;)A2T)>U=+>M.+[N,>D=!Z-SSJ+ AKAH,WNR2S=4K4]06[
'.C1PR*.3"$<Z7WUKJ&'G>KI4%J&X?B\%+Y0+J);1](#:)<N1.RCC1U:&=E$AA./(2P(<A:&
;<FX )]H5-EM+X9+YVE5!M,O5[U6.-I6_9-7<+UC&#M+V59P@@+$Z"+## >"D3Y%%ZCJ6*&1
JQBO2W$UM]NK8A=OS'RQ)S%BWBFR-!^8WE?>UWC&?$GP&I#701T!I]5!$!]!,6[.E-Q0S"8Q
G*OO%/M$$N6<;2/!>WN[KXIM<\[H,&_:DCIS%_+<'FY9;&X7JQBO2W$UM]NKJQBO2W$UM]NK
5LI4KA+%0P16U&<QI$23UR;4Q0*@/GW?I+3%4J?2E47<(KA24+ZK7@2%/Y!0+6.4%MT;]-XM
JQBO2W$UM]NKC<1*ZTKM>72-@6+&CC2;>XJ!;3PHZV8@6_MM;E=<&EHUAEUNLR,W8IZIW&>S
=0[1=-#!W4]U0N;,!F0:%U!">EH\+3/C<C]ZJQBO2W$UM]NK<>.YKVX9\X]QAY-\K5^3@4"'
&PDJHPP?XI8;JI(BC<$'Y>>JJQBO2W$UM]NKII%<,BR//GNF5B_0<T>H@D16('Q@^@57NO\@
JQBO2W$UM]NK809+52Q!>>)A:.8P))![<N-H.@>%RJ!84H@ZF:UP+<Z2NX>9'N\2%.<GMM<>
5R\N&A>.BWA7RX*8)4?9W";+JQBO2W$UM]NK>PB#7X[CH#1[7<%H>+Y8+91=[0$HD]-"7-;M
UI2"]4>!L2?6?EXRVQ][P'A^3?(/>6/%ESI-6:CE4 52&$!9-1E4JWE<SP$U*+KF1IWQA)\H
?2& GED-G 9]L[TA8-IG.Q*S']MUNJORKU<?3Y+E^TXD-E]/7P]\^-,2:[A?@-J 28*7<1> 
SG.OK?U%GNO.J1*3G.UCQ@JI@D,&_U@"+#F"'20@[21VW'4=BW['TD.;6@N+RE?GP"8:N&K*
^-RE\+ X#[;XU9A#[P<Y2B35;8$GE XE#P%M)JFRBTT-"'@FR.90 C_#\)/()B*JD*1*79TF
<15,O5PM8N1Q ]AC3_;X6S0#WH7"0$[-%N;> GZ_4Z7$=S,"P=2QIN3X;-C!%M%*2,6_#)P6
Y)Z[$[PZ21_D*QD%#3?X3.\K7VRY:V-MTDM?])_!>Y&;H2_T76<;&A.N0\E=7VRY:V-MTDM?
])_!>Y&;H2_TN)S:D6AU#2:X62IY)M_PP&I90VE"D(8]A,M#U'*Z!9++OI[4E4X;L%G0#K.5
\Z_*M]^LZ*GS'%$KVC0P:?D<JC?"5[?<Z>BJP?\=/ZF2'.[!NO2GQ2[S/R^Z/U/G6T7+LNH_
5IUAS-$^^QY65IUAS-$^^QY65IUAS-$^^QY65IUAS-$^^QY65IUAS-$^^QY65IUAS-$^^QY6
5IUAS-$^^QY6EUE"?K MZ:.7S-/]"BB.%6;,*N^N^V$!SNLJH/XPRPPCJ&.@E6AO=%MF)Z25
AM0<P//%]IZ&X6C-MLK[F6WA(^+>5A0N_WDCI?^N]0W:6"VE+(&R,##53V4LU4GDJ;/TOEG5
&MTSX""*'HX:08UFXN*;+C]!A_/R_8$?7W2'J 7^U\:%W6^HE3T68;C3=1N5G^\2^1U2IL.?
\R&@>B+M<M?SKU*K5M+9"6>O;L4#IJLD\^UN<@&%-.C7/"AR8SEG!9D3P'5CQ[]X37HO%Y#'
8I6\:0;1GBIB.^Q@'PZPN)D[6KO6-&\C+*M:!,&7S,Y>&7H$/TBH?WY'^RH_ QUA$V=UQWD#
VJ#3N&F^&F_:LL^N:OO)C_*R'\[B-_T_Y($?P,%[&Y=0^]S XK2UD_A09>#B/TBH?WY'^RH_
 QUA$V=UQWD#DOK)E>MKDS22LL^N:OO)C_*RDC^CS\6VAFR2S=+#?Y7I_/G-1AR6,84+FH!&
@Q/6 A"JF3:#%=S6.8@M3@,5.^Q@'PZPN)D[O0";YE^'J]V]DO*2I/M1TYR2KU*K5M+9"6>O
;L4#IJLD\^UNF>O8R/+=KCZ9:]D5S!<W$A]K#2TC%>H8XA8-VV3INA"'[8G;GJVR'YB87_F>
T@0F3MS19$K2V"*LS58]<AS8GV'J.S3@LXZ?R&%'E8^6EM[(X^E,G,YB%3/C1[,^2"OJ/HY'
[Z,#TI/5[5'OLL^N:OO)C_*RZPBP^5K+O^+K^KC(U%:RZ%3ZII;R!CPWK/.FP4/A<PKN5K#!
6/KX%?*;5&A8-]<#-R!D9;LW!9J6R$6QLY$%%NVG$"A3.OP6&S8=!C 586P;7JCC6JGO1*Q>
J&IL,Z' K9:HB/L-70J *=>(NWSSQ]&=B2R[F%KGD@.8F/J8V> Y.., 1TK9VDWG[$AALM+:
T[(0,@E9D)[3'$UQ, QUU;<<#X"PX=&_RIP/N^7_7?@_>E.[AY;W#;=WH2B'5)-)VE9D<O)4
W?[43NL!9Y3=$<DPD.X!EE@1JPOU[X';Q NK9O_*1F.:?I]F3XPD4Y=G/JI/.?CY](P='/TY
TZ%DT:@D^KK3[3(%@>3>?)7MKN3E[<JTU^RNE52+WJO<^ F5PM+$T(6Q;*W")-EM3&5DW\@D
*COKQ=51S" J*FE;9)%T:)XJ=]IE_32ROX1W)7WNU+$L7+@E*>^[O-@@DCTIAY;W#;=WH2B'
5)-)VE9D<O)4W?[43NL!9Y3=$<DPD.X!EE@1JPOU[X';Q NKG^MDC$7)[F>?2W=4#/D6R6Y+
!>Z;T$ X^/H%%07! /,10L$5AY;W#;=WH2B'5)-)VE9D<O)413I]2@^ E8M%D@+0GFN4/]62
<J&R1@LGZ\!R',MHY3RE:!H<05\T@,>YOQ1!?9Z'Y3%>6.!]/>ZMM_-.!;,]"E+F--Y^>O,*
^?F14UQMS<#YLQO,LSAU\E^SE52+WJO<^ F5'T6[RQ^_2ZD?DP=4#X(F7ZN38__:ZD8<++IC
+%XZSB,9WI(LE52+WJO<^ F5E.=EK&7C$ON44[&"1F1T13Y3/BOW_=_O!6,^KTB^;\@"RN>O
0 YUX2/^/B5 EM7@M3%UC7>6_'D\4W'Z/$?\RT!B5B.#>3G+=H6=L2Y9A7QVDTENVQA?UHR3
:O^+L2N[3BQJ\V$$':6,LW7SKMS"Z=ZK-I6NG]F&;48/=&R?=S7OP-/HELYW05\T@,>YOQ1!
-V[@SFLA*B(W0 _AFMELU,9 \'I&4[#$.<?P6&*;%4QCJJ=80 YUX2/^/B5 EM7@M3%UC7>6
A*99 U$7ZZ&$1\"^79;,--U'7^SA,O?":)A?AY;W#;=WH2B'@E*O-SMZCM."X4VP#A#BD7CA
?G,< Y0C>X=^3XB_;8JHSY%/+>,/8% (8)0ML#;]OT,O&X2P_,X/G\%3$W[\A=3_0YM]ZC:%
.,E1F<9[_F<XG7Q1C@;)O[2=3@:5$WXW+Z5."+1/5 )025T(.,E1F<9[_F<XM:5)?Q-N^%JU
3@:5$WXW+Z5. ,HT ) 4!:( GS@&K,S)&U&?D@+0GFN4/]6257L[J3D65?Q53X]YO0]<>=%/
ON;X^_\:.DF^7KDV2QVE [=>-9CT#7[Q7X0UY6R'?:*!83/EG(!-8=*)4;.<:O^+L2N[3BQJ
%NG!'L]S#IP6[3&?-6H=Z\3M.,E1F<9[_F<X58GK<_AW7Q-5C2;OE)V.K&"-VF4%R/#:BX;:
EM*M?R.[0RF6G]F&;48/=&R?4@ W2*!8^:Q2AY;W#;=WH2B'5)-)VE9D<O)421,*F5G!*#E)
D@+0GFN4/]62.AIN8F*L:*PZL#;]OT,O&X2PON;X^_\:.DF^7KDV2QVE [=>QT:!  Z,HE['
Y6R'?:*!83/E+F\)#^M#NX4N:O^+L2N[3BQJ%NG!'L]S#IP6\F*?&-/-YESR.,E1F<9[_F<X
3U!G OH/B<Y/05\T@,>YOQ1!-V[@SFLA*B(W%=KTBK39;!@5"E+F--Y^>O,*'4/:J,:6$<H=
C2;OE)V.K&"-K1<_BR%/IJZM_;;':@;@FT+]M2_&SI#P*;"U:O^+L2N[3BQJ@Q/6 A"JF3:#
>70$<;O=[S=YC5A"@/TGOV2-C/@]=,G?H=J,G]F&;48/=&R?V+6U]5:.L&C83@:5$WXW+Z5.
 ,HT ) 4!:( X8>YSDQ52+[A&P&DZ<&FIO8;<Q-<_!PA1Y-SVLL/82 >NV[:!%,>PV2_MH<$
CIM,L$,)/'*.:O^+L2N[3BQJ2UP6[KZ_[YI+Z@3[$'&-1"KJ.,E1F<9[_F<X8H BY /V!MYB
05\T@,>YOQ1!-V[@SFLA*B(WXX"#5OV7_[_C"E+F--Y^>O,*03U'EW'7@<=!CIM,L$,)/'*.
:O^+L2N[3BQJ2UP6[KZ_[YI+$<=,4]#33VX11AXCXXDEY A&@TC,D3>;YM*#TM91%Z@GM=+2
!*I-.\XW\,\$C2;OE)V.K&"-_>UX%7E5U;S]/X_+E\ACTSP_*>%!D.>^Q^,IQ^2J.!M;;=_'
-JJ'^&?/]W4V0 _AFMELU,9 DMD<6<A7Z3^2!A]CF+&PZT\&7Q?IK7\13=I?_>UX%7E5U;S]
/X_+E\ACTSP_*Y;,;6W;<8TK=N-5IF/U97-VV@.DL6<+JC/: ,HT ) 4!:( X8>YSDQ52+[A
BU<QK3[S9[B+G]F&;48/=&R?</Y)XWYCK'1PC2;OE)V.K&"-_>UX%7E5U;S]/X_+E\ACTSP_
*>%!D.>^Q^,IQ^2J.!M;;=_'-JJ'^&?/]W4V0 _AFMELU,9 DMD<6<A7Z3^2!A]CF+&PZT\&
7Q?IK7\13=I?_>UX%7E5U;S]/X_+E\ACTSP_*Y;,;6W;<8TK=N-5IF/U97-VV@.DL6<+JC/:
 ,HT ) 4!:( X8>YSDQ52+[ABU<QK3[S9[B+=]IE_32ROX1W.,E1F<9[_F<X66_?B#US0$=9
D5+2QQI>QUJ1 ,HT ) 4!:( X8>YSDQ52+[A;GXRBT?<0EMNC2;OE)V.K&"-F?4@%7MF\S>9
/X_+E\ACTSP_*Y;,;6W;<8TK=N-5IF/U97-V YX34O*5CU4# ,HT ) 4!:( X8>YSDQ52+[A
J=5DE8K5AM6ID7M&>A<$K2R1P&5>^C3;D$7 &ES-U(>0U[(:F](Z4U$&<>N;YM.:B7 G-,SF
#17:M7MG[JT-9A6&XK=\8*]FD5+2QQI>QUJ1 ,HT ) 4!:( X8>YSDQ52+[A;GXRBT?<0EMN
C2;OE)V.K&"-F?4@%7MF\S>9/X_+E\ACTSP_*Y;,;6W;<8TK=N-5IF/U97-V YX34O*5CU4#
 ,HT ) 4!:( X8>YSDQ52+[AJ=5DE8K5AM6ID7M&>A<$K2R1P&5>^C3;D$7 &ES-U(>0U[(:
F](Z4U$&<>N;UE6*#I!-1&W62W=4#/D6R6Y+JQBO2W$UM]NK.,E1F<9[_F<XHU>4(<Z.8NNC
05\T@,>YOQ1!C7P'H*@X6#B--)8V%QX3I;DTJQBO2W$UM]NKK996A84D.>>MZ2(R>92#%T+I
:5@&YBGVQ:!IAY;W#;=WH2B'W7; ]$P,&X_=VK&Y)5YRN"W:JQBO2W$UM]NK^(YPP#%@U*?X
 2][A QL5JP!48M/>&*+YGQ1C2;OE)V.K&"-K1<_BR%/IJZM%_+<'FY9;&X76ZZ\"BM1O95;
:*:]C#>U:29HIR*"@*$G>F6G05\T@,>YOQ1!".@SF!:NE6\(K9^R]E3-H7"M!/9<!/WN83T$
\5A2WG35F*#Q?/9EO87,)A%\JQBO2W$UM]NK9C_#HX2(N6!F%;N3CQ[-!=@5E^I7U2%^<,67
3@:5$WXW+Z5.*X(3JE6D\F0K@,*Q8!]P6AB F_]B@Y22C2V;'5FQ/DZN+F@=09)'X&ZI*)]!
)DX<S<^,?P(F%_+<'FY9;&X76ZZ\"BM1O95;,P:%F[R!9>8S^(!50#U2CE3X0 YUX2/^/B5 
%B1TXEKB^@\6]F;H;NBOD\WV.H:75: TG5<ZE  ^B%&N9.:46GH>'K7+7BM:*L6^I)U^*=(J
JQBO2W$UM]NKU1'WZT<QW'C5DH=+>43<^W620 YUX2/^/B5 %B1TXEKB^@\6]F;H;NBOD\WV
.H:75: TG5<Z%_+<'FY9;&X7EJ$']&>-JD^6/)%Y !(Z/4P\R;3?N#O;HZ/)AY;W#;=WH2B'
5)-)VE9D<O)4I??V-H&_S$NE@\5.0E[Y+=V#JQBO2W$UM]NKW\BY8:0Z.<??_XXBE1LP+/C_
3@:5$WXW+Z5. ,HT ) 4!:( L\1W\H([@_VSVK&Y)5YRN"W:6ZZ\"BM1O95;+X)N1W'[Q-8O
05\T@,>YOQ1!-V[@SFLA*B(W(V;A%N 5=;0CRX*8)4?9W";+JQBO2W$UM]NK0(@ U$61LCI 
]VTY=K4CN #W3@:5$WXW+Z5. ,HT ) 4!:( L\1W\H([@_VSVK&Y)5YRN"W:6ZZ\"BM1O95;
/%MFHYZ#WUL\%73MX"AN5NX5(]7^9[?2I7HC_,X/G\%3$W[\RRV;:JHX7T_+_RV*DU(F)G;_
B >P^B--"6B(JOXU2[Q="N*J9-MY;>$7LHIDGZYD111Z6V^?5I_)G%0[ *I61) W#[(=0[U$
F%(0D!&F_%.8T^81)Q?T2D_3:#4L2(_DV*MH@55^0WW<H9Z!&B^7!*-7:= :T[(0,@E9D)[3
I^2*/:[#<(6G67Z N?ZJ7"Q9H]-ZUQ 0_"BCT,(&MM+.T/?08/EV%I $<2M@8/EV%I $<2M@
8/EV%I $<2M@8/EV%I $<2M@8/EV%I $<2M@8/EV%I $<2M@PL/Z.,^&LOW" 34'>Z93T@L!
_J)M<\:P7"#^_J)M<\:P7"#^_J)M<\:P7"#^_J)M<\:P7"#^_J)M<\:P7"#^_J)M<\:P7"#^
_J)M<\:P7"#^&]6B#I@RJ+<;+:I[BA@2%"XM_W$0]25S;_+_%AB90MZ8];,69YYJ*]#X&;]G
A_/R_8$?7W2'Y>:MT^FG5-+E8>#X'HR?U59A)SJW!RAK\IHG']ZW"C::^-8?^>MO O=#:H[Y
;B-^O,I$PLIN,1>-6,'^R>PQ2V\K+FR,*_!+T'8O  4SCJO0(/YZ]4$ :@8@\\74+UV1%;/S
Q,,-^CR?+ ?$('G/+.$H&]X@NWSSQ]&=B2R[GRR((XMH'>6?C_O=(#_"9SJ/LWS[4R($^K^S
M6?)Y-@H #BU<I0U^%=-NC5RNWSSQ]&=B2R[@1((2Z$6A\:!:#4L2(_DV*MHY6G=\7P,,;KE
+K9Y<84TK40NF^7QXK9!3NN; ,HT ) 4!:( ;!_<EM(RED-LC_O=(#_"9SJ/LWS[4R($^K^S
M6?)Y-@H #BU1U/@7O%D6K1'NWSSQ]&=B2R[%'3* 0*:_K@4LL^N:OO)C_*RQ@^TRR=TT 7&
%:[R8-M!V'\5C([>GD.P812,WY4/@J8\IIC?'<CB%(*P&^\=&ES-U(>0U[(:$&-^K O^Z5(0
ELN>A9NVT="6W5(@631C'M?=V@.DL6<+JC/: ,HT ) 4!:( (K;JNU&HP<\B;JU](^*6RY)N
1WK=9L6HLO='N?:V']FO.6:Y^!QZ%3(+9)3X?T,LM!G?/YE_1<Z)QVD*6?E%5IUAS-$^^QY6
5IUAS-$^^QY65IUAS-$^^QY65IUAS-$^^QY65IUAS-$^^QY65IUAS-$^^QY65IUAS-$^^QY6
5IUAS-$^^QY6[S-T?@T^Z%[O7&U2YFVLU.E<)2N?A$+"(-\ELEGB0SJDHNFR204AVXWO_$%)
E"-N#VQ%_]N4)!7.T)(40X<DY4H^MXP+#-3E>_7$W_G-$JY[:09 D0F,JO]I^U<B?9,:^#3[
D]?8W$31YAR3'BM :C4Q:&D>6VEWFL=&S&];JK6Z-=U-CVRJB;$O(Z%,Q[&)<!A3NG;4F)9P
N%,,$E;-5VRXN^7_7?@_>E.[%_+<'FY9;&X7L458SOB".G&Q2.6]?FH-'F9(00J/VY^IS<!!
CN2W. 2E<F^.']:*')M8GXL?T0;<@+3BP*G1.>M7N!VK_+LYJ,,%>^ ?6+VHEHS6(I#'((F6
DY7K?[)U14R3Y&"<HW:)*?+DEX;SW!UH%.*7H"!$M]6DY'V@O6Z+,4F&&Z6]DW4W_G2<XR^3
:>%"!ONVBM)I]E=Z*JL!6%KVR)8C AIH(Q;(2HY\^]Y<9M]*2X/ PY5ND1M+U@V1@Y8>R/'6
!5+,)\ZL-@8%P)-5(4%J]YC <ZZ6_9@8C9=SV^D!$5V->*/;
#pragma PXL encrypted end
#pragma PXL encrypted begin
8)V$55Y9XS)@ ^1MG/W]*=@#@IZ@C3U&!I:"OD&E"I,)/,.^[5VMB.(_I6SMW:N5T6?.,[C=
_SM*Y9IE0$__7@Y!NROTQ85>
#pragma PXL encrypted end







#endif

#ifdef FILL_DM9

#pragma PXL encrypted begin
QFOD4LS>)6+&JWS+[B\("]NK@-1T4#PAU5^ [75D3.(]?++MR?@E$.-P23G)?Z](3V)3E")_
#2EA*(-EW\T-UI,@8H0,&!_6IR$W8V>D'!ZGHB@*#7@84>&B
#pragma PXL encrypted end


LAYER_DM9_MYBCELL_H : polygon_layer_s = {
    layer_spec = {
        output_layer_key = "OUTPUT_DM9_DMB_CONNECT"
    },
    polygons = MYBCELL_H
};

LAYER_DM9_MYBCELL_V : polygon_layer_s = {
    layer_spec = {
        output_layer_key = "OUTPUT_DM9_DMB_CONNECT"
    },
    polygons = MYBCELL_V
};

LAYER_DM9_MYBCELL_HEXT : polygon_layer_s = {
    layer_spec = {
        output_layer_key = "OUTPUT_DM9_DMB_CONNECT"
    },
    polygons = MYBCELL_HEXT
};

LAYER_DM9_MYBCELL_VEXT : polygon_layer_s = {
    layer_spec = {
        output_layer_key = "OUTPUT_DM9_DMB_CONNECT"
    },
    polygons = MYBCELL_VEXT 
};

// DUMMY SPEC : DM9_DMB_Connect
SPEC_DM9_DMB_CONNECT = unified_fill(
    fill_patterns = {
    {
        type = UF_POLYGON,
        polygon_fill = {
            insertion = {
                iterations = 3,
                shift_factor = 2,    
            },
            pattern_spec = {
#ifdef VERTICAL_M9
                space_x = DMY1B_SX,
                space_y = DMY1B_SY,
                stagger_x = DMY1B_OX,
                stagger_y = DMY1B_OY,
#else
                space_x = DMY1B_SY,
                space_y = DMY1B_SX,
                stagger_x = DMY1B_OY,
                stagger_y = DMY1B_OX,
#endif
            },
            layers = {
#ifdef VERTICAL_M9
                LAYER_DM9_MYBCELL_V
#else
                LAYER_DM9_MYBCELL_H
#endif
            },
#ifdef CONTROL_MAX_METAL_LENGTH
#else
            merging_layers = {
#ifdef VERTICAL_M9
                LAYER_DM9_MYBCELL_VEXT
#else
                LAYER_DM9_MYBCELL_HEXT
#endif
            },
#endif
#ifdef ANTPrevention                
#ifndef CONTROL_MAX_METAL_LENGTH
            merging_blockage_layer_list = {
                FORBIDDEN_RING
            },
#endif
#endif
#ifdef CONTROL_MAX_METAL_LENGTH
#else
#ifdef VERTICAL_M9     
            merging_direction = VERTICAL,
#else
            merging_direction = HORIZONTAL,
#endif   
            merging_length_limit = 500*(DMY1OR_L + DMY1B_SY) - DMY1B_SY, 
#endif
            fill_to_signal_spacing = {
    { CHIP_snps, min_space = DMY1B_CHIP, context = INTERIOR },
#ifdef FULL_CHIP
    { CHIP_BOUNDARY, min_space = DMY1B_CHIP, context = INTERIOR },
#else
    { PRBOUNDARY, min_space = DMY1B_CHIP, context = INTERIOR },
#endif
    { ICOVL_SINGLE, min_space = DMY1_ICOVL },
    { INDDMY, min_space = DM_INDDMY },
    { TCDDMY_M9, min_space = DM_TCDDMY_MX },

	{ BEOLBLK_FINAL, min_space = DMY1B_MY1 },
    { DM9EXCL_FINAL, min_space = DMY1B_MY1 },
    { CSR66_3485, min_space = DMY1B_MY1 },
    { M9_MAIN, min_space = DMY1B_MY1 },
    { DM9_O, min_space = 0.26 },
    { DM9, min_space = 0.26 },
    { DM9_GT1350, min_space = 0.45 },
    { M9_GT76, min_space = DMY1_MY1W1 },
    { M9_GT114, min_space = DMY1_MY1W2 },
    { M9_GT152, min_space = DMY1_MY1W3 },
    { M9_GT180, min_space = DMY1_MY1W4 },
    { M9_GT240, min_space = DMY1_MY1W5 },
    { M9_GT280, min_space = DMY1_MY1W6 },
    { M9_GT500, min_space = DMY1_MY1W7 },
    { M9_GT1350, min_space = DMY1_MY1W8 },
#ifdef FILL_M8_VIA8_M9_BTCD
              { BTCD_M8_V8_M9_E, min_space = BTCD_D },
#endif
#ifdef FILL_M9_VIA9_M10_BTCD
              { BTCD_M9_V9_M10_E, min_space = BTCD_D },
#endif

#ifdef FILL_M9_BTCD2
              { BTCD_M9_E, min_space = BTCD_D },
#endif
              { WRAPPER_DM9_O_L, min_space = DMY1B_DMY1O },
#pragma PXL encrypted begin
_* 2/\H*:5?\"<,&\IO;7@D)>U^H@2K0#]Y[S8Q(3G4B# G-+K\242/.^H\NV]"T=!$:Y<O;
NE?#'-2))&*Z!NX_2L82O, &Q BCU;^(R5S$+^?N;@^@Y24ODXG9*S4]!PN3*!?J^D+#^90H
:'T18D(*(.!H>7@O /0*-H)YJVO!A@?'6;JKQ9; 6%; LZW%I2@&8'2F%^BEXS3>D5L7A83C
4(C)E74X\P)0#T4>Y,184<,/3UO_EB"6I^1/G"$N,[56WV2<
#pragma PXL encrypted end

                            
            },
            hierarchical_fill = false,
#ifdef VERTICAL_M9     
            cell_prefix = "DMB9VNEW"
#else
            cell_prefix = "DMB9HNEW"
#endif   
        }
    }
    },
    extents_output = {
        {
            output_layer_key = "OUTPUT_DM9_DMB_CONNECT_EXTENT"
        },
    },
    fill_boundary = {
        layer = CHIP_snps, 
        type = LAYER 
    },
	grid = vGRID
);
//=======================================================
DM9NEW_C     = SPEC_DM9_DMB_CONNECT["OUTPUT_DM9_DMB_CONNECT"][0];
DM9NEW_L     = SPEC_DM9_DMB_CONNECT["OUTPUT_DM9_DMB_CONNECT"][0];
//***** spec *******************************************************************
#pragma PXL encrypted begin
WY6O2*BT^WW?NU7<OEJ':WV[XK)/6ZEV\>+BC"CRS$UAL0*,95U-/%$G[M%E$2OM4]Z[S%D1
4']?;/WA;)=0G<@:TX*BLH2=
#pragma PXL encrypted end

//***DM9_DMB***
// DUMMY SPEC : DM9_y1
PATTERN_SPEC_DM9_0 = get_single_polygon_pattern(
#ifdef VERTICAL_M9
	"DMB9V", "OUTPUT_DM9", DMY1B_W, DMY1B_L,
	step_x = DMY1B_SX, step_y = DMY1B_SY,
	offset_x = DMY1B_OX, offset_y = DMY1B_OY,
#else
	"DMB9H", "OUTPUT_DM9", DMY1B_L, DMY1B_W,
	step_x = DMY1B_SY, step_y = DMY1B_SX,
	offset_x = DMY1B_OY, offset_y = DMY1B_OX,
#endif
    FSS = {
    { CHIP_snps, min_space = DMY1B_CHIP, context = INTERIOR },
#ifdef FULL_CHIP
    { CHIP_BOUNDARY, min_space = DMY1B_CHIP, context = INTERIOR },
#else
    { PRBOUNDARY, min_space = DMY1B_CHIP, context = INTERIOR },
#endif
    { ICOVL_SINGLE, min_space = DMY1_ICOVL },
    { INDDMY, min_space = DM_INDDMY },
    { TCDDMY_M9, min_space = DM_TCDDMY_MX },

	{ BEOLBLK_FINAL, min_space = DMY1B_MY1 },
    { DM9EXCL_FINAL, min_space = DMY1B_MY1 },
    { CSR66_3485, min_space = DMY1B_MY1 },
    { M9_MAIN, min_space = DMY1B_MY1 },
    { DM9_O, min_space = 0.26 },
    { DM9, min_space = 0.26 },
    { DM9_GT1350, min_space = 0.45 },
    { M9_GT76, min_space = DMY1_MY1W1 },
    { M9_GT114, min_space = DMY1_MY1W2 },
    { M9_GT152, min_space = DMY1_MY1W3 },
    { M9_GT180, min_space = DMY1_MY1W4 },
    { M9_GT240, min_space = DMY1_MY1W5 },
    { M9_GT280, min_space = DMY1_MY1W6 },
    { M9_GT500, min_space = DMY1_MY1W7 },
    { M9_GT1350, min_space = DMY1_MY1W8 },
#ifdef FILL_M8_VIA8_M9_BTCD
              { BTCD_M8_V8_M9_E, min_space = BTCD_DY1 },
#endif
#ifdef FILL_M9_VIA9_M10_BTCD
              { BTCD_M9_V9_M10_E, min_space = BTCD_DY1 },
#endif

#ifdef FILL_M9_BTCD2
              { BTCD_M9_E, min_space = BTCD_DY1 },
#endif
              { WRAPPER_DM9_O_L, min_space = DMY1B_DMY1O },
#pragma PXL encrypted begin
OM?&:F2G+A.^['].[?NZ)U3L95+F&\6,Y4%E_'EH+S14G,S\N16E@01#ZQBYA3([MC!3W]F%
V\X\5/.4$7_;_9^J:9TQ^XK]Y"[MBRVNN4_DD:*A\K#>]V:1
#pragma PXL encrypted end

              { DM9NEW_L, min_space = DMY1B_DMY1 },
#pragma PXL encrypted begin
W?)?2Y<-427=L7(^25UR4Q^Q!0(X+6F7?K,%.C9RU5)JD6\ZE3]MXUC,RK*5L$@4:BI_?=&P
?SU<: ABFS)_$@!<,I5Z+!82
#pragma PXL encrypted end

    },
	shift = 2,
	repeat = 3,
    starting_point = CENTER
); //end of get_single_polygon_pattern


//-------------------------------------------------------------------------------

//***DM9_DMS***
PATTERN_SPEC_DM9_1 = get_single_polygon_pattern(
#ifdef VERTICAL_M9
	"DMS9V", "OUTPUT_DM9", DMY1S_W, DMY1S_L,
	step_x = DMY1S_SX, step_y = DMY1S_SY,
	offset_x = DMY1S_OX, offset_y = DMY1S_OY,
#else
	"DMS9H", "OUTPUT_DM9", DMY1S_L, DMY1S_W,
	step_x = DMY1S_SY, step_y = DMY1S_SX,
	offset_x = DMY1S_OY, offset_y = DMY1S_OX,
#endif
    FSS = {
    { CHIP_snps, min_space = DMY1S_CHIP, context = INTERIOR },
#ifdef FULL_CHIP
    { CHIP_BOUNDARY, min_space = DMY1S_CHIP, context = INTERIOR },
#else
    { PRBOUNDARY, min_space = DMY1S_CHIP, context = INTERIOR },
#endif
    { ICOVL_SINGLE, min_space = DMY1_ICOVL },
    { INDDMY, min_space = DM_INDDMY },
    { TCDDMY_M9, min_space = DM_TCDDMY_MX },

	{ BEOLBLK_FINAL, min_space = DMY1S_MY1 },
    { DM9EXCL_FINAL, min_space = DMY1S_MY1 },
    { CSR66_3485, min_space = DMY1S_MY1 },
    { M9_MAIN, min_space = DMY1S_MY1 },
    { DM9_O, min_space = 0.26 },
    { DM9, min_space = 0.26 },
    { DM9_GT1350, min_space = 0.45 },
    { M9_GT76, min_space = DMY1_MY1W1 },
    { M9_GT114, min_space = DMY1_MY1W2 },
    { M9_GT152, min_space = DMY1_MY1W3 },
    { M9_GT180, min_space = DMY1_MY1W4 },
    { M9_GT240, min_space = DMY1_MY1W5 },
    { M9_GT280, min_space = DMY1_MY1W6 },
    { M9_GT500, min_space = DMY1_MY1W7 },
    { M9_GT1350, min_space = DMY1_MY1W8 },
#ifdef FILL_M8_VIA8_M9_BTCD
              { BTCD_M8_V8_M9_E, min_space = BTCD_DY1 },
#endif
#ifdef FILL_M9_VIA9_M10_BTCD
              { BTCD_M9_V9_M10_E, min_space = BTCD_DY1 },
#endif

#ifdef FILL_M9_BTCD2
              { BTCD_M9_E, min_space = BTCD_DY1 },
#endif
              { WRAPPER_DM9_O_L, min_space = DMY1S_DMY1O },
#pragma PXL encrypted begin
ID&A6"PO-&:FQ M$#Z@4R:G$CCU3:U8^,22.G.&6ZD*U F"<]P1Z<K*;0VSWM^?8 TEYU1FW
@;]QT7ZE9Y2!(4  9>/[ASDAHN3P[KY?+2>BL07><BXA_6.Q
#pragma PXL encrypted end

              { DM9NEW_L, min_space = DMY1S_DMY1 },
#pragma PXL encrypted begin
,D,G&,B?MBPRU5N ''!W9_[5!!1AD*YATWT$'EMZO!G+IL<>U+#C7#1\-#;4<3F/0G^]9.5Q
$@N?EHV<2/$2XJ'R>41P$=WB
#pragma PXL encrypted end

    },
	shift = 2,
	repeat = 3
);


//***DM9_O_R***
PATTERN_SPEC_DM9_2 = get_single_polygon_pattern(
#ifdef VERTICAL_M9
	"DMOR9V", "OUTPUT_DM9_O", DMY1OR_W, DMY1OR_L,
	step_x = DMY1OR_SX, step_y = DMY1OR_SY,
	offset_x = DMY1OR_OX, offset_y = DMY1OR_OY,
	setback = DMY1OR_SC,
	setback_type = INTERSECTION,
#else
	"DMOR9H", "OUTPUT_DM9_O", DMY1OR_L, DMY1OR_W,
	step_x = DMY1OR_SY, step_y = DMY1OR_SX,
	offset_x = DMY1OR_OY, offset_y = DMY1OR_OX,
	setback = DMY1OR_SC,
	setback_type = INTERSECTION,
#endif
    FSS = {
    { CHIP_snps, min_space = DMY1_CHIP, context = INTERIOR },
#ifdef FULL_CHIP
    { CHIP_BOUNDARY, min_space = DMY1_CHIP, context = INTERIOR },
#else
    { PRBOUNDARY, min_space = DMY1_CHIP, context = INTERIOR },
#endif
    { ICOVL_SINGLE, min_space = DMY1_ICOVL },
    { BEOLBLK_FINAL, min_space = DM_BEOLBLK },
    { CSR66_3485, min_space = DM_BEOLBLK },
    { INDDMY, min_space = DM_INDDMY },
    { DM9EXCL_FINAL, min_space = DM_DMXEXCL },
    { TCDDMY_M9, min_space = DM_TCDDMY_MX },
    { M9_MAIN, min_space = DMY1OR_MY1 },
    { DM9_O, min_space = DMY1OR_DMY1O },
    { DM9, min_space = 0.2 }, //DMn.S.3.5
    { DM9_GT1350, min_space = 0.45 },
    { M9_HOLE, min_space = 0 },
    { M9_GT76, min_space = DMY1_MY1W1 },
    { M9_GT114, min_space = DMY1_MY1W2 },
    { M9_GT152, min_space = DMY1_MY1W3 },
    { M9_GT180, min_space = DMY1_MY1W4 },
    { M9_GT240, min_space = DMY1_MY1W5 },
    { M9_GT280, min_space = DMY1_MY1W6 },
    { M9_GT500, min_space = DMY1_MY1W7 },
    { M9_GT1350, min_space = DMY1_MY1W8 },
    { M9_45, min_space = 0 },
    { VIA8_HVN_5V, min_space = DMY1_VY15V },
    { M9_HVN_5V, min_space = DMY1_MY15V },
    { VIA9_HVN_5V, min_space = DMY1_VY15V },

              { R7_VIA8_CHK_REGION, min_space = 0 },
              { R15_VIA9_CHK_REGION, min_space = 0 },

              { S22_M9_REGION, min_space = 0 },
#ifdef FILL_M8_VIA8_M9_BTCD
              { BTCD_M8_V8_M9_E, min_space = BTCD_DY1 },
#endif
#ifdef FILL_M9_VIA9_M10_BTCD
              { BTCD_M9_V9_M10_E, min_space = BTCD_DY1 },
#endif

#ifdef FILL_M9_BTCD2
              { BTCD_M9_E, min_space = BTCD_DY1 },
#endif
              { WRAPPER_DM9_O_L, min_space = DMY1OR_DMY1O },
#pragma PXL encrypted begin
;2O;:^>"63-MP]"-6Q)@E(/#&Y4(F"9/FD,;_ F\ 9S/+/'\E'#2"Y;Y-?.4G4_ACINVM/^=
T_$>%% B@N'3$B3-C1[(SOT22%Z'MA^!749(8K6U+_\:L(=B
#pragma PXL encrypted end

              { DM9NEW_L, min_space = DMY1OR_DMY1 },
#pragma PXL encrypted begin
^2QA*X/SVWGYS5(U:0Y_:T_-S>61<BPROJ+-8QDW-:#V"<ICMP<%GN6)YYJWH<"<=6$7;5FA
/& @9Y3I HP\G;(]DJF9>R&=
#pragma PXL encrypted end

	},
    shift = 2,
	repeat = 3,
    starting_point = CENTER
);

#ifdef VERTICAL_M9
PATTERN_SPEC_DM9_2.polygon_fill.pattern_spec.pattern_spacing = {
    allowed_spacing_x = { >= DMY1OR_SXA2 },
    allowed_spacing_y = { >= DMY1OR_SY },
    extension = INTERSECTION
};
#else
PATTERN_SPEC_DM9_2.polygon_fill.pattern_spec.pattern_spacing = {
    allowed_spacing_y = { >= DMY1OR_SXA2 },
    allowed_spacing_x = { >= DMY1OR_SY },
    extension = INTERSECTION
};
#endif




//-------------------------------------------------------------------------------
//***DM9_O_W***

PATTERN_SPEC_DM9_3 = get_single_polygon_pattern(
#ifdef VERTICAL_M9
	"DMOW9V", "OUTPUT_DM9_O", DMY1OW_W, DMY1OW_L,
	step_x = DMY1OW_SY, step_y = DMY1OW_SX,
	offset_x = DMY1OW_OY, offset_y = DMY1OW_OX,
	setback = 0.114,
	setback_type = INTERSECTION,
#else
	"DMOW9H", "OUTPUT_DM9_O", DMY1OW_L, DMY1OW_W,
	step_x = DMY1OW_SX, step_y = DMY1OW_SY,
	offset_x = DMY1OW_OX, offset_y = DMY1OW_OY,
	setback = 0.114,
	setback_type = INTERSECTION,
#endif
    FSS = {
    { CHIP_snps, min_space = DMY1_CHIP, context = INTERIOR },
#ifdef FULL_CHIP
    { CHIP_BOUNDARY, min_space = DMY1_CHIP, context = INTERIOR },
#else
    { PRBOUNDARY, min_space = DMY1_CHIP, context = INTERIOR },
#endif
    { ICOVL_SINGLE, min_space = DMY1_ICOVL },
    { BEOLBLK_FINAL, min_space = DM_BEOLBLK },
    { INDDMY, min_space = DM_INDDMY },

    { DM9EXCL_FINAL, min_space = DM_DMXEXCL },
    { CSR66_3485, min_space = DM_BEOLBLK },
    { TCDDMY_M9, min_space = DM_TCDDMY_MX },

    { M9_MAIN, min_space = DMY1OW_MY1 },
    { DM9_O, min_space = DMY1OW_DMY1O },
    { DM9, min_space = 0.2 }, //DMn.S.3.5
    { DM9_GT1350, min_space = 0.45 },
    { M9_HOLE, min_space = 0 },
    { M9_GT76, min_space = DMY1_MY1W1 },
    { M9_GT114, min_space = DMY1_MY1W2 },
    { M9_GT152, min_space = DMY1_MY1W3 },
    { M9_GT180, min_space = DMY1_MY1W4 },
    { M9_GT240, min_space = DMY1_MY1W5 },
    { M9_GT280, min_space = DMY1_MY1W6 },
    { M9_GT500, min_space = DMY1_MY1W7 },
    { M9_GT1350, min_space = DMY1_MY1W8 },
    { M9_45, min_space = 0 },
    { VIA8_HVN_5V, min_space = DMY1_VY15V },
    { M9_HVN_5V, min_space = DMY1_MY15V },
    { VIA9_HVN_5V, min_space = DMY1_VY15V },

              { R7_VIA8_CHK_REGION, min_space = 0 },
              { R15_VIA9_CHK_REGION, min_space = 0 },

              { S22_M9_REGION, min_space = 0 },
#ifdef FILL_M8_VIA8_M9_BTCD
              { BTCD_M8_V8_M9_E, min_space = BTCD_DY1 },
#endif
#ifdef FILL_M9_VIA9_M10_BTCD
              { BTCD_M9_V9_M10_E, min_space = BTCD_DY1 },
#endif

#ifdef FILL_M9_BTCD2
              { BTCD_M9_E, min_space = BTCD_DY1 },
#endif
              { WRAPPER_DM9_O_L, min_space = DMY1OW_DMY1O },
#pragma PXL encrypted begin
>\C;&]WUGAU[]JG1S/=.J@OVV9(O5E/,&DC9V@VA=CB*G&G:OS&J1Y;/A7"_8<T"!..D21QA
E'\E_.EB7L*4QAEJ?GN<Z-W&_EU*T_?&4V[^5V(TM^XR\<U7
#pragma PXL encrypted end

              { DM9NEW_L, min_space = DMY1OW_DMY1 },
#pragma PXL encrypted begin
!\IA6WEF(60'2^2S4B<JVE)+0-RK'1-KJGE ^6M8_UQ7Z(#Y&"6:IT(4$O08FZ(OT_O7E32;
>-!SR2(5L8UXTQUORU441+S3
#pragma PXL encrypted end

	},
    shift = 2,
	repeat = 3,
    starting_point = CENTER
);
//=======================================================
PATTERN_SPEC_DM9_0.polygon_fill.pattern_spec.other_pattern_spacing = {
    1 => > DMY1B_DMY1,
    2 => > DMY1B_DMY1,
    3 => > DMY1B_DMY1,
};

PATTERN_SPEC_DM9_1.polygon_fill.pattern_spec.other_pattern_spacing = {
    0 => > DMY1S_DMY1,
    2 => > DMY1S_DMY1,
    3 => > DMY1S_DMY1,
};

PATTERN_SPEC_DM9_2.polygon_fill.pattern_spec.other_pattern_spacing = {
    0 => > DMY1OR_DMY1,
    1 => > DMY1OR_DMY1,
    3 => > DMY1OR_DMY1O,
};

PATTERN_SPEC_DM9_3.polygon_fill.pattern_spec.other_pattern_spacing = {
    0 => > DMY1OW_DMY1,
    1 => > DMY1OW_DMY1,
    2 => > DMY1OW_DMY1,
};

SPEC_DM9 = unified_fill(
    fill_boundary = {
        layer = CHIP_snps,
        type = LAYER
    },
    fill_patterns = {
        PATTERN_SPEC_DM9_0,
        PATTERN_SPEC_DM9_1,
        PATTERN_SPEC_DM9_2,
        PATTERN_SPEC_DM9_3,
    },
    boundary = ALIGN,
	grid = vGRID
);

//***** fill *******************************************************************
DM9_C   = SPEC_DM9["OUTPUT_DM9"][0];
DM9_O_C = SPEC_DM9["OUTPUT_DM9_O"][0];

#pragma PXL encrypted begin
CAAB,_0?1!F.')RLU\HK6K@<JSH0G#G^(*JKVPS3(VU87;S;"4X7]&+O/.X)%B0#4G6PU\\6
#%#2#E/OGNP,$63MT,C<:2P1ZF^GR/P*RKWJB4A4EI@4,TR)
#pragma PXL encrypted end

#pragma PXL encrypted begin
K3/[$R>&9BNMCWI;P< %)0>/N^-HS#L6?>^[8IU?( #I<IUBA*27^;XN%_*$N(O",,"30UZX
P_:IG-H./@;#)KJ9HLU:.EPF=5XMU[G.NX9UZ1R*72Q@PXOI
#pragma PXL encrypted end
#pragma PXL encrypted begin
6K4A+M JR7=:$X> ZB29M\L3B2O*,*:/SW>)&N]_K"*T\$D:$"V/$CON55@09@/YA>"7XBAF
(_,"KS.NAX@C(9WS4<XT;1\A*GXDXNO"^O,J^UL]L%RV51?[62MVFHCS/D!9T>H)@)+W@A#1
#pragma PXL encrypted end
#pragma PXL encrypted begin
U7970&:!6WO5D]1)Q@$(/&23?7>@72?FGH!])>00=&T65RDEG\-_(OY:5:>?-Y -C'I?GN0W
 FEM?Y8K\GH"
#pragma PXL encrypted end
DM9_O_L = SPEC_DM9["OUTPUT_DM9_O"][0];
#pragma PXL encrypted begin
AZL#0C#='5F':A]>2I&!#6QJ7+++<+-D \Q<O4O"I5VM1!"]Z;-L'VQ(XMWI54";>[X?W/!5
C<;&GW4$&E"-_JGWDM?*8YC^
#pragma PXL encrypted end
#pragma PXL encrypted begin
S/G"9)$N@ +,=N!6YCYGZVAV65-E'*^[,U=95H%DT2((ENE6P+]%BW3^!?[ Z$6=IM.(7%#H
+\;7C&H L/@O:Z((58D7UL=K.("6ISAAZ^LXY^4;:G&,/!WGP$L$%P?=4J[ /N_;"7;] ?\^
:++[?!S[Y*9H
#pragma PXL encrypted end
#pragma PXL encrypted begin
2+OX=B:%$@9(K@@O!.TGB4ZNK?Q4L$CJ4S6MOB4V\_8_Y]*^[^U57?4P+BGO*E+DZ6/I\:@J
1QCQ1M0.EHQ'LN5R&^"F%O.R!7427\Q19,<%Q88F)*9#_W;%
#pragma PXL encrypted end
DM9_L1   = SPEC_DM9["OUTPUT_DM9"][0];
DM9_L = DM9_L1 or DM9NEW_L;
#pragma PXL encrypted begin
PWPN";S;I G#?):W(D,Y5*1\'$!5()*1?MD<"H#;C6203<$*'!F<K71+MD(<XW CD_#UW%;C
H$MSO2R32U"@BM)]PF"0X&B**C\L20VLAWLJ9@..2QU:!>IFJW-P,5;-2J*K;E>U7<0H$M-N
";Y]EJU7[4X)
#pragma PXL encrypted end


#pragma PXL encrypted begin
K"11>KH\ET&L5890E+-6=9)5(@;'W_UU?]$BC6M7QOG??AN-XW#PJWWI6TOCMM6Y8]ZVALRV
)^6'D-_%'+,G]2.^VERM)%KU3BIWC@@W&(E.<S16E6,IBQIS
#pragma PXL encrypted end
#pragma PXL encrypted begin
\7(0'1N.^6KQM;QNQQ7:U!6UX&BIT'H_3CS@O2G;[PN9/CB]^BI#S#\>IRCZR']W466]>*/(
[8XI6!A6H&CM-,;S;U&9AR,TN9$ZM#W0;7FY%Z-(=B./E187<]F=T..MK.=S?.;EU(C0Y3=\
*<<IY@3>G"$II_%^.\G=!96G#4PYSXAXN$H-)HD&Y QYD;<FY]P@X:*#[^3G6+E_>#YS,D-8
DFV$ZCY&2(R2\M\.O!PWMI7RD3T;CKVD TN1CSFY$(WG-3^/LYG,J&X;'B2S2<0:3=EE:YQ)
;U%&KE,P"J]O<,P3#78V DIPH7T,)\-UY#*A/>AN9"91Z-,])W,*LG02+R0G&^X X0R&0ML;
]ERJ>[%TRDGV*"!=GNG'?&0H1YHZ/H?%J U'ZW R45E')'_K94/G$DOTFF9EDF6CXM%UFTR2
_CV^8HE?9(#^WW9QS>2'?W??LO.+UUKW?%>R1YHZ/H?%J U'?F:3$-G]$>!^94/G$DOTFF9E
6Y+G7&+3DI);"W1YJL21=H<+[6W@&NJJ573M%5094U%VI"L5_E*$7W*A^[W^H1Y'^T_L[:JA
(\6<V];R_"0CUFHJ7!T/J!K6W]S'XT#+(?_?2<0:3=EE:YQ);U%&KE,P"J]OUIQV'(M;#S/6
\TF+VGG;ZC?S-_")/HILC,8WJ_@$ER0[PY6K!8>\._UT2I<%TK\IJ&;*:)+2U9WIK3'KF#+5
=H-59Q=DP=YVYA1DT9[\CO?FT?B3&,*206[11JP EEG^@5]&/>AN9"91Z-,]G;S=X:N1QLB=
M^*@[A.+*W6WUIQV'(M;#S/6\TF+VGG;ZC?S-_")/HILC,8WS^>W;X==6X3/!8>\._UT2I<%
TK\IJ&;*:)+2U9WIK3'KF#+5=H-59Q=DP=YVYA1DT9[\CO?FT?B3&,*206[1[N0:(@:!HM;N
/>AN9"91Z-,]-I,9/ZRG5+<VH"ML$>.]E.F@&LPS.@JM<0H:= I[*_!QCAMT^VMOH3_V:Z7[
-^A.W+1:GN(W4>;)EJ!3?PI1ID\4:@6*"RRF7+JQE2N7I?!<HJ7(O2KDM+*B!-\G.??WZ"<$
[U56U/_.U$7OT_C9DMHB. 737$-=\BJ^L)]<8_<^ _99;0QCI<NL2:4/ 4ZE\V/(\Z=@PQSS
#\X=Y"-B1K,/C*H!21X-,G6,D1=A\"I9/&R1-QE!V>POX_TWI17H%JO%.&2E(+J0S3=%M%L@
= @F>A[Q\(IT]<=A .)ZZ2CU4>;)EJ!3?PI1ID\4:@6*"RRF7+JQE2N7I?!<HJ7(O2KDM+*B
!-\G.??WZ"<$<=P,I4,Y3)9QI3Z$NK6G2OVE&T^!B9B4E.(;!7_HNIYE6K\%4>;)EJ!3?PI1
U)V)GKS;OD+4])U\]<"N^(?T?.I8;CB5CL-\NVR)P42!?TV[9%4;BO 6*+UDD5S=*H(NC-:1
N4'$=P@M<M:Y0'B&'06H&71 76W:T*7T!I!=CE4/.D(1/C^.\V/(\Z=@PQSS'<:AFX(UAT$=
QA*72I#<!2+&X5#_2&)/X@3AK+1KM]-!+N*L\V/(\Z=@PQSS1^AA2EL8RII')^THV"T)=]$G
P&FY?.NE^4# *!3W(4\^7>THLY^N\Y"QZ/NS)'9^Z%EZ?^(D(^W'39*5V<8C3#_+__C=5)U,
#%<JT91^:F4,M![Q8K\$2NJT)EM.!N,/UW\F3!5KZ0>RCA=,]N-Q&7Z.VX7VCJ\(WF>%.1>.
CJ\G#-;W4"N.9%4;BO 6*+UDD5S=*H(NC-:1@RS:0=46>8N#^F2X$J4P-2+ZP&FY?.NE^4# 
F5GKV/JF58R9)'9^Z%EZ?^(D7+?S- 5[@5)<R %O8.YS6Y'(,AG<^AB9]10R+O=4L$&A0.4N
YU3;JYJ_7K+GUOL9A>CSD]36O-3UI5@,=BV\N)2O<)'1$8"X@>F5X$ -'M^!7$NB>[@G[$U<
C+QV;CPX<)R,U*J-E$NZ#@+4<,)M,A$_141P42=0U <*=311=N@A, <? ,]VM9^<\S%UPMNU
<,)M,A$_141P&*!V!.P<]7<8=N@A, <? ,]VY#!&:L1Z7S/DFC]2V>\@<K6:!'+_;\^ T)4$
QQ\\TSE_F1W'2H4>FZV++;I*C+QV;CPX<)R,[7:K,RR4]*7M7DNJ.S>EX^5>G$VZBXK _%6<
8$+)BFCH.*U@)EM.!N,/UW\F4:I=V-2-,&)1 M1>7$B1Q! "<,)M,A$_141PPY$P&T>VK2_#
(N6:Q4N)RKDB@LA57$:2V^2":*WIX0)=1^UHCJ\(WF>%.1>.NI2[NT<FVI.Z8OR#,"/Y$19B
4>;)EJ!3?PI1\P!$U(]#N+;SX4CL)HS_T8?AQQ\\TSE_F1W'BZ']6DLI* "+C+QV;CPX<)R,
[7:K,RR4]*7M9:6Y)_2SZ=QEG$VZBXK _%6<'/.;8(EFF"\<)EM.!N,/UW\F4:I=V-2-,&)1
 :H&5*4.S"8!<,)M,A$_141P0*-(!=3+02] 9%4;BO 6*+UDD5S=*H(NC-:1^JLAU9R,QA;Z
0'B&'06H&71 F@:\O2YX5'Z:(N6:Q4N)RKDB<_9&'^&MZ/AS?T+I0*P''G1_$*>MY5\%S800
)EM.!N,/UW\FXM$;PTLK9GSB>UN@WM]^=2M[A.A6.B-!=S6$KF0/=UYIT0:N<-:7'))+^UQP
^878J6411&SY=N@A, <? ,]VY#!&:L1Z7S/DFC]2V>\@<K6:?UN-72STDO5_;D0(9.A).NMN
7KF0?/"+C[9>I/V.2B>UW1&D#P,W2:C8IE,/)EM.!N,/UW\F4:I=V-2-,&)1K7SAX+S=7'VM
<,)M,A$_141PXD)9Y4E(CD;B9%4;BO 6*+UDD5S=*H(NC-:1@"!HS_>KA " 0'B&'06H&71 
1TIJMA39 O)'#P,W2:C8IE,/)EM.!N,/UW\F4:I=V-2-,&)1K7SAX+S=7'VM(Y+7Y)5=6TPC
!BE2TB%D^/0&>S%!<[ MG1%[*8%V2G%Z2;8I(N6:Q4N)RKDB.*_Z!AZYUP@X/>AN9"91Z-,]
Y*)!?:S[=;OD=N@A, <? ,]V1!L48L4;]FY$@RS:0=46>8N##(;"<MS4K<\,O1OBV<V*SA&]
++9T999X*]$LAPE:U<\9@2&'/>AN9"91Z-,]Y*)!?:S[=;ODE^?0V>0Y.7>7K@YVXF X9GNN
7G:I?E)X:VU>FC]2V>\@<K6:4JW$V+0Z;8%2CJ\(WF>%.1>.=;;)FBI ]DIU(N6:Q4N)RKDB
.*_Z!AZYUP@X/>AN9"91Z-,]Y*)!?:S[=;OD=N@A, <? ,]V1!L48L4;]FY$@RS:0=46>8N#
#(;"<MS4K<\,O1OBV<V*SA&]++9T999X*]$LAPE:U<\9@2&'/>AN9"91Z-,]Y*)!?:S[=;OD
E^?0V>0Y.7>7K@YVXF X9GNN7G:I?E)X:VU>FC]2V>\@<K6:4JW$V+0Z;8%2I17H%JO%.&2E
<,)M,A$_141PWRS3F;-&BFS??6C@3+_+>69]@^(W$B>U=/6#FC]2V>\@<K6:J48-C$3^@[*I
(N6:Q4N)RKDB/H;_"=U(UA ^/>AN9"91Z-,]Y*)!?:S[=;ODE^?0V>0Y.7>7K@YVXF X9GNN
@^(W$B>U=/6#FC]2V>\@<K6:J48-C$3^@[*IQ;;$O(). 4;%[KTR"+V%OKGN,E%ID"#(KZ\R
A_RP/-GG,?2'$&M,BQ3UL500 -%O#^!@A>\ - 4D*!U4[H(T?6C@3+_+>69]@^(W$B>U=/6#
FC]2V>\@<K6:J48-C$3^@[*I(N6:Q4N)RKDB/H;_"=U(UA ^/>AN9"91Z-,]Y*)!?:S[=;OD
E^?0V>0Y.7>7K@YVXF X9GNN@^(W$B>U=/6#FC]2V>\@<K6:J48-C$3^@[*IQ;;$O(). 4;%
[KTR"+V%OKGN,E%ID"#(KZ\RA_RP/-GG,?2'$&M,BQ3UL500<=P,I4,Y3)9Q1RH 6+\-VB)'
^O! KI$_-Y?ZZ:UY#XVL>LKI9%4;BO 6*+UD9H-[:HE* 3!FR>!X\EJ(Q2?)1RH 6+\-VB)'
V2ERCPROP^O9D7-C).Z<:M>14DL[K;*"_3A2OA*?I)S)4EN^YU3;JYJ_7K+G0'B&'06H&71 
1RH 6+\-VB)'E_;P+N3U4VR76O6US"%0N2U:ACCG DCK-+:&(N6:Q4N)RKDB<_9&'^&MZ/AS
:\P4*$1YA5)K1RH 6+\-VB)'(UP!?G*GY@4C;A4@AWVFFJIN9%4;BO 6*+UD2U6+A7[HK:-+
Y>1<8</8+EWE+UU%V_] G'0O<F3)QK "TM5RJQ05=/W=<(*K1RH 6+\-VB)'F'*!'\M/IKR8
_-M(%Z\QE\7\G%/W-AXUP@"<=N@A, <? ,]V6(0;R$GJ9B)8&P$F./*'DO\;)^$0G%="I"XG
Y[=TSTI;7 OGA+69G]?P%8N$SUJD(NGN IS/>_DA?;#4=3A[1RH 6+\-VB)'DO?8JXNJ6VJ2
FSZ6O$ACLF6;9,@:L_]&\1%D\V/(\Z=@PQSS=VSQ>Q9C!>-W+=?OX$.;818MK8LJB<\X8E:M
#AU+_+J 3T<.8#:U4RK[ZZ9@2WCJ=LUD?*-+1RH 6+\-VB)'2RFE$)A8*^-+Y<,H$)S>)3KE
\V/(\Z=@PQSS=VSQ>Q9C!>-W+=?OX$.;818MOE!2VAZN,+B^1RH 6+\-VB)'W\6: 8[[*+C?
9]X',W-@H#!G@C>EBXT*<_""C+QV;CPX<)R,Y'/R]VWF2<_DV)D)@76<GO'8V]H>G95Y'AK;
H/2(PQ$V^A"@2&1[PDS?DIQ(9%4;BO 6*+UDD5S=*H(NC-:1ZPXT+^;>)@;K"-1$"ZQYOC0(
1RH 6+\-VB)'P&FY?.NE^4# X9K&=Y1I[!CA)'9^Z%EZ?^(D7+?S- 5[@5)<S,\3<T_>6:W,
Q?<$[3+7OW/%J_"(0@\$B#FK*0VVI<X;)FTI1RH 6+\-VB)'8_:#')R@J4-C9%4;BO 6*+UD
QQ7\2=0H4#_'X@@IL(T"7=#BXHD5!HM ,"+B_?:PO_34YI[]EH.K4^'M D*6&9[YJ&D)64D9
SQ!I<P<O]B;/[" 1\EX"5$3LV0V/P]>H8I_9!*/NYXV/N)($":WMP:G,N*T)7IZH5.(666E>
"DS1U0$XV<L*3GN?9P8%DTY.BECY [=?UMN*:",(5:&1!]1HF"@W$^XQUBR80TWBXY#<?01#
QF I0FC#IN+&)\LV)K_M#<$G,\P9$O2( ;LS,\P9$O2( ;LS,\P9$O2( ;LS,\P9$O2( ;LS
,\P9$O2( ;LS,\P9$O2( ;LSYN_LJ\1I]=GFD;01U&;'(2"1O?1D9.9@'2"]Y<>P Q2 $5/E
6+E_>#YS,D-8R_[/^\)X3 K+G#446AJPQRV<!A/7EP:36:X&<^"CEC\XHT5SO)L,:%?'$4Z\
]'<+G?J>1/CT453%]@5AS\A1</5B6]J6X_QP\AK?-&KRNMCR>?-3Z*B9;K5Y#;=:0J"R-,L-
6/]E=17D6DE8RZMKJ'G&R_C+T?B3&,*206[1))4B'Z"+]-@D0'B&'06H&71 9!&R==@(O_%D
FI""1]14(F^:RP%)767V]DG+T?B3&,*206[1 \\=A=U@M00#GJZ7B0R7^<R>O_BKS&?J.D:_
VBZ0[4O/TDK:5T-24/_A\A!79.G646>:,>1DS=L+@[J@<2_-0'B&'06H&71 9!&R==@(O_%D
FI""1]14(F^:7;A[@0[S8&U=T?B3&,*206[1J.7[L9-(>2VH7+!E_%( 8*Y<< \5^82=Z>UP
MD@0 K'&P].V7\DCIKS7,:M?Y<;&L8HI@7?E[KTR"+V%OKGN6S6^*W\QC%=;RN@IKK?!9BW*
NFIV],J01X&Z^25<YO:!"#GYK@YVXF X9GNN7G:I?E)X:VU>I,WUI!HYAENDYIC[LPN3&$'F
D<SRMZ?H,461Q-Y+O/.;+X3$+!.I,.F8@04L[4PQ>J,^)=#MFI]YQ[*T+@6:( M6*TPYH=P@
&QY=3 Z7'MT;#;8)&Q]M=#0-ICS9I1R*EA2F0\>W (-RB:A#'V<+D]HG$A<?=(#10AQ%6:]T
&CL;F7J?M18:Q#TM:W#1=P7$DMY[J8T@)_Z2)=B[]S!K4I\EIUO.B8 0='^GHNH'-AD=D/NB
5CI"Q!M^!IE6JWTBWA32N9FK#D21S5<O=E\.&<TLQ*DT[R 9^J+_<32@P([Z\ 2M>8WSXXSP
@TUN_J(GUK>##R]1-7@('N$/1\$W=+___?M',Z7,PKU6%,HS,B :I$(F$X$R4,ALSD8[G350
;)_K8HVJDU5LDRF:/=S4SJ>3HNRMMR%&B3&BUF-SH_1+2"G657Y^8I5C3>15T-'GA4VJSO30
X.44'Z;$V@3@5YVW=F9H?H)7QS;./*#Q<VG' H<^@5SFIMH"AF87$N2"YH*&+W<TUD$Q**$O
V7PO3\.],<79MWP01#(5M]BW;XE"5BBGR$]O2P*FGOCI#2=+J#K=( ?:A].H.U4*43@"[O([
4.IG36.W&K-0L?!/B]21A$"Q%T!":B8U'=@7D'G?P;3'3J*0L?!/B]21A$"Q_;_()ZN[$@C]
LO?D;RX1N!BRUA]NRC3?7GK6#U8,PO_Z79\/VFK5J R'1N7:(B(?(ZVP\/XB%[(5><P:X!$7
V? PAEM<H!K9S9 ] OLUT^C-<C(VXS5S/_1RC>B']6!/H J-D=/>D#;AC=*17DF@Z![>E]Q>
-4<Q?=1BN7\U,H:6H"3L'L<RJ35GK67I_2JI>?J5 ?]!L=AY-,3+09GC(@DT)"W>NA[$HM0D
2""PJ6.ZUGA(K1T*XO'XV$6M#-/,Z4:>"8D,D>Z@KE3L6@:1^*!YU_(._6/X1(%9ER8&H )$
'PD$[(Y=S;$?HW"[NHH@.DJC$'ZDZ11PO1X0(:L;A9<L+'$A(:L;A9<L+'$A(:L;A9<L+'$A
(:L;A9<L+'$A(:L;A9<L+'$A(:L;A9<L+'$A(:L;A9<L+'$A.[685&'MZIL[K'V&_XD-4(:L
K6F355?OZ&"MG RE^87,!9Z<QOJ=EI6R)BC&,B :I$(F$X$R4,ALSD8[G350$4UQU]<$)1,1
B,6H,"%""B^(X2= OZRCY+/A[,HW1MP2-_CL6D#W#@>5.QM:&(:O: D6;A<8 '%6IBRZT64 
#."YIJ6ZC*\,T)5,$%:C@^30ML2UZ:]5X_:V&';,<766.,08RRUHQJ:'2U/+#[&AK5WX228/
V=U8^BRBW%W9O07B+2=:CD*]P?P/.+J+$QW!S6P?+3.\SUC-/;WWVCK(R7$]IMA8B[Y^A':F
<S,T]?1I?^QSMV.VT9>P(H*WY?AM'E;(O"3E2D3Q@M1(/4-*N$U,>0N_E^&XO=;85]@*GL&]
!^NHHV)^'D 'N5G3^3"10LZYR4\FMZO^I9G);VL$;Y&5C/%OV1UC-J_@$(_9V9>Z_FO,IL[9
K'V&_XD-4(:L; <+W,4(-6)L>N8@(1S=WQ-ZI)1>])+U5+>DYN39=+'$=(#F'GVJI"DJ GX>
+U/_,Z?;1? OYZV!!(#7.*WG3Q+3I'("4)M/U-ER 6>X1)S4(B(?(ZVP\/XB(%^*30,M9NT@
BGY1"W4[/N6*3FE0N-'4*8U.#"<SXS&Z7S ,#?R@LI=Q*9L-.5'2B/KH<=8Y?!*/&[J1FX=\
KRJ9EX0CRWFO>W(>UY'?\=![A:$;7+%5M8R%)F<@J,^(W?PFCG!3?.?,%"2.PSYQ A:T&WS#
RA*IA<V1 $K*7I:'?^&"W?U>F9-E9S')>Z^9O9)?#>W+(.F](!XS_81\]QX@\=<""G]U4''Q
^)#2)HR[\(SXQ_[@G'>ITC''*VR6E/5!JTHK8+89AHS'@>]@@&Y;YD'LMB6 N?:5TU5N+EFY
6YM*WX)(NL5;*_Z;^P^DU: KMV?B 1#W48ZWN++X<6[%#$*X7JI7 _,3@.1>K#("MD5S[MVL
8+89AHS'@>]@9CTUC!1Q1P)FN?:5TU5N+EFY6YM*WX)(NL5;.1KB+E#Q9<LYMV?B 1#W48ZW
N++X<6[%#$*X7JI7 _,3@.1>K#("MD5S[MVL'OS;+J)),^ >A]!X>UQEG N'@.%:5C1I)6V 
C= ?T4UZV8&-88 =72=,3J]A3'B7VZEE@%],.1HL5,^DRWHY0B.^#4!+%^Y",_K\:%^7M?$S
!M'?PB_;:GH&MO@85+QRK]VV@2=% "C^\&J!I$KOHY]DYW"D3N<S!OL X 1.LB#-E.BV$ABR
G%5I8S>J3W"<O4JDPU2DWT^]$87/V2Z</],1P;Z=!;BDV$G!&M=9P$NH^$T:6;[B3_A#G-!9
]-NT40%N<C'T1RH 6+\-VB)'8R]1,*Q6I7AC%QM=H]?M3:L7BYEQDXCE4T.+1RH 6+\-VB)'
/VODSX[ TXT_/5@SY?!RB&4][DP8QMY@0?7N*Y3BS5DQ\H4KAO/2?9_L: *&_T+([.S6CZ7_
X&PF?\HV!>_@: 1*7]X@1DMH0T/-/TJGL,5#1RH 6+\-VB)'1RH 6+\-VB)'.A_^>05AKJ@Z
@*AOI08_BY. >\N!8/%A#SQ[#=UM07,5L+X-C*N.O$N(GSZ,D-[8(N9,J6R01RH 6+\-VB)'
AL=LZG6@H 2&QVP&1HTR,CW''W@0XHL\S]<?<\38*(2W;P-S!3U1&X:ONRD%Y"Q+U6BV\I+D
PSYQ A:T&WS#^_M:R>I[$S/[!Y-"AZKU^EX'OOW233H-+L&^Z#QEELU*K##HKLEN\P-*0T^N
X)/D^)*5NTO@1RH 6+\-VB)'^RY^;>\_%4?[@41_:D<DTL^!9D3;#5A@F-QF1RH 6+\-VB)'
!FPO601YOXD&W/L3>%,7OKS<:H&*W6NF/E1J0;R5W,GVA.9!=1E?J[+I"3!UWSTGNUDB](3?
5F\S&HN<:<561RH 6+\-VB)'$\XE[>3$MOX35RQ7EDV=,+Y7(:#)I<VB%JDA*FVYK'W+,I<J
/O8VULN7E_D^';=^8W!@A9L=1RH 6+\-VB)'[+#?D4_ZA"GL8?_* %/:74=AMCK=_X1;]SVV
+7X&4!E96P@M-@DCDH>="2XV)Z%]S^J_>\DGD.AB0Q;>Z'N0LP$J@M(KE/^S!3_9X"ABH(4%
9%]!BMT>]AYD&#8[@C0/1\T8(C]JU>;AR5(B#+%W=6]@@9X,?BB2E,V6)FA^2J^MBWK\/&)*
.B_]FX9CU:@ZE.63J2WKVJ>4>RT(%7K?,,A[_S/&.WD0,YW_+>0^)LE"AC0M8M@!T['S8*9B
H[Z^/$\'\F:C<IXN%T'#K.5RY_3*AGZ#_S;GL?!/B]21A$"Q>K'Y82[UYAUZNTA('Y1F60:[
S]U*X3R*O<[/7[G1<\$!C,%?O(#/87N5?#"\O2YC4GRNO<>]?OH?#\&JY_)^O(#/87N5?#"\
XC!6">-A\:SB@V.>.H)UT#V#M8^K+N*98!6U+P"4=UQ9H3TO\=<""G]U4''Q>5[GU5N4!K1Y
5BAE(&.LB$]6'/BD4B-+QFD<0VNAR5SG_/M#UE":UZ.'H6[6I*JT+P:2V\VDHG7<\4!1EC.B
7F9@C0>?K<!>BK0"&HN#./"*KY 8:YFOQWJO"_*[&WP$['(+UF-SH_1+2"G657Y^8I5C3>15
T-'GA4VJSO30X.44'Z;$V@3@5YVW=F9H?H)7QS;./*#Q<VG' H<^@5SFIMH"G$@BH2-J2HB<
LF#-O\B14[^R]>OKQ*/I!'?UR[.>5B>ME@O+,3.GP-X_R@<Q^)P?L*^VWD[X<V8M$ X45,5S
>Q*)UB30]Z9[V@"\6JYPO#/:*-(1:O*4,@HH(@J.B7]A[Q,BE\OW+EQL2!B7\1W!GP[G-SGQ
<Q)+<MY%HFES(@J.B7]A[Q,B(F6G<FP^V+4B#"<SXS&Z7S ,#?R@LI=Q*9L-.5'2B/KH<=8Y
?!*/&[J1FX=\KRJ9EX0CRWFO>W(>UY'?\=![A:$;7+%5M8R%)F<@J,^(W?PFCG!3?.?,%"2.
PSYQ A:T&WS#RA*IA<V1 $K*7I:'?^&"W?U>F9-E9S')>Z^9O9)?#>W+(.F](!XS_81\]QX@
\=<""G]U4''Q^)#2)HR[\(SXQ_[@G'>ITC''*VR6E/5!JTHK8+89AHS'@>]@@&Y;YD'LMB6 
N?:5TU5N+EFY6YM*WX)(NL5;*_Z;^P^DU: KMV?B 1#W48ZWN++X<6[%#$*X7JI7 _,3@.1>
K#("MD5S[MVL8+89AHS'@>]@9CTUC!1Q1P)FN?:5TU5N+EFY6YM*WX)(NL5;.1KB+E#Q9<LY
MV?B 1#W48ZWN++X<6[%#$*X7JI7 _,3@.1>K#("MD5S[MVL'OS;+J)),^ >A]!X>UQEG N'
@.%:5C1I)6V C= ?T4UZV8&-88 =72=,3J]A3'B7VZEE@%],.1HL5,^DRWHY0B.^#4!+%^Y"
,_K\:%^7M?$S!M'?PB_;:GH&MO@85+QRK]VV@2=% "C^\&J!I$KOHY]DYW"D3N<S!OL X 1.
LB#-E.BV$ABRG%5I8S>J3W"<O4JDPU2DWT^]$87/V2Z</],1P;Z=!;BDV$G!&M=9P$NH^$T:
6;[B3_A#G-!9]-NT40%N<C'T1RH 6+\-VB)'8R]1,*Q6I7AC%QM=H]?M3:L7BYEQDXCE4T.+
1RH 6+\-VB)'/VODSX[ TXT_/5@SY?!RB&4][DP8QMY@0?7N*Y3BS5DQ\H4KAO/2?9_L: *&
_T+([.S6CZ7_X&PF?\HV!>_@: 1*7]X@1DMH0T/-/TJGL,5#1RH 6+\-VB)'1RH 6+\-VB)'
.A_^>05AKJ@Z@*AOI08_BY. >\N!8/%A#SQ[#=UM07,5L+X-C*N.O$N(GSZ,D-[8(N9,J6R0
1RH 6+\-VB)'AL=LZG6@H 2&QVP&1HTR,CW''W@0XHL\S]<?<\38*(2W;P-S!3U1&X:ONRD%
Y"Q+U6BV\I+DPSYQ A:T&WS#^_M:R>I[$S/[!Y-"AZKU^EX'OOW233H-+L&^Z#QEELU*K##H
KLEN\P-*0T^NX)/D^)*5NTO@1RH 6+\-VB)'^RY^;>\_%4?[@41_:D<DTL^!9D3;#5A@F-QF
1RH 6+\-VB)'!FPO601YOXD&W/L3>%,7OKS<:H&*W6NF/E1J0;R5W,GVA.9!=1E?J[+I"3!U
WSTGNUDB](3?5F\S&HN<:<561RH 6+\-VB)'$\XE[>3$MOX35RQ7EDV=,+Y7(:#)I<VB%JDA
*FVYK'W+,I<J/O8VULN7E_D^';=^8W!@A9L=1RH 6+\-VB)'[+#?D4_ZA"GL8?_* %/:74=A
MCK=_X1;]SVV+7X&4!E96P@M-@DCDH>="2XV)Z%]S^J_>\DGD.AB0Q;>Z'N0LP$J@M(KE/^S
!3_9X"ABH(4%9%]!BMT>]AYD&#8[@C0/1\T8(C]JU>;AR5(BTA9J,) 0%3?2+L2$SW1PXVLN
(QE%VJ4GXV,C<Q(<]=CC^\9S-Y:E*2#VAX8W^)P?L*^VWD[X=MJWUXP,THYV?ZV-*K3[@N-_
,B>[-_LJ!#,R;&#EBE_;\B9L:V-&<E6LA5-KVSB=W"-3H5G;@2=% "C^\&J!GXVZ8)M*,@N?
I+)%' SF*G2DDD!HQYH@QOJ2-S^XW<+*Q1@W.Y%0MN4PZ+@[DD!HQYH@QOJ2__48<T/H)"/_
.Y%0MN4PZ+@[X<9H@9 3:.OA^).NHJP@P"+XNA"CZ>D0CQ*ZF15\<UTBLB:9,%>\'V@C>0DP
E-&[AM->@I.49@+!X\$8"^AF-J%>V1T#;5LV]2\"8%BFT\[U]6A"D9URUR+U]RN[;O0EL0WW
(:L;A9<L+'$A(:L;A9<L+'$A(:L;A9<L+'$A(:L;A9<L+'$A(:L;A9<L+'$A(:L;A9<L+'$A
(:L;A9<L+'$A(:L;A9<L+'$A*XC DM'(' ,KM805L#H-(OJU83M. [O$8I9A,%04IE-^PK8P
.=RE2?F+=, Y>30-1X.30@YYEQ8(L^\5+[F7D;01U&;'(2"1O?1D9.9@'2"].J*TT'H<AN@Z
CJZD^2&@'6:.Y]P@X:*#[^3G6+E_>#YS,D-8DFV$ZCY&2(R2\M\.O!PWMI7RD3T;CKVD TN1
CSFY$(WG-3^/LYG,J&X;'B2S2<0:3=EE:YQ);U%&KE,P"J]O<,P3#78V DIPH7T,)\-UY#*A
/>AN9"91Z-,])W,*LG02+R0G&^X X0R&0ML;]ERJ>[%TRDGV*"!=GNG'?&0H1YHZ/H?%J U'
ZW R45E')'_K94/G$DOTFF9EDF6CXM%UFTR2_CV^8HE?9(#^WW9QS>2'?W??LO.+UUKW?%>R
1YHZ/H?%J U'?F:3$-G]$>!^94/G$DOTFF9E6Y+G7&+3DI);"W1YJL21=H<+[6W@&NJJ573M
%5094U%VI"L5_E*$7W*A^[W^H1Y'^T_L[:JA(\6<V];R_"0CUFHJ7!T/J!K6W]S'XT#+(?_?
2<0:3=EE:YQ);U%&KE,P"J]OUIQV'(M;#S/6\TF+VGG;ZC?S]:HS)M*<6/#UJ_@$ER0[PY6K
!8>\._UT2I<%TK\IJ&;*:)+2!EZYSJ;"MJ<&_[P-'5OY/EO_@A*^3U4#EHZ"UW0W*,"<#"?7
'9_H5M(\2[8=94/G$DOTFF9EA.]IIRH-O<B$HU0S(23;5D2CG0S*;8^;QG^=RR7X>1H!/T;+
WS+9O0T--AK?3]*FG$%MNXI/#(B0G36,Q6$,(&+DX@DH@&L@&(:O: D6;A<8L&A>6YUFU&&P
=H-59Q=DP=YVYA1DT9[\CO?FT?B3&,*206[1[N0:(@:!HM;N/>AN9"91Z-,]-I,9/ZRG5+<V
H"ML$>.]E.F@&LPS.@JM<0H:= I[*_!QCAMT^VMOH3_V:Z7[-^A.W+1:GN(W4>;)EJ!3?PI1
ID\4:@6*"RRF7+JQE2N7I?!<HJ7(O2KDM+*B!-\G.??WZ"<$[U56U/_.U$7OT_C9DMHB. 73
7$-=\BJ^L)]<8_<^ _99;0QCI<NL2:4/ 4ZE\V/(\Z=@PQSS#\X=Y"-B1K,/C*H!21X-,G6,
D1=A\"I9/&R1-QE!V>POX_TWI17H%JO%.&2E(+J0S3=%M%L@= @F>A[Q\(IT]<=A .)ZZ2CU
4>;)EJ!3?PI1ID\4:@6*"RRF7+JQE2N7I?!<HJ7(O2KDM+*B!-\G.??WZ"<$<=P,I4,Y3)9Q
I3Z$NK6G2OVE&T^!B9B4E.(;!7_HNIYE6K\%4>;)EJ!3?PI1U)V)GKS;OD+4])U\]<"N^(?T
?.I8;CB5CL-\NVR)P42!?TV[9%4;BO 6*+UDD5S=*H(NC-:1N4'$=P@M<M:Y0'B&'06H&71 
76W:T*7T!I!=CE4/.D(1/C^.\V/(\Z=@PQSS'<:AFX(UAT$=QA*72I#<!2+&X5#_2&)/X@3A
K+1KM]-!+N*L\V/(\Z=@PQSS1^AA2EL8RII')^THV"T)=]$GP&FY?.NE^4# *!3W(4\^7>TH
LY^N\Y"QZ/NS)'9^Z%EZ?^(D(^W'39*5V<8C3#_+__C=5)U,#%<JT91^:F4,M![Q8K\$2NJT
)EM.!N,/UW\F3!5KZ0>RCA=,]N-Q&7Z.VX7VCJ\(WF>%.1>.CJ\G#-;W4"N.9%4;BO 6*+UD
D5S=*H(NC-:1@RS:0=46>8N#^F2X$J4P-2+ZP&FY?.NE^4# F5GKV/JF58R9)'9^Z%EZ?^(D
7+?S- 5[@5)<R %O8.YS6Y'(,AG<^AB9]10R+O=4L$&A0.4NYU3;JYJ_7K+GUOL9A>CSD]36
O-3UI5@,=BV\N)2O<)'1$8"X@>F5X$ -'M^!7$NB>[@G[$U<C+QV;CPX<)R,U*J-E$NZ#@+4
<,)M,A$_141P42=0U <*=311=N@A, <? ,]VM9^<\S%UPMNU<,)M,A$_141P&*!V!.P<]7<8
=N@A, <? ,]VY#!&:L1Z7S/DFC]2V>\@<K6:!'+_;\^ T)4$QQ\\TSE_F1W'2H4>FZV++;I*
C+QV;CPX<)R,[7:K,RR4]*7M7DNJ.S>EX^5>G$VZBXK _%6<8$+)BFCH.*U@)EM.!N,/UW\F
4:I=V-2-,&)1 M1>7$B1Q! "<,)M,A$_141PPY$P&T>VK2_#(N6:Q4N)RKDB@LA57$:2V^2"
:*WIX0)=1^UHCJ\(WF>%.1>.NI2[NT<FVI.Z8OR#,"/Y$19B4>;)EJ!3?PI1\P!$U(]#N+;S
X4CL)HS_T8?AQQ\\TSE_F1W'BZ']6DLI* "+C+QV;CPX<)R,[7:K,RR4]*7M9:6Y)_2SZ=QE
G$VZBXK _%6<'/.;8(EFF"\<)EM.!N,/UW\F4:I=V-2-,&)1 :H&5*4.S"8!<,)M,A$_141P
0*-(!=3+02] 9%4;BO 6*+UDD5S=*H(NC-:1^JLAU9R,QA;Z0'B&'06H&71 F@:\O2YX5'Z:
(N6:Q4N)RKDB<_9&'^&MZ/AS?T+I0*P''G1_$*>MY5\%S800)EM.!N,/UW\FXM$;PTLK9GSB
>UN@WM]^=2M[A.A6.B-!=S6$KF0/=UYIT0:N<-:7'))+^UQP^878J6411&SY=N@A, <? ,]V
Y#!&:L1Z7S/DFC]2V>\@<K6:?UN-72STDO5_;D0(9.A).NMN7KF0?/"+C[9>I/V.2B>UW1&D
#P,W2:C8IE,/)EM.!N,/UW\F4:I=V-2-,&)1K7SAX+S=7'VM<,)M,A$_141PXD)9Y4E(CD;B
9%4;BO 6*+UDD5S=*H(NC-:1@"!HS_>KA " 0'B&'06H&71 1TIJMA39 O)'#P,W2:C8IE,/
)EM.!N,/UW\F4:I=V-2-,&)1K7SAX+S=7'VM(Y+7Y)5=6TPC!BE2TB%D^/0&>S%!<[ MG1%[
*8%V2G%Z2;8I(N6:Q4N)RKDB.*_Z!AZYUP@X/>AN9"91Z-,]Y*)!?:S[=;OD=N@A, <? ,]V
1!L48L4;]FY$@RS:0=46>8N##(;"<MS4K<\,O1OBV<V*SA&]++9T999X*]$LAPE:U<\9@2&'
/>AN9"91Z-,]Y*)!?:S[=;ODE^?0V>0Y.7>7K@YVXF X9GNN7G:I?E)X:VU>FC]2V>\@<K6:
4JW$V+0Z;8%2CJ\(WF>%.1>.=;;)FBI ]DIU(N6:Q4N)RKDB.*_Z!AZYUP@X/>AN9"91Z-,]
Y*)!?:S[=;OD=N@A, <? ,]V1!L48L4;]FY$@RS:0=46>8N##(;"<MS4K<\,O1OBV<V*SA&]
++9T999X*]$LAPE:U<\9@2&'/>AN9"91Z-,]Y*)!?:S[=;ODE^?0V>0Y.7>7K@YVXF X9GNN
7G:I?E)X:VU>FC]2V>\@<K6:4JW$V+0Z;8%2I17H%JO%.&2E<,)M,A$_141PWRS3F;-&BFS?
?6C@3+_+>69]@^(W$B>U=/6#FC]2V>\@<K6:J48-C$3^@[*I(N6:Q4N)RKDB/H;_"=U(UA ^
/>AN9"91Z-,]Y*)!?:S[=;ODE^?0V>0Y.7>7K@YVXF X9GNN@^(W$B>U=/6#FC]2V>\@<K6:
J48-C$3^@[*IQ;;$O(). 4;%[KTR"+V%OKGN,E%ID"#(KZ\RA_RP/-GG,?2'$&M,BQ3UL500
 -%O#^!@A>\ - 4D*!U4[H(T?6C@3+_+>69]@^(W$B>U=/6#FC]2V>\@<K6:J48-C$3^@[*I
(N6:Q4N)RKDB/H;_"=U(UA ^/>AN9"91Z-,]Y*)!?:S[=;ODE^?0V>0Y.7>7K@YVXF X9GNN
@^(W$B>U=/6#FC]2V>\@<K6:J48-C$3^@[*IQ;;$O(). 4;%[KTR"+V%OKGN,E%ID"#(KZ\R
A_RP/-GG,?2'$&M,BQ3UL500<=P,I4,Y3)9Q1RH 6+\-VB)'^O! KI$_-Y?ZZ:UY#XVL>LKI
9%4;BO 6*+UD9H-[:HE* 3!FR>!X\EJ(Q2?)1RH 6+\-VB)'V2ERCPROP^O9D7-C).Z<:M>1
4DL[K;*"_3A2OA*?I)S)4EN^YU3;JYJ_7K+G0'B&'06H&71 1RH 6+\-VB)'E_;P+N3U4VR7
6O6US"%0N2U:ACCG DCK-+:&(N6:Q4N)RKDB<_9&'^&MZ/AS:\P4*$1YA5)K1RH 6+\-VB)'
(UP!?G*GY@4C;A4@AWVFFJIN9%4;BO 6*+UD2U6+A7[HK:-+Y>1<8</8+EWE+UU%V_] G'0O
<F3)QK "TM5RJQ05=/W=<(*K1RH 6+\-VB)'F'*!'\M/IKR8_-M(%Z\QE\7\G%/W-AXUP@"<
=N@A, <? ,]V6(0;R$GJ9B)8&P$F./*'DO\;)^$0G%="I"XGY[=TSTI;7 OGA+69G]?P%8N$
SUJD(NGN IS/>_DA?;#4=3A[1RH 6+\-VB)'DO?8JXNJ6VJ2FSZ6O$ACLF6;9,@:L_]&\1%D
\V/(\Z=@PQSS=VSQ>Q9C!>-W+=?OX$.;818MK8LJB<\X8E:M#AU+_+J 3T<.8#:U4RK[ZZ9@
2WCJ=LUD?*-+1RH 6+\-VB)'2RFE$)A8*^-+Y<,H$)S>)3KE\V/(\Z=@PQSS=VSQ>Q9C!>-W
+=?OX$.;818MOE!2VAZN,+B^1RH 6+\-VB)'W\6: 8[[*+C?9]X',W-@H#!G@C>EBXT*<_""
C+QV;CPX<)R,Y'/R]VWF2<_DV)D)@76<GO'8V]H>G95Y'AK;H/2(PQ$V^A"@2&1[PDS?DIQ(
9%4;BO 6*+UDD5S=*H(NC-:1ZPXT+^;>)@;K"-1$"ZQYOC0(1RH 6+\-VB)'P&FY?.NE^4# 
X9K&=Y1I[!CA)'9^Z%EZ?^(D7+?S- 5[@5)<^F2X$J4P-2+Z1RH 6+\-VB)',AG<^AB9]10R
R[.>5B>ME@O+9%4;BO 6*+UDD5S=*H(NC-:1ZPXT+^;>)@;K"-1$"ZQYOC0(1RH 6+\-VB)'
G$VZBXK _%6<DCB[0H@^O)F2\)1<&-+'8-GP)EM.!N,/UW\F9>FNU<UVUB-EZ20CT'I.+//I
@L*"BSL2(&B"0'B&'06H&71 @?_.2TGQ>_*!E/KO&-I Y5Z4LYG,J&X;'B2SC$RY#R3S^G>,
+-!V2KVJ/1XL<[GYD5SPX_YSK_&W5MZS81"OT@[%'UT;R'[2SJ$$V3=<5G3.$QO(+YK.KV@3
EH/M-."1S].6["'H5"0:1DGLG3R?Q#\;3:&=LP#*N./! Y>SH$CUIS%Y_;F@,\P9$O2( ;LS
,\P9$O2( ;LS,\P9$O2( ;LS,\P9$O2( ;LS,\P9$O2( ;LS,\P9$O2( ;LSY,F[=S<TQ=KD
MZOW!R(*:0ZWMZOW!R(*:0ZWMZOW!R(*:0ZWMZOW!R(*:0ZWMZOW!R(*:0ZWMZOW!R(*:0ZW
MZOW!R(*:0ZWMZOW!R(*:0ZW/S1-G'CT7QD_1GT3%D';0.=&S>A8IA /^%;-H$>V><I0.+R@
TOI(ATL&G!G22SC\@0C>24E+()M%+&33XMD@6L ?"T-CB[%:-,ZXH] >6$ TS_XN8*C5[17/
08B+/X?5<U-!2<0:3=EE:YQ);U%&KE,P"J]O)?PO+N[S OHEWG>V VM//'_>2AF<-.&?($Y*
7+!E_%( 8*Y<B8-^5&=@PK^)]=TU,O]2+Y'U#!L7:P>NW_\, 4 Z,4X-%'P! 8#OTA[3-G !
S([.8^(!CSO,[/(#DK*WXUKL]=TU,O]2+Y'U?>&2<)?2NRE]I17H%JO%.&2E7&NR@3PW0M!<
RNR7]0I[_MW*XLIV>)74\Q7B^0M*Z,TB( /Y@RS:0=46>8N#W5:#B.G@-A[= 8#OTA[3-G !
S([.8^(!CSO,[/(#DK*WXUKL/O"O6+)5-/,^=DYXH%154S1V9.G646>:,>1D'9_H5M(\2[8=
99K1.UO3W(UEH"ML$>.]E.F@[T:"+@ZPQ?+O++9T999X*]$LAPE:U<\9@2&'/>AN9"91Z-,]
E2'0"N54>N65@P] < >>L#6#-BCJ,.;$'2,VUO7[#OF F=[6@RS:0=46>8N#NS=](1O4LJ>[
-BCJ,.;$'2,VY)6RWP8SR![D@>&/M_$4NM"!(/TP-B(",[(@U"ZW[T/[/C?42QK6F!3OLD]+
(:L;A9<L+'$A(:L;A9<L+'$A(:L;A9<L+'$A(:L;A9<L+'$A(:L;A9<L+'$A(:L;A9<L+'$A
(:L;A9<L+'$A*+GVFHT4N[LHI_%^.\G=!96GRMW@PY<\SAS*=#BCA+8(EYETJ0\7@PNX%C&I
EX]4/H$7@*J7QLOK@6B30Z+&DG-L8.'J@;N20ZL[<NEYL_9#*<<IY@3>G"$II_%^.\G=!96G
$]8$J\HTDB$3&19O@:.7R8,90'B&'06H&71 >3,&7H\YLB]Y@XO>[I@&"A"#!Y-"AZKU^EX'
-L)G2ZPXOG0V.;UIF5F__1PYAGI'QJ)0@&6&<S@'X,X08GUS%VZG\$UL&S47>^;,?X4E2,-[
4H!B)9^>].)2Z\C R+UYV GK%TB>HMG^[,07&8ESLKQ8.+89!(:\R&$4VS@$?#=$4;HMO8A\
MR9",BC,/LBWLN_[&#DN)0JRM=Q8PF^*.Y&U,-'L%=$M"8TPL7Q@Z E<QFRQO*]L!UU:.1^\
X=.2Z*:2><OA!^NHHV)^'D 'K0F2/W:&7#*MD432W:-E%B*1/S,!JKY%DRH_-RK;"VWI # W
@'IU8.CD7,* 7^8H08;W'K)?S2<CT& >5=_-05F>7P_<%]A![SUTAF_G_.OO
#pragma PXL encrypted end
#pragma PXL encrypted begin
^@>Z52>,U@CZ.:1]\GUIB58Y0#KQ#,H_=C% .H7T-\2Y3=HZ2H/:#H#L<7!*M]1VJ4>%.8FW
O\IB'0_K3[N_RVY@;A)3MQW+
#pragma PXL encrypted end







#endif

#ifdef FILL_DM10

#pragma PXL encrypted begin
<19J@)LK"7MQP)HR*+YZPQO *3#'HV-#([LI7761MIEI\CY=N )W>W@L1W*X+P?32>LE5UXO
I+<92UV'346D(N;N+&_VCD$B;GY2W07*S1INY#,Y%<<,VM;D
#pragma PXL encrypted end


LAYER_DM10_MYBCELL_H : polygon_layer_s = {
    layer_spec = {
        output_layer_key = "OUTPUT_DM10_DMB_CONNECT"
    },
    polygons = MYBCELL_H
};

LAYER_DM10_MYBCELL_V : polygon_layer_s = {
    layer_spec = {
        output_layer_key = "OUTPUT_DM10_DMB_CONNECT"
    },
    polygons = MYBCELL_V
};

LAYER_DM10_MYBCELL_HEXT : polygon_layer_s = {
    layer_spec = {
        output_layer_key = "OUTPUT_DM10_DMB_CONNECT"
    },
    polygons = MYBCELL_HEXT
};

LAYER_DM10_MYBCELL_VEXT : polygon_layer_s = {
    layer_spec = {
        output_layer_key = "OUTPUT_DM10_DMB_CONNECT"
    },
    polygons = MYBCELL_VEXT 
};

// DUMMY SPEC : DM10_DMB_Connect
SPEC_DM10_DMB_CONNECT = unified_fill(
    fill_patterns = {
    {
        type = UF_POLYGON,
        polygon_fill = {
            insertion = {
                iterations = 3,
                shift_factor = 2,    
            },
            pattern_spec = {
#ifdef VERTICAL_M10
                space_x = DMY1B_SX,
                space_y = DMY1B_SY,
                stagger_x = DMY1B_OX,
                stagger_y = DMY1B_OY,
#else
                space_x = DMY1B_SY,
                space_y = DMY1B_SX,
                stagger_x = DMY1B_OY,
                stagger_y = DMY1B_OX,
#endif
            },
            layers = {
#ifdef VERTICAL_M10
                LAYER_DM10_MYBCELL_V
#else
                LAYER_DM10_MYBCELL_H
#endif
            },
#ifdef CONTROL_MAX_METAL_LENGTH
#else
            merging_layers = {
#ifdef VERTICAL_M10
                LAYER_DM10_MYBCELL_VEXT
#else
                LAYER_DM10_MYBCELL_HEXT
#endif
            },
#endif
#ifdef ANTPrevention                
#ifndef CONTROL_MAX_METAL_LENGTH
            merging_blockage_layer_list = {
                FORBIDDEN_RING
            },
#endif
#endif
#ifdef CONTROL_MAX_METAL_LENGTH
#else
#ifdef VERTICAL_M10     
            merging_direction = VERTICAL,
#else
            merging_direction = HORIZONTAL,
#endif   
            merging_length_limit = 500*(DMY1OR_L + DMY1B_SY) - DMY1B_SY, 
#endif
            fill_to_signal_spacing = {
    { CHIP_snps, min_space = DMY1B_CHIP, context = INTERIOR },
#ifdef FULL_CHIP
    { CHIP_BOUNDARY, min_space = DMY1B_CHIP, context = INTERIOR },
#else
    { PRBOUNDARY, min_space = DMY1B_CHIP, context = INTERIOR },
#endif
    { ICOVL_SINGLE, min_space = DMY1_ICOVL },
    { INDDMY, min_space = DM_INDDMY },
    { TCDDMY_M10, min_space = DM_TCDDMY_MX },

	{ BEOLBLK_FINAL, min_space = DMY1B_MY1 },
    { DM10EXCL_FINAL, min_space = DMY1B_MY1 },
    { CSR66_3485, min_space = DMY1B_MY1 },
    { M10_MAIN, min_space = DMY1B_MY1 },
    { DM10_O, min_space = 0.26 },
    { DM10, min_space = 0.26 },
    { DM10_GT1350, min_space = 0.45 },
    { M10_GT76, min_space = DMY1_MY1W1 },
    { M10_GT114, min_space = DMY1_MY1W2 },
    { M10_GT152, min_space = DMY1_MY1W3 },
    { M10_GT180, min_space = DMY1_MY1W4 },
    { M10_GT240, min_space = DMY1_MY1W5 },
    { M10_GT280, min_space = DMY1_MY1W6 },
    { M10_GT500, min_space = DMY1_MY1W7 },
    { M10_GT1350, min_space = DMY1_MY1W8 },
#ifdef FILL_M9_VIA9_M10_BTCD
              { BTCD_M9_V9_M10_E, min_space = BTCD_D },
#endif
#ifdef FILL_M10_VIA10_M11_BTCD
              { BTCD_M10_V10_M11_E, min_space = BTCD_D },
#endif

#ifdef FILL_M10_BTCD2
              { BTCD_M10_E, min_space = BTCD_D },
#endif
              { WRAPPER_DM10_O_L, min_space = DMY1B_DMY1O },
#pragma PXL encrypted begin
_CZO-MN07%#^)G2N$U3JV6(F".[;C0N10%$(A(/R;(>D"12$>ZP'4G5[@P%[X-6_(M0L3E[@
\D> ("$J.!OR8\=JN( #PI1C#%K@Z0[/4.@,%T%-AZ$-8 H7 Z8E5W=8I4(#KOOE5S$ELN&N
V-"&4UNMA)_8/EO):.4@ 3\^J"VEP6/-!]"HA)_S2K+Y5H>$KKP,/<0(9=2N46<^YJ9XBB)1
YZU\ D:">!SG!&HVL$6XX ($< %;=WWFQ+-P:-UR7Z,"P9MH
#pragma PXL encrypted end

                            
            },
            hierarchical_fill = false,
#ifdef VERTICAL_M10     
            cell_prefix = "DMB10VNEW"
#else
            cell_prefix = "DMB10HNEW"
#endif   
        }
    }
    },
    extents_output = {
        {
            output_layer_key = "OUTPUT_DM10_DMB_CONNECT_EXTENT"
        },
    },
    fill_boundary = {
        layer = CHIP_snps, 
        type = LAYER 
    },
	grid = vGRID
);
//=======================================================
DM10NEW_C     = SPEC_DM10_DMB_CONNECT["OUTPUT_DM10_DMB_CONNECT"][0];
DM10NEW_L     = SPEC_DM10_DMB_CONNECT["OUTPUT_DM10_DMB_CONNECT"][0];
//***** spec *******************************************************************
#pragma PXL encrypted begin
O  E?HI/KU^\;T<=FGHS\29OTB)Y;*L'_>32UZBW'7OGYS+7<+%QM82GQZ-P];;AG&TV"XSU
V3<Q&P?5=RC9DU\SA Z957:3
#pragma PXL encrypted end

//***DM10_DMB***
// DUMMY SPEC : DM10_y1
PATTERN_SPEC_DM10_0 = get_single_polygon_pattern(
#ifdef VERTICAL_M10
	"DMB10V", "OUTPUT_DM10", DMY1B_W, DMY1B_L,
	step_x = DMY1B_SX, step_y = DMY1B_SY,
	offset_x = DMY1B_OX, offset_y = DMY1B_OY,
#else
	"DMB10H", "OUTPUT_DM10", DMY1B_L, DMY1B_W,
	step_x = DMY1B_SY, step_y = DMY1B_SX,
	offset_x = DMY1B_OY, offset_y = DMY1B_OX,
#endif
    FSS = {
    { CHIP_snps, min_space = DMY1B_CHIP, context = INTERIOR },
#ifdef FULL_CHIP
    { CHIP_BOUNDARY, min_space = DMY1B_CHIP, context = INTERIOR },
#else
    { PRBOUNDARY, min_space = DMY1B_CHIP, context = INTERIOR },
#endif
    { ICOVL_SINGLE, min_space = DMY1_ICOVL },
    { INDDMY, min_space = DM_INDDMY },
    { TCDDMY_M10, min_space = DM_TCDDMY_MX },

	{ BEOLBLK_FINAL, min_space = DMY1B_MY1 },
    { DM10EXCL_FINAL, min_space = DMY1B_MY1 },
    { CSR66_3485, min_space = DMY1B_MY1 },
    { M10_MAIN, min_space = DMY1B_MY1 },
    { DM10_O, min_space = 0.26 },
    { DM10, min_space = 0.26 },
    { DM10_GT1350, min_space = 0.45 },
    { M10_GT76, min_space = DMY1_MY1W1 },
    { M10_GT114, min_space = DMY1_MY1W2 },
    { M10_GT152, min_space = DMY1_MY1W3 },
    { M10_GT180, min_space = DMY1_MY1W4 },
    { M10_GT240, min_space = DMY1_MY1W5 },
    { M10_GT280, min_space = DMY1_MY1W6 },
    { M10_GT500, min_space = DMY1_MY1W7 },
    { M10_GT1350, min_space = DMY1_MY1W8 },
#ifdef FILL_M9_VIA9_M10_BTCD
              { BTCD_M9_V9_M10_E, min_space = BTCD_DY1 },
#endif
#ifdef FILL_M10_VIA10_M11_BTCD
              { BTCD_M10_V10_M11_E, min_space = BTCD_DY1 },
#endif

#ifdef FILL_M10_BTCD2
              { BTCD_M10_E, min_space = BTCD_DY1 },
#endif
              { WRAPPER_DM10_O_L, min_space = DMY1B_DMY1O },
#pragma PXL encrypted begin
><*<13H. F]YASC;Z<G 7**'9C]&/?THZ9%F7(B?\(*D_]]<^S(A/7QA'0S[#)@ C6!(<AX,
EZ]CN:;V))27,W8LKFI'P7(S!QZ(Y _R]S8'S *$M\W8L$G,
#pragma PXL encrypted end

              { DM10NEW_L, min_space = DMY1B_DMY1 },
#pragma PXL encrypted begin
<JH/9#^)Y&ER6':YYFB.YWI8JGL2+.GVO3BJV?4"9FTG7KS9$,<@+%@S?4,0U/1VP?RKC'O4
,]$;>V:\90(SLHPN6[J/*).R
#pragma PXL encrypted end

    },
	shift = 2,
	repeat = 3,
    starting_point = CENTER
); //end of get_single_polygon_pattern


//-------------------------------------------------------------------------------

//***DM10_DMS***
PATTERN_SPEC_DM10_1 = get_single_polygon_pattern(
#ifdef VERTICAL_M10
	"DMS10V", "OUTPUT_DM10", DMY1S_W, DMY1S_L,
	step_x = DMY1S_SX, step_y = DMY1S_SY,
	offset_x = DMY1S_OX, offset_y = DMY1S_OY,
#else
	"DMS10H", "OUTPUT_DM10", DMY1S_L, DMY1S_W,
	step_x = DMY1S_SY, step_y = DMY1S_SX,
	offset_x = DMY1S_OY, offset_y = DMY1S_OX,
#endif
    FSS = {
    { CHIP_snps, min_space = DMY1S_CHIP, context = INTERIOR },
#ifdef FULL_CHIP
    { CHIP_BOUNDARY, min_space = DMY1S_CHIP, context = INTERIOR },
#else
    { PRBOUNDARY, min_space = DMY1S_CHIP, context = INTERIOR },
#endif
    { ICOVL_SINGLE, min_space = DMY1_ICOVL },
    { INDDMY, min_space = DM_INDDMY },
    { TCDDMY_M10, min_space = DM_TCDDMY_MX },

	{ BEOLBLK_FINAL, min_space = DMY1S_MY1 },
    { DM10EXCL_FINAL, min_space = DMY1S_MY1 },
    { CSR66_3485, min_space = DMY1S_MY1 },
    { M10_MAIN, min_space = DMY1S_MY1 },
    { DM10_O, min_space = 0.26 },
    { DM10, min_space = 0.26 },
    { DM10_GT1350, min_space = 0.45 },
    { M10_GT76, min_space = DMY1_MY1W1 },
    { M10_GT114, min_space = DMY1_MY1W2 },
    { M10_GT152, min_space = DMY1_MY1W3 },
    { M10_GT180, min_space = DMY1_MY1W4 },
    { M10_GT240, min_space = DMY1_MY1W5 },
    { M10_GT280, min_space = DMY1_MY1W6 },
    { M10_GT500, min_space = DMY1_MY1W7 },
    { M10_GT1350, min_space = DMY1_MY1W8 },
#ifdef FILL_M9_VIA9_M10_BTCD
              { BTCD_M9_V9_M10_E, min_space = BTCD_DY1 },
#endif
#ifdef FILL_M10_VIA10_M11_BTCD
              { BTCD_M10_V10_M11_E, min_space = BTCD_DY1 },
#endif

#ifdef FILL_M10_BTCD2
              { BTCD_M10_E, min_space = BTCD_DY1 },
#endif
              { WRAPPER_DM10_O_L, min_space = DMY1S_DMY1O },
#pragma PXL encrypted begin
9M_\&B--9U-F-4Z2I'NA!Y(U]!;JUO@R*MOT0N8]U= 8Q]Y">,RN8.&//T9X4_E>XN+RJ$E3
3BN+WV41^8Q.]5N-G WP%!'U U'&K]WOU]T#MY-.UU$?GXZW
#pragma PXL encrypted end

              { DM10NEW_L, min_space = DMY1S_DMY1 },
#pragma PXL encrypted begin
O&T,:XJXN3^\D5*]BX]Z"_F1> (_<"F;;*MXO=Q:)$G:-;R]2ZY<ZY&8Q,!+2QG+J3+$S/]+
41B8F@^(NTA19;M&2S [82-E
#pragma PXL encrypted end

    },
	shift = 2,
	repeat = 3
);


//***DM10_O_R***
PATTERN_SPEC_DM10_2 = get_single_polygon_pattern(
#ifdef VERTICAL_M10
	"DMOR10V", "OUTPUT_DM10_O", DMY1OR_W, DMY1OR_L,
	step_x = DMY1OR_SX, step_y = DMY1OR_SY,
	offset_x = DMY1OR_OX, offset_y = DMY1OR_OY,
	setback = DMY1OR_SC,
	setback_type = INTERSECTION,
#else
	"DMOR10H", "OUTPUT_DM10_O", DMY1OR_L, DMY1OR_W,
	step_x = DMY1OR_SY, step_y = DMY1OR_SX,
	offset_x = DMY1OR_OY, offset_y = DMY1OR_OX,
	setback = DMY1OR_SC,
	setback_type = INTERSECTION,
#endif
    FSS = {
    { CHIP_snps, min_space = DMY1_CHIP, context = INTERIOR },
#ifdef FULL_CHIP
    { CHIP_BOUNDARY, min_space = DMY1_CHIP, context = INTERIOR },
#else
    { PRBOUNDARY, min_space = DMY1_CHIP, context = INTERIOR },
#endif
    { ICOVL_SINGLE, min_space = DMY1_ICOVL },
    { BEOLBLK_FINAL, min_space = DM_BEOLBLK },
    { CSR66_3485, min_space = DM_BEOLBLK },
    { INDDMY, min_space = DM_INDDMY },
    { DM10EXCL_FINAL, min_space = DM_DMXEXCL },
    { TCDDMY_M10, min_space = DM_TCDDMY_MX },
    { M10_MAIN, min_space = DMY1OR_MY1 },
    { DM10_O, min_space = DMY1OR_DMY1O },
    { DM10, min_space = 0.2 }, //DMn.S.3.5
    { DM10_GT1350, min_space = 0.45 },
    { M10_HOLE, min_space = 0 },
    { M10_GT76, min_space = DMY1_MY1W1 },
    { M10_GT114, min_space = DMY1_MY1W2 },
    { M10_GT152, min_space = DMY1_MY1W3 },
    { M10_GT180, min_space = DMY1_MY1W4 },
    { M10_GT240, min_space = DMY1_MY1W5 },
    { M10_GT280, min_space = DMY1_MY1W6 },
    { M10_GT500, min_space = DMY1_MY1W7 },
    { M10_GT1350, min_space = DMY1_MY1W8 },
    { M10_45, min_space = 0 },
    { VIA9_HVN_5V, min_space = DMY1_VY15V },
    { M10_HVN_5V, min_space = DMY1_MY15V },
    { VIA10_HVN_5V, min_space = DMY1_VY15V },

              { R7_VIA9_CHK_REGION, min_space = 0 },
              { R15_VIA10_CHK_REGION, min_space = 0 },

              { S22_M10_REGION, min_space = 0 },
#ifdef FILL_M9_VIA9_M10_BTCD
              { BTCD_M9_V9_M10_E, min_space = BTCD_DY1 },
#endif
#ifdef FILL_M10_VIA10_M11_BTCD
              { BTCD_M10_V10_M11_E, min_space = BTCD_DY1 },
#endif

#ifdef FILL_M10_BTCD2
              { BTCD_M10_E, min_space = BTCD_DY1 },
#endif
              { WRAPPER_DM10_O_L, min_space = DMY1OR_DMY1O },
#pragma PXL encrypted begin
X6+J*8+*#'+AS+8*AQLSK"S,A:'+=(C88;>%:DE=%A<:52!J,!\^(PU=C2PP+[SFPY8WGSLO
GB.=VBJX"G">9%MM>EGI[*9DI3 [E(QX%#NE1>+A' 91?&5%
#pragma PXL encrypted end

              { DM10NEW_L, min_space = DMY1OR_DMY1 },
#pragma PXL encrypted begin
FG';"1#2_V^:76ZFHE.45DA=L?"R(PA;IYVQ ,Q?8B;.61X "+52QI^$0M4(."*M8Q<M^UXX
[KTR+O-637GN0O'LD)FTKYY"
#pragma PXL encrypted end

	},
    shift = 2,
	repeat = 3,
    starting_point = CENTER
);

#ifdef VERTICAL_M10
PATTERN_SPEC_DM10_2.polygon_fill.pattern_spec.pattern_spacing = {
    allowed_spacing_x = { >= DMY1OR_SXA2 },
    allowed_spacing_y = { >= DMY1OR_SY },
    extension = INTERSECTION
};
#else
PATTERN_SPEC_DM10_2.polygon_fill.pattern_spec.pattern_spacing = {
    allowed_spacing_y = { >= DMY1OR_SXA2 },
    allowed_spacing_x = { >= DMY1OR_SY },
    extension = INTERSECTION
};
#endif




//-------------------------------------------------------------------------------
//***DM10_O_W***

PATTERN_SPEC_DM10_3 = get_single_polygon_pattern(
#ifdef VERTICAL_M10
	"DMOW10V", "OUTPUT_DM10_O", DMY1OW_W, DMY1OW_L,
	step_x = DMY1OW_SY, step_y = DMY1OW_SX,
	offset_x = DMY1OW_OY, offset_y = DMY1OW_OX,
	setback = 0.114,
	setback_type = INTERSECTION,
#else
	"DMOW10H", "OUTPUT_DM10_O", DMY1OW_L, DMY1OW_W,
	step_x = DMY1OW_SX, step_y = DMY1OW_SY,
	offset_x = DMY1OW_OX, offset_y = DMY1OW_OY,
	setback = 0.114,
	setback_type = INTERSECTION,
#endif
    FSS = {
    { CHIP_snps, min_space = DMY1_CHIP, context = INTERIOR },
#ifdef FULL_CHIP
    { CHIP_BOUNDARY, min_space = DMY1_CHIP, context = INTERIOR },
#else
    { PRBOUNDARY, min_space = DMY1_CHIP, context = INTERIOR },
#endif
    { ICOVL_SINGLE, min_space = DMY1_ICOVL },
    { BEOLBLK_FINAL, min_space = DM_BEOLBLK },
    { INDDMY, min_space = DM_INDDMY },

    { DM10EXCL_FINAL, min_space = DM_DMXEXCL },
    { CSR66_3485, min_space = DM_BEOLBLK },
    { TCDDMY_M10, min_space = DM_TCDDMY_MX },

    { M10_MAIN, min_space = DMY1OW_MY1 },
    { DM10_O, min_space = DMY1OW_DMY1O },
    { DM10, min_space = 0.2 }, //DMn.S.3.5
    { DM10_GT1350, min_space = 0.45 },
    { M10_HOLE, min_space = 0 },
    { M10_GT76, min_space = DMY1_MY1W1 },
    { M10_GT114, min_space = DMY1_MY1W2 },
    { M10_GT152, min_space = DMY1_MY1W3 },
    { M10_GT180, min_space = DMY1_MY1W4 },
    { M10_GT240, min_space = DMY1_MY1W5 },
    { M10_GT280, min_space = DMY1_MY1W6 },
    { M10_GT500, min_space = DMY1_MY1W7 },
    { M10_GT1350, min_space = DMY1_MY1W8 },
    { M10_45, min_space = 0 },
    { VIA9_HVN_5V, min_space = DMY1_VY15V },
    { M10_HVN_5V, min_space = DMY1_MY15V },
    { VIA10_HVN_5V, min_space = DMY1_VY15V },

              { R7_VIA9_CHK_REGION, min_space = 0 },
              { R15_VIA10_CHK_REGION, min_space = 0 },

              { S22_M10_REGION, min_space = 0 },
#ifdef FILL_M9_VIA9_M10_BTCD
              { BTCD_M9_V9_M10_E, min_space = BTCD_DY1 },
#endif
#ifdef FILL_M10_VIA10_M11_BTCD
              { BTCD_M10_V10_M11_E, min_space = BTCD_DY1 },
#endif

#ifdef FILL_M10_BTCD2
              { BTCD_M10_E, min_space = BTCD_DY1 },
#endif
              { WRAPPER_DM10_O_L, min_space = DMY1OW_DMY1O },
#pragma PXL encrypted begin
>+/R*\W$,@5X(1,+!F(NV4$A3+V=^&9UL\],U"R6-:I[0J+4WK5P#-@8,<+>!$#G)0!,PHT$
0@;7P/,T/49"0O,_I]V+;.9"?>X[TZ<13-%]B?Z]K!+%.CJ)
#pragma PXL encrypted end

              { DM10NEW_L, min_space = DMY1OW_DMY1 },
#pragma PXL encrypted begin
!+5X:VDUM4L$5\62K[E#=/A7FHP@6Y"4=)*:W_+CZ?YYK-O?@LWXQ,RO=86"XT% LZ)^S??C
UKY8<N%'E[G6:9(/Y+.>VG-I
#pragma PXL encrypted end

	},
    shift = 2,
	repeat = 3,
    starting_point = CENTER
);
//=======================================================
PATTERN_SPEC_DM10_0.polygon_fill.pattern_spec.other_pattern_spacing = {
    1 => > DMY1B_DMY1,
    2 => > DMY1B_DMY1,
    3 => > DMY1B_DMY1,
};

PATTERN_SPEC_DM10_1.polygon_fill.pattern_spec.other_pattern_spacing = {
    0 => > DMY1S_DMY1,
    2 => > DMY1S_DMY1,
    3 => > DMY1S_DMY1,
};

PATTERN_SPEC_DM10_2.polygon_fill.pattern_spec.other_pattern_spacing = {
    0 => > DMY1OR_DMY1,
    1 => > DMY1OR_DMY1,
    3 => > DMY1OR_DMY1O,
};

PATTERN_SPEC_DM10_3.polygon_fill.pattern_spec.other_pattern_spacing = {
    0 => > DMY1OW_DMY1,
    1 => > DMY1OW_DMY1,
    2 => > DMY1OW_DMY1,
};

SPEC_DM10 = unified_fill(
    fill_boundary = {
        layer = CHIP_snps,
        type = LAYER
    },
    fill_patterns = {
        PATTERN_SPEC_DM10_0,
        PATTERN_SPEC_DM10_1,
        PATTERN_SPEC_DM10_2,
        PATTERN_SPEC_DM10_3,
    },
    boundary = ALIGN,
	grid = vGRID
);

//***** fill *******************************************************************
DM10_C   = SPEC_DM10["OUTPUT_DM10"][0];
DM10_O_C = SPEC_DM10["OUTPUT_DM10_O"][0];

#pragma PXL encrypted begin
>\,H%MW4YSU[A*0R=[3,HZ:$/"AP(AIIP6X\>#]R5%E 71!XP,\5(:OC61W 9A4G1PC +]]F
"C[*%BP2RTX*8!$1&H3XB_)@/P5-BMQJ_Z$_1HCY7++$<T)&
#pragma PXL encrypted end

#pragma PXL encrypted begin
=*N;-.)/RCAT^+ 7^=B^.,OXJL>9<S'OP\:JX@0^47O,S0WB<J:J*AV"Z?%R0V(Y^F6;D\-#
W];X47DE\%_?!C*HF/$DF(8&()!3Z'$<_+$@$$Y71,H]Q-H0
#pragma PXL encrypted end
#pragma PXL encrypted begin
D\8T%16V[$J358'2'KI'1915H<CFM+$OO0^A/9'!C#Z6GI@]968JX(.BQT)E=4D^@6<4&R-U
2$.E:-<2&1I(-VM#07E$VNTW[/6FIRKAQ)'LG35_7\A):/B=1&M#B!2W@WY$%3_\^&GA ^85
#pragma PXL encrypted end
#pragma PXL encrypted begin
LN'-=4@<#UVRUF9.,Y >:!76<S-MB5#JI%!SKT/)[:JT0O&OY>9F0>%'?1/E*F!F;!I& !PJ
L>RPWVKL("VQ
#pragma PXL encrypted end
DM10_O_L = SPEC_DM10["OUTPUT_DM10_O"][0];
#pragma PXL encrypted begin
T?QF5GN",6_1 V,>Z.D*[I<#\?6--R5=B+SQ6&? O^,I7)181/7M0,]<FN-$6\8O9IB8.1Y;
+E?=( _=>KPN=]@6W,<M8+IW
#pragma PXL encrypted end
#pragma PXL encrypted begin
\!< -J[H4P'P#'">,\K>"5 , "X(E,Z"$,$ I!\R-(0LU>>D2(W',*XV>QE(E,\D\H&HF..4
.(TP,TT%E+0X,GDJ^\]'IF0R:<R??^H-WL1I/A5&>U2DO-0^ZOM/-7<,E\+JNM][_/X]XKJZ
53S2!^HH74Y5)IN5V_-$$Y@F
#pragma PXL encrypted end
#pragma PXL encrypted begin
,+,Y<NZ"5ADP:\LU7SU%LGQK9$55O0Q.16QD*X3B<[;T;&HK&C2I69S!%KD:@,3+5R8.XW6 
)&H^?O7 P<LD/<P<)9CEUZ\]L!WE00QAG "P3(?VUY/7S:9,
#pragma PXL encrypted end
DM10_L1   = SPEC_DM10["OUTPUT_DM10"][0];
DM10_L = DM10_L1 or DM10NEW_L;
#pragma PXL encrypted begin
JW1O!(39Z!RK.PPOZ9L0/3P[R9:_P9%VNS/)!/H-]7\I9@D$II;R#-0)J+BF(,<ZBC?7F9@@
6F&_]0U+\?U:C@9<1DGT[T^.26P\E%P% 3E)H8.,$YX-L06AWN2=K.2[7V7>Q/'.I.N]<VG$
4,YU_;KE3.I0
#pragma PXL encrypted end


#pragma PXL encrypted begin
7:D;!DXUJWI=;PTVJ!. Y,=OG+!",DSC^N2<[DL<B_*;"B3NBR\C]NG8P2Z+#_@@&I6UX1D/
FIM17]A%+S":\&62@GKP9CCP@[4*7>?X*WV#<.3<6/(H)^1P
#pragma PXL encrypted end
#pragma PXL encrypted begin
?,2T9H&;S0Q\RG7V719BZEO*#Q53'7G,T+,/U@B=PE-_4HG6;'2AY9Y_T,YLXPEKL/G"_QGC
N)C0?^P5M>*X!+?Z7N]F>K<$Z2;! N;%P=+I!L?C+_:!;B0&4Z-'37XS<')3!PT7!2-!E[P'
/"D]2WRV)#4\Y;L+OP\!X7;ESY;X21\?9K?/ BW5!&>&Z&$"$3+"A.VK%\P19V;/0:QK>^=G
N.&H05#J'#VXS(IK#R+*+\?,EOVUHC8R76Z6H8X+/5#G5.VABIDE!W12NHJ*B]=9TZ-L#5J+
A/IK6W1%+]"$NG[C3A(.$&6Z:#E0"=="#A1H*I6M=*G\2#TJOV3N(YWZ]QN_@\9H*;^MM1N#
U @@\0B,M;;4C.<? YRS[(&,.NUR.Q$H\.8ZE"ZO:BQWRAB4S!"ZVV;WMW3,B6M? FSW1!6)
7;HXY;(*[=Q=* ON<QVA:A(HD6E1FWVJBI>1.NUR.Q$H\.8ZE"ZO:BQWRAB41.;V-OJ8!3M$
B6M? FSW1!6)</[#J3%3[JEP?FDM\+&"9.1^H7#L ;U<,'RA=M)W,-J]G0IV(AW0QS%$>CHB
@\9H*;^MM1N#?4 A^@/6KY5]UJR6#PM'/?S6[D:R?WG_79;N+\8P^4FSA%\O]#<Z7VXPB^WT
QP02.K*3I,3'G7 X<9%Z-A2=:7<U_%=JJCUI:K3]_BNA/G=JWW%=:-KHG:+?RPQQ1-=WFL#+
>NV)ID:.+8AZ3%KY1IFPN"9,X7@W64ML;\CA@\9H*;^MM1N#5WV&]R?@R9M7B6M? FSW1!6)
=O8>[1W+.WYVT"R2<W.<)K'0-\471=609P$W4X"! @L6NQ93(&(,-A=:86@@?@"/C(L=4S]^
HI)^ARM\)DFBYXL916_/4ROGRVBU+#0## C+=]JHOX>?.H)WV<V+5CG$?UK9]'0Y>9( Q"3T
>@8SQ#B?<L1Z@\9H*;^MM1N#]4?G9R_,>R3UB5P)K+JF)Q^)+YP?2N/>YU(O,H'TO2-PGK4R
&GDIS;.7IM8:=E2R,ESCN?YV ;^.%Y(]CMP!J*=4D.W7P>RHT ?741M,SW'0/4JK64RTWE\]
HXJX1QB&$G^C'$&!K!RU[.8<(4/*,H(R6,0A;M!\;N'B =MND;//HHUUCAN1MR^R2*PUIDBW
NDH9MJ"T,VBZ['VAD^NY@8_LN;2&ESO9JVRY+YI-^Y EU*4OTKIE!Y.((]#2MSB;V<5$HZ*W
^%"O18B'!O7X =HDA9-(8R$!F(W.X[<0>5^8 ;^.%Y(]CMP!J*=4D.W7P>RHT ?741M,SW'0
/4JK64RTWE\]HXJX1QB&$G^C"XLTR"C%6QD+2^/^/'"-5%I+VS!8N!3F?53;"V"\1MH*(J4+
 ;^.%Y(]CMP!J5\,^W(Z#-RI)>W]<TXH^YDE(7G_I]$=I" A1PL9MDZG-\-'V:<(.PMDIO_9
=LD&9J3_VJEV<Q3D140B76]S&&Z !CW%/%\8BG_GEKXS_N2*@PHI#43,5>:#NDH9MJ"T,VBZ
G40<1XQPL1"=#E/;D@)+0SH.Z#Q>%6&>,*?H T'E#FY;%40#NDH9MJ"T,VBZ7;-%RF'KZE-=
"5^NM+)6?!4)#JU*5^5VUY,.-L[Z'F)Q?^8VV]EY8[W44]/;?>59?R(F?F)]#U]0O\50.B</
)>V\_!H:F6\E78Y[S-3'2%)=M:O1O@2,&C.U4-F*'+R&Z1A0NDQGA_1?"?NZ4".!22"&"<%0
:.$U;P7#=J1H8#)-&>."HFM@P[@RF@]68E##?>59?R(F?F)]>>K.E-+Q([EYOP9SL-S]J=^_
R <.JY%]O:G( WM2D CTNZH#RQ'P?^>CCW?+]==_16U#"OGU+"QEQK/%+C0L3SIM<:"RB.!/
\3WQE5O)=X3QRQ'P?^>CCW?+)$QS6= !:)8D_)%/ZJI0#=O\OB$UI;@\:'V^,0KFI6T3BLHQ
F\?LQDY=LA:;\@SS)=B5?=CR ;^.%Y(]CMP!YI73+#EZV_KF0L-3N@B;\=U"\79$UM@JI!GQ
#TFTTC'EZQX/,'4,)8 E)?4PO4*[H?50+G.]P(9I4C=IIR_ RQ'P?^>CCW?+]==_16U#"OGU
XZ,))*WJ<0GC@X.1*I#U5C6#8#)-&>."HFM@9"%NCB^#SBMDNDH9MJ"T,VBZ['VAD^NY@8_L
1H;#DY<EG<U&O4*[H?50+G.];.K8S.@>'1QL4-F*'+R&Z1A0NDQGA_1?"?NZJ<K#S*RW.]FI
(\AU1&VY$+$CF7YF4'Y&<U"9$WVDB8?#_TT3OUCHA):<N3._XK$L(8Q:#DKBU;[ABCQ(UY'5
VS?_L]7KF<S;0@+ZZ^B<(QU"#TFTTC'EZQX/M2C)UXX] 9.USFJWBS8^E9C.CB?UBTML9BZ.
U\MT<EGK#D'7CVD6EMTEDO&/=LD&9J3_VJEV&2KC.QK2K<,9G4[G^$.$!96=9V*N&\[>9H]G
E5LKL/G69_^5?>59?R(F?F)]*I3ZD[*;NO0J0>Y@&%7A(HM!0L-3N@B;\=U"DPD(!"8R4I&3
4-F*'+R&Z1A0NDQGA_1?"?NZ@X*?Y@.5=(>#(\AU1&VY$+$C-RIRH\1R8F8W4-F*'+R&Z1A0
S3O=712AV!?-R <.JY%]O:G(:*A^>/#C%<%HRQ'P?^>CCW?+]==_16U#"OGUXZ,))*WJ<0GC
= )-CY34<-9TNI$41/SU+].Z+9]>= .#>T(MSZZ5]*OKJ/7/CVD6EMTEDO&/=LD&9J3_VJEV
=M)W,-J]G0IVZQ:RH?9H/P#K.Q6F^F1UF9P[ F-L7/-!*%<"#*2HAZ+E[O4,7;S\$UTY0*-=
4-F*'+R&Z1A0NDQGA_1?"?NZ],31J/A_A?KT(\AU1&VY$+$CO2Z1D_#DT-.]$=8P 4IS)+ 1
?>59?R(F?F)]*I3ZD[*;NO0J2PJ[JH,17?Q+0O/G];^]9J5"PHNRS."0;,W"!6'";5$-F0 %
 ;^.%Y(]CMP!\S+.%?OZ=>?S<YC^(G9PM&MS[D:R?WG_79;N+\8P^4FSA%\OO2.R4TNA@^*]
FU[T'!7/_3F;#TFTTC'EZQX/4)U-\!SPF2M0B6M? FSW1!6)!+;\EG83KC8$NDH9MJ"T,VBZ
Q'$.R-@<8F'$XZ,))*WJ<0GCW%R&%DM4) ;<>C"WZ"K>6=UZQ,$0G&*2+$O$[1G(/,%%]PWM
B6M? FSW1!6),JSJ( 7_",TR[^08Q=:O>UWORWNC&(5HUF7+4)?X,9N.@"U0O![7\D\Q-Q^\
O@]S*3KBK>Z^CB?UBTML9BZ.=D:U'S":FZEVRQ'P?^>CCW?+CT%&:69';-Z/=M)W,-J]G0IV
)Z1R'9*:[STG#TFTTC'EZQX/5@!TYX*YI.=6B6M? FSW1!6)H:(C%]WOH..A@L_KMTL;+PN"
YV. !V&K[N[G*N"ZN^]E[0 J=M)W,-J]G0IV)Z1R'9*:[STGR]Q2VA?CG+K+R+6/))O ]GK(
T*)O C[WV:S0>$I!.M?&6 1X>EQ*6Q;E.IQZ.G&KWE4YE@<ZO4*[H?50+G.]'(ZEQ=J>;D(<
NDH9MJ"T,VBZ#3&R\L5-Y=@-XZ,))*WJ<0GCW%R&%DM4) ;<4-F*'+R&Z1A0KL ;0+D8*1^N
@\9H*;^MM1N#V\9-L8P3__7;0P5\_F%[WUU#!*O+FDRRK5<$#3&R\L5-Y=@-XZ,))*WJ<0GC
W%R&%DM4) ;<>C"WZ"K>6=UZQ,$0G&*2+$O$@Y/="CPQE]2#B6M? FSW1!6)[YZ&O70H*K_O
O4*[H?50+G.]-FL@8C+.!/LV#TFTTC'EZQX/4)U-\!SPF2M0B6M? FSW1!6)H:(C%]WOH..A
V:<(.PMDIO_9<_WK1<.HNJ=SE"ZO:BQWRAB4H %C*5<+2NZ@>C"WZ"K>6=UZQ,$0G&*2+$O$
[1G(/,%%]PWMB6M? FSW1!6)H:(C%]WOH..A@L_KMTL;+PN"YV. !V&K[N[G0?A>,'?+T!Q!
=M)W,-J]G0IVV^Q'5O> -R;;\_._>_7J,AWSL:980",@(J"QT ,_$'%6N0;0 Q<;0ZRYM!$#
D,I8?!&'6?B0OUCHA):<N3._SAS%<N\X=%3.P[=..8?C3G;#JG1V)F9GA$>JFJEBQ'YR>2*:
I,FB009:,]*DJD.=DQN7,5FJ?>59?R(F?F)]L0P3@.7Z+/.QJG1V)F9GA$>J>R)3^]K?#;)[
&E1Q0"77Q0X:P]Y-KC/S(G+#7S> SU##ZBU?OUCHA):<N3._ZL98W"V!%F_JJG1V)F9GA$>J
!G?9>LY*)7H&Y^AJ=.-C!N[G%O):C"M(BKD6NDH9MJ"T,VBZ2YZ<TY3TEN)+[(]+C" 345'L
Z3JS9K)&&JSIIEV.KVH W5BF?":7B\.\56Q\JG1V)F9GA$>J8HC(*J.0"I=BH%*:76.Y#["@
%#EF?,G&NW$4NDH9MJ"T,VBZE$.ULK#,@%R4\)'$D%DCQ.WPUJR6#PM'/?S6JX9.!-,5^\RK
\_15FJ4/@O7SL@C3TFI&81VR?":7B\.\56Q\JG1V)F9GA$>J8HC(*J.0"I=B8(_Z\5H ^QU@
/[QXD&]S<^\_RQ'P?^>CCW?+5KH@@KY3Z\!6M(TPOW%1A=:T"XLTR"C%6QD+'$&!K!RU[.8<
P$->@16@GQ# KA3:'=8"ZG&NJG1V)F9GA$>J0Z.2?(,-I+=#+T,W+/ C?DDO&$JZ*FGSV"L8
U;'.GK$5F\[5%LMWU8TP;!06MMY0ESZ+>.6V#C86\49V\?0.T ,_$'%6N0;0+L-S L:1TFLN
L%DNLXWE ORPV:<(.PMDIO_9=LD&9J3_VJEV5M2V8L!@'ZU6X9 YTIL\.L_AJG1V)F9GA$>J
#JU*5^5VUY,.M,LV'W(WH-:TRQ'P?^>CCW?+]==_16U#"OGU+"QEQK/%+C0L3SIM<:"RB.!/
JG1V)F9GA$>J*,%.S*Q">!,H#G=R[I 5;% . ;^.%Y(]CMP!IWSEIM!.Q1:GE<;T+W[GL,Z5
] :M&5Z01WKTA7@-/K\6[0:%G0II <G^2JV=JG1V)F9GA$>JUS&U71"0J-374-F*'+R&Z1A0
U=65FJ'K(&/5.-,=;;8NP.XXM(BOHD-9N#"T[,MKT"RDRX3L?51O(-AK%1U](4OT :O]2F A
Z/(&O1*$^7GHW_X_$[?-YN#?F__Z*)I:F56;2C=2*I8$U\9*J0A8^M3EG^2IC;S4.%QW)&*-
T"R2<W.<)K'0QC:PTD^7F,;&A1J]*5):;SN%4C*0*0//0&-2X_5&'GD@,17C]:N>_US?TQ_U
@^>+<(E0WI.#9J&,C]?CN]EF_K!'4&!_F2_^_K!'4&!_F2_^_K!'4&!_F2_^_K!'4&!_F2_^
_K!'4&!_F2_^_K!'4&!_F2_^\H&->Q 7P][R2F<L6G,O*1]*LJ4K+F(-2R&RG'.XA7!Y!OV<
&@LIXLB.9@@:YU @6MS8'1[GZ%H<'A;% #3HRXP0SGAM4-++]13O@'<7F&/UNOG5J>-*#%&Z
'$&!K!RU[.8<3MZG?*7%SOQ.3S'/",U)X>=/F;->PFF:'9J9C"+!YW9[)P6,!N@]:0NUGTT&
>>K.E-+Q([EYPO93=J=Y*OS"R'P!  3VF93(E5H)^&WML=&5?3>A]GU8O8Y]JS871RJBZ;6K
,C PMCBK9(<R@4.3S2VZG+Z!R'P!  3VF93(EYG4X#PB^=B7.G&KWE4YE@<ZY5R.6C<"_ 'E
FVX!"A;RJ\&;&0UOR;>'7%0928H;1T./UWM)B6M? FSW1!6)2O4[<1+/._]*JS871RJBZ;6K
,C PMCBK9(<R@4.3S2VZG+Z!5/KGRV7,TUM4(H(Z$,M^;V@B3M^:LA</3F].(UKB%@9PYI$C
B?ZY8*:/@'Z)R=^UFMMS?T_)$@/!:%?"$O02YV. !V&K[N[G*N"ZN^]E[0 J=M)W,-J]G0IV
Y$7^U!H.PVWDZ.Z,WXSG/7+HQ,$0G&*2+$O$@Y/="CPQE]2#B6M? FSW1!6) NUT895="G\"
Q,$0G&*2+$O$UG_'!OQP;"[6#.W_ #>T8;H,EQ"^B.Q7#^27#1VZ3BX=4P$-S&W?2O^;LVC,
F%>Q;E8S!%68%'IWZYSBS]844D]A!62%N2)2$KB(W>3.7TT2L:980",@(J"Q->-ZGY)!VO8U
Y;L+OP\!X7;ESY;X21\?9K?/2L!?P7@;<$E*(\AU1&VY$+$CPCD.*P@4#?K"4HU2.E8#1\=2
MLV"VG]RCTNVK7:^X[<_N_:M)&.]_X43$M$D:>E\&?HS,%!I[0TL>M](42[MN,L]HVMM13BX
"$>8)H#1-RL(LT(T+(MZ>9>S"U'R>N4<L^L+Q6QSR^9 [UW%WW%=:-KHG:+?RPQQ1-=WFL#+
2I"V^.[T05-*D! (A!M)HD60X%'HK_@3-)_@KNA4&_+B<AJN%HV3< :)%R<6,.,EO'"7<B8P
*$?@@WD_:4PH*AQ>_Z^?N@ JW0Y+[OL^5I[=^-V;,VE8)0OX.KLP;(RHY90Z>!;?MDMBXBUX
=.89^=1">5YT+*#+3:*S'^ L<NO^E:N4AW-RHG;EHV88,2BB:5/G422;B8%IMYBU,_^XCIZW
:DKC3RP.[+UJ.!I1TKGJ0" X9+EMMVO.M<UD[<)%-IAIU@'M.!I1TKGJ0" X;0^;6"$D>4)M
FAMH"8KXX4.:HLAN[DQPL0RB KIERI-Y$(<"!!KX7*6>NBL$-HX(@^Q%QGHV &+7I^;2T04 
BSD76R7C6L.+L>!9=8EL'>ZQKUP;K1!X9,:OH:H<I@I!$>NA&GDIS;.7IM8:)(D9#Z-*!=(D
P 8BY?3/FW7 S8F!8>C-MT_-"LT:O'>9$&0*)UA46!';M]@G#@AQ]]"*\T0.2L]QDF.LEY5*
$NC4JC@0H[02X*OURH_:@T;@*><(SHG):N(IF$4H3VPI'GB8"LT:O'>9$&0*B8_%$6FG>V>)
)&&\BU:5."XD!DJ\H5(*VH &[417U?::-W/ME:!A&FY9[\254%9;XDU;Q:!04%9;XDU;Q:!0
4%9;XDU;Q:!04%9;XDU;Q:!04%9;XDU;Q:!04%9;XDU;Q:!04%9;XDU;Q:!04%9;XDU;Q:!0
$>[M%@VMBF$1N,2)O#^F0ZBX+^?OS<]:LN$OJ0?QKQ\90Y2I[\4[L1XP_F+OV3B_UHZ?#([9
/<<YU*N(-"T]RC0AF5+.=$W*\K\G4AG5OZKR,UP.*0;Y&M8S$[S)(%2L)503>+'4]SV$-D-X
\^_8Q4ZH)IOS9K7JQ;Z^T4%FR)$_/!Y<J)G(FU[XM2*2[>6;;9Z%=%L_\"-M)G]__)<V^:TF
!S<)!(V\];H'[]E0[*_$RIGOVEEHY\\'L=K:;G?150='^-)N2M"O3+VF4!-*?!N 3#SHFRE\
H@?S\_6XYB6BKJB<>LXO_7"N'Y50#_>0NRX?K#\CB*\?M8BLD[;@)Z%'".^3&,N_/C7,$BL8
0#S:BBBR%/Q 3.>RJQU/<Z%,-I,#VCSU7&4VA"Q<-%^S92J$L8.2<(^6BL2QF4]$![I8,HN9
3N@Q7@X'DA-.+L-S L:1TFLNH@F_EJ9V5FBBK_H-!7@2+C:O6%JRA&+')XU8+QFDK1E_7ITO
AWQ,T0W!>4*')&@N\VE("R,D6O()%;PTD'):F9Y?RLQ]79:9':G5GJ>N10 =G G+7[P?P;6<
:5I1CNR,ZREIAWQ,T0W!>4*'&U3SLR5C76H;.%?9IPFJ55$X-VI=XRVP=-0WTR:M?0[&=I;3
XBE/U8C#TW3BEI12]-FQ9BB6S0^D W^O\]O-!!=4KX7K3F,$(P$\?\0X(Y4C#29.K/8MVIL-
%LT4I&=Q4F,6QD_SW)FI>5S&.U=+KH!)Y,T[,SXDB%]K;8,S%D8CS,BNY+H682,P1N.:EFUA
)KR@S82">40FGM:?V#-Q_?F>07BTO]26(BA!J.0A5?)8F.VH3'9&\3^#DFY,%>;MHCGOHL(5
PKLMV/(^Q#S",9)N;4ZF-DLQ1(Y!;A#"I(%$GKZGXBW%ZV*>&,Z4T+4+B1\8$=3)M^GR=+L1
8M6M%Q<3RDUBJ; LP',FX!JI[\8_Y2K);(3O,TQPW_60XDHS:'!.H+S(J4QH;N)IM@0V<U!N
GKZGXBW%ZV*>&,Z4T+4+B1\8$=3)M^GR=+L1X95WH<3_R"SAJ; LP',FX!JI[\8_Y2K);(3O
,TQPW_60XDHS:'!.H+S(J4QH;^0)\ 77>5AO0XS2K.%78W]#7+%?ETOI9\U<ZB?^":GZ;J#J
?.0P&K-:WBA\OK#IW2-LOA^^MYBU,_^XCIZWY,@VG3]UF$#DH%@T#<T"OZR@%@5M(QQ3-' 6
N,L]HVMM13BX)S[7?&)!"I,GKAYITN;<O&:N$,PBC#O02T4038:KL=^*8&Q-119L48*D"N]%
.^4/O('&'Z0[TP<BM8*+7FS3RBVG /(A9NO*/?V:K@;^J8L]* ;J;04, -LH$/"_*%L_,540
86.PYQQ&O?5A\R/F%%5[1)[S; V6)8E))8-L_$'Y'?Q@IH/\JG1V)F9GA$>J"MCJ\TZ&@1 *
06'AJX[5[J1!?&>P&/8CYNU\A76KWDC 6>^%)D@6NO=>P-TFY Q&*XD@-E[DQ>0C[AFJ/LS%
#R%7%)6)4:0/JG1V)F9GA$>JJG1V)F9GA$>JJG1V)F9GA$>JP%5/1OAE.1K >04(R$AL;GUY
MC=-X_*T'D:V>&4L.^HSORIX,QET6COGI DSHZM&*I_UU.2CJG1V)F9GA$>JE'!L\I"'L;N4
YX6%1#O_U4_G'/+_/P\[H!\<.-D67GM)AF XS90U@PM7[KK-@;S*&85TXJ.!$7>*:K&S,+H1
FLS.%Y$&)"R:JG1V)F9GA$>J.6_6$EF<\PHYL)U_T"UR2W:P2^\+'!+'^9!+>4]C=<&@FHMY
JG1V)F9GA$>J7D/BCWQC8PI>O/J8JDBR*36\Q:QT,W/.PD3%JG1V)F9GA$>J^:TCKLP PG'Y
JP0=9""-9).K13TSHL"8<_E%M88RIHO5&O"URKJ\DJJW>WG*!#-DMX&%9R $P[=..8?C3G;#
JG1V)F9GA$>JOG?+IS1N5F&^C7#\?%O;>I^-50@701;8EB%5,%6LNH-GO,XP%@5M(QQ3-' 6
CD2OGPVQFI:.:./\$CH$$)1HL:980",@(J"Q+\;\':Z7MVDO.Y7]=&8*/B [@VNZJO)RN9F#
>EQW.)XU *QZ;MNA^^%UB2!NW95* T37JV/=Q_W-Y8*FKCG'K:I1A;7N%9*M#M^U#4M\M(P.
,(*M9ZU0H2(P[+!H_WFYQ0OL5P-$>X2]_*-7,.L)(&$75%LP>D#3\KHKJ^UZ4<^RQ7W'QX)1
#P&)IC,IH(,/&3#%WOX'"-P9?T>X%4)92[U_(+G :(4?7CD@=IXX !HLDS9V,A$I]Y3UHTXR
%I2F(3?\,*T6?+"#TM\P2KQ\MYBU,_^XCIZWG_<L[QA4:I2?%2B&ZDF'>245!()J,NV,A^0$
O_BR>[/BSV:_01S<O6H#]/9!ND9IN M0#:"Z:V^6"3?Q5.-K01S<O6H#]/9!234+?F!B[GA)
-)3N11I/@[ T??(V/&+=6'U];<+)?-2B*A=M>UWY>^<YBNQ[))6P'3GAEHDD? T)%R?BJ2-\
QVK#2@X'IN?'OHP0L:WKTJ6^:WPD1DF;R#EK9>0A](J)R -E.CZ2)Q^0N;,ZTZ9 EK]C,873
M:O1O@2,&C.U$X!%=V9*V/H3QN?YE52W*/7&_ K[%2V+)AG\[07W?8#MMT#M WM2D CTNZH#
4NW1N04BT3A2#U5OFV- -QL/;9Z%=%L_\"-M#WR5>>P=GAL/6[=_,EZ_W%%;WXH_Z;;@B#O?
#PAZS#5%S%P/YFDT37_3!?3FK?" PW?*A*^M'B-96L,G-K4>FVN^@W_ $=N;(M6@"<B*XD4B
(<Z:+%F(4!XAK1QW8B+&-=&MZC(H;?(=8S;JW=>$<C4U!6W=GG(:T?LKFS.>#7T!CEFL)84-
5"NO +T!P6U4@\2:DO8FDN&#G03ON"E0%RJ=2G_N+AV%N&E*(2^%FLK--CXA01S<O6H#]/9!
23L+5#!6/,])"MHX7)5^--<*3>+6)$I2A[E-$\1)VFA ?Z@30.AP1A9F4:5 $"I%G\6IQV<0
FI!*>-WV_YV:Y!>W!+;+OU7D&10YD[R5RW<9HM_3%>Q _ZNBQ2=* 2P&ZKK%VLJ B.2R ,?:
\1U9G69HITSQ>PK$9N%3/8M[&AI!2HE=*1<:NL#^Z5/8<(.Z:H()5*^<:-5JHPFLQ&IX %.C
$D@QR3LQB&@2!!=4KX7K3F,$(P$\?\0X(Y4C/&7(!Q>I.-@\YZ[KXK;?I6+G<+C[C"L_PC1P
&,Z4T+4+B1\8JFOM/RHV0S2J3F!?\&FDO01.Z''D>(5!,(CH!!=4KX7K3F,$(P$\?\0X(Y4C
2D./P>6-)"%*YZ[KXK;?I6+G<+C[C"L_PC1P&,Z4T+4+B1\8JFOM/RHV0S2J#:%,HO6J!($-
/(\?9_P='6,\O1- A0@5!Q>]\675V:^K"U'Q# D0=CN.P](,H9VRX*/3T)"AGQVHR^EQOCR?
%2B&ZDF'>2450)4A,8GTA\9 #C418K3C@6@.AM,F8:\;#D:&J7"=/6\"U'RINK0H(UOS:M&Z
<?8]_))L_5MQ%HL4O,RFTHL68Z$(&D\*1.AC [LM.[QEG6\#>?R2U"%G%RQY< EH02P1IQMP
^7I+EQOJ7X[YQ?/<U<TTK3[%C0")I:I.M1B-@NC/^!BG'ZB"[(0X16[8*T[LQD_SW)FI>5S&
P$#B#+/ESGW @NC/^!BG'ZB"9PFE<6E'/:)G"+G*0+T7V5T(9*]T"%)])N5DFU+X4C455F>;
L[Y,>OAEC^&S?Q@H7Y\07?M_^L&U8]YQN=#Z %Z1;NUQT2L S-4/,#./ 4W,JG1V)F9GA$>J
JG1V)F9GA$>JJG1V)F9GA$>J.A?^V^?E/,PZA@TL&A$[0'^&+E J&Y>\I*0NRE[HJ7!.YY_*
D-I9!<H.<5R0L:980",@(J"QR<,:5_>)&7S)JG1V)F9GA$>J^#TQ,/+]T'/XBC;2YK8&?S**
"0] @ZOYD"T)!*)F1(K8&YT$,7>>EW&R<%$QF9XTQ#RE$MB9$547[C"YMKT1JG1V)F9GA$>J
R\JF>:R9<^'+!0&I*&F.VS8%+%TJ?\/E&;TLJG1V)F9GA$>J$:%VO.Y]E;$1M.[)3T8>Q@BT
;JN/HDQK$V]NJG1V)F9GA$>JJG1V)F9GA$>JBHV2F^9>II^*P ^41=)+V?7 /LQN@6I+0^P^
>?_!!Q#/H4=Y;2*+3L_H.4-M8:)N*M%C[_-AJG1V)F9GA$>J#^-$U=..SPD/4RMA Q>:,(13
69'$$GXW-4=9B;N.%7,,+JF)SQ45,TY-L'?/^&L#_CT9="_XJG1V)F9GA$>J;_ZEO9DMUE=O
<(S4H9P\7;!P3"X>YH)S%\9,^_7J1"A&_)O[78<AAZ[[/RA=44GTP(=('D=1E+LVO;-:NT64
+#^LRB[JKJPLA5R2[,/CB(B%)!QE>D; 380D@/VGNU@C@": ;<+)?-2B*A=M58TSO>3%+-A5
EWXCDU0>?D"7[S\FFCU/\!7O*JB]UA W.CTJ^ <+4^+\57OX=IXX !HLDS9V%Z&[[ 9O0]\7
<P?D,SG5K0-SW"E6%6/#X=_<9L.TTTQ/[_AF]N&6FE#8M%?VJ\4_H7^<H,VKW"'%7M7>($'<
ACX0?,E7,O^&J7"=/6\"U'RIHHV.\W-:Q8VBW^C#UX&S$E3?MYBU,_^XCIZWB)?3_9H&:1.(
!D<P\4+Q2*8&MYBU,_^XCIZW1^?_]_UNIJI'/&V"_O<_GK8\TD92E7$K);_2*1#__E/XJY\I
= +JW;<.\#=T(#@I+U=&RGT@JH4XO=W]1XVJ^99F,C6/(G/YR:E)'IU%SYW)01T"XW]X1UA!
VE4!HANJIJ_:*UV8U8/J?M\K4%9;XDU;Q:!04%9;XDU;Q:!04%9;XDU;Q:!04%9;XDU;Q:!0
4%9;XDU;Q:!04%9;XDU;Q:!04%9;XDU;Q:!0LXB$D?>^WPFSI*^G0W@_LS2D5I 1X8%9IX56
6BOU;+AS#N=:M2WG@.">M0RUIW@/<O+T3SRG#:-@F(ZSB=4-#IP/WC*HW>X.2F<L6G,O*1]*
LJ4K+F(-2R&R7R7"GQ+WM]A?1G0 A/61- -&(?X+J"0L&V$A&@LIXLB.9@@:YR-UA_)/$SWG
'COE?X^J>Z\>4FZQ.Y<"(9=2;LZTE[[$"ZMN,3ZG J3MW>@Q 0/),=P/O=P!'Z1]1XQY/S,?
D6E1FWVJBI>1.NUR.Q$H\.8ZE"ZO:BQWRAB4S!"ZVV;WMW3,B6M? FSW1!6):>%IC6DC-6-I
?FDM\+&"9.1^H7#L ;U<,'RA=M)W,-J]G0IV6WUG<GTV>8U;#B7>95H>7B(._/.7,.C#HZ7\
YB(20M$S:SGFT+L?Q;[KT)C0H7#L ;U<,'RA=M)W,-J]G0IV\-8%27%C553P-^G@F$W&.@DW
[>K)PK9FA?KM]X;;BGMJ^:WWVO80,(THBH;:77S.(Q89@YU=?Q%=F''HFG-_B6M? FSW1!6)
VX_R+WE?YX;;BUG5[1N"(G^+S&&\1R LT=?,E,<%$+!J=)>4\$/E[K8>4!#P5XG<XFUN )%7
0MFTNP:TLSE"]S#&DOD-G)[W^!W*'5_D,(GX](\8[6U'WDWTOQZ#* ',=4&_3:A7N.=@%LI-
ZKW:M%R@II7JNOG5J>-*#%&ZE"ZO:BQWRAB4^<M> K&TKUKY=M)W,-J]G0IVN>,KH90[#AZY
YB(20M$S:SGFMG:3+\$H2)ZVAL4-6%1^9%"&"=A6V\A9/L@)'RZ=9KRLPEP?);QC((VK$S$E
AU;:[: 0CA&'*'^JPP?)2FLHA!^;Q@X&0I:$3%KY1IFPN"9,X7@W64ML;\CA@\9H*;^MM1N#
6$$E,6HP_XI8B6M? FSW1!6)"?(JU_&D^%,)V![QJX^I]ZW8FRK)F ^6CLV;*A[ZCWK,+U<J
2L]QDF.LEY5*4-F*'+R&Z1A0NDQGA_1?"?NZ '>S:DK&US@ .-,=;;8NP.XXM(BOHD-9N#"T
[,MKT"RDRX3LL5,_N:#9*]>Q""!K41YDQ!$(2&.OPLH<'<-("*T*%;M6GL\(M2&XX:^VQ/JU
OUCHA):<N3._2E^(^#,B9AY*L*=QJ'A"ZZZPCQW'AB$Y9FF/,SW3M>E\Z#,S@Z_1J'A'.6V#
%3%3 ^R!;%D58%(9GCF22,U@4-F*'+R&Z1A0NDQGA_1?"?NZ '>S:DK&US@ .-,=;;8NP.XX
M(BOHD-9N#"T[,MKT"RDRX3LR=^UFMMS?T_)J,BU@X2'9 6HB.VQ\3H8*I.(4-F*'+R&Z1A0
NDQGA_1?"?NZQS=YP;0N7_W'(\AU1&VY$+$C-\WQ/+%"E;HW;,=ZET]P3GILRQ'P?^>CCW?+
9]O]8>K-;>MGG-S4*I4QV_R<R <.JY%]O:G(_ =.J(G7+JG\PNPJ"X#O;KC"OUCHA):<N3._
_:5GZ&*9P^']EE@]=PF%VCB6(H7^HA]#N XB?DH43WZ]U2-^OUCHA):<N3._7U-1'UL(<3U?
YCY[,;A:*R?F*,%.S*Q">!,H>^O.NQ/-$ I[CH\&\OL8&8>. ;^.%Y(]CMP!'YO1$0K9:30?
TE^EG6\$*JO272#+^RVC&#A=AN%$4*!8M*B&#TFTTC'EZQX/1D4,27E*A[!&"3BJ3 7@7KH)
(\AU1&VY$+$C8R[!(Y!*+;UC:"@>GF3LH#QH ;^.%Y(]CMP!@\9H*;^MM1N#Q_LVK+-9=2W'
,0KFI6T3BLHQ6I>BA??-&DY:NDH9MJ"T,VBZ4)?X,9N.@"U0 +[#B%EM&Y( R <.JY%]O:G(
 L'3J%B+4#\"NDH9MJ"T,VBZG9*Z<NN$4P*=C]LG^5R&);"/EUV(X#)^VMZ7Y7HC9N#R07CE
DPD(!"8R4I&34-F*'+R&Z1A09'[F*YY!['9D/55IVRZK5Q$]8#)-&>."HFM@84$KW.L(\M%A
?>59?R(F?F)]L0P3@.7Z+/.QVS?_L]7KF<S;01.;R"^VG$!!NDH9MJ"T,VBZ4)?X,9N.@"U0
O![7\D\Q-Q^\(\AU1&VY$+$CF7YF4'Y&<U"9,4'*XU</L\0QOUCHA):<N3._XK$L(8Q:#DKB
D1R*9;7Q]0V1VS?_L]7KF<S;5J!E/.M-6R56#TFTTC'EZQX/M2C)UXX] 9.U&]C)AMX(VD<;
CB?UBTML9BZ.'#GR"*HX>XT<CVD6EMTEDO&/=LD&9J3_VJEV&2KC.QK2K<,9G-7)[6)/\WZ<
9V*N&\[>9H]G9"ON<T5XTVID?>59?R(F?F)]*I3ZD[*;NO0JX>.6*=*#ZJ/A0L-3N@B;\=U"
$W7JWM4I1M 3RQ'P?^>CCW?+]==_16U#"OGU!_$ Z;/[ D\'R <.JY%]O:G(1JL*I9=]V*!&
AJ8 C]P['(*& ;^.%Y(]CMP!1+YH\.\L\LE$GUQV\H6UNCJ?8#)-&>."HFM@D-<FG^H7Y?V0
#TFTTC'EZQX/M2C)UXX] 9.U?2K>B_Z23>U]CB?UBTML9BZ.GMVG%5^JKMV>#TFTTC'EZQX/
,'4,)8 E)?4PO4*[H?50+G.]+'F_-RY4\U LNDH9MJ"T,VBZ4)?X,9N.@"U0O![7\D\Q-Q^\
)^+X8B3;1@,G##' E93'N? ,)2N*_RD7R,LE]6X!SF^,8<3URQ'P?^>CCW?+]==_16U#"OGU
XZ,))*WJ<0GC= )-CY34<-9TNI$41/SU+].Z+9]>= .#>T(MBK9Y;#5]YL:*2HWK08__E_I*
#TFTTC'EZQX/M2C)UXX] 9.UOBGUS!ZOS6V^CB?UBTML9BZ.5:A<CC43V.!5!6'";5$-F0 %
 ;^.%Y(]CMP!1+YH\.\L\LE$TKF"P&9R"B_2*?^AZ^08#7<I:N?AG#GQS05J4-F*'+R&Z1A0
NDQGA_1?"?NZ],31J/A_A?KTHD SS\DJ]6NBS&&\1R LT=?,E,<%$+!J=)>40L-3N@B;\=U"
 =\'*\BM+VD!JN+8.ZLZ^SFJ>,:?ICF+J29X>$I!.M?&6 1XR,49[=E6_+K(3Q>DY&^@;#U/
4)?X,9N.@"U0O![7\D\Q-Q^\@O@-CZ/O Q:"R]Q2VA?CG+K+R+6/))O ]GK(>,:?ICF+J29X
>$I!.M?&6 1X7]<V"_UHKWA?3G=O3(@%-.A.@M>^4M5^"8V"E"ZO:BQWRAB4H %C*5<+2NZ@
+0GX/W(W(RXM0L-3N@B;\=U"D\:_#VMT:MV3NDH9MJ"T,VBZ#3&R\L5-Y=@-XZ,))*WJ<0GC
?&$?=7*G->9\JN+8.ZLZ^SFJT*)O C[WV:S0>$I!.M?&6 1X_<MA6.$.56/]0P5\_F%[WUU#
!*O+FDRRK5<$#3&R\L5-Y=@-XZ,))*WJ<0GC9J_&>'H_VF1F7L\T61J+;G5>91XR3$H)K:EE
>>K.E-+Q([EY@8Y5S\FJE)"!2>?'BA6T6'-)* ON<QVA:A(HVS?_L]7KF<S;(AAUW^@1@.HB
CZF_5NA"1>2/4)?X,9N.@"U0O![7\D\Q-Q^\@O@-CZ/O Q:"#TFTTC'EZQX/5@!TYX*YI.=6
B6M? FSW1!6),JSJ( 7_",TR[^08Q=:O>UWOW'&KOT$C6FW<4)?X,9N.@"U0O![7\D\Q-Q^\
@O@-CZ/O Q:"R]Q2VA?CG+K+R+6/))O ]GK(T*)O C[WV:S0>$I!.M?&6 1XY)_@(2GFF'/D
VS?_L]7KF<S;QF$7&9*QNK?&JN+8.ZLZ^SFJ>,:?ICF+J29X>$I!.M?&6 1X_<MA6.$.56/]
RQ'P?^>CCW?+:&*W,?[BQG%H=M)W,-J]G0IV)Z1R'9*:[STGR]Q2VA?CG+K+R+6/))O ]GK(
>,:?ICF+J29X>$I!.M?&6 1X_<MA6.$.56/]0P5\_F%[WUU#!*O+FDRRK5<$Q'$.R-@<8F'$
XZ,))*WJ<0GC57H!B<21/=I5B5P)K+JF)Q^)JG1V)F9GA$>JZ1YB:VFE0UGI?T-5%'TN5MM_
V:<(.PMDIO_9 "33O4R]\(  %WDOWKR".CL7JG1V)F9GA$>J?34[D-9'2W%]WL+JND+9LLS>
XA1B ;G2F,KB7%YL$P%T2?I< ;^.%Y(]CMP!\Z7J%)9@3";SJG1V)F9GA$>JJ0H)C9'V@%^I
K5Y8V6*9B#"MT!@6X?[ 7,/03EAVLS]0]GQ. "33O4R]\(  HO'K[3%:HOJBJG1V)F9GA$>J
MN#O/>H[&AFV\(G"NR27IJKP7S> SU##ZBU?OUCHA):<N3.__B?$P<@ZJTW^JX9.!-,5^\RK
NW_T*M3?D+V[0!M61A@5;2) 3S8QC1MW ,Q/JG1V)F9GA$>J>I9*W..3X -Z">ZY1KU+.PL)
S>$WMI5.#93-OUCHA):<N3._PP^!VNU/YY3#,G9;!0Y6V\DRBUG5[1N"(G^+S=R=M:(P^/7-
&["5;8,6?+@;9]44A?24O(%G3S8QC1MW ,Q/JG1V)F9GA$>J>I9*W..3X -ZQ#-P5>R&W@;$
\!9X[@SRIKCPNDH9MJ"T,VBZE$.ULK#,@%R4\)'$D%DCQ.WP:4Y/,/QM5?=I?QXDY2_7])M_
852X^--@@\-A+D2>W.#Y5P<NJG1V)F9GA$>J8HC(*J.0"I=B%(D!,.PXSE@4RQ'P?^>CCW?+
5KH@@KY3Z\!6M(TPOW%1A=:T"XLTR"C%6QD+JG1V)F9GA$>JJU@C1:D.B#>KF4]$![I8,HN9
3N@Q7@X'DA-.RQ'P?^>CCW?+]==_16U#"OGU+"QEQK/%+C0L3SIM<:"RB.!/JG1V)F9GA$>J
*,%.S*Q">!,H'].XX5X/;.L?NDH9MJ"T,VBZ4)?X,9N.@"U0 +[#B%EM&Y( R?%APN N\U/)
JG1V)F9GA$>J@D6Z"E#%7;""4-F*'+R&Z1A0NDQGA_1?"?NZ6C2Q%LJ 6/9:ZK=6M@Q+=H3J
JG1V)F9GA$>J*,%.S*Q">!,H)&^J-N)IE8,DRQ'P?^>CCW?+]==_16U#"OGU+"QEQK/%+C0L
3SIM<:"RB.!/JG1V)F9GA$>J8#)-&>."HFM@*EK2!SB3V(,JRCFU;U5.B^'*NDH9MJ"T,VBZ
8^C55OC@'MAC+YI-^Y EU*4OTKIE!Y.((]#2(\AU1&VY$+$CX;.O85O@,BWA,5=C#H]=TX8Q
5^[W(D_6BP=7!=YZW;\PSM %G98*T&>*TQZ=8A9XC"9O.3AB>EQLG"4E@J1Z(L PNB=L4I<B
V "2-R.UD+#8"XLTR"C%6QD+JMT9D"\Q+0NJ$F]2R0P,^WH2K1X=<N%'"@2M!&HS#2G2Z38$
9QJ^LVZG[G-G_K!'4&!_F2_^_K!'4&!_F2_^_K!'4&!_F2_^_K!'4&!_F2_^_K!'4&!_F2_^
_K!'4&!_F2_^^'^#3PJ07W_X03 86)$%R\%!03 86)$%R\%!03 86)$%R\%!03 86)$%R\%!
03 86)$%R\%!03 86)$%R\%!03 86)$%R\%!03 86)$%R\%!KCN"JCW'*D"N*B>4Z\U8;N,J
X0W/*H3L4)CA:AYF%#1LWQMJ!5/W/H*#\8,%J]IR*+50B=*KSB.[F.])::;.3M^VBIX//==.
DI3L>--#MP^2ZP>Q$0I OP'K>[K6JF%"R"E[ 0/),=P/O=P!'Z1]1XQY/S,?^QUDZ(J6S'K[
&XLNM<(]S'T;P5PZV4)A]L+!RI YE90MSRO*(UKB%@9PYI$CDVW=1!P-N"&3"!N17767-ET(
<\NT+%U2ZPQS'Y@(Q%^I(0T?[5]GP]K<C9CMX38R$8D7H6'A)/2&M1,K P<D"!N17767-ET(
YP7HXRVGL #GV\U*EYK]%&/;D^CG2Q-F%663JTX\-4F.W86K72]QT*_+"(%=@\9H*;^MM1N#
7IP55^;H+;)>'Y@(Q%^I(0T?[5]GP]K<C9CMX38R$8D7H6'AM&'B,B%Q@YFT"!N17767-ET(
:J-%'YO8UKIJB6M? FSW1!6)K6Q4WQPNR[:M"XLTR"C%6QD+B2\;P8IQEF2)DGGF/FW1:^:2
ZK)UF17JI KJE"ZO:BQWRAB4Y%,<1S)K=,ODLDY["/K7%/2RAL=3?Q (97"&;!C4I7W&6F%L
@\9H*;^MM1N#8<#L^IK^BB9A:55V,8EVJA)I$"N%#^?:ZYT04UIL)RN_/7)3Y&Q1(UTE9<'D
=CH=#?N0 REV#\-WPEMJKB0/4%9;XDU;Q:!04%9;XDU;Q:!04%9;XDU;Q:!04%9;XDU;Q:!0
4%9;XDU;Q:!04%9;XDU;Q:!04%9;XDU;Q:!04%9;XDU;Q:!0& "(2!G*,Z 83T%.TF6:ZC=/
/;U#&:/PB&\]AX[R]E3D@Z*'JW:OU4'H E2KK.D6DGX$Q3&L=]S1F9K[Y;!W@NC/^!BG'ZB"
%*=ND5+@M $4):JZJ_V0<#4E0M9,..EQ;W!"NTM9E>I,7LR[V71<!Z'PVW#90!,-B*$U=(9 
$&T*[ZI'1[H0!\@%C5G4M8H'EP!GN[E\'!"7KWD4^Q''#Q*O3@2*#1PPW^1.L:980",@(J"Q
]+=3FY&@G33T_.;J)\3B<9;\(4OT :O]2F AFHY-*CZ))_6:!,U.-M+WE/X$$D3-CYT^F-D2
F#@27?,R8C^8,UP.*0;Y&M8SS"0UEAU)'G_,$Z@6C"[[$G\31&&P-Q,S= !$EQ/,%N%8(>"7
5_[-K@E]J+57O[E4;1#0'J:_J>Z."8OV8FNIX-AJ$*QAB97@M>EF<U;-:42U6L_%1>WZVE9:
)&^J-N)IE8,DK?" PW?*A*^M5-RC%@(Y;4Y4CM!B,R';XBR.X_A"D? -\F[C+@SYHY6A]=\N
^INJS9'-B/_ZKMK!"2FQ);&N
#pragma PXL encrypted end
#pragma PXL encrypted begin
K(R$8;J$ZD&LITKK=OLLU]>G?CP0TZ'!NK-^^B;"!^$ 7&+ZF<!0%])8-,>9*9NI*"O37'HI
X]M<OB4:M/+CZXN$[KNPW"CK
#pragma PXL encrypted end







#endif

#ifdef FILL_DM11

#pragma PXL encrypted begin
$EOD7B@*+7$2U9=!H;AN%K75_8UEMVA9CI3]?THG>#Q5)_%_N@*"*R@^R$JZ/FO5@YV:$< ^
(C?'1KK.^0,BCC-&C611@D>.F05M2LZ6]2^96$07"L!DLS=8
#pragma PXL encrypted end


LAYER_DM11_MYBCELL_H : polygon_layer_s = {
    layer_spec = {
        output_layer_key = "OUTPUT_DM11_DMB_CONNECT"
    },
    polygons = MYBCELL_H
};

LAYER_DM11_MYBCELL_V : polygon_layer_s = {
    layer_spec = {
        output_layer_key = "OUTPUT_DM11_DMB_CONNECT"
    },
    polygons = MYBCELL_V
};

LAYER_DM11_MYBCELL_HEXT : polygon_layer_s = {
    layer_spec = {
        output_layer_key = "OUTPUT_DM11_DMB_CONNECT"
    },
    polygons = MYBCELL_HEXT
};

LAYER_DM11_MYBCELL_VEXT : polygon_layer_s = {
    layer_spec = {
        output_layer_key = "OUTPUT_DM11_DMB_CONNECT"
    },
    polygons = MYBCELL_VEXT 
};

// DUMMY SPEC : DM11_DMB_Connect
SPEC_DM11_DMB_CONNECT = unified_fill(
    fill_patterns = {
    {
        type = UF_POLYGON,
        polygon_fill = {
            insertion = {
                iterations = 3,
                shift_factor = 2,    
            },
            pattern_spec = {
#ifdef VERTICAL_M11
                space_x = DMY1B_SX,
                space_y = DMY1B_SY,
                stagger_x = DMY1B_OX,
                stagger_y = DMY1B_OY,
#else
                space_x = DMY1B_SY,
                space_y = DMY1B_SX,
                stagger_x = DMY1B_OY,
                stagger_y = DMY1B_OX,
#endif
            },
            layers = {
#ifdef VERTICAL_M11
                LAYER_DM11_MYBCELL_V
#else
                LAYER_DM11_MYBCELL_H
#endif
            },
#ifdef CONTROL_MAX_METAL_LENGTH
#else
            merging_layers = {
#ifdef VERTICAL_M11
                LAYER_DM11_MYBCELL_VEXT
#else
                LAYER_DM11_MYBCELL_HEXT
#endif
            },
#endif
#ifdef ANTPrevention                
#ifndef CONTROL_MAX_METAL_LENGTH
            merging_blockage_layer_list = {
                FORBIDDEN_RING
            },
#endif
#endif
#ifdef CONTROL_MAX_METAL_LENGTH
#else
#ifdef VERTICAL_M11     
            merging_direction = VERTICAL,
#else
            merging_direction = HORIZONTAL,
#endif   
            merging_length_limit = 500*(DMY1OR_L + DMY1B_SY) - DMY1B_SY, 
#endif
            fill_to_signal_spacing = {
    { CHIP_snps, min_space = DMY1B_CHIP, context = INTERIOR },
#ifdef FULL_CHIP
    { CHIP_BOUNDARY, min_space = DMY1B_CHIP, context = INTERIOR },
#else
    { PRBOUNDARY, min_space = DMY1B_CHIP, context = INTERIOR },
#endif
    { ICOVL_SINGLE, min_space = DMY1_ICOVL },
    { INDDMY, min_space = DM_INDDMY },
    { TCDDMY_M11, min_space = DM_TCDDMY_MX },

	{ BEOLBLK_FINAL, min_space = DMY1B_MY1 },
    { DM11EXCL_FINAL, min_space = DMY1B_MY1 },
    { CSR66_3485, min_space = DMY1B_MY1 },
    { M11_MAIN, min_space = DMY1B_MY1 },
    { DM11_O, min_space = 0.26 },
    { DM11, min_space = 0.26 },
    { DM11_GT1350, min_space = 0.45 },
    { M11_GT76, min_space = DMY1_MY1W1 },
    { M11_GT114, min_space = DMY1_MY1W2 },
    { M11_GT152, min_space = DMY1_MY1W3 },
    { M11_GT180, min_space = DMY1_MY1W4 },
    { M11_GT240, min_space = DMY1_MY1W5 },
    { M11_GT280, min_space = DMY1_MY1W6 },
    { M11_GT500, min_space = DMY1_MY1W7 },
    { M11_GT1350, min_space = DMY1_MY1W8 },
#ifdef FILL_M10_VIA10_M11_BTCD
              { BTCD_M10_V10_M11_E, min_space = BTCD_D },
#endif
#ifdef FILL_M11_VIA11_M12_BTCD
              { BTCD_M11_V11_M12_E, min_space = BTCD_D },
#endif

#ifdef FILL_M11_BTCD2
              { BTCD_M11_E, min_space = BTCD_D },
#endif
              { WRAPPER_DM11_O_L, min_space = DMY1B_DMY1O },
#pragma PXL encrypted begin
I#:O?(DFX%>DT*ND6ON"B5/0>:>+\5CP/K=Y7+RKOWD*OYA<?F[F)EUN*4-^'<W+X _V_]T=
EL&U9N^C\Y26(8F1*)6M5LTAK9<P;1*(3PJM8,BZ@%@V#GI@[/ _<%F547/LR!C?JDG'0T?(
#]FT?W37$BH/]T<"^?#&]-7W_JC$PMHM/?C^?4MCR+W 7;1]"M>ET+&2]O8*[NV2].P)\H3N
RVC"3HN;-9[+<"EA _#H&R9PC'';03 //A6,&+-"0%;3/1,8
#pragma PXL encrypted end

                            
            },
            hierarchical_fill = false,
#ifdef VERTICAL_M11     
            cell_prefix = "DMB11VNEW"
#else
            cell_prefix = "DMB11HNEW"
#endif   
        }
    }
    },
    extents_output = {
        {
            output_layer_key = "OUTPUT_DM11_DMB_CONNECT_EXTENT"
        },
    },
    fill_boundary = {
        layer = CHIP_snps, 
        type = LAYER 
    },
	grid = vGRID
);
//=======================================================
DM11NEW_C     = SPEC_DM11_DMB_CONNECT["OUTPUT_DM11_DMB_CONNECT"][0];
DM11NEW_L     = SPEC_DM11_DMB_CONNECT["OUTPUT_DM11_DMB_CONNECT"][0];
//***** spec *******************************************************************
#pragma PXL encrypted begin
8O@E1#CE,F=BQ0V';(5@873%UKP)+8%95B;6.1=Z_$VX<SDYW4VGUB_,6Q/=V;L_40>EFG+9
MD3JM'.AV%*VP>VC/^+H#,_!
#pragma PXL encrypted end

//***DM11_DMB***
// DUMMY SPEC : DM11_y1
PATTERN_SPEC_DM11_0 = get_single_polygon_pattern(
#ifdef VERTICAL_M11
	"DMB11V", "OUTPUT_DM11", DMY1B_W, DMY1B_L,
	step_x = DMY1B_SX, step_y = DMY1B_SY,
	offset_x = DMY1B_OX, offset_y = DMY1B_OY,
#else
	"DMB11H", "OUTPUT_DM11", DMY1B_L, DMY1B_W,
	step_x = DMY1B_SY, step_y = DMY1B_SX,
	offset_x = DMY1B_OY, offset_y = DMY1B_OX,
#endif
    FSS = {
    { CHIP_snps, min_space = DMY1B_CHIP, context = INTERIOR },
#ifdef FULL_CHIP
    { CHIP_BOUNDARY, min_space = DMY1B_CHIP, context = INTERIOR },
#else
    { PRBOUNDARY, min_space = DMY1B_CHIP, context = INTERIOR },
#endif
    { ICOVL_SINGLE, min_space = DMY1_ICOVL },
    { INDDMY, min_space = DM_INDDMY },
    { TCDDMY_M11, min_space = DM_TCDDMY_MX },

	{ BEOLBLK_FINAL, min_space = DMY1B_MY1 },
    { DM11EXCL_FINAL, min_space = DMY1B_MY1 },
    { CSR66_3485, min_space = DMY1B_MY1 },
    { M11_MAIN, min_space = DMY1B_MY1 },
    { DM11_O, min_space = 0.26 },
    { DM11, min_space = 0.26 },
    { DM11_GT1350, min_space = 0.45 },
    { M11_GT76, min_space = DMY1_MY1W1 },
    { M11_GT114, min_space = DMY1_MY1W2 },
    { M11_GT152, min_space = DMY1_MY1W3 },
    { M11_GT180, min_space = DMY1_MY1W4 },
    { M11_GT240, min_space = DMY1_MY1W5 },
    { M11_GT280, min_space = DMY1_MY1W6 },
    { M11_GT500, min_space = DMY1_MY1W7 },
    { M11_GT1350, min_space = DMY1_MY1W8 },
#ifdef FILL_M10_VIA10_M11_BTCD
              { BTCD_M10_V10_M11_E, min_space = BTCD_DY1 },
#endif
#ifdef FILL_M11_VIA11_M12_BTCD
              { BTCD_M11_V11_M12_E, min_space = BTCD_DY1 },
#endif

#ifdef FILL_M11_BTCD2
              { BTCD_M11_E, min_space = BTCD_DY1 },
#endif
              { WRAPPER_DM11_O_L, min_space = DMY1B_DMY1O },
#pragma PXL encrypted begin
'[J<"^BCA78?QER366(VEX#&7^Y3C_@YJU=?P"R$!P0SJBW =7"<IN1W 6QUCT;/Z0+<CBJ/
,;;!SMUN.I(QA-P.=$$LZ#R$5Y=]W!!"7UI7*?<N@7B0V+TI
#pragma PXL encrypted end

              { DM11NEW_L, min_space = DMY1B_DMY1 },
#pragma PXL encrypted begin
T>Y(#;+_1U31TQL;!L8^3[S3!P<6LZK'[<('03_(0A5#HY5!YJ-5IX?VB.OF-OD,A(I/#H V
B"P[:!F^S@&(EGE!A\R)4V"6
#pragma PXL encrypted end

    },
	shift = 2,
	repeat = 3,
    starting_point = CENTER
); //end of get_single_polygon_pattern


//-------------------------------------------------------------------------------

//***DM11_DMS***
PATTERN_SPEC_DM11_1 = get_single_polygon_pattern(
#ifdef VERTICAL_M11
	"DMS11V", "OUTPUT_DM11", DMY1S_W, DMY1S_L,
	step_x = DMY1S_SX, step_y = DMY1S_SY,
	offset_x = DMY1S_OX, offset_y = DMY1S_OY,
#else
	"DMS11H", "OUTPUT_DM11", DMY1S_L, DMY1S_W,
	step_x = DMY1S_SY, step_y = DMY1S_SX,
	offset_x = DMY1S_OY, offset_y = DMY1S_OX,
#endif
    FSS = {
    { CHIP_snps, min_space = DMY1S_CHIP, context = INTERIOR },
#ifdef FULL_CHIP
    { CHIP_BOUNDARY, min_space = DMY1S_CHIP, context = INTERIOR },
#else
    { PRBOUNDARY, min_space = DMY1S_CHIP, context = INTERIOR },
#endif
    { ICOVL_SINGLE, min_space = DMY1_ICOVL },
    { INDDMY, min_space = DM_INDDMY },
    { TCDDMY_M11, min_space = DM_TCDDMY_MX },

	{ BEOLBLK_FINAL, min_space = DMY1S_MY1 },
    { DM11EXCL_FINAL, min_space = DMY1S_MY1 },
    { CSR66_3485, min_space = DMY1S_MY1 },
    { M11_MAIN, min_space = DMY1S_MY1 },
    { DM11_O, min_space = 0.26 },
    { DM11, min_space = 0.26 },
    { DM11_GT1350, min_space = 0.45 },
    { M11_GT76, min_space = DMY1_MY1W1 },
    { M11_GT114, min_space = DMY1_MY1W2 },
    { M11_GT152, min_space = DMY1_MY1W3 },
    { M11_GT180, min_space = DMY1_MY1W4 },
    { M11_GT240, min_space = DMY1_MY1W5 },
    { M11_GT280, min_space = DMY1_MY1W6 },
    { M11_GT500, min_space = DMY1_MY1W7 },
    { M11_GT1350, min_space = DMY1_MY1W8 },
#ifdef FILL_M10_VIA10_M11_BTCD
              { BTCD_M10_V10_M11_E, min_space = BTCD_DY1 },
#endif
#ifdef FILL_M11_VIA11_M12_BTCD
              { BTCD_M11_V11_M12_E, min_space = BTCD_DY1 },
#endif

#ifdef FILL_M11_BTCD2
              { BTCD_M11_E, min_space = BTCD_DY1 },
#endif
              { WRAPPER_DM11_O_L, min_space = DMY1S_DMY1O },
#pragma PXL encrypted begin
#-?\8-'BZEH,'ZGP_=+$W"(?[<X@Q 3\ID#MK^^8,]#4U *OM7O!59OD3W*UH)*128VF]C^@
9C\/AU_3]AQF8&<=YL76A/!@2\/$ ;Q=OF!+"CF(0P),Z=$*
#pragma PXL encrypted end

              { DM11NEW_L, min_space = DMY1S_DMY1 },
#pragma PXL encrypted begin
O@NI8IL^K3B^[5_39QWA1CGM8A'-SXS]]4MB1)%@A_3$1O9$X41R6C9\Z!+A@D-FTVF<$_B"
4L'6J//D]6-2E(.AUDG]K]^4
#pragma PXL encrypted end

    },
	shift = 2,
	repeat = 3
);


//***DM11_O_R***
PATTERN_SPEC_DM11_2 = get_single_polygon_pattern(
#ifdef VERTICAL_M11
	"DMOR11V", "OUTPUT_DM11_O", DMY1OR_W, DMY1OR_L,
	step_x = DMY1OR_SX, step_y = DMY1OR_SY,
	offset_x = DMY1OR_OX, offset_y = DMY1OR_OY,
	setback = DMY1OR_SC,
	setback_type = INTERSECTION,
#else
	"DMOR11H", "OUTPUT_DM11_O", DMY1OR_L, DMY1OR_W,
	step_x = DMY1OR_SY, step_y = DMY1OR_SX,
	offset_x = DMY1OR_OY, offset_y = DMY1OR_OX,
	setback = DMY1OR_SC,
	setback_type = INTERSECTION,
#endif
    FSS = {
    { CHIP_snps, min_space = DMY1_CHIP, context = INTERIOR },
#ifdef FULL_CHIP
    { CHIP_BOUNDARY, min_space = DMY1_CHIP, context = INTERIOR },
#else
    { PRBOUNDARY, min_space = DMY1_CHIP, context = INTERIOR },
#endif
    { ICOVL_SINGLE, min_space = DMY1_ICOVL },
    { BEOLBLK_FINAL, min_space = DM_BEOLBLK },
    { CSR66_3485, min_space = DM_BEOLBLK },
    { INDDMY, min_space = DM_INDDMY },
    { DM11EXCL_FINAL, min_space = DM_DMXEXCL },
    { TCDDMY_M11, min_space = DM_TCDDMY_MX },
    { M11_MAIN, min_space = DMY1OR_MY1 },
    { DM11_O, min_space = DMY1OR_DMY1O },
    { DM11, min_space = 0.2 }, //DMn.S.3.5
    { DM11_GT1350, min_space = 0.45 },
    { M11_HOLE, min_space = 0 },
    { M11_GT76, min_space = DMY1_MY1W1 },
    { M11_GT114, min_space = DMY1_MY1W2 },
    { M11_GT152, min_space = DMY1_MY1W3 },
    { M11_GT180, min_space = DMY1_MY1W4 },
    { M11_GT240, min_space = DMY1_MY1W5 },
    { M11_GT280, min_space = DMY1_MY1W6 },
    { M11_GT500, min_space = DMY1_MY1W7 },
    { M11_GT1350, min_space = DMY1_MY1W8 },
    { M11_45, min_space = 0 },
    { VIA10_HVN_5V, min_space = DMY1_VY15V },
    { M11_HVN_5V, min_space = DMY1_MY15V },
    { VIA11_HVN_5V, min_space = DMY1_VY15V },

              { R7_VIA10_CHK_REGION, min_space = 0 },
              { R15_VIA11_CHK_REGION, min_space = 0 },

              { S22_M11_REGION, min_space = 0 },
#ifdef FILL_M10_VIA10_M11_BTCD
              { BTCD_M10_V10_M11_E, min_space = BTCD_DY1 },
#endif
#ifdef FILL_M11_VIA11_M12_BTCD
              { BTCD_M11_V11_M12_E, min_space = BTCD_DY1 },
#endif

#ifdef FILL_M11_BTCD2
              { BTCD_M11_E, min_space = BTCD_DY1 },
#endif
              { WRAPPER_DM11_O_L, min_space = DMY1OR_DMY1O },
#pragma PXL encrypted begin
15JI.A;XSVU%._)!IKZ[XT [?73H>4_I)%-]47Y'!V[&H"M1+#S7^(L)]- LAP5 P.IN1WN'
;:)8ZO,G7ZUMGJ3MNA,N;2F>AR(S#I-MA*N'TF](:"\9WS'2
#pragma PXL encrypted end

              { DM11NEW_L, min_space = DMY1OR_DMY1 },
#pragma PXL encrypted begin
]XY5/.!3DDOWJ\5^DX,VH&NKA?;IZXIB/FN%C"7?2J9&(YR,,V_+>=1VX2TSSFQ0547"@A+.
)%MKRZ@U>A8DE=Z>)T::&MN5
#pragma PXL encrypted end

	},
    shift = 2,
	repeat = 3,
    starting_point = CENTER
);

#ifdef VERTICAL_M11
PATTERN_SPEC_DM11_2.polygon_fill.pattern_spec.pattern_spacing = {
    allowed_spacing_x = { >= DMY1OR_SXA2 },
    allowed_spacing_y = { >= DMY1OR_SY },
    extension = INTERSECTION
};
#else
PATTERN_SPEC_DM11_2.polygon_fill.pattern_spec.pattern_spacing = {
    allowed_spacing_y = { >= DMY1OR_SXA2 },
    allowed_spacing_x = { >= DMY1OR_SY },
    extension = INTERSECTION
};
#endif




//-------------------------------------------------------------------------------
//***DM11_O_W***

PATTERN_SPEC_DM11_3 = get_single_polygon_pattern(
#ifdef VERTICAL_M11
	"DMOW11V", "OUTPUT_DM11_O", DMY1OW_W, DMY1OW_L,
	step_x = DMY1OW_SY, step_y = DMY1OW_SX,
	offset_x = DMY1OW_OY, offset_y = DMY1OW_OX,
	setback = 0.114,
	setback_type = INTERSECTION,
#else
	"DMOW11H", "OUTPUT_DM11_O", DMY1OW_L, DMY1OW_W,
	step_x = DMY1OW_SX, step_y = DMY1OW_SY,
	offset_x = DMY1OW_OX, offset_y = DMY1OW_OY,
	setback = 0.114,
	setback_type = INTERSECTION,
#endif
    FSS = {
    { CHIP_snps, min_space = DMY1_CHIP, context = INTERIOR },
#ifdef FULL_CHIP
    { CHIP_BOUNDARY, min_space = DMY1_CHIP, context = INTERIOR },
#else
    { PRBOUNDARY, min_space = DMY1_CHIP, context = INTERIOR },
#endif
    { ICOVL_SINGLE, min_space = DMY1_ICOVL },
    { BEOLBLK_FINAL, min_space = DM_BEOLBLK },
    { INDDMY, min_space = DM_INDDMY },

    { DM11EXCL_FINAL, min_space = DM_DMXEXCL },
    { CSR66_3485, min_space = DM_BEOLBLK },
    { TCDDMY_M11, min_space = DM_TCDDMY_MX },

    { M11_MAIN, min_space = DMY1OW_MY1 },
    { DM11_O, min_space = DMY1OW_DMY1O },
    { DM11, min_space = 0.2 }, //DMn.S.3.5
    { DM11_GT1350, min_space = 0.45 },
    { M11_HOLE, min_space = 0 },
    { M11_GT76, min_space = DMY1_MY1W1 },
    { M11_GT114, min_space = DMY1_MY1W2 },
    { M11_GT152, min_space = DMY1_MY1W3 },
    { M11_GT180, min_space = DMY1_MY1W4 },
    { M11_GT240, min_space = DMY1_MY1W5 },
    { M11_GT280, min_space = DMY1_MY1W6 },
    { M11_GT500, min_space = DMY1_MY1W7 },
    { M11_GT1350, min_space = DMY1_MY1W8 },
    { M11_45, min_space = 0 },
    { VIA10_HVN_5V, min_space = DMY1_VY15V },
    { M11_HVN_5V, min_space = DMY1_MY15V },
    { VIA11_HVN_5V, min_space = DMY1_VY15V },

              { R7_VIA10_CHK_REGION, min_space = 0 },
              { R15_VIA11_CHK_REGION, min_space = 0 },

              { S22_M11_REGION, min_space = 0 },
#ifdef FILL_M10_VIA10_M11_BTCD
              { BTCD_M10_V10_M11_E, min_space = BTCD_DY1 },
#endif
#ifdef FILL_M11_VIA11_M12_BTCD
              { BTCD_M11_V11_M12_E, min_space = BTCD_DY1 },
#endif

#ifdef FILL_M11_BTCD2
              { BTCD_M11_E, min_space = BTCD_DY1 },
#endif
              { WRAPPER_DM11_O_L, min_space = DMY1OW_DMY1O },
#pragma PXL encrypted begin
CQVF06$GI4./_Y^/.FDRGX__ -U"_FH#,8  X@V0F/.=5^/B>GT;IUG<\2]Z.:IP++>?I',Y
YSJFE>V0O+_G\5 \Y\^<'N;Q "?D:1-CQ#$ 3!0D,RL#(W),
#pragma PXL encrypted end

              { DM11NEW_L, min_space = DMY1OW_DMY1 },
#pragma PXL encrypted begin
KC@_(I2-QU6N=JXGO(G3W3MVMJ<9AM/X]]JVO8G),J2),_F]T@I,_>!HG:'23M1J^DJEW1=.
)#'UD!L)#H4D"IH_N]-(+1,*
#pragma PXL encrypted end

	},
    shift = 2,
	repeat = 3,
    starting_point = CENTER
);
//=======================================================
PATTERN_SPEC_DM11_0.polygon_fill.pattern_spec.other_pattern_spacing = {
    1 => > DMY1B_DMY1,
    2 => > DMY1B_DMY1,
    3 => > DMY1B_DMY1,
};

PATTERN_SPEC_DM11_1.polygon_fill.pattern_spec.other_pattern_spacing = {
    0 => > DMY1S_DMY1,
    2 => > DMY1S_DMY1,
    3 => > DMY1S_DMY1,
};

PATTERN_SPEC_DM11_2.polygon_fill.pattern_spec.other_pattern_spacing = {
    0 => > DMY1OR_DMY1,
    1 => > DMY1OR_DMY1,
    3 => > DMY1OR_DMY1O,
};

PATTERN_SPEC_DM11_3.polygon_fill.pattern_spec.other_pattern_spacing = {
    0 => > DMY1OW_DMY1,
    1 => > DMY1OW_DMY1,
    2 => > DMY1OW_DMY1,
};

SPEC_DM11 = unified_fill(
    fill_boundary = {
        layer = CHIP_snps,
        type = LAYER
    },
    fill_patterns = {
        PATTERN_SPEC_DM11_0,
        PATTERN_SPEC_DM11_1,
        PATTERN_SPEC_DM11_2,
        PATTERN_SPEC_DM11_3,
    },
    boundary = ALIGN,
	grid = vGRID
);

//***** fill *******************************************************************
DM11_C   = SPEC_DM11["OUTPUT_DM11"][0];
DM11_O_C = SPEC_DM11["OUTPUT_DM11_O"][0];

#pragma PXL encrypted begin
_A/)"MM!NC#^)W$E8S1SI0DG3#E,0DIA=[A,6&F?:VD7?>Q8ZJ$7V3\9H<#J@7?B.Z_2?[^!
-?[3@_8&1L4U@[VHD5-@T!F#:W](Q63"2>AKA<B*5 C%#"J%
#pragma PXL encrypted end

#pragma PXL encrypted begin
>M7^''"83#1ZVF-]"1U!8(3:GA.B G U.1:>8ABV3CGL-Z=BU&1))2MZP%+4>PFHP#!0Q:A[
39AA2:K<1@=-/I;D5P52-J,^<1UXK1+.3$=Q(L# 2108VR(B
#pragma PXL encrypted end
#pragma PXL encrypted begin
OR.^/]'IKEV_H1RJQHWP"0ZAW'C_*&]A[X+<+EY6$-*4C? NL+LR*Q_J35NPT6<P[AQ)%]O1
;C45Q0K*3HEN4[B?=N^_U253')8]%AVF"!H<V$(/R@P;:??8/4I?9_LN3+P]!5\6IY-J"C,%
#pragma PXL encrypted end
#pragma PXL encrypted begin
!')]8C([$0<$#466>O1*XI<-08-MN?(>O!=!>XDKV[VXI7%[)FO&C:?B("<F4J9G8&= %PM2
[VY?K!0IWF?O
#pragma PXL encrypted end
DM11_O_L = SPEC_DM11["OUTPUT_DM11_O"][0];
#pragma PXL encrypted begin
2< \!9.,<S!)</"DW^;_HZ5P,Y<[I>EFN]\S&-O+GP0*[<P8^>"QB/IN@"7Y5QUF_;H=/TU7
689NJ2DG4%%9%4'?%]Y/XLH5
#pragma PXL encrypted end
#pragma PXL encrypted begin
C@[\)_3=U5F.C_W4XWB5Z^J/]GVHQX&RQT'V0P#V5V8L&-M#F8T/AJ.VVAZ9,1[9&>)WC9(Q
+2_>O#X0"L(M&CFZQ Y+KA,:<PZ %C&>N\%S^.%_=3.EW:#XFTDF8X38ALJ; <!V*<G679T!
5^A[>/NMB2=73_7. +E0A<!/
#pragma PXL encrypted end
#pragma PXL encrypted begin
0$.H*;XYF#= WT2YJ&7?)VG?+K!G&8#TUN,NP[003V**I#W#,-MO!U)0]J(P^BX6?WL!9[;Z
-BERA".];M8V=Y+U!N%YS^5W!SH$%]E(4O<'&O;A-:MI#:H:
#pragma PXL encrypted end
DM11_L1   = SPEC_DM11["OUTPUT_DM11"][0];
DM11_L = DM11_L1 or DM11NEW_L;
#pragma PXL encrypted begin
*.O*&KV:BF\H::(<2[][9.AIU8'#+2BU!"_58TY*(A4N&#%CKT_Z.?Z5ZJ*OH AJ5H7;#8B@
;*YS$KH(YF)L:5GQZ E4G1!I@*O&*PT!.]V -@TH:ODNXC4VI":3&:-Y*':DJX[M-2L$LNNK
RYC-2$5&$6/+
#pragma PXL encrypted end


#pragma PXL encrypted begin
$9/M"[O[?"<1I7S2!K1[9L2E#1B\D#^@KX\-?=!05& 0IW=]H5Y^5^,6W@VABS4=!M"5R_:+
TLEY$S/, *;2&'X:"E!L'O@8S]VR/5\H11K/3>9H5)#D9Y--
#pragma PXL encrypted end
#pragma PXL encrypted begin
'VXV/^A'KW8?VSQM&]FF=,W;GQ>6AO\URUJ?4(?DN3+L.'!0Z#?CP'-+'7SHA3=8;_8ZXS&%
;>:N$[Z"3@UM!UM?8N('$)\'^8$3O[@;0=/Y5#*,U<+5,[%46)IP\(6KC\98)UZ\.M F)XHG
^@ /@3+DZ OZW-.WB$1I"##<0KT898[E#!Q"4EE9NI9>E7A2X-P/_"5WC+3@0IK371!FY>-"
_O&<X>;,X9+^"*N9,)5=Q($(';C"JT/6_XD=NFT8S#W"$Y^Z)S 7J\;1_+HG@56'P-N+PE>!
>7!,MRE%G+9YK-EV-N /;6>LQ> )8JL4/^#%6// C" =[K58O["L7U\+'W:_:0L9VGEAY"EI
L/*-HN[MNX&P'\PD*PL-D5@?%!8O+<V*4R<4(#G97Q(2U"@@WH!)VUX1L)/><"-"\AIB>A5P
>/'B,\9ZQT1XV+QUUQ_QDYK82JRAU@1Z1-A*%!8O+<V*4R<4(#G97Q(2U"@@TH6=7H(*>Q_2
<"-"\AIB>A5PC1Q'^CE$>P*-]W/%$_Y1XB3W@J0C/85"JBN">_='@(9Y  U[R8S$OL6?$O/)
:0L9VGEAY"EILZ'O(DB4#URS-M:_K&C@%" V9.]N77'FI6=D6.#XNBZ4JD5813OXW%T!?=]%
?9<%RL;QV<!]5RS[5!?2["Y7C^69Q#FZI=6/JJ&L]\?K?-"J54>(,T\PF$U5#Y4L$9L"KD(/
,Z#*CYZN[(DS?K.Z#DNI @I^I7'D_U5A:4ZE:0L9VGEAY"EIBA<0!2S;Q$N*<"-"\AIB>A5P
AKV5>]-SQ%>&^@"=G E4U%#Z>99QN^HQR<%Y/4-A $"Y>5\]51$VL'OD[QU5:_@6(OJR@VUK
48U->G0I"_A1Q0]>'XC^^;K%);X5IR<_:%HEI%NB5XVC5NZDTV+K37,\8Y+36R6-$S]8<#-;
3FO*?%9*7"U.:0L9VGEAY"EIJE0:!X)G=P>J#2FR.)^Z"; -X;0M_C8=ES[A(Y'18"5.P>@C
!UN_HU:-X-8'U7L9:[!V1FW5MYCMSAQCP96WKR=6]S@-WX>ODO0Q)V?6EI>2&^?/I0 ")L<;
-Q6'V?T.I_(W#YYNU/6JI (/*@K9KC83PO<J\*A$TUZCI3?PGX"$5PWA#VZ?K/ITNTF>!B&L
'IU*Z[BR<A0>_^NK5OV/&4?_*FYA7+5 8.<J8G@^8_W&B^9BI];5>-$0:-2GC%RS7[X$?+&,
;.,(?)<Y_W)LI5'-[%KT+D"EKZ*-7;=\3\JOMYCMSAQCP96WKR=6]S@-WX>ODO0Q)V?6EI>2
&^?/I0 ")L<;-Q6'V?T.I_(W[1X0QJ;SW9CM[I&<0!F:YA#N <R(HCX;8UX!NM\3>1 M=@JZ
MYCMSAQCP96WZ>Q&!W^:,MGI>50@T2G0NM=Y%A]MZUSCX9 62SO1B^IJ@QM+ X,/T5J@'/$#
'SA=!?)4)B(?H(E"F[\<,U*@%AX&CW3.>0L6FC)<$Q\B>J:::5YDSR9NDOII'IU*Z[BR<A0>
\$+*=@NM"$7P,:6!I(EWIL$Q_]A.K8@D5"W_]RV=Z7&&'77W'IU*Z[BR<A0>;$N"L0>VL]QL
4D:Y#-)M0W=2TLC!*,MWDZ+26<5@C84(C+A9131@,H30Q'M%!6&P(P-T,T$%YQ2*?02.%TGG
N*F(P-Z(<JBX:(SCH(V'4VQH^F5._$UA<P3Z L]F5T.-LO0""2@GQCV^X%()#0%<3T,?;P8-
WK6/^[ @$O#>XS\LBB0@Q1;C@8A\9T+7CN>!!6&P(P-T,T$%?2\\DJ><$EU](Q#( U*+0;LC
[2 J(W[8 [CM"I;Z5!G();4*G??CP<;J=<>="ANVXYDBF&@*-:G&F-BA' LU&G=)TW7'7I,:
W5-@UF58\!;=G??CP<;J=<>=VSB=M7-GO13;';F!$&V<?0D=)J(<)F]&/!4F+=&SDP[CR+HM
I#'L"8N_<O&DWD[':0$'K1[>MYCMSAQCP96WVKX9!?3=[/K:0VDKC.Y,>B1#_/V382K2KQC\
ZBINA@^<.D/JV#LJ5O.FS:O8W1^BC*^?[+'=,4-YE3@&!ZTQG??CP<;J=<>="ANVXYDBF&@*
+".['W T!\HLM_HAG&A<&<FWXS\LBB0@Q1;C.46%=>AX8P@Y'IU*Z[BR<A0>_^NK5OV/&4?_
('O7JUF-YR8@W1^BC*^?[+'=M@[*D=*;5YBV L]F5T.-LO0""2@GQCV^X%()M<I;WS8?+\FU
K'<Y)0-3H2JLC4K7,?DUI5N-W\KP]E>C)(??K:_V 0+TTSBMSY_81[_KXCW/>;B'-877KY)Y
BOO>-V&M3E**X>C0:5*V.$#AZBINA@^<.D/J6\=JUUU:8V-;[UCX=+OVQ73O?;/.IHE9ZB9]
IT^V#%950G"GAWLRY&[Z5O6''SA=!?)4)B(?;2OVPQIIT"%M\=/9T89%>3SQTZW95(%)C"'3
S<X]#+PS>17-!6&P(P-T,T$%%!9UZ:%<6@\4E8P.I_D?5;*50VDKC.Y,>B1#3ZTOW8CC^7Q/
 L]F5T.-LO0""2@GQCV^X%()'?6Y$XWZ84\=K'<Y)0-3H2JLOZJXH-(J;S>_ L]F5T.-LO0"
9[=S>>Z$-<YG[2 J(W[8 [CM-@AQ _9!HD VG??CP<;J=<>="ANVXYDBF&@*+".['W T!\HL
SHG30%&:_M+.D+_NT$Y=_4R0;Y;E$4)L(2!O7"),3<ONH+!<AWLRY&[Z5O6''SA=!?)4)B(?
>_='@(9Y  U[K0VJ&<J7XYFMKK2@V2X=9ARN0:G\',QWZO]!7Q"F5B@0QE]?RVSIUN"Z!6C+
]%ZF"$$P&F+T'SA=!?)4)B(?68ZM 39\=8%9S +>ON'. [7,9>M;9;%2  5EC?!/#QT5][R-
'IU*Z[BR<A0>_^NK5OV/&4?_[0OJC_#@&LGM& XJW0S6WUX8<'EE\861^WMP#PLX%"A;C1P/
K:_V 0+TTSBMPC>I14'K9[G"2-A*QIF!;.U(TX__N;08Z/73C,%GF])#"T&,Q3W8K9>8Z>O%
">I$>U1]=P<)G??CP<;J=<>=J90JT2:SSMNI>_='@(9Y  U[\(W>9!,WHY;PZBINA@^<.D/J
$0FWE!JECTP1<"-"\AIB>A5PI'5%0?^TV^RD^$$PPJJ8EP_X(D&$:?S?[A8B='K2>.IO*%)T
>_='@(9Y  U[\(W>9!,WHY;PHQB2"Z_PIA^CUY-69 ;CN';7=ACY0ZXWRR9V0J ;<BV-ZDA"
ERSF<O V=V^7[2 J(W[8 [CM!I5[,]VU=UX& L]F5T.-LO0"O&GS6 Q>GG2\:0L9VGEAY"EI
#7U%3U GW?,-G??CP<;J=<>=NC>2&O9'0<"Z>_='@(9Y  U[674[W774_2598N=>42>3'G1B
.QJN#P/BJ"<[84 PV19W1>=A:0L9VGEAY"EI#7U%3U GW?,-8J.PMQDB>*=B?>X9S=4DK3%]
#-J@^MG:.*0,+".['W T!\HLU>/3T:1-PY75C%RS7[X$?+&,;.,(?)<Y_W)L[R0J%,L/T17O
ZBINA@^<.D/JTM,^"WO1R3?2<"-"\AIB>A5PI'5%0?^TV^RD X,/T5J@'/$#P%&+KBQ6-W? 
(#G97Q(2U"@@;K)NBY2TF")N?[:T8:-QTSY_L@5P/)Z46<JRMB44$?C_/^.V<"-"\AIB>A5P
I'5%0?^TV^RD^$$PPJJ8EP_X(D&$:?S?[A8B-)YK*<8V@A<T>_='@(9Y  U[F,1/&L%@30^8
?;/.IHE9ZB9]\2 10W..7VOQG??CP<;J=<>=J90JT2:SSMNI>_='@(9Y  U[674[W774_259
K=R7GI?]%'2M7 IW MO&+!E<?2\\DJ><$EU]KH))7N9)%O2N^K.=W7]="9?Z(D&$:?S?[A8B
='K2>.IO*%)T>_='@(9Y  U[674[W774_2598N=>42>3'G1B.QJN#P/BJ"<[J@\X5JP0;%6J
:0L9VGEAY"EIS<PNX^R'SV7-6G8[=X1<^5U:CXUAW]"//%./FN:/U:@U;'":++@>,'5K&GPL
W%5@4ZA_K:_<!6&P(P-T,T$%]:A!S 2I"H?UI:$S^BV+W\JEFN:/U:@U;'":(C];0G2;2D<B
:\3W.C&BMT%KRN$KA9NGP5K*ZBINA@^<.D/JV#LJ5O.FS:O8]0(QO56A;@CU=5#28U ,9QYU
$696/$I)8SH1*,7(W$=[LW HFJK*@13^)\Z:'IU*Z[BR<A0>,:Z)/1NLU0\Q]0(QO56A;@CU
=5#28U ,9QYUZZ,7IUKR#]/K]9"?.7^,E/OUG??CP<;J=<>=1J.1-&=7ND%&>"Z=&'U_8+UX
*IJS_UW%XLPJA)#)8QC\N'.$*,SN+ZG>+98H]0(QO56A;@CU=5#28U ,9QYU.T[=GU Z1SH[
4/(2Z62@O/)0SNX\X>"S'I/.K:_V 0+TTSBMYH>NKRN S.KFFY7T9,5/6DJ;I;G@1](;(>VE
SR?L]T-/6L[/\4-B%W-,:&'Q_BY)F=^%8 S^Z3:M+=RJYF;IFN:/U:@U;'":'O^$0ZSQ&!P>
 B.U:GHWK-T")L,.&%"H'M F'IU*Z[BR<A0>X*'8 -@<0*_@QSKW+3;PL>7'\I>/1)DOEKWR
>8:QR*E7C2IY!EC;-HM(4-(&2><=M1PL*0!)FN:/U:@U;'":XR:)8$6[N8OCGI(R5,=SL,">
G??CP<;J=<>=]P!BQENQ L3WNR'2*\[J]KB[[1X0QJ;SW9CMFN:/U:@U;'":I(5,]*Y(16RD
!=2,)(RL@-8%/1GU,AFQPC\]G??CP<;J=<>="ANVXYDBF&@*-:G&F-BA' LU&G=)TW7'7I,:
FN:/U:@U;'":[F2OEBBS8.[NMIS)U?5=+(*V'IU*Z[BR<A0>:HMH8ZE" 9IJ&$V^DX+1P9<8
I:$S^BV+W\JEFN:/U:@U;'":QQTI<S8Y&'?' L]F5T.-LO0""2@GQCV^X%()PXF0_SHMR\C#
<5 ?I=[Q^$YQ8?&3>/\J[^]A\6D8.3_SK</Q7.>%>"]U3 5<=5#28U ,9QYU[.09R55260/L
ZBINA@^<.D/JK.@38(^RXW6L99L0%,K$8AUE8A4"MP7!(!)BRGI47@:7!C[*B](B+PN5Q)>+
K'<Y)0-3H2JL??.WOVD25$]]/6Y*2!;FA1P]>:-%&*&;,BAYL:Q9,Y+G(L*QLH=!KTOG>+*R
6IBE$L"F4K%://VA..%8\TD\$8J#UR:5@RT1^?7SUIX='7SY7UCG^7#[&7U? QGZ98P]E1L#
OHBD;B.&K6R^ESG\G"/7PJ^7=# @*A4F#,]T<>?E+I2)$]1Q<>?E+I2)$]1Q<>?E+I2)$]1Q
<>?E+I2)$]1Q<>?E+I2)$]1Q<>?E+I2)$]1QN++.FQ1&;K*XA.BL<UMS;YF$!=,=,' .!$0%
TR^.BCR08L?3PVYU.X[#ZY/#$S"."NG*W'(3=U<.R5*X2;EW\^O>IFI; +3S'3:I(^3?>FH=
 7\3VU9%-N(!TX__N;08Z/73C,%GF])#"T&,(CI?**-T,; B(T(JSOS)TU@C&#CZ?8@)+? 8
(\" _B0Y1S C:0L9VGEAY"EIW(S ]H)NH>S<(#G97Q(2U"@@S@8+>V;RM'C.K'<Y)0-3H2JL
X3DU.^^#&?GA$!'V]!E_(NL094R.?V @FS9E(#G97Q(2U"@@VB><YN"0NRC:V+QUUQ_QDYK8
@A#&RQ1$4;B" ;ZQ!7-[.S8!!C"?&[!')PL&JY;%U:M(QDNKUWT>95+\5\'7K'<Y)0-3H2JL
X3DU.^^#&?GA$!'V]!E_(NL0]._9;03%4"GT(#G97Q(2U"@@$@%S?)6<$HH2?2\\DJ><$EU]
AK/MBSYOX0R&^="=-TP9WG3Y4K<<7"=.Y4]2+P:3TFKMW\TO?>X9S=4DK3%]MUG -.Y_0,>W
E%+5G+0[$>:4O(SX:-RJY&*\^<*6>$MN4\/YUY-69 ;CN';7=ACY0ZXWRR9V\KW$TCW1V0CR
!:5K:1N:)]T%XM5=M3[<]17BN6$A^9JB^I2YL-YG:G9ELH^PO)4GDY$,F&V\0)]PJ;R7:0! 
D]*.VWZDF9*3C/A ::7%2..,44(%!VAFXJE1@H:\9^PD$FN"^'.(^J]3KP+X '4YN9J;X+D 
_R,Z-Z6;L!'_8L]KPFS8ST%B6F_P"PBI)5I:A7_\&O6Q+)2%^T&NK3EVU<+[_):Q@F1.) O\
]D?776"YD]3VUV5;-\$VZ4C7+5046<KJ8$ M8,!^SKE3KO-@WLG+1TBFT[;>1[#?#?VF!Q]'
 BFI#%5;594"47\+\(R!+4513_16+&+\QTU/'>=U20.E\&T=6_RHNJ<-AZI; WW)7S/W-)@#
ZT9EQ]^YIV#KX9 $P&Z!72+AH#.)/_6#PL&@T+3L@ZQLQR[0S K66(%G-X',LCD.#C7ZO""R
&R*7L,Q"5BT;/8)T)&>@)4@]?<NMXDMF,#E]( F7ZAS%QEH@&JNEGV F0=L:ZJ1W!8Y#=X?J
5S'3=A7=XT%7&][[0\KE$CH;%.$DB>Q(@S 4_*H]JD%XMC#\O9&Y%OO]*$V]_*$<TTS&T7+\
!3ZETH**C0(%YCRE3>3E[O3F$U5/X^  H3(3UC/B:IS=6#?6%_W97>+>/2T7QNP#8:^K/(3&
UC/B:IS=6#?63#W]F6$F"(5,R,+GEUL-L#C(30&@$>>Y&1--_@@"/W$91.#^,RL[QGE&EF0S
P0$'US8):'3!=TB35&)%4!AW^@"=G E4U%#ZETH :EP6!K.7MY5K\K]8R+VW1[$4<4"[P.Q'
^?7SUIX='7SY[:G:X4$Y5/+MG3YU/M'=!@N=CIX9[,>BO5>.7TL+@'O42,A?M(>;14 I@_*T
7_-U@D:^(61?O(?8OM_[V*"\Q:[\9S$C^[K%A8=>. XD"KR%95ZHZDY:&H-E7A"F2EO7_:=>
1;>14+54MO=%["X]4,]3)47LFL< !&9OD6&:ML-MQ1?LPE2V5[#*9Z=&@/M7X:!^=+^]NO[A
X:!^=+^]NO[AX:!^=+^]NO[AX:!^=+^]NO[AX:!^=+^]NO[AX:!^=+^]NO[AX:!^=+^]NO[A
X:!^=+^]NO[A!RW77MC7DT,'08PP?8=X%F-!F3VK::#OAE29G)C'--@"]!&<ZO9OT13&N2?J
[+; [!D1/;_L$GK-\6\LS4L2_Y<FR5JA[RW_E10I#E1][[:59$3S?8&S*$5D3HPGMTL"UU].
\5Q.HUF0NV/Q1OY+Z"P8/TY&_6 HUVAQS,+]-*E4T!ZK\]TT%-C"P\"*6CX4=$?Y:4 :ZC1T
\/FE:5V/:>'PD]9QM=B?HKR3Z3)]:0CP8UOIT;7I]L8G!6W1.+.B"$BNO60X<0(.68O7Z8MQ
N2:VU".6F7FY$2670@S1S\$1R0!-)'24;,#)%(3L+H&*-JX46FR1EIXMC5Q:7^LM,H5/KRQ?
6_.MU;H5TXE;@6B(6V*ZT3*!2)+SDJM!X@I(6ZU]:.I:4 U;L/HUMS>:-QZP&6:Z15<! E@9
N;#608&?<5&Y),7=-,Q3"H,D!=2,)(RL@-8%,%/L&94*E9@PHRK $(Q5V=VC "=6+N<=JV0 
4:$N0?X\$]Y1O=+"L,1S]+"]VZ<\]A-YB)K;[OIXEF,*:R7N8$A4U3Y,&'=@<@?-#"\._91R
2CC*$@Y46'9*9N^"OD8I8O9FX[2MHG0NA@WCQO8(\;,[6I_&9L)+Q)85;A!F]XW"S?FW>*[W
8:%F+FXX&S9AS7:46MWC]SW-WLG+1TBFT[;>WU=?B.OF8_3?P^L<+ >^4(C#^K=PZHFE</OZ
J?'$//]#9Y&I3FYK-Y.QQ7).U$^".H/"&F/4_4!)."(XG1C]AV03;F41R.>'>^Q.RVYS[?M[
CI6=*'U&N/R.O(<#A4CG%1:\0#F=@<P5O;9 ]5ZHV1KW1PGU)!RUKY;ZV64DR"_=7R0[/%O(
/:EL=BWKAN@]8@C;OMX)EP5B82VU!YVOZ%1AK:9"\9J?T4&M8<5B^"P@Y=QA<UJT9X,UT_!S
2:>,UX<_2@I)<][05EI25*USAF@J5/XW.=N&CE/D9HHX/<N.#;PK3A?>-;L-1JP2F=?H5YE&
D9EOLY@.VGN18<5B^"P@Y=QA<UJT9X,UT_!S2:>,UX<_2@I)29P "PA(.6Q)AF@J5/XW.=N&
CE/D9HHX/<N.#;PK3A?>-;L-1JP2F=?H5YE&>?GZC)+S.NIYWT88J+9ILVC?LQ),KSPJ8O&S
L&6=_DSG/^BP(Q&!R?.E']<C7UZ3C[Z'Z6E?3'Y6*RW0>Y5,%OQM7@LD",\6LJ0"+!7JJ6JR
%.0#$0?-MJ\4.6>@&_&7[T8Y7DR$0,$J8N1>6ZB(120/S:!;4TXI?WG"G&53A1#C<]\&W/N%
N8N3EZ1<'D6Y#7+P(5QS]X(-!5IZ?C5A['<%_,\(610\AM+\M>@<B"EGBEJUP[ 1'ZZU1FS#
_/UUVLS<'#'\#VBW:MFX^;8/>?ZHLPKDSN=Y>]D"$*&XH5-[_/UUVLS<'#'\TH%SJY7=.7K2
3YEX-3#]]GA/ M_\BV2 GDX"T00M/)[(Y'K1+^S3_4*1[,(OV[/;W8QSRR_;Y-7Z8E'C+SGD
,TD_\2:EW^XS^>5]2*J/7C7YFN:/U:@U;'":FN:/U:@U;'":FN:/U:@U;'":E2ENO!*@J$*5
1  O0).X#P5$][).0-BBR2OWX-<'C;C#Z.W@Y=J<7TRVVT?E9S$8;PXG\M5G.1!E&O?)]L8Y
]0(QO56A;@CU-1+<2F)]T?PUFN:/U:@U;'":_OK+6]"&9QG^3^<7!DE]ZYI/S&+C03TJ(.;,
Q'@R;U0*B\C$^35X<S8#0!?YFN:/U:@U;'":>10]R:M:@@%YQH1=BKE:;%C&T%]54CVR^++0
FN:/U:@U;'":FN:/U:@U;'":B9!]K%76G<N)QSV24I0C(?7']0(QO56A;@CUFN:/U:@U;'":
_A=A54#/KJ'^(=^&6:"0:DDA=W["KC=QW$IW,TD_\2:EW^XS@G-@URV>[9V"VP;! W_&')G;
FN:/U:@U;'":FN:/U:@U;'":#3KLV=\T^'8-2\DIC>,UUK!+XSWY&0@4V2CC]$')E=+_Q9/T
A>&5 8R^2HZ%FN:/U:@U;'":=>1JX;EX]+1U>:5.2V_)A-5Y',Z@=O95D? <?UYP%4T5?:Q_
 2<H7 =+G< !MP>OAB11O?.W[Q^[O.'Y6+KO>I1F ,JJW!IZO:>Q2!2)U.N]^O:H.S51XLOZ
"=]07]N#6;X)YI&+ZEY*UP;FI3H(8@784B*E5&T%N"H0M'E4_&QK)DMZ?R7\^G1E7Q1[[*#Z
^9+5#^/:K03YS&VC5#C4<B#,])LUH*V(],;T>4)E]7=K2 =Y;W_.)NSEN)QO!A=;2H\*&0P&
<*8N-89*'_MP182+HC A5"I%9R[]XO69IE9G3'Y6*RW0>Y5,',\[D<(5=3 </?6C@\%*=IX]
.,'>K*L=4BTX+EI:A:"#B XNX065W<<T%VSA N?R5B>.WH("*+5"CA.OE#8HX065W<<T%VSA
P\"DMW'EN/O#?!10F9,\*79\?V5KKGY08]I_J@TCV[09_K:JA__ 1NMK^QR')QW7@&=F@K0G
686F:V8;' A9P&C>Q^MN<9' XT[)S5+-TN_C9X[OA#C\6==G#*P+G-@RC-0,5VA(=$^RA^-7
[?P+!(K][*?M9J3N_7[HV31F6'/G8G@^M+Q8T2)X9]XGA,+1(+V&9.KK+8T@ G=FZ9F(F3<"
O/#F_:7_H0>\!1P[/^]Z^,<%H"A6!@<M2_.@H0I^.HBX"5ZA=P_' \*8)NAWW$9E&U[LW#W<
B!<T$B?0F^>(VB1X99Z. :G::*9(\M3ZCEEH]G8A1>0GY*WV"?LA/[U$RW<)9-95XI*KP5UD
V8B/Z%4LK[S9WZ-S ?I,MAS?K7@_4F1 6 2MFP](9J%<6::;>DY90?^M<#MZ@KR/Q?>R!/R"
XR(5&(A?XR;C4\PBFP1=RS]3)25NK#\>_H0EU4Z>P]0/G"S5I4)@RLX(M]*ESJ&'E>)43P[.
X065W<<T%VSAU^1J';'#^.[7FES(H?,J;WR:(,%$NA9*(]D@CI6=*'U&N/R.U^1J';'#^.[7
1V%*0P\NET5'5H(Q53S"9Q%6IMKD::WT]["FCN/".S,+Z=F.TR?>B[8<!Q'3<!6"INL@N<IP
;8/E4C3U3DQM"V\!A-89S_<+]#:[W] B0%ST$]RES@N,'"H3S T)PHJ3'ZW,W0,=/LVEP>W=
&8/)6N1I1HX9!NR3SO!5.,(&P^L<+ >^4(C#@>G=S)=UW\J!1N\[MTUW>%9&#-+$(31'D6D,
L=U#7^&O_^ZQ<UJT9X,UT_!S+0>Y)I5L1M,M&8/)6N1I1HX9UI86)R!DY8_6P^L<+ >^4(C#
@>G=S)=UW\J!.MC@TB9.G$<Z#-+$(31'D6D,L=U#7^&O_^ZQ<UJT9X,UT_!S+0>Y)I5L1M,M
K9Y329\O06NM.Z@H1OFI+K,[2Q:#"\@9>>M+6\(E!D20ZC];-4=N8TQ18$(U?X?FS 6*/GM_
N=*F$0D+ZA2Y<Z&G5QC1E=AS 2A:X=N)+, !"1DM.M&A:HT)#%#8D$ E32L,MY->7MR_'!BW
J<5=1TS68H:IL<3,YQ9Z6DNQ!=@C!VBJ364%-0PA\E>7:4,UG(4;.V)^&4"<\_\5;XZ:?9_S
< "0UH =,/)P'CFU'QPUNZ$>5?L96G).)PQ51;&='W: \]A%FN:/U:@U;'":O_$F3O K_%Z_
>^$$N*=3A'Y[^6-,==R22VGYFN:/U:@U;'":I9BNZ2D7LF>EN&N1MZ77<7VX#5UQ-CY1?R -
L,82<(8;&N.POA!9 R\7MDZ^VS.I:/);Y6K;!-QI1YE\0ST$3H>KPWH4KM=.I:$S^BV+W\JE
FN:/U:@U;'":FN:/U:@U;'":(4AM?FG@\V(A?SS)M:2X!G-_8.E>R%L:_'I@UT3URFEQM977
X$$<4\DCC\G@F15<:)V)U>J9FN:/U:@U;'":,F@GO4=HZV R0\I6[<*9!05#<ID#KZ>=Z^%R
U#U1-MJZ8?K4\&M !S6H9S[P)0,Z,OK4+F8E40/M-!$&HWU1-/5A=%<Q%70TR?Y',BT6L.3)
8CI[Q5>W<@1B#+('S;IS;RX,CQ/GAW"C/""/:U004(\:ZU=KFN:/U:@U;'":L&3\;.9&#>ZP
:^-.A%BF9[=KJY8DFZ!I QJKFN:/U:@U;'":R_*MAF%QE]S+%.+XIXN5SU$4*!*76,>%?0PH
W]HS4,\W>X;?>N8SUY:FFIUZ9:7Q J+'_7QEND& QO4*^\>ZFN:/U:@U;'":=EG-C#Y4,X%V
;D'?6(TJ'6)NT"'I@'P+EUW0/PTJ)N-6CC<_4D"3B$]ZS7529[,7/91BD8YGFN:/U:@U;'":
%:QS:.SY>B 5@QHEF),/S#N#^5<7UI-J>MSYE%K/'5 PD4*4T$!+FWC5L0+08]C7L\LLVHYC
;A5ITI_09)UNV]SK(=AOQVW;:"_WD':PY2UHD'#SB/'Y& >0\K\Z(T8W\,WR#.SNA*?5A]D,
<>)"P\COTXEQ__PJON,&:A?_:.#*-X,AF.5H.:J&D?SX_Y<Y?)[;(Z9\D>)\!A=;2H\*&0P&
%Q&BY'PC,[T7'8YHM+#984,=YEW <@C1+ _F>8GF]\0TV/MY0,-A]%I$"T9  "'EB<_H=]\ 
.6>@&_&7[T8YF*0^O7TQI\*8MY->7MR_'!BWV.3= WE+U'/88M.;4B,#4)%B3'Y6*RW0>Y5,
>O-_D09_"WIZMK88%D68ZO6V3'Y6*RW0>Y5,#97Z:/\T#J -Y.5%6(+U78ODA<?R; !X56R%
RJR\(&QGCYC*8TW-F-+\S#=C5O1C,\&B5'16/O-U\O.,./<^@*P$,8M]P[2 M]3,V;,!Q6:W
8_CSE[R2F.1C&N%?/F!O:)L:U0;$>=[52;C5X:!^=+^]NO[AX:!^=+^]NO[AX:!^=+^]NO[A
X:!^=+^]NO[AX:!^=+^]NO[AX:!^=+^]NO[AX:!^=+^]NO[AE/KFM _*VCN4QM4O=I ?'P;&
1MG85J:_&Y!&GCISIBK/ODB>W*IMYYUD..;<X7XC1W>L%;_AG4'U'ELPS'2=^K3GR;MD3:/Z
A.BL<UMS;YF$!=,=,' .!$0%6%C-3H$*7_=8=B/O_R9'U+)V/O,"GM[-=PX^PVYU.X[#ZY/#
%2UENA%RG245>*_T][]3]69XZ!/'\8:4].+H"",CM<HM!:8(#YYNU/6JI (/R,P8_H:X.H/(
,,_L BA(<\8P3[[H572/[TA/@J0C/85"JBN">_='@(9Y  U[FB:S=Z3Y]Y2:JP)ED"1J73JK
/R7J<BE9:@P_"K!4IY%'-6T*,5"\IIPD]'@QWB.?Z!^Q*<W>R(3V]?C/[LW(:*IJRF=J$B1H
FU+JJ3>VNW:;,EB_0UL?W8 R0FS<_D3\T_5",5"\IIPD]'@Q-,#>4IX)HK@TR(3V]?C/[LW(
W1G9*2&C(6'=N;?K:5JZ^RJYQ> )8JL4/^#%6// C" =[K585+Y8M(S&16=4 -H:93\$]'T 
/C?$?V4TS^0^6G8[=X1<^5U:7'F[*5@8\NY<>.-#]6<^JTEX-2N(#J3/+.4UU;;@[L+(*9+5
#8Y(6HG/1/T-6GOJ+6-RR:):L@JBK*,X[V.R/(=I"?BW-JL\4#9.>%)D4NQ0Y%V(94^'"_/D
7CW^3*:66RM>%].-(/KTZ=87N<!72YN:\(>Y>_='@(9Y  U[[JW@W:FP42;NE%+5G+0[$>:4
)N.,77XA>U<F&/MG%WUXN2T8M=I[=^LAU!NU=I3\:=JL3JMVN0U2#D1<1[ZY"[:A(=HJY#4+
< ZL&[M4$!UPF0<&\Q417]69?31@=#2%.:9],D< U1?C1&DR ^C8 %P.6)$#[Q;TL>4++T;O
<"-"\AIB>A5PZ.J=B=!+*B7H:>_'E-YUS5UIJ$X?'5M"RG^HFQLY N/I^L:;HH@E17BH2R&B
;67#1J2N8[-MM5@'?*UOR VUZBINA@^<.D/J6\=JUUU:8V-;9_=6/#P;N=5G99L0%,K$8AUE
8A4"MP7!(!)B3I7Z0'A!Q^M.Y;4X$?@.Q]3E:88Q9ZQ7\N=I?ABDUZR<3^%^K+J7YG0=,@ZL
D!NPR1A-<QJ0'SA=!?)4)B(?F-A.71 N)]V8B*"TFW&? %R(T":E'6H/:!#0<MU_4=L<[_QR
CPB2:2V5OX:/(5\"K8V]6'LAD>C[6 P=46.1ZBINA@^<.D/J6\=JUUU:8V-;9_=6/#P;N=5G
99L0%,K$8AUE8A4"MP7!(!)BRGI47@:7!C[*4K<<7"=.Y4]2[ =Z[L9'^3_LVJ6O\D1+4:':
ZBINA@^<.D/J6\=JUUU:8V-;BG32:<Q:>3F*?;/.IHE9ZB9]HP7L7!SL)A.CA0<NS]2-^P^%
'IU*Z[BR<A0>\$+*=@NM"$7P,:6!I(EWIL$Q$(I-WJ8R,B<0 WAZ3=C)9B #E_^\"ZJA.N"7
'SA=!?)4)B(?H(E"F[\<,U*@%AX&CW3.>0L695_^CX:.<W%ED!NPR1A-<QJ0'SA=!?)4)B(?
IDX$%3O(#+ZFK'<Y)0-3H2JLB%2P/MH<O#"(HJG4%\SS<,^B L]F5T.-LO0""2@GQCV^X%()
)44PO.G/KWLEK'<Y)0-3H2JL5L,SAB<ZW I6?:'HP4$F+SM]!6&P(P-T,T$%0N;B8<+J;[]"
X1U9NUT:(\?A?;/.IHE9ZB9]Z/7GNV+[D@7H L]F5T.-LO0""2@GQCV^X%()<"-"\AIB>A5P
T&M_35PD2\70E0[ZOWN%0E65?9=*;C=.V@!]K:_V 0+TTSBMR:E,5)+X_\+)23)JVZL6Z$-)
+=&SDP[CR+HM,#6VV,O<D7PPK:_V 0+TTSBMX'ACX6JK]Q+@M-;N9F-K:GZT =PPX>7H%VH!
&)+='LWKG(L8O/*MHL=EV>>\ZBINA@^<.D/J"TK+V!]^:<L+K'<Y)0-3H2JL8]YHI3&-/T9C
NM\3>1 M=@JZMYCMSAQCP96W9=FX#-?F!@9ETZW95(%)C"'3;GL>X%W:\SUNK:_V 0+TTSBM
(#G97Q(2U"@@7&AI6!!D )5<?;/.IHE9ZB9]#B^G7:& 6^,.'],DKPH_,XX?'SA=!?)4)B(?
;2OVPQIIT"%M66(?23V&COY9TZW95(%)C"'33M#+I%M^2Y-.!6&P(P-T,T$%%!9UZ:%<6@\4
E>75I]?8,E:50VDKC.Y,>B1#S3'=MQ@U@G_-G??CP<;J=<>="ANVXYDBF&@*L4RU"JW#J$JQ
[2 J(W[8 [CMH(SY:)-X0+"@]0G@?23:FZ3UMYCMSAQCP96W5R%P144TYBM77LT&;+-"ZD%>
XS\LBB0@Q1;C;SVT!4G,KB5O'IU*Z[BR<A0>_^NK5OV/&4?_"](:EVCE5 $+W1^BC*^?[+'=
SDH&N .KHN7. L]F5T.-LO0""2@GQCV^X%()QP9MH=34X8['K'<Y)0-3H2JLC4K7,?DUI5N-
'W\.L[7KZ\<?!6&P(P-T,T$%%!9UZ:%<6@\4PXWY *^'L='#0VDKC.Y,>B1#8B;9QZSS$Z1B
!6&P(P-T,T$%C%V+#J["J/J,BOO>-V&M3E**KVLJ;"($&"*OK:_V 0+TTSBM(#G97Q(2U"@@
:; W:8Z4LS1I,>)TN)Q+!$LQH[A;6<S571BCW1^BC*^?[+'=!B"].*>;=GL&'IU*Z[BR<A0>
:HMH8ZE" 9IJ%^S@_'Z&%4$7Q?P4AX@)3*#%^3AEG/?@G]/Y,-RND(I!LN<P^"R<"V7?#7_X
C?!/#QT5][R-'IU*Z[BR<A0>_^NK5OV/&4?_.TH<- 6980<[W1^BC*^?[+'=UJ"?4@=_5Y/6
]%ZF"$$P&F+T'SA=!?)4)B(?OT_Y310]E4N_S +>ON'. [7,"/#(\*:/?<T("]3?YQYXLKH+
G??CP<;J=<>="ANVXYDBF&@*(NH)+8.*8#HBR&3)!'Y84#O(^8,V\1\W"MCY99P3/8+]'LUE
BOO>-V&M3E**C*3?]Y4@(A",[/[&OMA8Y+[L:HMH8ZE" 9IJ%^S@_'Z&%4$7RF'!O>.+*7+*
7 IW MO&+!E<?2\\DJ><$EU]KH))7N9)%O2N##]A#4QGZK0,WAF(D]Q,,-'>"N$3H'2?/$X*
:HMH8ZE" 9IJ%^S@_'Z&%4$7],_]+2QF4ZOT.QJN#P/BJ"<[J@\X5JP0;%6J:0L9VGEAY"EI
IRW7*T195;>G;=OC&1@98YYMBOO>-V&M3E** [G-M_41Q4D#CW+-GAC[QS*/4%O)2;;JF(90
0J ;<BV-ZDA"U1CHJF>E'U[5HTOHDR=RMLFC:HMH8ZE" 9IJ%^S@_'Z&%4$7#W%221@+CS,/
HQB2"Z_PIA^CUY-69 ;CN';74%O)2;;JF(900J ;<BV-ZDA"VD J)QG BT;:G0Z\H3.4,26=
IS\]:BEHRGRG(#G97Q(2U"@@;K)NBY2TF")N.YPG@M^T!'0[CPB2:2V5OX:/XS\LBB0@Q1;C
PPL?O)X;7#?#"MX3[GACCW@*?2\\DJ><$EU]KH))7N9)%O2NJ<'3L]+-_I*I'IU*Z[BR<A0>
#-J@^MG:.*0,+".['W T!\HL]N=2EBGY@.?V^H#A*]G;)7CZR,JI4C;_=$?(?2\\DJ><$EU]
KH))7N9)%O2N##]A#4QGZK0,WAF(D]Q,,-'>^&+)91KJH+SX:HMH8ZE" 9IJ%^S@_'Z&%4$7
E^V<X&]B6L:7XS\LBB0@Q1;C/!\X]PE1"X0\[/[&OMA8Y+[L:HMH8ZE" 9IJ%^S@_'Z&%4$7
#W%221@+CS,/ZBINA@^<.D/J$0FWE!JECTP1<"-"\AIB>A5P"K2V7]GK[<P*WAF(D]Q,,-'>
"N$3H'2?/$X*:HMH8ZE" 9IJ%^S@_'Z&%4$7#W%221@+CS,/HQB2"Z_PIA^CUY-69 ;CN';7
=ACY0ZXWRR9V0J ;<BV-ZDA"I7N70?%58)REU1OA@S"<95#5FN:/U:@U;'":0VDKC.Y,>B1#
8]O 3 2!3R)C L]F5T.-LO0"S%V3T/TOW7[,T/P0^EX%.Y/0FN:/U:@U;'":M^E0!L^77)FW
4N2&5#BEL?E2N0BB2=?@D]VYZD#-5=N^H'#JMYCMSAQCP96W9=FX#-?F!@9EFN:/U:@U;'":
161&A= "8W%%3'U5!;??)<I,R''IIDV3W1S(W9\N]>>-T ;="30X7S[P%FT)SKT:\D'H"E'.
FN:/U:@U;'":WQXPE8!N&3W?L?R68/LLUXZQ-?\=72N&"'<UK:_V 0+TTSBM/6,VE*.3:7X]
"J$=1UP(DU0*_[!9/("_ZLK__D>=FF[Z-S[^ABM:FF?D#22&FN:/U:@U;'":XR:)8$6[N8OC
<J.!5\"P9GAR<5J.BWWY)4QQG??CP<;J=<>=]P!BQENQ L3WNR'2*\[J]KB[[1X0QJ;SW9CM
\21*V9EJI4CQY2XLDU1B7:[EY!!JD$MX#H_DYP=<"68\Q*'GFN:/U:@U;'":#EWQ9\F-((,.
0!KNSN1\HP% !T/[[_,&9YX'E+K_WD^]"\:4)HHPR(Z(6<\FB,19=<@EFN:(6G8[=X1<^5U:
[S+8#Y.]G!'OFS4D]!XBN/B;8"95$=_B\UE@]0(QO56A;@CU=5#28U ,9QYU.T[=GU Z1SH[
SNX\X>"S'I/.K:_V 0+TTSBMYH>NKRN S.KFFY7T9,5/6DJ;4K<<7"=.Y4]2FN:/U:@U;'":
+UJ99)=M;BHOAP] %1(T&K*'-]@+N7JI .PWK:_V 0+TTSBMR:E,5)+X_\+)23)JVZL6Z$-)
]0(QO56A;@CUTDO7QIZ@$G+2W$9E&U[LW#W<W!94Q*^D:^/<'SA=!?)4)B(?./U4/O2GZU$X
O<<)_&PH7)B]FN:/U:@U;'":TLC!*,MWDZ+2]T#6-A)]31WW!6&P(P-T,T$%?2\\DJ><$EU]
M.;XU[_>\S^T]0(QO56A;@CUTDO7QIZ@$G+2!]$IXH;@OY8'-]@+N7JI .PWK:_V 0+TTSBM
R:E,5)+X_\+)23)JVZL6Z$-)]0(QO56A;@CUTDO7QIZ@$G+2#%P.;RI>'A<,_;RS+#S)Y:+]
W9\N]>>-T ;="30X7S[P%FT)B*"TFW&? %R(T":E'6H/:!#0<MU_4=L<[_QRN3.SA!5C#5BY
89IR[*E]+^9AVFGZ1*]NDTG:?%H$I/,%1\1\(F1(J5X]-,4B8&++%5?FMJY@XPSR6S99^'_C
XRWE5[C&:G+C_OZ/G#'1]AC^Y'H1,2=O_.KD4K<<7"=.Y4]2@)*TZ?_%?/2 -SG5 >]W?XDW
 _7QA^9@[%(#KWX@C?DNOTZO<>?E+I2)$]1Q<>?E+I2)$]1Q<>?E+I2)$]1Q<>?E+I2)$]1Q
<>?E+I2)$]1Q<>?E+I2)$]1QU.TS,<O6W^W4.'OH4NE#CD0X?\O6UDRZW5)_?\O6UDRZW5)_
?\O6UDRZW5)_?\O6UDRZW5)_?\O6UDRZW5)_?\O6UDRZW5)_?\O6UDRZW5)_"5J3P!;#U1H)
_R,Z-Z6;L!'_8L]KPFS8ST%BHESWO+:#(]VB6W&OD/*Y,R1;PVYU.X[#ZY/#$S"."NG*W'(3
=U<.R5*X2;EW\^O>IFI; +3S'3:I(^3?>FH= 7\3VU9%-N(!TX__N;08Z/73C,%GF])#"T&,
(CI?**-T,; B(T(JSOS)TU@C&#CZ?8@)+? 8(\" _B0Y1S C:0L9VGEAY"EIW(S ]H)NH>S<
(#G97Q(2U"@@S@8+>V;RM'C.K'<Y)0-3H2JLX3DU.^^#&?GA$!'V]!E_(NL094R.?V @FS9E
(#G97Q(2U"@@VB><YN"0NRC:V+QUUQ_QDYK8@A#&RQ1$4;B" ;ZQ!7-[.S8!!C"?&[!')PL&
JY;%U:M(QDNKUWT>95+\5\'7K'<Y)0-3H2JLX3DU.^^#&?GA$!'V]!E_(NL0]._9;03%4"GT
(#G97Q(2U"@@$@%S?)6<$HH2?2\\DJ><$EU]AK/MBSYOX0R&^="=-TP9WG3Y4K<<7"=.Y4]2
+P:3TFKMW\TO?>X9S=4DK3%]MUG -.Y_0,>WE%+5G+0[$>:4O(SX:-RJY&*\^<*6>$MN4\/Y
UY-69 ;CN';7=ACY0ZXWRR9V\KW$TCW1V0CR!:5K:1N:)]T%XM5=M3[<]17BN6$A^9JB^I2Y
L-YG:G9ELH^P277HOIYFU*I)AR?X:D7 Q6>'\^WLQQ_Y=4GSX:!^=+^]NO[AX:!^=+^]NO[A
X:!^=+^]NO[AX:!^=+^]NO[AX:!^=+^]NO[AX:!^=+^]NO[AX:!^=+^]NO[AS:7 4_&7&Q3-
T.NIGC)..ZC0<!\.].*H7C-P_ZC"'LU7V);_9,%DDDASVU!D@1XT( I#Z7"!%2UENA%RG245
AVV!A52O%F>'T4%]031N"1+1U7!+.KQ_NC;53?/%K1_(P'5-N;<734!54RJY1!^M,:2#IL)$
K'<Y)0-3H2JLP,2'$J9$%^C Y.5%6(+U78ODR?Y',BT6L.3)R<W<<43(8=3)I%@%*S"+SH.D
FWAMKOO]S-R;S]);S6,/*C;/Q:[\9S$C^[K%9CE2G3.BN>-FJ"[W_FDT>Y>H["X]4,]3)47L
$>T]873^_9D1+3;9DN.'FF@M]:J(H](5F#7U8L]KPFS8ST%B0?ADT7J-[/)!%HI$!@NVVGT6
[+; [!D1/;_LM,?'P_T[QCJT+S"-'EY''(\O2G0>_?9;S@]*T2)X9]XGA,+18_1O/0<:[;1C
H0I^.HBX"5ZA!]$IXH;@OY8']0F3Z'H/+>7U]*[5E+F3_6KT:R#4@K!XX\UK_1L\%*_\/@;]
OA8,]B/6'^F^])6;&Y%88NWT#+&Y4<?U"5P,S0IC:8-[H\C-
#pragma PXL encrypted end
#pragma PXL encrypted begin
+K9E7Q3]ZR4N\=L :J&4\Z;Q]'G;*@908$'TW)7HS.S$P'/<ZSX.U7.+,N?KBG3*TU=/B?**
)_CB;)21%9TG:VGDX&5=E5QK
#pragma PXL encrypted end







#endif

#ifdef FILL_DM12

#pragma PXL encrypted begin
I,05"HF<'ABDG*_C<&:PL3Z<(:4'G,N'AV(AZZ<5!M\B7N_K;""A"6E=R?ILT_IWV/AIPLG3
$!=%V[VDW:(0QDGK0_YIO\K&AY:;7H$U2EN'<BHD00ITZJ)R
#pragma PXL encrypted end


LAYER_DM12_MYBCELL_H : polygon_layer_s = {
    layer_spec = {
        output_layer_key = "OUTPUT_DM12_DMB_CONNECT"
    },
    polygons = MYBCELL_H
};

LAYER_DM12_MYBCELL_V : polygon_layer_s = {
    layer_spec = {
        output_layer_key = "OUTPUT_DM12_DMB_CONNECT"
    },
    polygons = MYBCELL_V
};

LAYER_DM12_MYBCELL_HEXT : polygon_layer_s = {
    layer_spec = {
        output_layer_key = "OUTPUT_DM12_DMB_CONNECT"
    },
    polygons = MYBCELL_HEXT
};

LAYER_DM12_MYBCELL_VEXT : polygon_layer_s = {
    layer_spec = {
        output_layer_key = "OUTPUT_DM12_DMB_CONNECT"
    },
    polygons = MYBCELL_VEXT 
};

// DUMMY SPEC : DM12_DMB_Connect
SPEC_DM12_DMB_CONNECT = unified_fill(
    fill_patterns = {
    {
        type = UF_POLYGON,
        polygon_fill = {
            insertion = {
                iterations = 3,
                shift_factor = 2,    
            },
            pattern_spec = {
#ifdef VERTICAL_M12
                space_x = DMY1B_SX,
                space_y = DMY1B_SY,
                stagger_x = DMY1B_OX,
                stagger_y = DMY1B_OY,
#else
                space_x = DMY1B_SY,
                space_y = DMY1B_SX,
                stagger_x = DMY1B_OY,
                stagger_y = DMY1B_OX,
#endif
            },
            layers = {
#ifdef VERTICAL_M12
                LAYER_DM12_MYBCELL_V
#else
                LAYER_DM12_MYBCELL_H
#endif
            },
#ifdef CONTROL_MAX_METAL_LENGTH
#else
            merging_layers = {
#ifdef VERTICAL_M12
                LAYER_DM12_MYBCELL_VEXT
#else
                LAYER_DM12_MYBCELL_HEXT
#endif
            },
#endif
#ifdef ANTPrevention                
#ifndef CONTROL_MAX_METAL_LENGTH
            merging_blockage_layer_list = {
                FORBIDDEN_RING
            },
#endif
#endif
#ifdef CONTROL_MAX_METAL_LENGTH
#else
#ifdef VERTICAL_M12     
            merging_direction = VERTICAL,
#else
            merging_direction = HORIZONTAL,
#endif   
            merging_length_limit = 500*(DMY1OR_L + DMY1B_SY) - DMY1B_SY, 
#endif
            fill_to_signal_spacing = {
    { CHIP_snps, min_space = DMY1B_CHIP, context = INTERIOR },
#ifdef FULL_CHIP
    { CHIP_BOUNDARY, min_space = DMY1B_CHIP, context = INTERIOR },
#else
    { PRBOUNDARY, min_space = DMY1B_CHIP, context = INTERIOR },
#endif
    { ICOVL_SINGLE, min_space = DMY1_ICOVL },
    { INDDMY, min_space = DM_INDDMY },
    { TCDDMY_M12, min_space = DM_TCDDMY_MX },

	{ BEOLBLK_FINAL, min_space = DMY1B_MY1 },
    { DM12EXCL_FINAL, min_space = DMY1B_MY1 },
    { CSR66_3485, min_space = DMY1B_MY1 },
    { M12_MAIN, min_space = DMY1B_MY1 },
    { DM12_O, min_space = 0.26 },
    { DM12, min_space = 0.26 },
    { DM12_GT1350, min_space = 0.45 },
    { M12_GT76, min_space = DMY1_MY1W1 },
    { M12_GT114, min_space = DMY1_MY1W2 },
    { M12_GT152, min_space = DMY1_MY1W3 },
    { M12_GT180, min_space = DMY1_MY1W4 },
    { M12_GT240, min_space = DMY1_MY1W5 },
    { M12_GT280, min_space = DMY1_MY1W6 },
    { M12_GT500, min_space = DMY1_MY1W7 },
    { M12_GT1350, min_space = DMY1_MY1W8 },
#ifdef FILL_M11_VIA11_M12_BTCD
              { BTCD_M11_V11_M12_E, min_space = BTCD_D },
#endif
#ifdef FILL_M12_VIA12_M13_BTCD
              { BTCD_M12_V12_M13_E, min_space = BTCD_D },
#endif

#ifdef FILL_M12_BTCD2
              { BTCD_M12_E, min_space = BTCD_D },
#endif
              { WRAPPER_DM12_O_L, min_space = DMY1B_DMY1O },
#pragma PXL encrypted begin
6""! O;LL018.B)H0U!>V%<Z>X,^18GZZ^9[G2ZIA@I:/2&=:D)U$.]^O]%J:D&.C#QT41AJ
>P= \>/YX/E[8?+*)'<9YJAAU[D;<6&$>#77_O!,J*>@L?3^U?H)Y#$9%NO58MS+CL7D(9-B
D>6>3;'VZW21#TZT+B04*1\/9HR.1@4CK$YFLX&N&HQ=5K"S.RI6Z:5222$[N+H<AGO_0$JX
#^V5_RI_@! /]Q+_8UQ1CK3WT]0W%J]XT3W36A(E@O$_P_Y:
#pragma PXL encrypted end

                            
            },
            hierarchical_fill = false,
#ifdef VERTICAL_M12     
            cell_prefix = "DMB12VNEW"
#else
            cell_prefix = "DMB12HNEW"
#endif   
        }
    }
    },
    extents_output = {
        {
            output_layer_key = "OUTPUT_DM12_DMB_CONNECT_EXTENT"
        },
    },
    fill_boundary = {
        layer = CHIP_snps, 
        type = LAYER 
    },
	grid = vGRID
);
//=======================================================
DM12NEW_C     = SPEC_DM12_DMB_CONNECT["OUTPUT_DM12_DMB_CONNECT"][0];
DM12NEW_L     = SPEC_DM12_DMB_CONNECT["OUTPUT_DM12_DMB_CONNECT"][0];
//***** spec *******************************************************************
#pragma PXL encrypted begin
1Z+H4;GYU%Q'I74:<%.SFP^E1G)0R?$NBD]&!6DLPGY5"4P%?'<]L1\Q>>)\]N2C1[QM8,OV
2_^4R$Q2@9Y+BY<.7Q. JH^+
#pragma PXL encrypted end

//***DM12_DMB***
// DUMMY SPEC : DM12_y1
PATTERN_SPEC_DM12_0 = get_single_polygon_pattern(
#ifdef VERTICAL_M12
	"DMB12V", "OUTPUT_DM12", DMY1B_W, DMY1B_L,
	step_x = DMY1B_SX, step_y = DMY1B_SY,
	offset_x = DMY1B_OX, offset_y = DMY1B_OY,
#else
	"DMB12H", "OUTPUT_DM12", DMY1B_L, DMY1B_W,
	step_x = DMY1B_SY, step_y = DMY1B_SX,
	offset_x = DMY1B_OY, offset_y = DMY1B_OX,
#endif
    FSS = {
    { CHIP_snps, min_space = DMY1B_CHIP, context = INTERIOR },
#ifdef FULL_CHIP
    { CHIP_BOUNDARY, min_space = DMY1B_CHIP, context = INTERIOR },
#else
    { PRBOUNDARY, min_space = DMY1B_CHIP, context = INTERIOR },
#endif
    { ICOVL_SINGLE, min_space = DMY1_ICOVL },
    { INDDMY, min_space = DM_INDDMY },
    { TCDDMY_M12, min_space = DM_TCDDMY_MX },

	{ BEOLBLK_FINAL, min_space = DMY1B_MY1 },
    { DM12EXCL_FINAL, min_space = DMY1B_MY1 },
    { CSR66_3485, min_space = DMY1B_MY1 },
    { M12_MAIN, min_space = DMY1B_MY1 },
    { DM12_O, min_space = 0.26 },
    { DM12, min_space = 0.26 },
    { DM12_GT1350, min_space = 0.45 },
    { M12_GT76, min_space = DMY1_MY1W1 },
    { M12_GT114, min_space = DMY1_MY1W2 },
    { M12_GT152, min_space = DMY1_MY1W3 },
    { M12_GT180, min_space = DMY1_MY1W4 },
    { M12_GT240, min_space = DMY1_MY1W5 },
    { M12_GT280, min_space = DMY1_MY1W6 },
    { M12_GT500, min_space = DMY1_MY1W7 },
    { M12_GT1350, min_space = DMY1_MY1W8 },
#ifdef FILL_M11_VIA11_M12_BTCD
              { BTCD_M11_V11_M12_E, min_space = BTCD_DY1 },
#endif
#ifdef FILL_M12_VIA12_M13_BTCD
              { BTCD_M12_V12_M13_E, min_space = BTCD_DY1 },
#endif

#ifdef FILL_M12_BTCD2
              { BTCD_M12_E, min_space = BTCD_DY1 },
#endif
              { WRAPPER_DM12_O_L, min_space = DMY1B_DMY1O },
#pragma PXL encrypted begin
!&1?&6FX)VP$+9P6X&$#L?TM!T=AE]'4230'18G=\J):6;!%L:#9>->N[L*QGRH;WXN$!\R?
 $%",P(FWXD Y[1/@LS#HL+G0LWM9HVFXYI"(O#HR[!,*+$B
#pragma PXL encrypted end

              { DM12NEW_L, min_space = DMY1B_DMY1 },
#pragma PXL encrypted begin
Q]A;2#DNV@S'I;Q-,,@]%VZECCTL<V!0UR".;!>(F*-)QW1L],6E&UI,X+CTK%2B-!5[A]VL
Q1.B9UA4NZC%B:0+)?:V#BF)
#pragma PXL encrypted end

    },
	shift = 2,
	repeat = 3,
    starting_point = CENTER
); //end of get_single_polygon_pattern


//-------------------------------------------------------------------------------

//***DM12_DMS***
PATTERN_SPEC_DM12_1 = get_single_polygon_pattern(
#ifdef VERTICAL_M12
	"DMS12V", "OUTPUT_DM12", DMY1S_W, DMY1S_L,
	step_x = DMY1S_SX, step_y = DMY1S_SY,
	offset_x = DMY1S_OX, offset_y = DMY1S_OY,
#else
	"DMS12H", "OUTPUT_DM12", DMY1S_L, DMY1S_W,
	step_x = DMY1S_SY, step_y = DMY1S_SX,
	offset_x = DMY1S_OY, offset_y = DMY1S_OX,
#endif
    FSS = {
    { CHIP_snps, min_space = DMY1S_CHIP, context = INTERIOR },
#ifdef FULL_CHIP
    { CHIP_BOUNDARY, min_space = DMY1S_CHIP, context = INTERIOR },
#else
    { PRBOUNDARY, min_space = DMY1S_CHIP, context = INTERIOR },
#endif
    { ICOVL_SINGLE, min_space = DMY1_ICOVL },
    { INDDMY, min_space = DM_INDDMY },
    { TCDDMY_M12, min_space = DM_TCDDMY_MX },

	{ BEOLBLK_FINAL, min_space = DMY1S_MY1 },
    { DM12EXCL_FINAL, min_space = DMY1S_MY1 },
    { CSR66_3485, min_space = DMY1S_MY1 },
    { M12_MAIN, min_space = DMY1S_MY1 },
    { DM12_O, min_space = 0.26 },
    { DM12, min_space = 0.26 },
    { DM12_GT1350, min_space = 0.45 },
    { M12_GT76, min_space = DMY1_MY1W1 },
    { M12_GT114, min_space = DMY1_MY1W2 },
    { M12_GT152, min_space = DMY1_MY1W3 },
    { M12_GT180, min_space = DMY1_MY1W4 },
    { M12_GT240, min_space = DMY1_MY1W5 },
    { M12_GT280, min_space = DMY1_MY1W6 },
    { M12_GT500, min_space = DMY1_MY1W7 },
    { M12_GT1350, min_space = DMY1_MY1W8 },
#ifdef FILL_M11_VIA11_M12_BTCD
              { BTCD_M11_V11_M12_E, min_space = BTCD_DY1 },
#endif
#ifdef FILL_M12_VIA12_M13_BTCD
              { BTCD_M12_V12_M13_E, min_space = BTCD_DY1 },
#endif

#ifdef FILL_M12_BTCD2
              { BTCD_M12_E, min_space = BTCD_DY1 },
#endif
              { WRAPPER_DM12_O_L, min_space = DMY1S_DMY1O },
#pragma PXL encrypted begin
NPU)?QWR7':[10N'E[;*\6A%_KTV?[PD#''^C+X;&:;3E#&,9CA+D?O= 25FA%A+D.;^IH*$
Z8[PK2>N@/?I%**_=E35;_84^SK]6I.G$1[[>)X=H( O/+EX
#pragma PXL encrypted end

              { DM12NEW_L, min_space = DMY1S_DMY1 },
#pragma PXL encrypted begin
1P_//KEBWSQ'D4>VC6Z]G.>1=7.%$^5FJBUUCADI/TB3.">.,KYF/Z!L6W<RXSN]1PEG@?OC
0#N+YIVMD(M E5F$Q03]B#J5
#pragma PXL encrypted end

    },
	shift = 2,
	repeat = 3
);


//***DM12_O_R***
PATTERN_SPEC_DM12_2 = get_single_polygon_pattern(
#ifdef VERTICAL_M12
	"DMOR12V", "OUTPUT_DM12_O", DMY1OR_W, DMY1OR_L,
	step_x = DMY1OR_SX, step_y = DMY1OR_SY,
	offset_x = DMY1OR_OX, offset_y = DMY1OR_OY,
	setback = DMY1OR_SC,
	setback_type = INTERSECTION,
#else
	"DMOR12H", "OUTPUT_DM12_O", DMY1OR_L, DMY1OR_W,
	step_x = DMY1OR_SY, step_y = DMY1OR_SX,
	offset_x = DMY1OR_OY, offset_y = DMY1OR_OX,
	setback = DMY1OR_SC,
	setback_type = INTERSECTION,
#endif
    FSS = {
    { CHIP_snps, min_space = DMY1_CHIP, context = INTERIOR },
#ifdef FULL_CHIP
    { CHIP_BOUNDARY, min_space = DMY1_CHIP, context = INTERIOR },
#else
    { PRBOUNDARY, min_space = DMY1_CHIP, context = INTERIOR },
#endif
    { ICOVL_SINGLE, min_space = DMY1_ICOVL },
    { BEOLBLK_FINAL, min_space = DM_BEOLBLK },
    { CSR66_3485, min_space = DM_BEOLBLK },
    { INDDMY, min_space = DM_INDDMY },
    { DM12EXCL_FINAL, min_space = DM_DMXEXCL },
    { TCDDMY_M12, min_space = DM_TCDDMY_MX },
    { M12_MAIN, min_space = DMY1OR_MY1 },
    { DM12_O, min_space = DMY1OR_DMY1O },
    { DM12, min_space = 0.2 }, //DMn.S.3.5
    { DM12_GT1350, min_space = 0.45 },
    { M12_HOLE, min_space = 0 },
    { M12_GT76, min_space = DMY1_MY1W1 },
    { M12_GT114, min_space = DMY1_MY1W2 },
    { M12_GT152, min_space = DMY1_MY1W3 },
    { M12_GT180, min_space = DMY1_MY1W4 },
    { M12_GT240, min_space = DMY1_MY1W5 },
    { M12_GT280, min_space = DMY1_MY1W6 },
    { M12_GT500, min_space = DMY1_MY1W7 },
    { M12_GT1350, min_space = DMY1_MY1W8 },
    { M12_45, min_space = 0 },
    { VIA11_HVN_5V, min_space = DMY1_VY15V },
    { M12_HVN_5V, min_space = DMY1_MY15V },
    { VIA12_HVN_5V, min_space = DMY1_VY15V },

              { R7_VIA11_CHK_REGION, min_space = 0 },
              { R15_VIA12_CHK_REGION, min_space = 0 },

              { S22_M12_REGION, min_space = 0 },
#ifdef FILL_M11_VIA11_M12_BTCD
              { BTCD_M11_V11_M12_E, min_space = BTCD_DY1 },
#endif
#ifdef FILL_M12_VIA12_M13_BTCD
              { BTCD_M12_V12_M13_E, min_space = BTCD_DY1 },
#endif

#ifdef FILL_M12_BTCD2
              { BTCD_M12_E, min_space = BTCD_DY1 },
#endif
              { WRAPPER_DM12_O_L, min_space = DMY1OR_DMY1O },
#pragma PXL encrypted begin
DC?3/]]?<@:2U@0,<=-CYN'65 7L4_VQ.%]4-E@7FL6\7C(VB.M-H>G)>(Z(XZ_EK$%:Z;SC
BR=/ V2?,.R+/74WE_2XAVX] >AQQ-)1)5\!__)O,C7+AJC_
#pragma PXL encrypted end

              { DM12NEW_L, min_space = DMY1OR_DMY1 },
#pragma PXL encrypted begin
BQ]&7N3:5 &+SJQZUJ-/D>'.FC[;_,RU$M*:O?&V0[>&$16],6N@=8XRI\$Q6!95/FSLYQ=8
>I!T-%R2)9MZR)G=/+U&J(W(
#pragma PXL encrypted end

	},
    shift = 2,
	repeat = 3,
    starting_point = CENTER
);

#ifdef VERTICAL_M12
PATTERN_SPEC_DM12_2.polygon_fill.pattern_spec.pattern_spacing = {
    allowed_spacing_x = { >= DMY1OR_SXA2 },
    allowed_spacing_y = { >= DMY1OR_SY },
    extension = INTERSECTION
};
#else
PATTERN_SPEC_DM12_2.polygon_fill.pattern_spec.pattern_spacing = {
    allowed_spacing_y = { >= DMY1OR_SXA2 },
    allowed_spacing_x = { >= DMY1OR_SY },
    extension = INTERSECTION
};
#endif




//-------------------------------------------------------------------------------
//***DM12_O_W***

PATTERN_SPEC_DM12_3 = get_single_polygon_pattern(
#ifdef VERTICAL_M12
	"DMOW12V", "OUTPUT_DM12_O", DMY1OW_W, DMY1OW_L,
	step_x = DMY1OW_SY, step_y = DMY1OW_SX,
	offset_x = DMY1OW_OY, offset_y = DMY1OW_OX,
	setback = 0.114,
	setback_type = INTERSECTION,
#else
	"DMOW12H", "OUTPUT_DM12_O", DMY1OW_L, DMY1OW_W,
	step_x = DMY1OW_SX, step_y = DMY1OW_SY,
	offset_x = DMY1OW_OX, offset_y = DMY1OW_OY,
	setback = 0.114,
	setback_type = INTERSECTION,
#endif
    FSS = {
    { CHIP_snps, min_space = DMY1_CHIP, context = INTERIOR },
#ifdef FULL_CHIP
    { CHIP_BOUNDARY, min_space = DMY1_CHIP, context = INTERIOR },
#else
    { PRBOUNDARY, min_space = DMY1_CHIP, context = INTERIOR },
#endif
    { ICOVL_SINGLE, min_space = DMY1_ICOVL },
    { BEOLBLK_FINAL, min_space = DM_BEOLBLK },
    { INDDMY, min_space = DM_INDDMY },

    { DM12EXCL_FINAL, min_space = DM_DMXEXCL },
    { CSR66_3485, min_space = DM_BEOLBLK },
    { TCDDMY_M12, min_space = DM_TCDDMY_MX },

    { M12_MAIN, min_space = DMY1OW_MY1 },
    { DM12_O, min_space = DMY1OW_DMY1O },
    { DM12, min_space = 0.2 }, //DMn.S.3.5
    { DM12_GT1350, min_space = 0.45 },
    { M12_HOLE, min_space = 0 },
    { M12_GT76, min_space = DMY1_MY1W1 },
    { M12_GT114, min_space = DMY1_MY1W2 },
    { M12_GT152, min_space = DMY1_MY1W3 },
    { M12_GT180, min_space = DMY1_MY1W4 },
    { M12_GT240, min_space = DMY1_MY1W5 },
    { M12_GT280, min_space = DMY1_MY1W6 },
    { M12_GT500, min_space = DMY1_MY1W7 },
    { M12_GT1350, min_space = DMY1_MY1W8 },
    { M12_45, min_space = 0 },
    { VIA11_HVN_5V, min_space = DMY1_VY15V },
    { M12_HVN_5V, min_space = DMY1_MY15V },
    { VIA12_HVN_5V, min_space = DMY1_VY15V },

              { R7_VIA11_CHK_REGION, min_space = 0 },
              { R15_VIA12_CHK_REGION, min_space = 0 },

              { S22_M12_REGION, min_space = 0 },
#ifdef FILL_M11_VIA11_M12_BTCD
              { BTCD_M11_V11_M12_E, min_space = BTCD_DY1 },
#endif
#ifdef FILL_M12_VIA12_M13_BTCD
              { BTCD_M12_V12_M13_E, min_space = BTCD_DY1 },
#endif

#ifdef FILL_M12_BTCD2
              { BTCD_M12_E, min_space = BTCD_DY1 },
#endif
              { WRAPPER_DM12_O_L, min_space = DMY1OW_DMY1O },
#pragma PXL encrypted begin
,^[F$&S(5SPSTN+K875H9WC2B@8OO2*AY1N*FZ^ C?9+$$6;,HEL[[N*G@DRV7Y;T1^<Y.[9
V5YZL:5S$[396)W,+LN.Z^U86D*\N!R)KHA:9%&RMGG^@$-D
#pragma PXL encrypted end

              { DM12NEW_L, min_space = DMY1OW_DMY1 },
#pragma PXL encrypted begin
B7SV8-,SJBB)&3,=[QOR<%D9KO>S_?JG!.BN-$@M1#>3(:8T^TI[C@X$N^+[B$B"GKB]U5R(
OT\&[:0^80"_F@[D8)\*G\2:
#pragma PXL encrypted end

	},
    shift = 2,
	repeat = 3,
    starting_point = CENTER
);
//=======================================================
PATTERN_SPEC_DM12_0.polygon_fill.pattern_spec.other_pattern_spacing = {
    1 => > DMY1B_DMY1,
    2 => > DMY1B_DMY1,
    3 => > DMY1B_DMY1,
};

PATTERN_SPEC_DM12_1.polygon_fill.pattern_spec.other_pattern_spacing = {
    0 => > DMY1S_DMY1,
    2 => > DMY1S_DMY1,
    3 => > DMY1S_DMY1,
};

PATTERN_SPEC_DM12_2.polygon_fill.pattern_spec.other_pattern_spacing = {
    0 => > DMY1OR_DMY1,
    1 => > DMY1OR_DMY1,
    3 => > DMY1OR_DMY1O,
};

PATTERN_SPEC_DM12_3.polygon_fill.pattern_spec.other_pattern_spacing = {
    0 => > DMY1OW_DMY1,
    1 => > DMY1OW_DMY1,
    2 => > DMY1OW_DMY1,
};

SPEC_DM12 = unified_fill(
    fill_boundary = {
        layer = CHIP_snps,
        type = LAYER
    },
    fill_patterns = {
        PATTERN_SPEC_DM12_0,
        PATTERN_SPEC_DM12_1,
        PATTERN_SPEC_DM12_2,
        PATTERN_SPEC_DM12_3,
    },
    boundary = ALIGN,
	grid = vGRID
);

//***** fill *******************************************************************
DM12_C   = SPEC_DM12["OUTPUT_DM12"][0];
DM12_O_C = SPEC_DM12["OUTPUT_DM12_O"][0];

#pragma PXL encrypted begin
-OX<>WS8#'4VNI0G/+])5FRZ)K?$&M? >JTFD.6'M+;WJ).0G*\( [SP/<R<7H4/Y=_E!.=>
E.0+Q528'.24$-_F4;)AN[,05STR\TY>:4E7<.A4K]U.4Q)P
#pragma PXL encrypted end

#pragma PXL encrypted begin
51FV6Z\^+P=5L; C,EY%4(^QE^1L-Y0"H2N7>]$;T*1:#:1[VH#(S49QI9O:5$="R\"]8V54
+$_#A":+?P$L*%#;FV'6F$PHZG=R:=>_\/CJ=+VX4% YFX-T
#pragma PXL encrypted end
#pragma PXL encrypted begin
JJ?%*Q>J@7.J\E'/TL3_Z.KR_3 U>]>;9WW],-YM($364-HPOA>%D MZ*\2^3,8XQ_>\/=],
$NTL=VV])SD2,JMIR(\Y[U\R[KRD3X>*S!+NBII]4 ,;_#J* IC=N)8),;X"/;89!^"Y'94]
#pragma PXL encrypted end
#pragma PXL encrypted begin
R<)>#$H0I 7).V(4M/7D[7T[2.1ZV1[Q]#I(2LO!K)7DLFM*!D ESWO*XHP&)::2+V$/("XE
$9+[Z7&[J0P1
#pragma PXL encrypted end
DM12_O_L = SPEC_DM12["OUTPUT_DM12_O"][0];
#pragma PXL encrypted begin
>_<*#A1L9F-[/ 6!)*CCH[(\H!'+++..<D>@";$59FC!L+ )$C+3Y-]#60L22'=F'VS#TOU(
%:.9C-1BWL 5QM#:14P'5]/&
#pragma PXL encrypted end
#pragma PXL encrypted begin
/FP'/>3A& 0^!;,6Y[&BC!<%Z!HJTK;0RY[H J-5**>@;8H"%B%9]'5RIY86G4;.6-DJL R=
C>!X!BRA1<F-[Y1=69+W+(WOD9YP!:[3/KF1<AR]%&$$GF9RQZK$26]9\$G'3-[=O1^IF$1,
WV:C8-+VIHO?._-]" LWC-D[
#pragma PXL encrypted end
#pragma PXL encrypted begin
D_H6#4Q-:W"3$=L1GGZ7&>H1 QQLJ"M0RCH#7#G//S2;!%Q<2U@HU&@5$&E+\B&_>\6,!?SR
ZS+=K^F7)"7K,E57."'GM]LR.P!5".=_>0T[-9/%0&)&C^@U
#pragma PXL encrypted end
DM12_L1   = SPEC_DM12["OUTPUT_DM12"][0];
DM12_L = DM12_L1 or DM12NEW_L;
#pragma PXL encrypted begin
Z8@F7;.XO5SIUB/];9#UT'W6E_B;?2K2]G>7!7Y4E>B.X-$%SF%.RS;-[AK.YIH?GTSBJHGF
YF@QSRE1P>KF(_4#CIF) G C/\K?AI)9'P,_I6@_6TR$]U*EAX>TOR17_NB'\.%'%%9,NECP
3="MC.Z9+75-
#pragma PXL encrypted end


#pragma PXL encrypted begin
/A<V+1LD$$D^3?-VS3?LXCQ-*N_]P)E2BWXJAKYVNY:__8Z&?WGQ&$ JZ1I_V.MP] O3<:C8
;SK _K"2KRMO7X(M1#QU1U!?6__-]W$$>P!;6JH,T:%6G9Y:
#pragma PXL encrypted end
#pragma PXL encrypted begin
\$OB+N5_TB;PBA5BEM&,ERZ*0(J5![RTCX9 JIEX(-OK8B>JF$B&>#+4'#*8I[Q57PQCW8"G
X\$#:9HZI8_C-O&SQ[ZH3$<VPKAE2*N31K;"'<^\JCFQU>P=]$0/WR>!3E?TZJ.%JB[?:1/J
X#)0?N@<)+;@..K8!6[&:M0X(1OL*&^YO'\A/T[ 0++6<0\_L61T)^^286BQ1^$GXMR7.WI'
'YYX:L@-68<?<;RYP 6S:FAQQ._T8(#)$]'$W4&<ZMG;HSW=OHYA;UV+6C*^FE."ME!*:5R:
"D>RE3<CFYT*O'RL+YR)^'^\8)1PP/K3(U=@\94X*9@ZS.CQ7TZ^UVV;#A9?!P!J>SJA]9H'
/@01J#5#C>H^3RWP& V(Q+M/J;@@69)I 6VI%OGOEH/B\B86]4R+OF',&]?U-^4#D96%*[ W
<\621#EH.M]S$96V+5__X)81R'YJR@5-4$O(J;@@69)I 6VI%OGOEH/B\B862).]6^BIP-9(
-^4#D96%*[ W[M5E$09 Y'7N-C?(;#.M;D V=22R$GH$,6]UD":>)8[UE!V0HE[=[I< 2="B
!P!J>SJA]9H'QB!. &?]C_?&)[85&^P+^RTGD(;='/WIB/V0Q<YVS/$^U!_%?AV!&\6(F,9^
OMM.? $8*L&^+=<Y&PX/ 1PM4^^2]BT-1,53E+K. W'%=V:4T+1A6K]^"&;0,W1=?1D)B+LS
\_<"+\,.!$CSD#XE<[($5/B0#RL;>A 1=G$/!P!J>SJA]9H'KF'[Z#RM.(*N-^4#D96%*[ W
0EK<FQ?:9LQ"_;9 @JPM"VS]@M>'K@]?VF2"$V:7+Y3QD583=C(;,^!3AY5V"]]=:A ':.<+
]T5%^NOZE/?W>LP<?C0$X3]ZS+.56!?@\-[,9LC_1V=RD/IF2K^,VL>$X M*XXKE.*L0!USC
"*^$D=03$T4(!P!J>SJA]9H'_IU9<#!\=@_^'I] E[4XXE(>:@<4Q'1!]U%J\8=#C@IB'%_Q
.HU(P@U /%(Z-E4U!C)-AB\VM]@Q<GM<7C"W4F,3_Y2T,AY2PP3KG]-VS;3#C6\:824=>Z*-
<<*]!A^O?F1Q^O"BFVX.0B[ZA/(5S4_$Z<^$5C+2T%@:6#A68LR !YFC495B-4)D1.O3YJ8U
&JOU!\)%E^T:2'4;?.LUC3I(B@>K#P>H8,.*N;K(S'6FJ!FY7$$78+:EPUQ<UJ6S,SGKI876
$T5Z78X\E,838+?BC2M""G9@#Q5H[R^3S.P/M]@Q<GM<7C"W4F,3_Y2T,AY2PP3KG]-VS;3#
C6\:824=>Z*-<<*]!A^O?F1Q\4DZV\]YA_#Q4YUJ@.F*#5!3!830H$B1O6(%(\-HS:Y.((4C
M]@Q<GM<7C"W+WSX?28RC"8O#'\$6OG1'OP,PFD.^GGYE&C"P@!,SFX(N,_"%,7G99F+=<D4
_YQ#KU+?*RK_2B-.:$/5@'5*4*DLI #W_\E0C;F\G/Q Y>6-(E0(>,<1+'XB&JOU!\)%E^T:
89ULD2;_UGQAH$_W((4A%+F@V-0TZSJN>N+8CSXP327GP76/&JOU!\)%E^T:RFF=FKBS'B+*
!?6)WI;[),H%\=+U;\0L)R/Q<];Q_1:*+@5S:*EGI9<BF0]H(J@[O4;5;8,B8+>Y-288!KY@
[(B",.507'CL=Z7-AY+J&\9WJ =&ZA(-J*NH=Z>=I(K)NGIWNI@70C<'1C6Z/3,0EHX+IGD]
5G99]\[_$HU6G:2GI9L#YV>='G8]&Q; N"\>(J@[O4;5;8,BZNN@M3[:?__J2CT&3M^"F%Q*
E_$P/4) ?1F7FWU NA*EH>6;E3/-SQ[R0!>5#AR:?N^+M6P.04LZ2-OTVRU!:P@8 8C;J0UK
^C?YP=S@9#'ZE3/-SQ[R0!>5<\I5KHT^Q-9S6?AYU$]$TOA9!MK)]Y9>0W,&H2&%-:$,^L*A
)<4/",P0+B(E*JI)6[[QT64JM]@Q<GM<7C"W'<G)E[/BRZT=B9_ %RDHK(V)@B<\FH'%:0*"
=AL@U _%&,]V,&T<\$D=-@0PHW$>FSTQ>=ZC1":8OX23Q^Y$E3/-SQ[R0!>5#AR:?N^+M6P.
"=-;?L4MZ <)-R#:1L;F2^4WG:2GI9L#YV>=MVO[2+@I^*2W&JOU!\)%E^T:2'4;?.LUC3I(
R63M7KO\?!O)HW$>FSTQ>=ZC!E;#PN!;\OH&=Z>=I(K)NGIWNI@70C<'1C6Z"[-K9>CUH%4+
^/"'F ..=4SX!&29>K_!);$$"T\%Q2XYPX0+D2S$E52AGP:1D-1,'M)_@>60R69OB=<85N#)
75M!"LTW5EU=M?#$D"];",RU=AL@U _%&,]VOQ%F5;3>3=*__)LVW39R;#7\_V=95(:ZL>+_
+SL8I!Q(8H8O?W:N(IT/$?=__YQ#KU+?*RK_6(=0L;(0>O!8Q;E]'RAGW93%)LC&E.>=FWDF
@B:#+=31--V"(J@[O4;5;8,BB)QZYOFY)[:(%3H6M6O7OU85B9_ %RDHK(V)RF[R9$WIT??*
=Z>=I(K)NGIWNI@70C<'1C6Z]*$ZSP\G9>KT^/"'F ..=4SXOP&WA#L0,^B_=Z>=I(K)NGIW
*]LJEM96^.4KE_$P/4) ?1F7']VK91 [AT<?E3/-SQ[R0!>5#AR:?N^+M6P."=-;?L4MZ <)
:FVYY[>>1^QJ .-.SRR8HP4 PWGJY-0Z;OS#8K AQ49<;=IB?W:N(IT/$?=__YQ#KU+?*RK_
D":>)8[UE!V0<-Z"U>+]TUAP[NSL!O! 90+N'C%B$<D[OU0>HP8LW@9K"=.CDUT- SK&#KJ3
WL;9E1+FQP?>_YQ#KU+?*RK_BW(%(=KS'AV+J4()F_OK/*.ITN56(TS*.$O2??I<D/.8&#A]
&JOU!\)%E^T:2'4;?.LUC3I(W>2E[D&B[D7=,:R=8'$&NP8QS%UA_F<6N=K,Z[H&C[!0T=_K
D2S$E52AGP:1^N5" QF4Y;'Z7YO 4Q:O(1U?4D]U"$%,'OA2A6L$F0A(2?R%1T4Q35$8,F5'
UZ-%?;= ]277E3/-SQ[R0!>5>1D'/4"/3SYYD":>)8[UE!V0Y 8D/!8[^\WD=AL@U _%&,]V
:7L*]' >H29I-^4#D96%*[ W'+&QX-$&<F$<GC2Q:R]4I&B>=:)3S@:$N31UU>\2O-FZ/:K5
D":>)8[UE!V0Y 8D/!8[^\WD*F%F4'0&"ITJDB;+$I/;3UZ2F>S ;O^C:0"9^[SP'.#5WB'[
;UIFT@B-OD1OE_$P/4) ?1F7I'I[T-V0HP:D=Z>=I(K)NGIW5K.VT7,6Z;I6!P!J>SJA]9H'
4H-9<B IG#U2E3/-SQ[R0!>5V6RU7@?.,CK9D":>)8[UE!V0ST3"9<2>8('/*:+)^+GN2=0I
G.CW6'FD& N<!'-?MQFAY \$!P!J>SJA]9H'4H-9<B IG#U2V=R=TKH6&1+9W<_CT.*KX9#=
F^]:>Y#K49F;"=-;?L4MZ <)HR/;5DP^H5JCUJ6S,SGKI876$T5Z78X\E,83@B4H?V,0SX:"
=AL@U _%&,]V7EM'IW?K1K=>-^4#D96%*[ W'+&QX-$&<F$<%,7G99F+=<D4?R_-9C&Y$]5_
%OGOEH/B\B86F_?0ZN9?P2*;J<#72^[T96&I9E_U!)6,M/MFV#U7U.XCKR'8-^4#D96%*[ W
'+&QX-$&<F$<GC2Q:R]4I&B>=:)3S@:$N31U#7IZ<E"RW=<-D":>)8[UE!V0/C0>!M,H>Y4^
_V=95(:ZL>+_"KTILDF:!@L*E3/-SQ[R0!>5>1D'/4"/3SYYD":>)8[UE!V0ST3"9<2>8('/
>2O,_5Z7Z\1Y=J.$G@71+[1VZNN@M3[:?__J. 1YVST'9-$XR[4XEXE/Z![+=:)3S@:$N31U
U>\2O-FZ/:K5D":>)8[UE!V0ST3"9<2>8('/*:+)^+GN2=0IG.CW6'FD& N<V7PAP,L=]P_9
!P!J>SJA]9H'^X*A26SQS.[[LT^W>RKZJXVSY5<Q^&?UYWCEIO'U<=8+D[RF+HM+Q>$,A44N
I@N)#!_1N?2F(J@[O4;5;8,BTYU1QP<?:C73*/=.,AS!L#HHIO'U<=8+D[RF0[_<_+GK4$!#
?A0G_RK8W5]^QP*QB?9@Z2/'=AL@U _%&,]V,&T<\$D=-@0P'VHG72LQ>ED?Y3=4$C&K,8OE
5?B+SM;#UNY5Q*1S)S_ ^)7$[W6=9,[:8_[O&JOU!\)%E^T:V3D5.J"D_K/9'VHG72LQ>ED?
Y3=4$C&K,8OEZ4C[IP<T?^CIM4-[32($PV>UE3/-SQ[R0!>5(O+NGXNZ,>\B7V6>ORRVA+I?
D+[UNCG:J8V0K9BF4NV581>ME.&94LRB&JR4'VHG72LQ>ED?Y3=4$C&K,8OE'[6AHJ2P! X?
%N=Z9KO.Z+P6A3U>D%6.IQ:%D2S$E52AGP:1*AP'A2?%R"DJH(CZXA=X *2@T5I_J<M14OK1
BU9":29<7Y.+A:N&HM]0B4.%E.>K07 D?A.4D2;8FZ8LUF"1IO'U<=8+D[RF@<8+90P)CAR!
5U<16IV-@;I7476779%:[J91&JOU!\)%E^T:O1S)E2L0['*],=P++<O0S-DQA;(J3FM76;F%
P _@"R*!7._ M&CM/7Q4;3FT$+^95 )E9H,0IO'U<=8+D[RF1J?<)_A><%I&6KV0*Q=EBS%:
E3/-SQ[R0!>5)IH9[ ?G-+TFTD&IX09!C*O2\4DZV\]YA_#QIO'U<=8+D[RF$;L([!P0* D1
"Y/&CR:,DVP+8D%*'$@4=(%BE3/-SQ[R0!>5#AR:?N^+M6P.04LZ2-OTVRU!:P@8 8C;J0UK
IO'U<=8+D[RFG*EP>M -I=&<V^Z:T?-4GXG;&JOU!\)%E^T:/79Q!&U3'.8]K C@@^*/1@BL
*/=.,AS!L#HHIO'U<=8+D[RF+R>.GJQ/V2@O=Z>=I(K)NGIWNI@70C<'1C6Z2&;@&NBM!?M(
9I/*6X(2^[QF>W*8_<)/W>)[YGS\_TDF*03FL+RTZ4[LV]FPY3=4$C&K,8OEM<E(5Y5COK^U
=AL@U _%&,]V@M8J>G% &_>"9C3M$S,**(QF^MI97=0"=4KZ#P:Z_(2!//P/+/*!Y[H.0ATL
^/"'F ..=4SX&1!4]3%O51 9EIHB45:=XA.68\@J3ZK<JZ]C3RVP3Z#\J_1/IV R0(3F74*G
D,H!&+)'V"B0R>^'96ZS#P')1(;[-]'Q8S)$13M_66A,OG)%Q4E "^D*V>3%U%66& ZS=_W4
\4O3@A()89#Q7M@$;3*!& 1>&S6R<,$;O[\;G\HDT@]9$S:?G\HDT@]9$S:?G\HDT@]9$S:?
G\HDT@]9$S:?G\HDT@]9$S:?G\HDT@]9$S:?1,+<#V=(Y0A$J)/0:EYR0]>H4:Z[\&L"4*E1
OI,WFI/#[V>^!=H1\]CET4\%> Q),;X[P@QX:O*ML'A0'*5J&@XT+D7Z9JD:&^;%&SRZ)(8;
2=;[7YCG%09)4D]U"$%,'OA2A6L$F0A(2?R% 32+@+L8!/<!+NDS],;/SR$NY[9!RU8N5GKG
IVZ4#L+XMR*G!P!J>SJA]9H'ZH8;!=<C<%OJ%OGOEH/B\B86L"("2)._CD^P^/"'F ..=4SX
=&F4+_!^X6AT7[Y:7?[,*SQ?H"$'^(SG"VN@%OGOEH/B\B86D]?$FFL!^R63$96V+5__X)81
Q,M6O>DL]A;$]!%>T+R7QG7T[="!CO%T(7OMN[&R*->''0^[UJ?(LG. 3XW6^/"'F ..=4SX
=&F4+_!^X6AT7[Y:7?[,*SQ?>WLC2C8>?4E[%OGOEH/B\B86(K[3S#L0@)XBZNN@M3[:?__J
"TOB5F/-EQH+>TPW3A=B3#U[#0NI@U2]>74-5VOU$X\U\^A7W<_CT.*KX9#=BC1!_3^]9D>*
$^^;8Q[7:?(3,;!U)?9L7+<Q+53OC]%A0T8MDB;+$I/;3UZ2F>S ;O^C:0"9>-%L*P'@">AX
* 6.D=TH;/,H^XWEC!833&_[G>H[$ 5#)C"=&<96)U,5M8D99]>OB!-1+ 1GO^JT1S' !;N_
,9R#:=HMMU<Q3#=I;]HI^$I,A!G.N+WUJQ"$W307):<3R1'=%VKQ;"@:7P 7R>ADY,>$-X?)
V'??XI61 ^K8Q3K\=!'L&B?%]BO%8V.VTI_V_V=<(!GJ!D7_A"C\1@LMJ,2$;SCB7@\'TN9O
6Q&VFG?[5:);KRB%AD<OD9>O'1HWU"'+IU4=LB7!CU+J(1*R4Z1#V,"AFJ13I466.EEL*5ZE
C>:'/+R\N.R-WO5LUD&OTV3>Y04G/8XU,-;E>WPU/BZ:V/U[*BSW?I%W&O JFNT^#8-!7MN:
ZPKQ?8%!A4SK;7<WD>6^[1YMEZA:1QS6VF67;"3K<C/?[IQLXLNDRP4 $\;B<X#Y+EZ($5QS
B1>-<D\LW]2)RX[,#^FU(6W+1W6#1C3UO_)'-X+D1X+O"%$WOW)<ETPPEL*_C&A@Q0^G_(Z,
:1*>/1R^:L)I8#]C&2H6I4U@Y?7I.W= T6KE*T),D-\I>T4KJ9;%L#5D[V&I$JY'0?ZHT?P2
S4I^3;X :C/-UXPW*+[VS@S7'<(0ES0I\%T=-@<M2QCYQIPVO;74O%0XJ@Z]D)<$C0-G1;V0
-@<M2QCYQIPV4)<YM)(!F;Y0^9"3RKZ*4K_YT+_)/S8G"/G02B^*^=.,I;%*VO-641@34"#:
W0SDQ!HJ)*G=^^ .@,M:8P[[_;9 @JPM"VS]18-G1F#X@QQ%9T2\2"NR%>)G4NF \[<!9J]2
13M_66A,OG)%IZAK>0/O<,NG,BFNF651(#@RGZTMCQ/T4P^?=N-8.<>\;D%VI #^G:K_+.6D
$#1\:M3"WV(0>9$GP/4#S4AY(-[P(%*_<>,@!YQN#)H30%,'N/NRDW-=U'^X!9:!#">+-B %
$0J;_MY3Y*H1%/)F<4$&[MP4$?J$7(V)W=\1&-N?S:RW-=<8S2Q$S"C^E5_- U(C87&J/<8#
 U(C87&J/<8# U(C87&J/<8# U(C87&J/<8# U(C87&J/<8# U(C87&J/<8# U(C87&J/<8#
 U(C87&J/<8#2K !9#"!Y;1*!/\'+K\F6B@$W*8 NS"-B6S<KU%%. *VN66O!KP@QH3'6/T&
2]$B((<Z/81+"7 Q^;(*<'H)$J'OTIHA(-42@46\AZ<)YYV!2'_C9Y@P%^](BX?8I4 J7(N+
EG,0A?H0K[B6PUC^^X2&I@?#=IC>V&99;:MV6"_<E@9[93]8Y&V7=2[H<:+DD1L)3R"5*R:1
5P0#7T0<@%Q7Q6EI^+U4$>K%_;"3I?=!K3[].=W)NA5.(KTY*N9B9!IX[,<JLG\O"%$!'W&R
3RI!G=C)(IA/HO4I/RZTC92BZP)XJ$/\"B;K/[)7>]\L>*,_JE5UKF]AP(BJ!W4\\]H9)^,'
N!JG.,<JG8>X*A23>_?R.GXJ&#R"0"X*,KP8KVN$<G,R%P&ORV7C"";<_CK+=YD*'(7KLR)W
AAS6^"C0+/B&B>[RDV#C%8N)"Y/&CR:,DVP+50G*#6IJ"MA5IM?.9 Z17?.FE5'?(?WQUTR5
A"_SE/>@AZ*$:^UHL:BPBF-K/=MFAW (UVX]19*I*+W)PU]%*CX=M'(+^MDJ^ZU)MOI?RDS[
Y\9B2E7W")'G,XG$6B@K->,SBVI'XV?<JCF+'-_XH2G%CO8<S6"P,6=O73C-D@\ 5,"QL2B2
+1: D=Z-]P(MF'0[<#@X\1*84Z1#V,"AFJ13=^&"P02IC@1WS\1HM'C( Q+/J$:*70JS[):H
[W;74'4)B*COCNUU^I7Z)N&.X+[7SEH&TX'@QO<R$B\_(Q;&7*$OZD:VW@-<Z3SAH@YUL/CI
QTC(%)XUX:S'-2/U6 J(CR$UIJ,&FT@_=:VF=2 $WE:*>Q)U9\%+:9;XZ$!G)PR<(L? KF4G
XY."=3>YDM'C'GO5U-;E):$>])!9C29@VC?T.LR+^MV\;DLZP$_HFWVY9.K PM0ED37%H)'"
X"EA8V#,-WC@^+GQG9-@_[[XGI#"=_FW UZ>J476=?@5T.ZIYLY+V8*M'C;F<$1H]>OEC*UP
Q:2*A._$V$?%P$_HFWVY9.K PM0ED37%H)'"X"EA8V#,-WC@#P2\HC4@QB\/GI#"=_FW UZ>
J476=?@5T.ZIYLY+V8*M'C;F<$1H]>OEC*UP[GJYZT:WQ.+NTAVR92]KS__21@.?!AM]HBA&
]<GUZCED@&_U&T[!BU@-CNP;]]2KXDWUQ.GWE4J^"I=C'/^5_?,10JMI\6?]12">/:M8![E%
&JI(-N):$_8:P[FGS/($PR[#G+H#=%+Q,SN<DZ(8='*+$AB3L7/7_(,M#I2Q8?!N8GJ"0V1A
7S\OS8"#!&Y?6+U;TX_2*O]84SK*1*' D[I3,!B)_>*TUQ P$W^H?]9/]&03IVB,6V6#L\.G
@N7^U&OC,T*"XI)# ^ZO*0_BK#"CQ"&]L[RL)TB&&7LN^C G@N7^U&OC,T*"J_<&C_*3I(VK
SY#Q0M%2!F?/>  E_# 60@-XPNJ8(@'3:5?"A*KQN]MYBGB$VHLNF#(=58W::2UBT&47/_9I
KR2YR;/YHJFONL>!:QI:Q=6ZIO'U<=8+D[RFIO'U<=8+D[RFIO'U<=8+D[RF4[UMM7X[OD)3
A"^4A>HKKI^$MW(*4G@:)1:W:PZ>NNRP -=K7M;[K'+8#6Y>JHZ?@A68[,^J>3I'P1P\P0)Y
'VHG72LQ>ED?>5/XH3E]]"MYIO'U<=8+D[RF:$"LR!E/O+UHT4$J&OPVW2C1/?W.+Y9.O2P]
Q*1^U+2\K?[$/&%15"FFTP@\IO'U<=8+D[RF<!+(BI'UVKMP75YA/_ARJO!=]ZIXU/J=-1_W
IO'U<=8+D[RFIO'U<=8+D[RF0@*%>,;L1*%"3[  Q_$D='Q/'VHG72LQ>ED?IO'U<=8+D[RF
AP$=I$/RJ#V'W:/=-]XI);K=@YH)9W781%F#KR2YR;/YHJFOR%561C@<\RO(A-$ WJA=%Q:$
IO'U<=8+D[RFIO'U<=8+D[RF) C-]%NH7DHD^PDT;,F\\%+[GZ5F"%8&\V*?=BA\L134HK]V
9_?'4R[*H*-GIO'U<=8+D[RFF"D+-].]%:&8+HVRH!_+AV@NJ6IYYA=C '^I<%'#%*"!9$QP
>L]?N2.K7PEZ;[R&.U8(V8YOO:A QNV1;/B]\]'&$\'6>O;S=OZVX;@W_7]V5:T*K<&ST>M5
#(6"H*,&JZ8,A*T(^F3N.[F$"M]RQ7<Q#>8*X413'"QTUJKA/9.&,QG9+IX]6YIX *=EU--;
6)ZO=FS7IUI82D4Q6.C)T)-*D\P76Z$;>J"3P0@P/T;+5Q+!,H6--5![?;PR8I=H^Q1=Y-UB
QN?55(N<!HC&5K<;B']=FYI6#-*$=!Y1.4\,E4J^"I=C'/^5&1;.WVY"32L9%72D .E^?N45
_,4_]5E(KCC\PQ]\$[^%J%W#_\9IF+0:AP?_ZI7>P'-BI//JUN(#2DPGSWS6_\9IF+0:AP?_
 ]Q=LGP>F]@#;5UON0A(-Z]M8E#O0'80"&UB(7">EG-["=TATE-G7M/*JYW2(=BFUEE#7C(A
U*@/LCM[W"S4)14'PF ?^T0E.C$5?\_/JB4Z6;?*BGE5;TM9@:FQ($&+^1*!N7O.]I7($4^Y
? #/%#GXNTY\XV(&?7X":(/C5 #\R=';CTQ41@ ;$M]^HC9&/+UTX<6H\FP\'#A&/"(BOCH<
WXL&&-9*'<7?6WD#^RDB:GE;=A?^,6@+C>%V1WQE-8\\SG%'S\P_FD*@.T'/DB,HP<OF:A^2
\BPPQ[)SG*ORK$@F \^!Z ^L].G?C'_\(U[T;GEO4A*47!INCHZ/:T7]$Y..@S_E31RW>:"#
BU.*>MX/P0>+Y %.'#D@;=3DIH(S K259S>F:@  #;?O9&!J$K3K@Z7JAGP2KF9B%7Q[E=>N
!8S*(G#-K',%GH$F\D;FDRJ>ES@SVH=/#>27J/ZU^E#))'VH$QG-1N68!HX3?_[Z$"*;;WM_
_\9IF+0:AP?_ J5RN$H3720"E?9YH-Q4UNJ52_M/F\_*<%E+QTC(%)XUX:S' J5RN$H3720"
-NR.6IX<UW\V?VP'X/]TR]5_*:);$1UGA[DI)%-J-\J4X#XD&(^ 965[K^48_J^TOS;(HA[^
T=-:DZMAWX/1^SCT9*Y"%7G[F-:Z[KP[TG*8:=B%.,NQH=5IBQ1MR]M/D5N+?,YZ+V^.70Y\
E,FK9418-5B4M9ZMS@@L4%FUS\1HM'C( Q+/T_KV80&*"B_3[35S+M/K?[OMHBJITK=#XF&B
6AKLQ%<G?H]:PM0ED37%H)'"F^OZM+%QU;*;E,FK9418-5B4OE7T9RL>XK&^S\1HM'C( Q+/
T_KV80&*"B_36-5BXD@8.6U8HBJITK=#XF&B6AKLQ%<G?H]:PM0ED37%H)'"F^OZM+%QU;*;
LFURY>7-#F&RS:]M8'ZS7\+-7XCV-E%[MUM?+3=J<35WQ),MH(&>LX_&/I&@#/\G5XY]\(@,
B'47\?<'1S*(.JU4! ; P40ZM,%I6\K+^JZTY+)NEYA-@'7DZ*W-3/!Z7#KHQ.J7X;^)43+$
V:T*HH7XT7#9T)N!HOB\@4#0V5I_6Z5H-,S9%]A"2V7R=WX7!175]!T$D-@%#MYW;F6+Q[T.
)5HNXEU!"8@EM)D,I]<L%=FT3HKDAQI-'$-.AJBM)#"JONJ&IO'U<=8+D[RF[S)"[L'M$SOO
1[3H[0,/@ZU'9%]+&82VL4YDIO'U<=8+D[RFDWV+/U].6 V3AT4H*6?V]1F'4U+&2DV7"G)3
&H,\**#[^MH:>6^F\4?B#95Y&!9E;%L(6!@84FT ]H'1YL=2Z3=TFMFW&L'I*/=.,AS!L#HH
IO'U<=8+D[RFIO'U<=8+D[RFBG),1T&X2Z**WUKGE#(> ;G?N/014!38I3NX)14T)F+U&UXE
A'K2_N,ZR52$"=,-,!YB-YX)IO'U<=8+D[RFV0<EN_#@!H[9C_;4?)K+S/"/W[9O8.V7NZO?
M@!3EN#'?=6V5LX9]GQ[*L16C+A^'6T'.XF,]<DH;[O[@^?UXB8R&VDV-:WB!VI.]P3:^4L'
<(\"EA-78+YP,4"3Z%4Q5]LQ)DLUL$=GM<4F+T:"%3, YR8OIO'U<=8+D[RFX5+&W%HX,M_A
=S V_\7"NCYW@5"L+09I$?.!IO'U<=8+D[RF5E6VJL6 I7A6VVCB1.Z!J&';B*Q$#;[?64V(
NW,BM.TQENF[(;KPFB_9_F4A!+BCS/:]C'0$]1ZF$3I[/SOUIO'U<=8+D[RF4:CE-['KWX]1
I9202>YQ&G*EB]+13$56.0R+,K-&KZ:5;_0RQ^&<B%_.5HO'8C%TBOK/XR!BIO'U<=8+D[RF
:E&0M]<"82QJ1W,NM)M!9_='=V\"A=/NC%9W[MBB:X;*?\'N?JD!XH*P2:%^!J^]S]N:I3H&
?8,.Y-I$"7-]/-^%9AT*\Z4\1X8;&6H[H'='<V9/X%KV37-S@7-2'*J :MV!ZU[WI7-Q >3K
"Q"G!UI?6&H+HHEI9,PR; ^B*IB(^?J7NB$JG1Q3R5Z4VUR=&.V1>#$"]?T88I=H^Q1=Y-UB
<KU\H4),?YURXHY1F/F8ICOB3SPL1.A[QM%/:INHWBCLI;MJ$^L9>L%8O:43#<,B=75CAQ -
P[FGS/($PR[#<!$3JJ*RF>9PQ.J7X;^)43+$4K@,Q]Z#6#-2#]1_YF-+"=(/E4J^"I=C'/^5
M+QC@58?M9*TK.7#6C&"X-VLE4J^"I=C'/^5)1K<1Q8 H_0EU4&5<9@')7#5MY&T. PY[8.W
45KVIMABP@U1/%2NFI^-1B,\&DW%>#6Y[#8:;P]A%Y^[V%1O3K/%/*0=L0Q.!)1^ T,[DXT$
<W@SH(3#2W=S&Y=_G=GV*)D;=B'VL+@F91YV U(C87&J/<8# U(C87&J/<8# U(C87&J/<8#
 U(C87&J/<8# U(C87&J/<8# U(C87&J/<8# U(C87&J/<8#@KB#DNO01B*"'UA'9";C%M,?
TY6^V<IPOPW3 'WWU[>F''L <*TO]2GJ%K=PD\]<DF&@$B23Y*;/F0%5F87DZ*=*+MF:]\[H
J)/0:EYR0]>H4:Z[\&L"4*E1@G+/)9E,V N"N_\V"?RY*]B['P2E,Q\S(V8?!=H1\]CET4\%
2H>3F:+A("]*R[7!&BX\8)O+1CW)D_/,?#U&6%Z(O&S#-*98^O"BFVX.0B[ZE96_[1DHO8*5
E.6*=ZQTA<R4*OIGZD-EL^(J=22R$GH$,6]UD":>)8[UE!V01,X;O$1[J!M$!#P9RTBKVA0$
/JSNY,9DO9(^F;/)/H:R/L^9+V2S9:%;#3@O*7.(4ZOL_+<IQ(BZ\:@*B-[$UWL.1$SA^177
"O$R#/MDI: *2VP>":5TIIU+EN+'VN5/KZ:6+V2S9:%;#3@O'70[<0BG OD=Q(BZ\:@*B-[$
0C&:^D7FU3I"Q-*=C([/GN7$8)1PP/K3(U=@\94X*9@ZS.CQS!QZLIM -C',N#<K3[AG!@NX
NR+OB+O*4=J[LT^W>RKZJXVS4E8DU:]!4I!2"5;Z4-8%%B4)&&J$30+D!S<8= G:FA7H"^9T
)M[;1$%]L/0F/1J#8Y7IR.D] LX;O9*BD00"CU9^IQ@2W-R/U7:5J:G#[H[5W*"9L6XLC C<
)IY<K;_N['LFVZ5A%.'A>Y?;_^$HM(-$67#_D":>)8[UE!V09'DMPB#Q<.1D$^^;8Q[7:?(3
Q8>;^9>]=+O%'8!O.DGB7I,=^I.,XV)']VOZG 9O&DD/CIR<O%CHI9+F5P>\8K:GZS11A5)B
%^(-C'Y<@D(7I3!1Q8A<_MVEW855A:'=.OC=JTI1#FF,N3BK\GE+<A,?6)KRCRLU]^P8\%6/
-^4#D96%*[ W.JN3S4IM['HZ*#DK_I_\HV<H]XF$2O9_@.;WG?J=E]WPFER=HX](87_[/4ZC
[$P1D_?P<*7LBZ7$<':\:VB+=AL@U _%&,]VOQ%F5;3>3=*_J-78O[$>'\VH9C3M$S,**(QF
^MI97=0"=4KZ_<,(UK4XAR?]#@PQNS)TT+D.17C5-8&9E!]%*]-W[ QUZ-<K'N' U6*N[M >
.OMUB[$Y-_HZ_YQ#KU+?*RK_PU-+@WWJ&E##*M[9WT]T>U0JP T6DNYH(33 ,?[Q*&HRH>LQ
&5*::0?L@>(9:\-CYEP#9U-K$]?;GZISJ+L3=AL@U _%&,]VOQ%F5;3>3=*_J-78O[$>'\VH
9C3M$S,**(QF^MI97=0"=4KZ#P:Z_(2!//P/#0NI@U2]>74-))I86H8SFB4D U,& N,];+<#
=AL@U _%&,]VOQ%F5;3>3=*_U_:OZN2(#LK7_V=95(:ZL>+_G&D3=9;(*W><I9BZS:Q=&.VE
&JOU!\)%E^T:89ULD2;_UGQAH$_W((4A%+F@T=R 7842;\31#G_?"X'3TI8.@/?(#9&A<Z. 
_YQ#KU+?*RK_2B-.:$/5@'5*4*DLI #W_\E041P(0AR\FUU1.OMUB[$Y-_HZ_YQ#KU+?*RK_
3=AP2$).HFI-^/"'F ..=4SXB[VHJ4Y+:]V+WRI<:WJ!$[_?=Z>=I(K)NGIWNI@70C<'1C6Z
8G)8FT+(5G5B^/"'F ..=4SXK"NA[SX8?ERL-HFIH49>M(,V(J@[O4;5;8,B#$;$DJ)Y-(8,
^.(-PS2>T/SX_V=95(:ZL>+_OSTTG8DBC_V_=Z>=I(K)NGIWNI@70C<'1C6Z-^4#D96%*[ W
?9=K&_F<G^%]ZQ"V\.'K*1'K11J9=U*3>P!%D2S$E52AGP:107(.=:E^E4I!0F@2X%:K)+E"
H2&%-:$,^L*A[7[E AXE*9KMD2S$E52AGP:1F4/C:>JIMNZ9CLE _;ON1(>.Y@Q?<)4''Q'F
68]K:L5VVHM92^L9XK?UN6=+=AL@U _%&,]VV63DG5G7^&K9^/"'F ..=4SX8(9[<VI=)8]@
(\-HS:Y.((4CM]@Q<GM<7C"WAT9]^#SS:$R')LC&E.>=FWDF;*^#BGV7N/!LD2S$E52AGP:1
%OGOEH/B\B86L=#Q?'=>A'^Q_V=95(:ZL>+_H3]8%=7OG=VA/7O7A+? _30]_YQ#KU+?*RK_
6(=0L;(0>O!8:LINA=LZ:[)J)LC&E.>=FWDF7OD<,4!EB_)>(J@[O4;5;8,BB)QZYOFY)[:(
G6S-E0"=(OR=B9_ %RDHK(V)]7H!2X2R[?GUE3/-SQ[R0!>5#AR:?N^+M6P.58@V7^)0MV=5
E_$P/4) ?1F7?UU.#N^KV)Q_DWL;,DH9<0*3M]@Q<GM<7C"W&)UM&>LBY988RINL3CBOAQ'*
G:2GI9L#YV>=+P>J,S!-CE@O&JOU!\)%E^T:2'4;?.LUC3I(G)C"3;$[U)2<HW$>FSTQ>=ZC
&'\J*AGM-*$8=Z>=I(K)NGIWNI@70C<'1C6ZW8O_3?![8++=^/"'F ..=4SX!&29>K_!);$$
$'WP^N+/HNT0(J@[O4;5;8,BB)QZYOFY)[:(&4J$3RTE:(@9B9_ %RDHK(V),J<(*H<QLV<R
(J@[O4;5;8,B.>94DOONT^\Y75M!"LTW5EU="RYWO*O[?@L+D2S$E52AGP:1%OGOEH/B\B86
^F'//>S!Z"OZTF%_G_C=');27F6SP9:&%3M>HW$>FSTQ>=ZC3YL$[G,?H.!/&JOU!\)%E^T:
/79Q!&U3'.8]-AXQLYHB"^$VY_;_1;:H1//G0+@BG](=D91 .LCSGK>#B7XZ%FTJIF8';NT6
??I<D/.8&#A]&JOU!\)%E^T:2'4;?.LUC3I(C'98PGA* &>,HW$>FSTQ>=ZCIW,FEB@,_2^G
WL;9E1+FQP?>_YQ#KU+?*RK_)N;3*IS<^,LFJ4()F_OK/*.I(6R:#PATBNXAF+BJN ,"\#R8
E3/-SQ[R0!>5#AR:?N^+M6P.O+2OEC/ F$6\P2YNJTB\3!#!EWV*Y0H/V!N7KCVON.M6F/:N
75M!"LTW5EU=>[I H:PM,Z-[^GBH&T:(2I3Z/79Q!&U3'.8]-AXQLYHB"^$V)VH4/ @T,#HG
=J.$G@71+[1VZNN@M3[:?__J. 1YVST'9-$XXP:=S3^$!^GC$V9*XA7CD9X38;KQR3>O]9UA
/79Q!&U3'.8]-AXQLYHB"^$VU3K2YU,\Q]35G.CW6'FD& N<V7PAP,L=]P_9!P!J>SJA]9H'
\OPM9YB(RMGR'"8D$*9.0T0<75M!"LTW5EU=UH@:\=[-M#76-103V;UP/\@U%M5D"L[:'@\6
^[SP'.#5WB'[0=,4P_!!;UI!^9YZ@'D&X>3Y/79Q!&U3'.8]-AXQLYHB"^$VFK<YV=]72_.:
*F%F4'0&"ITJDB;+$I/;3UZ2%M5D"L[:'@\6^[SP'.#5WB'[9)<QQQ)A$IUD7Y:,FL8YZ/Y?
]F')1OXDX23V%OGOEH/B\B86F_?0ZN9?P2*;3G87/@H!IPY.&5*::0?L@>(9G:2GI9L#YV>=
*Q3_4A;*=2PKVBR>4)5BGBO:ZNN@M3[:?__J. 1YVST'9-$X73S3""49Y,Y=&JOU!\)%E^T:
F^]:>Y#K49F;"=-;?L4MZ <)?]-TGU3K@'Y_&M&,:06UFED:N6%3+#NL4\&YZNN@M3[:?__J
. 1YVST'9-$XXP:=S3^$!^GC$V9*XA7CD9X3RY7E7.,U=]W+/79Q!&U3'.8]-AXQLYHB"^$V
(^$&LQXWL@TCG:2GI9L#YV>=KB @#'2#K@BN^GBH&T:(2I3Z/79Q!&U3'.8]-AXQLYHB"^$V
FK<YV=]72_.:=AL@U _%&,]V:7L*]' >H29I-^4#D96%*[ W7(:4(FC"]J9<$V9*XA7CD9X3
8;KQR3>O]9UA/79Q!&U3'.8]-AXQLYHB"^$VFK<YV=]72_.:*F%F4'0&"ITJDB;+$I/;3UZ2
F>S ;O^C:0"9^[SP'.#5WB'[EIZEY0/R.3>6AIAQT<R'M_*&IO'U<=8+D[RFB9_ %RDHK(V)
KN_!>/1:+!*N=Z>=I(K)NGIW)@[)<N4S4\0FS-RY,?B-NC/,IO'U<=8+D[RF!6>>DK=.?"0%
- RMEYRHBL4T]2N 3[.INHSUQJ! ^;1^3TO&M]@Q<GM<7C"WAT9]^#SS:$R'IO'U<=8+D[RF
%> #I=?W# @5: CMO;H,W+EH<2&ZIORX/=]Q)-65Q)VV5<HDA?^J]#<GH*:%5O=7>\Q!LC-6
IO'U<=8+D[RF@8EG(N'/)Z.!(5):(3,"'9(A*<=JG/<*GLXID2S$E52AGP:1JX8K2,WUGRBK
P76<)CV6@H3!<<2W5]:Q*"%Q>K\I9?G<*:MZ%R)SSR4UN*@7IO'U<=8+D[RF1J?<)_A><%I&
255!B"1=YZ%)Z^'BR3NB"__KE3/-SQ[R0!>5)IH9[ ?G-+TFTD&IX09!C*O2\4DZV\]YA_#Q
"F)"*R@011 *2"=NGF5FE+=(.?GHF@#IFRPYSB]3:=ZW"S3.IO'U<=8+D[RFX%OLWEG/RZO@
@7O"!#^^FO^!+:L!/M4;SJ MCWD9"XM! ^R/R4;I84YLQJW)VGW,)?O\)3+:LT^W>RKZJXVS
(1S?/<S#'-PAT'71W=>H9#70@S2&( $!_X6#'VHG72LQ>ED?Y3=4$C&K,8OE'[6AHJ2P! X?
A3U>D%6.IQ:%D2S$E52AGP:1*AP'A2?%R"DJH(CZXA=X *2@#0NI@U2]>74-IO'U<=8+D[RF
?'R>K8^2>W%\]>]??7\/U$_UO;@DCT_4E::]D2S$E52AGP:107(.=:E^E4I!0F@2X%:K)+E"
'VHG72LQ>ED?/)[:G *QB:0\DB,HP<OF:A^22<;ON<$R83))_YQ#KU+?*RK_P-EA</*GUFG 
.:LZ\N?(87\YIO'U<=8+D[RF\=+U;\0L)R/QT,W9D8+*5^+0(J@[O4;5;8,BZNN@M3[:?__J
!&BGZ9!0YZD$'VHG72LQ>ED?/)[:G *QB:0\"K3&64V1/W,*O;@DCT_4E::]D2S$E52AGP:1
07(.=:E^E4I!0F@2X%:K)+E"'VHG72LQ>ED?/)[:G *QB:0\7XL[ A-J7B]?6 U/'KLZWS-8
)-65Q)VV5<HDA?^J]#<GH*:%*M[9WT]T>U0JP T6DNYH(33 ,?[Q*&HRH>LQ/,#]?SJRF'P\
%@Q:PUQ%PY86IKRW+!CSK"JF@*_<M_:"++" L/0%'L[F8'BPDF$1)E M6;"2[2LXWXL2LY?M
I&,^%(E9''JDA9-P]O_'N.&%APY#A.1P5Z*'#0NI@U2]>74-AD\J/PR+3-J&WV!"^R>E"WG?
/T*!!EEWC],_"6BZU:VI0A4)G\HDT@]9$S:?G\HDT@]9$S:?G\HDT@]9$S:?G\HDT@]9$S:?
G\HDT@]9$S:?G\HDT@]9$S:?U"]5ZHI?3"_4$D+ <Q%CG&02L>K,W^V&*>.QL>K,W^V&*>.Q
L>K,W^V&*>.QL>K,W^V&*>.QL>K,W^V&*>.QL>K,W^V&*>.QL>K,W^V&*>.Q,OTF];YT59<R
V'??XI61 ^K8Q3K\=!'L&B?%LEI%CM(0E!RR7G3O#\C 9)1>!=H1\]CET4\%> Q),;X[P@QX
:O*ML'A0'*5J&@XT+D7Z9JD:&^;%&SRZ)(8;2=;[7YCG%09)4D]U"$%,'OA2A6L$F0A(2?R%
 32+@+L8!/<!+NDS],;/SR$NY[9!RU8N5GKGIVZ4#L+XMR*G!P!J>SJA]9H'ZH8;!=<C<%OJ
%OGOEH/B\B86L"("2)._CD^P^/"'F ..=4SX=&F4+_!^X6AT7[Y:7?[,*SQ?H"$'^(SG"VN@
%OGOEH/B\B86D]?$FFL!^R63$96V+5__X)81Q,M6O>DL]A;$]!%>T+R7QG7T[="!CO%T(7OM
N[&R*->''0^[UJ?(LG. 3XW6^/"'F ..=4SX=&F4+_!^X6AT7[Y:7?[,*SQ?>WLC2C8>?4E[
%OGOEH/B\B86(K[3S#L0@)XBZNN@M3[:?__J"TOB5F/-EQH+>TPW3A=B3#U[#0NI@U2]>74-
5VOU$X\U\^A7W<_CT.*KX9#=BC1!_3^]9D>*$^^;8Q[7:?(3,;!U)?9L7+<Q+53OC]%A0T8M
DB;+$I/;3UZ2F>S ;O^C:0"9>-%L*P'@">AX* 6.D=TH;/,H^XWEC!833&_[G>H[$ 5#)C"=
&<96)U,5M8D9$=+M;X(>VUD1,M7>IV4$EZHR*=D.%%Y#Z,0I U(C87&J/<8# U(C87&J/<8#
 U(C87&J/<8# U(C87&J/<8# U(C87&J/<8# U(C87&J/<8# U(C87&J/<8#_0$ H^DC>/[]
!+> %+F/X?$$F[TT+\E=!.N;U(ET+0GY7U+4B#9V1[O00BF(L$OXW\'TNF>P2H>3F:+A("]*
?A56^Y;B=?Q^ P[FWQ)7:-@#_2<TBP3Y9'[]\B)!M&-(#J?R&I>^DKO%D%\:5_E\VE48)ZA7
^/"'F ..=4SXV@Z$V>I$G2':U4&5<9@')7#5!VI.]P3:^4L'6030-9:9^>U9TEGVI"]8J4#2
3 W_TR3D_LA,L?IW7"&SDU^Q(-[P(%*_<>,@Y._U[%"VZ,CDJ495V+G,3 JI%/)F<4$&[MP4
O8Q("0@+T2.]##Z@T9)E7L,,"R0NN[&'$G8+Q3K\=!'L&B?%O(IQ%%3O/4F\FC0+KI&IY=V:
2]$B((<Z/81+#%"][2+L:+\,F2DTP$SIT\B9J@R7 [DKA,2J1@ ;$M]^HC9&/HXGS/]ED2L^
1WQE-8\\SG%'"K3&64V1/W,*-RA@3__$;K$W02JI"^6"S%U!QIRPQN)%J,W&BQ4''L*&$WF+
KM$Y+%:&Z9FNKFU-CR5;6L.N#@%$OFC'!C<.!1@K:-(0=@D%
#pragma PXL encrypted end
#pragma PXL encrypted begin
*Z%\;P3,?PTK KX3KB=Y=:$"J7_K+610_,6I7,B<0@Y$R!1<)%&\(,UVO3\DO>5)&BC>-XV]
@HC:5NY<W+>"VMJ^\]4%?D+:
#pragma PXL encrypted end







#endif

#ifdef FILL_DM13

#pragma PXL encrypted begin
-<D_.P]A4DLU//',UD8W>RD\RK"0TT7NH?/*/U(9()JS5M _A]HA;55@=C:'BA(=J\LA$)^*
V))O-88SI./8>&02@KU _NYX[:/VTW^\E!+M=C_1FI?>E6QV
#pragma PXL encrypted end


LAYER_DM13_MYBCELL_H : polygon_layer_s = {
    layer_spec = {
        output_layer_key = "OUTPUT_DM13_DMB_CONNECT"
    },
    polygons = MYBCELL_H
};

LAYER_DM13_MYBCELL_V : polygon_layer_s = {
    layer_spec = {
        output_layer_key = "OUTPUT_DM13_DMB_CONNECT"
    },
    polygons = MYBCELL_V
};

LAYER_DM13_MYBCELL_HEXT : polygon_layer_s = {
    layer_spec = {
        output_layer_key = "OUTPUT_DM13_DMB_CONNECT"
    },
    polygons = MYBCELL_HEXT
};

LAYER_DM13_MYBCELL_VEXT : polygon_layer_s = {
    layer_spec = {
        output_layer_key = "OUTPUT_DM13_DMB_CONNECT"
    },
    polygons = MYBCELL_VEXT 
};

// DUMMY SPEC : DM13_DMB_Connect
SPEC_DM13_DMB_CONNECT = unified_fill(
    fill_patterns = {
    {
        type = UF_POLYGON,
        polygon_fill = {
            insertion = {
                iterations = 3,
                shift_factor = 2,    
            },
            pattern_spec = {
#ifdef VERTICAL_M13
                space_x = DMY1B_SX,
                space_y = DMY1B_SY,
                stagger_x = DMY1B_OX,
                stagger_y = DMY1B_OY,
#else
                space_x = DMY1B_SY,
                space_y = DMY1B_SX,
                stagger_x = DMY1B_OY,
                stagger_y = DMY1B_OX,
#endif
            },
            layers = {
#ifdef VERTICAL_M13
                LAYER_DM13_MYBCELL_V
#else
                LAYER_DM13_MYBCELL_H
#endif
            },
#ifdef CONTROL_MAX_METAL_LENGTH
#else
            merging_layers = {
#ifdef VERTICAL_M13
                LAYER_DM13_MYBCELL_VEXT
#else
                LAYER_DM13_MYBCELL_HEXT
#endif
            },
#endif
#ifdef ANTPrevention                
#ifndef CONTROL_MAX_METAL_LENGTH
            merging_blockage_layer_list = {
                FORBIDDEN_RING
            },
#endif
#endif
#ifdef CONTROL_MAX_METAL_LENGTH
#else
#ifdef VERTICAL_M13     
            merging_direction = VERTICAL,
#else
            merging_direction = HORIZONTAL,
#endif   
            merging_length_limit = 500*(DMY1OR_L + DMY1B_SY) - DMY1B_SY, 
#endif
            fill_to_signal_spacing = {
    { CHIP_snps, min_space = DMY1B_CHIP, context = INTERIOR },
#ifdef FULL_CHIP
    { CHIP_BOUNDARY, min_space = DMY1B_CHIP, context = INTERIOR },
#else
    { PRBOUNDARY, min_space = DMY1B_CHIP, context = INTERIOR },
#endif
    { ICOVL_SINGLE, min_space = DMY1_ICOVL },
    { INDDMY, min_space = DM_INDDMY },
    { TCDDMY_M13, min_space = DM_TCDDMY_MX },

	{ BEOLBLK_FINAL, min_space = DMY1B_MY1 },
    { DM13EXCL_FINAL, min_space = DMY1B_MY1 },
    { CSR66_3485, min_space = DMY1B_MY1 },
    { M13_MAIN, min_space = DMY1B_MY1 },
    { DM13_O, min_space = 0.26 },
    { DM13, min_space = 0.26 },
    { DM13_GT1350, min_space = 0.45 },
    { M13_GT76, min_space = DMY1_MY1W1 },
    { M13_GT114, min_space = DMY1_MY1W2 },
    { M13_GT152, min_space = DMY1_MY1W3 },
    { M13_GT180, min_space = DMY1_MY1W4 },
    { M13_GT240, min_space = DMY1_MY1W5 },
    { M13_GT280, min_space = DMY1_MY1W6 },
    { M13_GT500, min_space = DMY1_MY1W7 },
    { M13_GT1350, min_space = DMY1_MY1W8 },
#ifdef FILL_M12_VIA12_M13_BTCD
              { BTCD_M12_V12_M13_E, min_space = BTCD_D },
#endif

#ifdef FILL_M13_BTCD2
              { BTCD_M13_E, min_space = BTCD_D },
#endif
              { WRAPPER_DM13_O_L, min_space = DMY1B_DMY1O },
#pragma PXL encrypted begin
#EC1=:N<)4\.7+J )=(I<PY<H!P:!U <L.V@M;"N0>/*YNJUK?[S.?S=7:^M;P%*:$^YA))O
\Q=NMF#E[NSS@S+&<Z[XU%"#YVD?4 1;_03G49-+D#9#0[)10J_,!;PD(*I" 'A60@>22/( 
@GJ?JQ0VW1V"^TW@^@<S)NK[ O$*LC:((=L"W<"5ULA31SS=%(8,1W77 4P4):6-TH0QTHXE
U]:<%I&\D;37W/W@PH)U[Q3<S%H7_;:9$__,N(LACA9(BCFX
#pragma PXL encrypted end

                            
            },
            hierarchical_fill = false,
#ifdef VERTICAL_M13     
            cell_prefix = "DMB13VNEW"
#else
            cell_prefix = "DMB13HNEW"
#endif   
        }
    }
    },
    extents_output = {
        {
            output_layer_key = "OUTPUT_DM13_DMB_CONNECT_EXTENT"
        },
    },
    fill_boundary = {
        layer = CHIP_snps, 
        type = LAYER 
    },
	grid = vGRID
);
//=======================================================
DM13NEW_C     = SPEC_DM13_DMB_CONNECT["OUTPUT_DM13_DMB_CONNECT"][0];
DM13NEW_L     = SPEC_DM13_DMB_CONNECT["OUTPUT_DM13_DMB_CONNECT"][0];
//***** spec *******************************************************************
#pragma PXL encrypted begin
E:;132962 25%8_D3I)5]F\5UNX55H ,M5K6&D)X:^FU"18:]*UL:SESB__TXQ5M&;8PV/'C
\W!AC#/(7'7S$;*/ C],^; 1
#pragma PXL encrypted end

//***DM13_DMB***
// DUMMY SPEC : DM13_y1
PATTERN_SPEC_DM13_0 = get_single_polygon_pattern(
#ifdef VERTICAL_M13
	"DMB13V", "OUTPUT_DM13", DMY1B_W, DMY1B_L,
	step_x = DMY1B_SX, step_y = DMY1B_SY,
	offset_x = DMY1B_OX, offset_y = DMY1B_OY,
#else
	"DMB13H", "OUTPUT_DM13", DMY1B_L, DMY1B_W,
	step_x = DMY1B_SY, step_y = DMY1B_SX,
	offset_x = DMY1B_OY, offset_y = DMY1B_OX,
#endif
    FSS = {
    { CHIP_snps, min_space = DMY1B_CHIP, context = INTERIOR },
#ifdef FULL_CHIP
    { CHIP_BOUNDARY, min_space = DMY1B_CHIP, context = INTERIOR },
#else
    { PRBOUNDARY, min_space = DMY1B_CHIP, context = INTERIOR },
#endif
    { ICOVL_SINGLE, min_space = DMY1_ICOVL },
    { INDDMY, min_space = DM_INDDMY },
    { TCDDMY_M13, min_space = DM_TCDDMY_MX },

	{ BEOLBLK_FINAL, min_space = DMY1B_MY1 },
    { DM13EXCL_FINAL, min_space = DMY1B_MY1 },
    { CSR66_3485, min_space = DMY1B_MY1 },
    { M13_MAIN, min_space = DMY1B_MY1 },
    { DM13_O, min_space = 0.26 },
    { DM13, min_space = 0.26 },
    { DM13_GT1350, min_space = 0.45 },
    { M13_GT76, min_space = DMY1_MY1W1 },
    { M13_GT114, min_space = DMY1_MY1W2 },
    { M13_GT152, min_space = DMY1_MY1W3 },
    { M13_GT180, min_space = DMY1_MY1W4 },
    { M13_GT240, min_space = DMY1_MY1W5 },
    { M13_GT280, min_space = DMY1_MY1W6 },
    { M13_GT500, min_space = DMY1_MY1W7 },
    { M13_GT1350, min_space = DMY1_MY1W8 },
#ifdef FILL_M12_VIA12_M13_BTCD
              { BTCD_M12_V12_M13_E, min_space = BTCD_DY1 },
#endif

#ifdef FILL_M13_BTCD2
              { BTCD_M13_E, min_space = BTCD_DY1 },
#endif
              { WRAPPER_DM13_O_L, min_space = DMY1B_DMY1O },
#pragma PXL encrypted begin
'/71):$/:SD<Q*9\AF30I;3$A$<'PG/V(D:$3)=K%&Z;)-9,P' -HHADD[' 4Y_2"/1,1<)3
&MH^,+5@AJ8:>0\^)<ZA#TUYJ+/L#3-G.J2H3/OQ:'\\!4E,
#pragma PXL encrypted end

              { DM13NEW_L, min_space = DMY1B_DMY1 },
#pragma PXL encrypted begin
J/9793V [7^H5KI:,?VHDS!6^;99-D#L-@+Y7K];?*MS_Y1><#3\O/MZ$SUP^M=!?PTOG2WZ
XHH?!>IK:TCB7LRE1/?3\%I>
#pragma PXL encrypted end

    },
	shift = 2,
	repeat = 3,
    starting_point = CENTER
); //end of get_single_polygon_pattern


//-------------------------------------------------------------------------------

//***DM13_DMS***
PATTERN_SPEC_DM13_1 = get_single_polygon_pattern(
#ifdef VERTICAL_M13
	"DMS13V", "OUTPUT_DM13", DMY1S_W, DMY1S_L,
	step_x = DMY1S_SX, step_y = DMY1S_SY,
	offset_x = DMY1S_OX, offset_y = DMY1S_OY,
#else
	"DMS13H", "OUTPUT_DM13", DMY1S_L, DMY1S_W,
	step_x = DMY1S_SY, step_y = DMY1S_SX,
	offset_x = DMY1S_OY, offset_y = DMY1S_OX,
#endif
    FSS = {
    { CHIP_snps, min_space = DMY1S_CHIP, context = INTERIOR },
#ifdef FULL_CHIP
    { CHIP_BOUNDARY, min_space = DMY1S_CHIP, context = INTERIOR },
#else
    { PRBOUNDARY, min_space = DMY1S_CHIP, context = INTERIOR },
#endif
    { ICOVL_SINGLE, min_space = DMY1_ICOVL },
    { INDDMY, min_space = DM_INDDMY },
    { TCDDMY_M13, min_space = DM_TCDDMY_MX },

	{ BEOLBLK_FINAL, min_space = DMY1S_MY1 },
    { DM13EXCL_FINAL, min_space = DMY1S_MY1 },
    { CSR66_3485, min_space = DMY1S_MY1 },
    { M13_MAIN, min_space = DMY1S_MY1 },
    { DM13_O, min_space = 0.26 },
    { DM13, min_space = 0.26 },
    { DM13_GT1350, min_space = 0.45 },
    { M13_GT76, min_space = DMY1_MY1W1 },
    { M13_GT114, min_space = DMY1_MY1W2 },
    { M13_GT152, min_space = DMY1_MY1W3 },
    { M13_GT180, min_space = DMY1_MY1W4 },
    { M13_GT240, min_space = DMY1_MY1W5 },
    { M13_GT280, min_space = DMY1_MY1W6 },
    { M13_GT500, min_space = DMY1_MY1W7 },
    { M13_GT1350, min_space = DMY1_MY1W8 },
#ifdef FILL_M12_VIA12_M13_BTCD
              { BTCD_M12_V12_M13_E, min_space = BTCD_DY1 },
#endif

#ifdef FILL_M13_BTCD2
              { BTCD_M13_E, min_space = BTCD_DY1 },
#endif
              { WRAPPER_DM13_O_L, min_space = DMY1S_DMY1O },
#pragma PXL encrypted begin
4,7X%\5M\#I0M/U5YDP8&IVTU'5<=CIJ5%;4OYX^EQ,'I42_/HQ839:^5\T^7*[TB4TBIW%<
CS]K1$\Q(+2/HMR@&Z Q0!"BWQ4JWKV%1N7?6E&8T,3>4WE:
#pragma PXL encrypted end

              { DM13NEW_L, min_space = DMY1S_DMY1 },
#pragma PXL encrypted begin
IE,(:"S90B>F_X@P8/I9 >'_6W9[.TQ/Z2M;-4YTKM3XQ$0UFRT^^J[D.-V;">%2NR;.#88)
SN]B'<XI+5C.<,#/>0,LS\YP
#pragma PXL encrypted end

    },
	shift = 2,
	repeat = 3
);


//***DM13_O_R***
PATTERN_SPEC_DM13_2 = get_single_polygon_pattern(
#ifdef VERTICAL_M13
	"DMOR13V", "OUTPUT_DM13_O", DMY1OR_W, DMY1OR_L,
	step_x = DMY1OR_SX, step_y = DMY1OR_SY,
	offset_x = DMY1OR_OX, offset_y = DMY1OR_OY,
	setback = DMY1OR_SC,
	setback_type = INTERSECTION,
#else
	"DMOR13H", "OUTPUT_DM13_O", DMY1OR_L, DMY1OR_W,
	step_x = DMY1OR_SY, step_y = DMY1OR_SX,
	offset_x = DMY1OR_OY, offset_y = DMY1OR_OX,
	setback = DMY1OR_SC,
	setback_type = INTERSECTION,
#endif
    FSS = {
    { CHIP_snps, min_space = DMY1_CHIP, context = INTERIOR },
#ifdef FULL_CHIP
    { CHIP_BOUNDARY, min_space = DMY1_CHIP, context = INTERIOR },
#else
    { PRBOUNDARY, min_space = DMY1_CHIP, context = INTERIOR },
#endif
    { ICOVL_SINGLE, min_space = DMY1_ICOVL },
    { BEOLBLK_FINAL, min_space = DM_BEOLBLK },
    { CSR66_3485, min_space = DM_BEOLBLK },
    { INDDMY, min_space = DM_INDDMY },
    { DM13EXCL_FINAL, min_space = DM_DMXEXCL },
    { TCDDMY_M13, min_space = DM_TCDDMY_MX },
    { M13_MAIN, min_space = DMY1OR_MY1 },
    { DM13_O, min_space = DMY1OR_DMY1O },
    { DM13, min_space = 0.2 }, //DMn.S.3.5
    { DM13_GT1350, min_space = 0.45 },
    { M13_HOLE, min_space = 0 },
    { M13_GT76, min_space = DMY1_MY1W1 },
    { M13_GT114, min_space = DMY1_MY1W2 },
    { M13_GT152, min_space = DMY1_MY1W3 },
    { M13_GT180, min_space = DMY1_MY1W4 },
    { M13_GT240, min_space = DMY1_MY1W5 },
    { M13_GT280, min_space = DMY1_MY1W6 },
    { M13_GT500, min_space = DMY1_MY1W7 },
    { M13_GT1350, min_space = DMY1_MY1W8 },
    { M13_45, min_space = 0 },
    { VIA12_HVN_5V, min_space = DMY1_VY15V },
    { M13_HVN_5V, min_space = DMY1_MY15V },
    { VIA13_HVN_5V, min_space = DMY1_VY15V },

              { R7_VIA12_CHK_REGION, min_space = 0 },

              { S22_M13_REGION, min_space = 0 },
#ifdef FILL_M12_VIA12_M13_BTCD
              { BTCD_M12_V12_M13_E, min_space = BTCD_DY1 },
#endif

#ifdef FILL_M13_BTCD2
              { BTCD_M13_E, min_space = BTCD_DY1 },
#endif
              { WRAPPER_DM13_O_L, min_space = DMY1OR_DMY1O },
#pragma PXL encrypted begin
!V_B?7FG)44'MM+9=: H5^*VXVL/!N8;N:WC4CA2%"<MZ4I24:*@^2X-&OQ1@I3XL$%$FO6"
DS;SZZ+7T/Z3Z76 5%H,0MGI9 ;2VML>&F)DE"#CJR.8(3N4
#pragma PXL encrypted end

              { DM13NEW_L, min_space = DMY1OR_DMY1 },
#pragma PXL encrypted begin
7/WQ3>$2>#%<)-K+0''MV/HD#=D ??5R.(P-=0<; %WD"?QU)JY,9J>&6PDFE /)R54D<-24
^X)PO>-[A:+[MI@H<F>@5ABV
#pragma PXL encrypted end

	},
    shift = 2,
	repeat = 3,
    starting_point = CENTER
);

#ifdef VERTICAL_M13
PATTERN_SPEC_DM13_2.polygon_fill.pattern_spec.pattern_spacing = {
    allowed_spacing_x = { >= DMY1OR_SXA2 },
    allowed_spacing_y = { >= DMY1OR_SY },
    extension = INTERSECTION
};
#else
PATTERN_SPEC_DM13_2.polygon_fill.pattern_spec.pattern_spacing = {
    allowed_spacing_y = { >= DMY1OR_SXA2 },
    allowed_spacing_x = { >= DMY1OR_SY },
    extension = INTERSECTION
};
#endif




//-------------------------------------------------------------------------------
//***DM13_O_W***

PATTERN_SPEC_DM13_3 = get_single_polygon_pattern(
#ifdef VERTICAL_M13
	"DMOW13V", "OUTPUT_DM13_O", DMY1OW_W, DMY1OW_L,
	step_x = DMY1OW_SY, step_y = DMY1OW_SX,
	offset_x = DMY1OW_OY, offset_y = DMY1OW_OX,
	setback = 0.114,
	setback_type = INTERSECTION,
#else
	"DMOW13H", "OUTPUT_DM13_O", DMY1OW_L, DMY1OW_W,
	step_x = DMY1OW_SX, step_y = DMY1OW_SY,
	offset_x = DMY1OW_OX, offset_y = DMY1OW_OY,
	setback = 0.114,
	setback_type = INTERSECTION,
#endif
    FSS = {
    { CHIP_snps, min_space = DMY1_CHIP, context = INTERIOR },
#ifdef FULL_CHIP
    { CHIP_BOUNDARY, min_space = DMY1_CHIP, context = INTERIOR },
#else
    { PRBOUNDARY, min_space = DMY1_CHIP, context = INTERIOR },
#endif
    { ICOVL_SINGLE, min_space = DMY1_ICOVL },
    { BEOLBLK_FINAL, min_space = DM_BEOLBLK },
    { INDDMY, min_space = DM_INDDMY },

    { DM13EXCL_FINAL, min_space = DM_DMXEXCL },
    { CSR66_3485, min_space = DM_BEOLBLK },
    { TCDDMY_M13, min_space = DM_TCDDMY_MX },

    { M13_MAIN, min_space = DMY1OW_MY1 },
    { DM13_O, min_space = DMY1OW_DMY1O },
    { DM13, min_space = 0.2 }, //DMn.S.3.5
    { DM13_GT1350, min_space = 0.45 },
    { M13_HOLE, min_space = 0 },
    { M13_GT76, min_space = DMY1_MY1W1 },
    { M13_GT114, min_space = DMY1_MY1W2 },
    { M13_GT152, min_space = DMY1_MY1W3 },
    { M13_GT180, min_space = DMY1_MY1W4 },
    { M13_GT240, min_space = DMY1_MY1W5 },
    { M13_GT280, min_space = DMY1_MY1W6 },
    { M13_GT500, min_space = DMY1_MY1W7 },
    { M13_GT1350, min_space = DMY1_MY1W8 },
    { M13_45, min_space = 0 },
    { VIA12_HVN_5V, min_space = DMY1_VY15V },
    { M13_HVN_5V, min_space = DMY1_MY15V },
    { VIA13_HVN_5V, min_space = DMY1_VY15V },

              { R7_VIA12_CHK_REGION, min_space = 0 },

              { S22_M13_REGION, min_space = 0 },
#ifdef FILL_M12_VIA12_M13_BTCD
              { BTCD_M12_V12_M13_E, min_space = BTCD_DY1 },
#endif

#ifdef FILL_M13_BTCD2
              { BTCD_M13_E, min_space = BTCD_DY1 },
#endif
              { WRAPPER_DM13_O_L, min_space = DMY1OW_DMY1O },
#pragma PXL encrypted begin
E^6E(0#U&CB7W^#U1U&WX(W?$$)*>"E$#PH07W5^0[H7Y<E?XR3Q9S/3*5_CM\5 XNPM8X>W
 U!"P>Q@*V0#0P^8:;+;__1#"Q=<QZ?8VT0+CY0Y5I C"VZ/
#pragma PXL encrypted end

              { DM13NEW_L, min_space = DMY1OW_DMY1 },
#pragma PXL encrypted begin
(^<K89QFG7XCPXB!K&C;Z^'#NU@-6$*R$%F[M,B%\<9=*)2T,;TPJSRWF.4QQ7W#23%SLZW%
(#:4[?G.0RL@&!GQNR$"%YT8
#pragma PXL encrypted end

	},
    shift = 2,
	repeat = 3,
    starting_point = CENTER
);
//=======================================================
PATTERN_SPEC_DM13_0.polygon_fill.pattern_spec.other_pattern_spacing = {
    1 => > DMY1B_DMY1,
    2 => > DMY1B_DMY1,
    3 => > DMY1B_DMY1,
};

PATTERN_SPEC_DM13_1.polygon_fill.pattern_spec.other_pattern_spacing = {
    0 => > DMY1S_DMY1,
    2 => > DMY1S_DMY1,
    3 => > DMY1S_DMY1,
};

PATTERN_SPEC_DM13_2.polygon_fill.pattern_spec.other_pattern_spacing = {
    0 => > DMY1OR_DMY1,
    1 => > DMY1OR_DMY1,
    3 => > DMY1OR_DMY1O,
};

PATTERN_SPEC_DM13_3.polygon_fill.pattern_spec.other_pattern_spacing = {
    0 => > DMY1OW_DMY1,
    1 => > DMY1OW_DMY1,
    2 => > DMY1OW_DMY1,
};

SPEC_DM13 = unified_fill(
    fill_boundary = {
        layer = CHIP_snps,
        type = LAYER
    },
    fill_patterns = {
        PATTERN_SPEC_DM13_0,
        PATTERN_SPEC_DM13_1,
        PATTERN_SPEC_DM13_2,
        PATTERN_SPEC_DM13_3,
    },
    boundary = ALIGN,
	grid = vGRID
);

//***** fill *******************************************************************
DM13_C   = SPEC_DM13["OUTPUT_DM13"][0];
DM13_O_C = SPEC_DM13["OUTPUT_DM13_O"][0];

#pragma PXL encrypted begin
=,*U2>(:D%ET2M-\FK\"@IE*U*%PREYEW\S4SQAQY>1,!=// 2,.)=8U5J@![B_Y'Z<J#Y+N
$[LLL>AW;W<3%FPN-Z+GZU$6)1TBVER=[KPE(,CM/MH?4S4@
#pragma PXL encrypted end

#pragma PXL encrypted begin
R5#%&4J&XD7)IKGTWQH=8H2F/.<=MRS"O_4\I8!:.B:YG8FEM#Y&JO/YJU.TI<)-LG (R(2E
35#"**2:1 1-4"$;B6DTN^Y0\!^D NO*923P4K793@0_D\U2
#pragma PXL encrypted end
#pragma PXL encrypted begin
PC@X.$\!Q4#"2IS&7P;\HJ=*T'X1W(IX\XO0VH6$4SI#'#O:4CW5C?MU9F!2:EM5QV7<3_]J
0,JUOR+5SNM !HR=%*!LMI\&V,Z0\"2I;3;8UYWK-/L5=,77(K!ILI%+*LTB>_[W![>1?'Y[
#pragma PXL encrypted end
#pragma PXL encrypted begin
J^!:*4UBMWBK^RYB+H$@\_/[_J/5%A+%Z K^C\^GLCJ>X7>/BV"&VEJQHUR+.N2'+]W^P9HZ
&F@%*YA[@HT:
#pragma PXL encrypted end
DM13_O_L = SPEC_DM13["OUTPUT_DM13_O"][0];
#pragma PXL encrypted begin
ROOS"8#(V0K*CTPR5]I<1N:/2]S:!']C'F-+AYIJ4??V-P2'Q:0>UM)^B)+%-5\E37"D&W(U
P;2'+=L@]4'![$58'RGJXQ3L
#pragma PXL encrypted end
#pragma PXL encrypted begin
5OUY21PY7%%6CF,O:5'VMU6.7A&M1BFX"9I>"&!H;:$*EG4(&YLXPX$T1G0;84J&OVQL;U5A
&*.#:DE46E48N[\M^N<RKD&[Y3-15:<\]<CEB#MA>R'+*M.(/88CCI3H<?$]QZP!3] ^*CS'
!O>XC/HH.+0&X#P>Z1-OF,7@
#pragma PXL encrypted end
#pragma PXL encrypted begin
XO[_"+BIWA?B_K@_8_#;J:[^O00(L3/&_[R])S+<YLM0XT,GKC.JWE#PJZ*NN$CG#C.AJKFX
;?;J$[E+5KQMGQ?XKX<S3ZZ?\A]D?"I_O#[R#]X0</UP,#0/
#pragma PXL encrypted end
DM13_L1   = SPEC_DM13["OUTPUT_DM13"][0];
DM13_L = DM13_L1 or DM13NEW_L;
#pragma PXL encrypted begin
-XT/62 5,00W8_PW-\72;#9CD^10/F%#^4Z3@%K[?MFJ 'R Y%;[)9GZ5E[DT>=NUB=*>)W1
_0&16ND=?7G]-:,NJ"W_?L$UFRHHET]R=Z:;#TGWQ_6NGJ\/B*!B8B]IK)N(:\\W93+?0"IK
78\#ITUPL71=
#pragma PXL encrypted end


#pragma PXL encrypted begin
C1L?*8> @W"-6-!?8[;-T*A8*_%"?.<XD<TKO=UBI6W$-$F]IST2O0L8CC*G8$['$$TYR%!@
IIJ*0DL!X$RF\5K9;Z ;J]'Q9.&+\4J"1<ID>QS,LL]RBBE[
#pragma PXL encrypted end
#pragma PXL encrypted begin
=<-!&H;A=2AU$T @&\WLAE,3IA8%!Z&DA8ZF#QM Q*F@3VD/F PBRIUG%(J8'#_,4Y'F;7\<
'_V314?4JY,?[Q [Q0$MXW?O=W&]/.&3N39W70MH6.1"S@9=R!$=#]0=Q^/(&(V0YMN[$=\8
:-6(Q/D@R^5HT?1DV6UBJ;C1+BQQ6H8NR+TNL*% /=<H?B>PI[^&;T',?YZG0^D^ @X*WR)#
G& $6XW];?&<YR-44-]M;B[GM&CG_+9+$H&T0CQXGOBV&U="+1_ _^BTSQ$M-."2?;R"KZ@T
NV9KT36R-&R[@=L.I*6P!*B!+TAA)^:P'I$OJP'>#*-R?ORKN$K?3>ZE-KFX@M)T1S5+S"."
?H3UNW( 2:=^">'0M;8^#P@).1!Q4-BXW-TYSCTO8J*(V$+./(AK<44'6,<\38@3P$NSM[9-
3LFEVD)<!2M.5R\+%(2F8J]7J!L (=$5(!&H.1!Q4-BXW-TYSCTO8J*(V$+.M!$S&3(5!G.T
38@3P$NSM[9-G];TOY"QS0.?.VYMF.'78O [ 10!G5"L]T\!=*.BN9>D@S=T\4L2"K"YH>?Q
@M)T1S5+S"."))1^8BJGHQ D92OZU>(N!,5E&KDN/;EGG$4:".,Q+ &5'S8(DW@19''#EB:3
E_LS4?+E;W>72^%$Q$/6SK%+O=4$."I]D&:]4[1I?>QW45A3(1Q7!F[M%"DAQR;*7,_  EG'
=ZO"AX]=Y0EW!E5FO>^E")X&BAW8ZFPN'%2*@M)T1S5+S"."(YAB7,<&J>PC38@3P$NSM[9-
:$1C-R ISF%H11+>+P)#G-!%E^@13*&5:KR778+3R;+ #MM=8<G"R+C5G.IA#BGL_DC'V/\.
%TNI625FYH$7<3.$"=:[%R!QE>P"NKFEWE*5L;I*9-K19_RQ_\%2*&Z##8;_!3[@@I3%[@<%
IN#%+:>XDE&F@M)T1S5+S"."^91+JVBJ1B3Y-5-=T104A$$U,);ZKY^AR44P@!MXD;V./^: 
NGB1*VU8CFZZWT\D6^Q=..S?]1B2&C3*LSCU.Y[D.Q4^D&$[8(SO,"FRXL5@M65&>O^IAIVU
1^!ZO*)(X5U'/+ZJ5PKWZ] \O/XWX&-Y +^\$TG"O3UR!3 3<H7' C3!BE9R$XO)N$DZH^ 3
7OW.1UB=161>L_,9;3639@^S3KQ-W**6WP!.KMX&!K,FBW>NO62A_@]_Z!R]]1L*1K*F17/U
!%(-EGXN8G\$"&+N'C#\[50(PD4B;%W??$/"]1B2&C3*LSCU.Y[D.Q4^D&$[8(SO,"FRXL5@
M65&>O^IAIVU1^!ZO*)(X5U'7N[]-S@1%/5>#65F/GN)(5X-FR]R+29Q7OZ;'MD.4EKDHY<>
]1B2&C3*LSCU P"0*J',4GX#G?,_8W_;WI^=Z9B IRK6A)3I>H*R&(D[#59ZDG N4FM$(8J2
3].FY[^/EA-/U<'QR"NQO(#5*H;'8B-['Z4JCF^2:MCME:J.*M343:V]>9PJ7OW.1UB=161>
5OX_Q"3R/2]6EIK'HK2""0*63IB9<0C$<]U.MZ\'4X!ZO?VW7OW.1UB=161>%T57]\',[@L7
T^L4SQ/7?UC3NYY0*B9<;Z.[LA&WK#W09(6RK'M2-^!T\9FLJQ#&[2-7R3ZKK#$_NC"^HR6L
7BZJJ*P(<6]>6A>()[7(/G1:^)5@"QSVS _X'_$+:OH^(20?4UE&OXTWZ793,0 ,["6 NR0Q
%$_57&WP8J,4<+(DE,MJ;;5POFC@AT(93$B^JQ#&[2-7R3ZK0C5[RH[ 5O="F!I4-)31K0:8
/O+>GTY/>'@^8G+UFZAY_ZYBC^,ALE<=&$*//8OZV<*I[) ]86TQ@0XOX:=A->QRQX M?*HU
)>Z=>+4H;X\EC^,ALE<=&$*/47=E/5^WW1)187Z:?OA NH=AM?5H@WEUWLZU _?QMO/MID\#
;1D)DX[H9.1M8D:?ZSBCMQMB]1B2&C3*LSCUXEIK[/"LLH/B$2)&]\L?!Q@1_=0$'Z[.'7?]
I"MY*MWW>-ND=,M" 5J<U?=TZ%^>2<7VZ\_H-#+@3$[-HU4TC^,ALE<=&$*//8OZV<*I[) ]
,@W/RW;R3.XR/(A3Z+%M<W4\<+(DE,MJ;;5P.H3_.3#\\F0Z7OW.1UB=161>L_,9;3639@^S
"(C7]X ZZ3L(Z%^>2<7VZ\_HK#1\6<@^81VL'_$+:OH^(20?4UE&OXTWZ793G5C=0T8\E^>=
13\W5R4Y[\Q%#6K O7*PC:8- 05'6<(8'=T!4O$I48[L8\U2?18!G5,6]@1]F4PW5E>TX0*9
;N]6CQ#/+8!NS5SU(Z,'JTS-I"MY*MWW>-ND!8UIZ.R*AB<%XF(4Z!UK8;#B]E/1DV@/AR7V
P_ X70TY/N/#/B0''68+R?@^3].FY[^/EA-/[_N&*T#%JJKOT[5FHFCQ*'K3PE[KYJ(60NC"
%/@FODJ>F+X4JQ#&[2-7R3ZK5P+$]AT[;5I7\WYXBEC5/.'S$2)&]\L?!Q@1>AZ%G$,_.6!Z
'_$+:OH^(20?4UE&OXTWZ793L:N?(_*]N6*Q13\W5R4Y[\Q%-?SA#N@W)D<U'_$+:OH^(20?
P6D5GZ8"Q'K!/O+>GTY/>'@^X9:SJ)VCU.SAC^,ALE<=&$*//8OZV<*I[) ],@W/RW;R3.XR
8]IAYOAS&V-C)L)O]1\O);$F-].DP#]8QA W;E6B53=XTLYN/B0''68+R?@^3].FY[^/EA-/
=*.BN9>D@S=T:6]L7BS6+QUIINDV[3.69BBFWXD<+?=I--W?!MH]B=87W/ &BMG>%>#V1*Z*
R.FC9335/R7(3].FY[^/EA-/"".PXV7O.)L( [$_^DFO1$(#DCY,W$G@4(N2R8"9K-VCH.O)
7OW.1UB=161>L_,9;3639@^S2#:KUF1&>,%(N#BG-1)\\$:XP=,7N"C/&I?!#QK4K,6M>F\/
4O$I48[L8\U2,]W=?W.=SDLS^4W[M,$,\,CY4LB/\->F(_92+W>HZ0@<_CTO9P?9-[@I+CIG
6I@46"LYAO]:C^,ALE<=&$*/7AG2RS7KVK%>=*.BN9>D@S=T=LG.0,_#=1]VI"MY*MWW>-ND
1;^ @X'D;Y%%38@3P$NSM[9-OXVO-M :Y]._NZ0A*:>O 0N[*++N'D9#M@LH$L8<A!&QWMT2
=*.BN9>D@S=T=LG.0,_#=1]VM(D9VB49I/^TM$-LX[S)GXVT]Q- ,R/'&]+W64LNMC QA.Y9
Y6Z[,Y!FB*3E/O+>GTY/>'@^DK<K$:>QTA22'_$+:OH^(20?"D:]LWAI5D<*@M)T1S5+S"."
2O(.SKM2 /E*C^,ALE<=&$*/2S36F&A.Y.U+=*.BN9>D@S=TV0_@97R2U1;9H7#U!%(5E5:A
8ZWB/@BM!?!CLP.YD*WW"SJS@M)T1S5+S"."2O(.SKM2 /E*F=@.<,ME#XN95P3G-#]O)=A7
J+4;+__6J'&H,@W/RW;R3.XRQ.1*R57H#H[$]1L*1K*F17/U!%(-EGXN8G\$R,%;K5^TBW?(
I"MY*MWW>-ND;:  V<(_+2-M38@3P$NSM[9-OXVO-M :Y]._DG N4FM$(8J22"?A_7^>F+9(
SCTO8J*(V$+.&?Y]E</T@#$9/=1,BW1)64<]H\6-NLPMF'ZC)M/!61)J2*\F38@3P$NSM[9-
OXVO-M :Y]._NZ0A*:>O 0N[*++N'D9#M@LH9XM;W5AQC#!G=*.BN9>D@S=T"/C:.6U:0X((
]E/1DV@/AR7V1Q4^V6S\0RA'C^,ALE<=&$*/7AG2RS7KVK%>=*.BN9>D@S=TV0_@97R2U1;9
R(N:@/[4W!#(>:VADO'77@=Y0C5[RH[ 5O="Z//1T1QHR'OH+W_Q;I7%D:,O*++N'D9#M@LH
$L8<A!&QWMT2=*.BN9>D@S=TV0_@97R2U1;9H7#U!%(5E5:A8ZWB/@BM!?!CX_W\B<4O!:SC
@M)T1S5+S"."7Z6W]:LE#$)?@)2Y1G8;MK> +1 .9YZ6.!@M7C.X86HJ<8Y>1QY5SY/_Y=Q'
OY:<9A8+^UJ_JQ#&[2-7R3ZK[6?R0D.+0:/MT^]:ES7;K$337C.X86HJ<8Y>F<[Z%06NUP>9
\:#)4M:N^5WQI[BCB%[HR+FGI"MY*MWW>-ND=,M" 5J<U?=TA?N(\D.34TV%7C.X86HJ<8Y>
*<FQ:MIBDG(I8F':+HK?8U5B'_$+:OH^(20?P6D5GZ8"Q'K!\_<[<#U67?OS,5PE;H-(Q,TQ
D9*&+3^);=61S27+TS"U(HO-@O0S06?CCD""7C.X86HJ<8Y>1]%<J_9(@$A'@]T?I0\ 8+V#
I4,XC>Z)O4&EJQ#&[2-7R3ZKYP18=5BF]SOGRJD:=QJ2ZDO*MR2,1:0;<L6W^IGT,C#CY&?Z
O0/Y,%4RG!J]S/&7R@*9<T#,7C.X86HJ<8Y>DRL&!O)\K+>3A&(/]>YXNS:$I"MY*MWW>-ND
P6$'0$C9W6;!KZJRZI]JX@JO-5-=T104A$$U7C.X86HJ<8Y>F,L81LQN9>*8<*YC?CV@G2%P
?BQ3.S&+59!^I"MY*MWW>-ND!8UIZ.R*AB<%T/#O<,-AUI?013\W5R4Y[\Q%7C.X86HJ<8Y>
'9DB.V8V$V =,.OL\%B5L2<PJQ#&[2-7R3ZK0C5[RH[ 5O="M7@>;BB.5#>U9&:^87^/)^1D
A1H&)VCGN0Z%1=(KNS':(,!%C^,ALE<=&$*//8OZV<*I[) ]86TQ@0XOX:=AXGP'?\I1IK+B
B.!O49"*HV"(W4?O:@CD[T/=P5:C1-\"QM3!S"C$%H8=FV7,\&8.Z.WAG'SP7OW.1UB=161>
$+ '41A^'H@0KMX&!K,FBW>NO62A_@]_Z!R],'W9_GK_6XPPUA%8V5..BY;6&)'T12\#W@@8
0>KS\C0B)9=!VCB!+VXN7>G:%&%&\# Y&O$4DD\,,7ELQ?Z2*O&O<*AX]!@J;]]46S</(JEO
#%J*U]I=VB<,._C9BBDHD<D[7N[]-S@1%/5>U\XWA?^76:#7[$M1@&M,:2SLKB)6$AR>04RN
J&X!$&']E[VH21'3TR/X@Y=)E24H3G(IM."5E24H3G(IM."5E24H3G(IM."5E24H3G(IM."5
E24H3G(IM."5E24H3G(IM."5:-6(Q/D@R^5HT?1DV6UBJ;C1+BQQ6H8NR+TN-# JP*)P'3 T
DBPK^ OM0(*2+;!A2,13G  MXK/%O'"V/V/BJ5NTOQI6)L^I\L1>6MR%-_CR!\#9=";3=R4'
&KDN/;EGG$4:".,Q+ &5'S8(U'7EDWI\?774&,CTB$ZUB%D8$KUUK I2 R<2,@3N:VG A (R
=*.BN9>D@S=T)9-;"4%1-GLE@M)T1S5+S"."?P/T#O1&O$Q_@9Z&'";,2M&!MC9PHQ%8AN6V
WV->=BF;?QS?A$&E[9KPB!"$@M)T1S5+S"."@+A+]":3*3J OSXE%ZW]/O^_G[I:,?$S*A>?
VN=_PD\Z:@O: C4SI$=*ND,"C/E799^V"[&,TE&WXPA6B%_2@9Z&'";,2M&!MC9PHQ%8AN6V
WV->=BF;?QS?;GK%M9<(#>UN@M)T1S5+S"."F1>(**)&PN29SCTO8J*(V$+.U1W9TBQX41/5
,'W9_GK_6XPPYH/YMHQ,[6OF7]U^3D3R( Q?M$-LX[S)GXVT *OMO$- WS8 K7;^#F/N5#*M
'GY$ G>4^^P>B##56"Q<\5V(5MEQE;23%^56'SO>#4W#%8@?5QCD@Q95PN=7)%DP67]Z)!TD
^S[[T8''[\[[@X\NI7O6A+J#*D7"<>O9N'4JDJ8*.3;%,;&2U.!1U;;7*%#4,,-^N E0JY(P
9G"F6YYZ1WUF##C)/("8X>\,5MQ;B=N(8!96V!*5%(#XSGG8TQ]NR$]86^K3+./WMCW_C:,L
%/?$NM%<G ,4(\0Y&[M$(STCV1MW%9_ZCQ/9#?0DR@10E$,-<011O8YW9 IQ#GZCXO+< $T.
&%,7GT/)TPH8:!.;&@IHP+%H]Z+<M$CZVJOWYI;E(UX]_;WFWTR;>R""DL_?W^N3T 9N\UW?
9.9[5JGP-H]DKCI_W/^7Q0^NY'?AT_$$/+?DFXO]0Q>@2.F;_N8)_R%&W<_^;K>%2H7"ZB!N
-]\C#4G=IQ8W/()!/3;=):(\9_,!QC\YXYUGN=6P(O8)3;>Y]\],#8>,X=_W:Z>%P$&E;R]K
]CJ84>7]Z_?V (,RM7*17TP FB=XA"4A S6:3-O;J("UB%=,6>POPAQ*]W]9E68X7EG,Q%"5
W@^JWV>P=D;>6J/D^.H8B>!:I&^W2,?RY:6D^FUS$4<H;@'ZRCZNP\Q?1)?*@!,"WWB)?S& 
V_G$#:3*6\+;OMS)(R+GMF>^:W]V6UI,8U!K>)-\ _,$%-EX#.]<RY. QS0,:W]V6UI,8U!K
&Z3]5%]_C= ;]!;*LNVN7OST*TD.P>ODFGXKR. "'KBG3?7(?=M;\J 5_*%]"6N LY!/W70)
^,^A4:<"T /X"7W/9@3CR*T)1BI+K[-\S8M&QUT$K,8;A)7'F&)FH3UA8WB8*C,Z0FI8RVDJ
/R,]7?Q%N?D_CW.UJVV6SK^/,?#^?&ERO^XQ])==4O8K8D/T:!>R[4JP'\!H06:UM1>,-PY!
D17<UT]]\E.15LILE4WM%)-6.5$,)@^HYCPYFB>Y<VSOGYR:J^ >[+??:V*K@B_HWZ"#%6V"
8-4#<KHB&%A@VG7*V\77S*?:>&4:[2-)3O9X3A^L-=<(CG].2.TIB6RY8W=(2.TIB6RY8W=(
2.TIB6RY8W=(2.TIB6RY8W=(2.TIB6RY8W=(2.TIB6RY8W=(2.TIB6RY8W=(.JJ?Y84"G%0Z
E>&H&7LOY,R5"G?.UT.80.D*V6?X!_&W#@39;]-^@B9TM/]OTLXY!&2&>O+2]R5FF0+PEEOW
I^5NX%-IAMBG71A%N%(6YFA=8Z()O=9MB0YC#?>WJ_K8YZL-FV#RZQ6&_BZ;"P"#]V05&8L+
RSRCR]D4HK3+7;#:3 )@CEI=(R/Z3'W!,(XC#Y<K[A1&Q3H/OLC\_9,ZB^&^J Y5%?SD^8.H
;H\ALLT_K[9N^DK4P'@\SB;Z0L_/D1]'Z>5"=R1;Q_RJMG-W]%=J'M_X;E_T<L+1#=U^3E-R
H)=^@F)P]76@>U*,%\HSU>1[9Q1M4GUG&Q-GD'V5Z/64#TN00/$!,1F!C1= -E>)KP_M7+$V
II8.Z&LH$R*F.:B>E4!_-7LY1=(KNS':(,!%X?C Z.OC_[OAL+4K)R:D9M2P;IV_/VO^9S5N
2@K)K!'N<L-*<*YC?CV@G2%P,)_:H:ZNB8,P]Y,[Y_4DS=[W8^Z8(M3X<>UC\1^%7#QK06_Q
Z6H1_])<))GIK5\7I#'&XJZMBO)DJ-U<!0B*A&M,J!0O\TV$&TJI454^.0(;PH99T.F4_&7"
J&9-*;[O:T.HK!.5!UV#Z\.L"6N LY!/W70)00Y)QU_[[LM!#*Z,__#<X[@,RZ\LW>*'/G[+
.(%V$*NLO0<XRD[:^";[="7*;&1K=8\HJU)L1_S'YI)L15!'&PW*SJWY)_4;$V]^35"%0HD3
<&]O#)O?7P=P.\.V2<*@[*T[[==YI3;5KI[MJ$,F7XN5M$2H./(1T%2'A>\XTH:DNP[K=G+2
N>BRSR$[RENY'150-T15LN@=0I67A8,^'5)"_6[D2.U'"%[]\Y_[K5&SQA;S9J25&Z/=@UAF
;2F@,# 5 E%M$01O"XJJZ8P1D"5UC:!>!I606&QG'?M-Z&]898\:YO8!:%=EM]8/ WDX8C^W
.19?E9S>5A8Y$9PM&^#(/_<1BF]\(.!(?%**S42\WPW7R8G-WG[6Z_7<&^G>J4#(6U-=8,NI
6&QG'?M-Z&]898\:YO8!:%=E3!9+C9(0(6E,.19?E9S>5A8Y$9PM&^#(/_<1BF]\(.!(?%**
S42\WPW7R8G-NA+]UG9^\_.ZLSAV;$)F[LBS.,;&V BP4.4X6?ZE:9<V#I]9(+;:DRUUJTX@
V^-Q N$H:(#;RB4! D77/>'*3B]%[6,0"WI.X;JFD%@:DG/A -V[;=N?BP  GFTP^<808)*>
J6!*3^[PJJ*I4608)#!2OH112P1'"8TF4!Q+^?IM?:(ED,+YQ.;NT%7]M,O$'UD7:Z=*;J@?
LG ,K-D]YW2R=-Z<!2=QS-5T!IRQ Y/<G\D&UZA!T2W)6*O7H6+B2C%;"5JAH*NUHU(0+3Z@
]IL=-]RAK*KVB6%L!QKU21*)3A.M2%N5*LY.H*NUHU(0+3Z@PKV%4+4<U7?"N+LN/D"]S\FX
(]W()=A[\S4CPL#^L4DD=$C"C4$D]+K[^UB-%#3FEOUHH#T47IAG8K5M)>I><(P,*RBARVYP
+ZW&#%'Y1]XO7C.X86HJ<8Y>7C.X86HJ<8Y>7C.X86HJ<8Y>;BQQ)H0 *L%N1<F8]7][^;I%
A[%FC39P?(*'[H9PLTO@WM3NBI/.-,.WW7:*P5:C1-\"QM3!H3AP**'DPCZA7C.X86HJ<8Y>
O5H&RJW%/46]G1ET8)/0'AN=)%!PAH?E/[8DXZ^OLE] $C/CNJR)DXK^292Z!;LH !N$:5\%
DTD;#-E5=W^37C.X86HJ<8Y>J,L%YHLV:-6H^;-*-5+9/T#YHSCSK,XW^FJC7C.X86HJ<8Y>
">RKAQ[6E>@)0:?]@BJ$_/A!F%V ;<'92OF87C.X86HJ<8Y>7C.X86HJ<8Y>C[F.W*ZS&XN/
'P'&G=&)DH(?VI=12\%N5=O:9#BFUT5\#-YDPEUC\*[V4*'"=%PR&,.!,^5T7C.X86HJ<8Y>
XG_<%YH#VN#BU]5'"U>$YE#7^^EO7BI4&T_[:M 8'N*XF&EJMDL4M]4H\KZVBB\ 9%)E?SZ*
7C.X86HJ<8Y>'-M((7K_*U<<N9(SMM^_@:VYC4IAXI@!-=F-DZR9L,OE.WN3;GNW'UXL919N
&U5,YG=0[,,;J%#+_)."R4NH2RJ^N<#/(%E+7XBZ<K#I@S%?>O'NBM[E\@-Z3XGA<S37BT!/
<@9 9P,.%DYR=K_MG!\2X6-VNS?.9]%2ZZ"[$Z)*W!:RVST3^@'0XGP"D%SZ$H2J9\6>C+$2
B87=@I^,<T>)'#E"=X,#MK0<\^$6X1,O(]3SU64/>V4TTT75KM05OV2,#?.NZAN65)?[C43J
K1:$Z'YG:12M0&0T/8)PRZU 3B]%[6,0"WI.6&KER Z4")-84FUL2)BZ91=2JI#]T#!=&3.J
Q!70CY',F7O$G@3O3?WJ-4R>''A:'YY#GZ4<N2SDUFGQ\3.YG@3O3?WJ-4R>%881785M\XT5
E^VI+N <E&27VL:\9'&@!57:I;^Q01)'/$^E)7/O/";VR&DEJ3B LYH4@3&I[ .ICC=!*[/L
K X.\+]FDABL?NP+9_[5<51^PH99T.F4_&7">Q6N-EFR>I1[>\1[LG0 AS=[]A9",E(5N$GV
#_B2-,D_A$(/L6JL/U/X&B&Q;_/6]>>U;5]O)TTR=2F9&HTGO70 K@WZ#MV]EK6R&+)'ZM*6
#$+" I'9.,(,H2'F*)7VIX&ANPG^LCB%V]2[];6N!3KE14'U>X=SJZ>,XP)[5BI%QW;0BC]6
]8BNOR:"MWWUPMNM5<IY]Z3"C7_Y$A#^@7^-A)N51^RXZO>$?7OU)-NLH1)]@G::&5.6]O:"
3_WQ$%(D:%)/J=3"7A5JHR2I+OM5F6D#$^\N,#6$Z@AX=%@P%1HU*999H_05IAGS868TU9*F
YFT.5YJ-.;/FR_&<HV_0<SC+T2];W;3OKCO1P5YYJ4A\BV'!8T*^^YG$R-!CC&]UQ+\8*/J,
Q_L;A7O!\Z#'I-&0:-_J$]2DC719P5PC#%J-TH:DNP[K=G+2UY'A3Q]V[+[7TS:FLW1%?+73
%*XU%KF'TNP4&JN"](1R]Z4:YWD\$[VU5-?G>=L%:1K7/ 9Y(=GSUT!_>XLA WJU&V%3-!L#
*%.A[&4"[GLHXD:$T]"N<[_BK3!);0KRLP&MPJK<!LP=AX'"38-/,\ [6X5-"3*D3H:=/88)
@I;K?:$<JUN"1_S'YI)L15!'P*"EGF-2Z:_ $;)Y%+"50H(1*)9>Z9/)TS$H6&QG'?M-Z&]8
98\:YO8!:%=E-'7!D#:J5Z\T"3*D3H:=/88)W"Y/V&OHR/;<1_S'YI)L15!'P*"EGF-2Z:_ 
,DXQ[!0K1( R*)9>Z9/)TS$H6&QG'?M-Z&]898\:YO8!:%=E-'7!D#:J5Z\T*<\:?0K?8 <I
GG\:4S\N5+B>KXK#X\:DX="O^TX3X:1*<7?[W<7,I67+O._=B/)A:T0$I3Z(_)IU$93G=8#\
ZO=+DV4>\GGJI5/ C5@EC5BE"WTAE5VB6%(+1'$58D"7+=)$^8I483R/$Z/YV>L)H?S)T0/9
:?.BQ3?*2K%I7)Z/,%ZG3WY<)@^I/Y6-^8DF\M/;Q\]_Z&7RB6OV-89%_P&)X*:TS.MEB&+@
8;/I?L_$>K)A::*U*VWHZ7-IJQH22@C156ZKG1ET8)/0'AN=[",WJ=)%A1CLE4/\1U1"P]Z5
T,0(^V6V,//07C.X86HJ<8Y>(](7KME1"T(C+*]4**C"F3@L9/%K3VF^_.!D6FAB?5Y?=-U:
<>#2CZJ[W1%QX9YX:?[2K(#A\ .($>49#>/P%2[=E%Q1:.859&:^87^/)^1D7C.X86HJ<8Y>
7C.X86HJ<8Y>O@D/GY:00E2^0"/6[,? 1$% S<FE"UI&X37-T5R![+]IM8/15!8R+;?9K:Y4
A#,N=N'^/O^$7C.X86HJ<8Y>G _8Y3+LWM"<(6./QW78*1PALD34:5 C[3BR 5RQ;^81]HL!
J$,F7XN5M$2HF9RN@RW4['^9:3W__W2NZ<=IJJI+0-_WTGZJP5:C1-\"QM3!,;@3-6%X"D Q
[ .ICC=!*[/L;E>;(CX#-.!NZ;[ 1D)HF,KI7C.X86HJ<8Y>.-NJ*P9P0Z$X+GSO)D@ 5[PN
D5K+<XY>V?N17C.X86HJ<8Y>Y\YP,3^X#I+G9(%_6^(J.IQD0/I$VRY\"&5 UTS<P"*6'Y/7
[J/13.J$$\/N=I-H1%TN6%UV13\W5R4Y[\Q%7C.X86HJ<8Y>])B#:^<)E _T]-%O+6ZO4Z_T
JQXI$WN0OMJKQ:U)"#T-QC'%D:%BB'#ZB[>1)RM@6"Y#8$HG7C.X86HJ<8Y>CC1XU:K8 VZ.
*>-6&<A1NAPIB5#YH\[K4+&)P1[@/B, P<C!"/O@^KQ@Q&@(M:9D*C>]JO>UIWOU*V:TOC:G
.K#^OWC0L%0ZM*+,/HYP+[2T](D1%G;Q6@_T"$-N_X$_4NL(*%@FDJXV\[$H20L&]*C?D>-)
'V,?T#J(5;$?@)02Q/77+D> US_@4F8DIM[7\#-6VTFNIDKP8K'G4M/8.<9BFZW$&&SVQ^J;
J-DUU#4WG[>H1U\VR<>*_>A'#":<4G1#QTP,L^EY!(7\?5>S[<H:_8'LTU/MJ6!*3^[PJJ*I
3)RS?<5+W[Y,[SM?H_8L(JGO8'#3%%P$5P9@ =@=SES2#:@!3B]%[6,0"WI.Q5Q*E#EO(XS%
GA+&I085Z):>3B]%[6,0"WI./01]K;Y<+(@]+_+L]1Z4_-8O(!%&&G,@,: @BZ-CN02%T)V+
T_N#EHH29]_3GLD-KU1$TER>P)M#;Y2!F9K 48P%W19>S:U1EEN7D_N=C>&6 =BVI@%23"X!
-@V1.W%/738V$4IP]U%4X@\12.TIB6RY8W=(2.TIB6RY8W=(2.TIB6RY8W=(2.TIB6RY8W=(
2.TIB6RY8W=(2.TIB6RY8W=(2.TIB6RY8W=( 9U94NH!M> ![Q [Q0$MXW?O=W&]/.&3N39W
[?QW?#]&L-_MFL*)2S^>I]J:RL73KD/M:WC*EB5Z MO[ *N6:-6(Q/D@R^5HT?1DV6UBJ;C1
+BQQ6H8NR+TNBZ)/($SA>/B+HQ/.[[T_E@:C7>=U@)\ @"M=DBPK^ OM0(*2<??H*L+ZJL9Q
5#8(C]H@/1U4.K#^OWC0L%0Z5'FN!1>5;S=4D,XO?_V56^N0+%EWZ6LCE^HL V++^+ECYP #
0H=5F1;I\-="0OOR'%D<^$Q"38@3P$NSM[9-KVQ'K"F)!9&OO5(V+12TTU>]%LY%.+^-T>H6
!;^LA[(#=1@%^1%HO&D]X1;Y/XMIO3":DWP_SCTO8J*(V$+.T]0=52XRD?[3]1L*1K*F17/U
<$SBA4B#K6%P&DM"XH=(\3L:^1%HO&D]X1;YL4>A[IF9;5ZQSCTO8J*(V$+.0OQ^M*P%BIM"
I;QEN%U"1%*EYQ"L$VE"J@?G!3[@@I3%[@<%HW7Z,-^[L;&C.,/#/";],QLXD8B@916E;XV1
_SK9B1N4Z,W_/+ZJ5PKWZ] \2$W&1N-S!]I(J0H2[("R;[JIYXBX%OOP4:+G56W\>.!@*B)5
!7,T^!<Q%M %V):G!YL_SY78<NT9KFT>NE]R.D;R%%*2P!$ZB9KONLY:S=N),'PR"11'^R\P
/C3:XA/O^X,^"WV(@\O]VPX+38@3P$NSM[9-Q)QQS+^?'B7$M:,[?$L!<,VU]1L*1K*F17/U
6+4,C]("QS!8E_LS4?+E;W>72^%$Q$/6SK%+8NDAA/:[^6=B#BGL_DC'V/\.%TNI625FYH$7
<3.$"=:[%R!Q2Q$J5?OS&U-+)W1/ T/!36HG3-IT7_!/-/M,H\K4/?Q2;%RC:MY"S%F340YJ
 D.#J$$:U5T"GM0^'VIRY%>>@)2Y1G8;MK> EDKS#N2*87F6G<O5S3["X2Z=F)51)DM4A,:8
TDY#&_ZSORG27OW.1UB=161>L_,9;3639@^S3KQ-W**6WP!.KMX&!K,FBW>NO62A_@]_Z!R]
XGP'?\I1IK+B9S)L 73?_#)GATD'D71Q[V"';4*E7HL1SM=M)+)0]]A0FM8D'_$+:OH^(20?
4UE&OXTWZ793EGJC&,Q 9%66GG/PXF9MO7B>11V\B7GWI*%%I&$&@:^S]@ND>/N#J__^XQIX
76_ IH.JX%9=$XO)N$DZH^ 37OW.1UB=161>L_,9;3639@^S3KQ-W**6WP!.KMX&!K,FBW>N
O62A_@]_Z!R],'W9_GK_6XPP6./3--=DA6!875_^!=1NG>]=Q6L]?MZPGRC%7OW.1UB=161>
L_,9;3639@^S<@*?BJER6.9R><(DAON4RUAY!("SKQ/Q]>4$K'M2-^!T\9FLJQ#&[2-7R3ZK
Z-R%C:A @87H33=Y3J>L6;]-.R\H*?'T+>L[]W(+4K295JSW'_$+:OH^(20?4UE&OXTWZ793
@"RXBMT&_\F 13\W5R4Y[\Q%:M0-!SHVI!-J'_$+:OH^(20?4UE&OXTWZ793:(^LS*A IP-H
/O+>GTY/>'@^A!_9DWY%7BF$A-P;EIFQYJ^$C^,ALE<=&$*/:%J#+%EV/Y!H'-CRJ]%[I:$<
/O+>GTY/>'@^0ZG$XP"Y-_-#V 2--6K(@?/84O$I48[L8\U2@;'&@A<;&MF!J#91DY6$Q=JH
Z%^>2<7VZ\_H1'+$/+((<V%$C^,ALE<=&$*//8OZV<*I[) ],@W/RW;R3.XR/(A3Z+%M<W4\
GHB5;VZA_2.>=G!\6_O-9TEV]1B2&C3*LSCU8(J58 T'^ A@B^A\+W*#@P:+NYY0*B9<;Z.[
Y:J+JX"\QRSE]1B2&C3*LSCUB%86]7ZV<=2(/X@8SQ\,XG4_C1ZJ@D1 RT*-=,&C)@WVQ(AT
XL8V+T-+YG'B7OW.1UB=161> 4=7-;6V420!/O+>GTY/>'@^ZOJCS$(EU\SJP04]:AO%#BO!
1.P,'M[H,J5$13\W5R4Y[\Q%#6K O7*PC:8-RYL<GH7GTA_+]1B2&C3*LSCU@M)T1S5+S"."
+0M0Y@Q=-H<MZ%^>2<7VZ\_HZMGBW,UL,&+J'_$+:OH^(20?4UE&OXTWZ7936V\I$8FTG.U;
13\W5R4Y[\Q%#6K O7*PC:8-GI\=F ?:4<R>4O$I48[L8\U2?18!G5,6]@1]Y+=^YZ=8023D
;N]6CQ#/+8!N68S-$N2 V\!9I"MY*MWW>-ND!8UIZ.R*AB<%PS3T#O]2,";#]E/1DV@/AR7V
ZS,"PA_1I^'K/B0''68+R?@^3].FY[^/EA-/[_N&*T#%JJKO!:;0QBCWL4,%PE[KYJ(60NC"
W6\T(T<HW>W=JQ#&[2-7R3ZK5P+$]AT[;5I7NU]$8/?_ )F[$2)&]\L?!Q@1M[9KKOXX0^"W
C^,ALE<=&$*//8OZV<*I[) ].WCKM[S*A[L[/O+>GTY/>'@^0W/@5S!#%6M# $GH,SK,T\0 
4O$I48[L8\U2?18!G5,6]@1]8R?&@OJVFN%C;N]6CQ#/+8!N<W6]@=U%$G9S4O$I48[L8\U2
=H%8(Y3$0A1V<+(DE,MJ;;5P;6[!FZ6JV+9M]1B2&C3*LSCU@M)T1S5+S"."_2WARH#[!%G]
N;H59.'E_HRY-K95$/REK(LV$2)&]\L?!Q@1%.3])(S+6]L4JQ#&[2-7R3ZK0C5[RH[ 5O="
Z//1T1QHR'OHN1C0SM#/U3ZYX@(QMF@#'_?B.?4 NLC!AGTYSJ+2Y6CRT7O.K\CURP+_J3&O
JQ#&[2-7R3ZKJH\W2<-:$F"JL>6')(NWDGJQ$2)&]\L?!Q@1F=B!ATIV?:B9'_$+:OH^(20?
4UE&OXTWZ793:.;5ZJ!&1'EH13\W5R4Y[\Q%L_J?%YUGO22S) ]!.M2VO<LDI"MY*MWW>-ND
!8UIZ.R*AB<%UEA%=;U8?<_6VCB!+VXN7>G:QZ# ^I$]CE#'B+,P$E8XK@F(<+(DE,MJ;;5P
)KTU)@&W2A8FY9'CLHL8J"[E0C5[RH[ 5O="Z//1T1QHR'OHA\UA0I-4M9:'2"?A_7^>F+9(
SCTO8J*(V$+.&?Y]E</T@#$9D+UH!=%.-1>0S "P$17D1BC,PO(C/)D6#=?"0C5[RH[ 5O="
Z//1T1QHR'OH+W_Q;I7%D:,O*++N'D9#M@LH9XM;W5AQC#!G=*.BN9>D@S=TV0_@97R2U1;9
XN6UZE_J$>[B<+(DE,MJ;;5P$5P:83-">1P1S35\UP*D97;-'SO>#4W#%8@?:LRB69E<3Z)J
A$\S&O1[#5&$>:VADO'77@=Y0C5[RH[ 5O="Z//1T1QHR'OHD"("O@;"K"N0];XE/%VFU/[U
GAWJ]1M!_N2>'SO>#4W#%8@?:LRB69E<3Z)JF0:E]EJ+IUZ98ZWB/@BM!?!CX_W\B<4O!:SC
@M)T1S5+S"."V8.R,.+C1$O997=P.N\/R^-E>/N#J__^XQIXGDT'Z1M[8.&>/B0''68+R?@^
W)1M$IQY8M[<SCTO8J*(V$+.&?Y]E</T@#$9?_XX L^5;+-_")IQ(W:!]P<(]Q- ,R/'&]+W
64LNMC QA.Y9OSJ7YEZW[/6_)P+#CT5J3X\G#@)_.EU#?(T.SCTO8J*(V$+.&?Y]E</T@#$9
D+UH!=%.-1>0S "P$17D1BC,42=8PO"\B5!10C5[RH[ 5O="Z//1T1QHR'OH<N9)%=N1ERAR
!.P[H9KK*_4$4MK-3$&E+>Q2Y9'CLHL8J"[E0C5[RH[ 5O="Z//1T1QHR'OH+SFPB>@7[I8O
7OW.1UB=161>J+4;+__6J'&H,@W/RW;R3.XRUP)%RI>6E677S "P$17D1BC,PO(C/)D6#=?"
0C5[RH[ 5O="Z//1T1QHR'OHD"("O@;"K"N0];XE/%VFU/[U5MEQE;23%^56'SO>#4W#%8@?
:LRB69E<3Z)JGC?!"(65MXR>P?7F?_@P%1C!7C.X86HJ<8Y>;N]6CQ#/+8!NN(96>NJ"1N"X
C^,ALE<=&$*/?DI4H\1R#35^%P\"U24%DG@77C.X86HJ<8Y>E\OO%K=J3$&7NM5FLS7)P_NZ
.2I"Q9"LAFTY,7$5!'DCUMPQ1.P,'M[H,J5$%OL*-@90$B<67C.X86HJ<8Y>V>XU&=$WT<G9
.$#;;V=8!Y$X+9=)AM::\+(M4O$I48[L8\U27+USV%[Q*)E<^IGT,C#CY&?Z'7!JZR'!0S,=
Q7/T>K.YJ@S%EC6F2L- )YZ67C.X86HJ<8Y>/THU[6BLE4D_&P_*P+N 2MH;9%Y/D'1=>"1D
C^,ALE<=&$*/-2PC5GWN(.@U%3AS/K6B$U<57N[]-S@1%/5>/+ZJ5PKWZ] \7KHXL1I8W$5>
-4T8AC5@60PU7C.X86HJ<8Y>2G?][@%$URU*.+*[\(L@2)TXP04]:AO%#BO!)<^>;D VR(,E
-;9D6*)6Y3(U@)2Y1G8;MK> +1 .9YZ6.!@MA1H&)VCGN0Z%5BI%QW;0BC]6U.!1U;;7*%#4
DG N4FM$(8J23].FY[^/EA-/)MBIZ<2RHE\F27XI83LR_QQ)7C.X86HJ<8Y>NYY0*B9<;Z.[
!*]!MC\PCUL$C^,ALE<=&$*//8OZV<*I[) ]86TQ@0XOX:=A->QRQX M?*HU7C.X86HJ<8Y>
GHB5;VZA_2.>@82RMD"BB@>!]1B2&C3*LSCU8(J58 T'^ A@]-S$G?>+PHOT7C.X86HJ<8Y>
NYY0*B9<;Z.[C7_Y$A#^@7^-DG N4FM$(8J23].FY[^/EA-/)MBIZ<2RHE\F27XI83LR_QQ)
7C.X86HJ<8Y>$2)&]\L?!Q@1TG^KV AAP:#2Q0DM.'A$-L_%C^,ALE<=&$*/ @]O84/B_D$"
CG@>9':+,\>.I^X72F,XO.NG:=L3.?'P>8=I+NM<Z50)>BLNASDYGDBH1$V'@IR'IR<&G3."
87V@:B#:?0%AWOI^I7$)<%;>$NFF_N4/S\<2DK(!A9:>KV>2F!_YN#[^:(J8*O&O<*AX]!@J
Z(?$UXA7XU7HTL[\"I4BQ,?2BV'GS&!O,IF+4YB\R%:;-_13T1$,ICX'E6W1_P]D5@067=__
E24H3G(IM."5E24H3G(IM."5E24H3G(IM."5E24H3G(IM."5E24H3G(IM."5E24H3G(IM."5
M#HJ3!I.:7JT?)[;098VXKA\?)[;098VXKA\?)[;098VXKA\?)[;098VXKA\?)[;098VXKA\
?)[;098VXKA\?)[;098VXKA\?)[;098VXKA\'J>T#P+T@"H>N)R3OX9&1SJXRTX!939U@H++
_ONR:A0N*<K^=>^12]VV3DUU\KX+.M[=&E/R*PH\09K\$UDKRI/0OZ=4*U'*_W;>O<V=?,7_
9/)$!K#!CEMD(&.*<F('^KD@-."2?;R"KZ@TNV9KT36R-&R[O2,8(TS, FN]GMIG=X!E/JJ>
.DA$$/DV,U(ZIL-1'"J)!].F38@3P$NSM[9-8E?@92_29,=B=*.BN9>D@S=T0.1>T)RL90% 
0[CZ4(D$W%Y#&,CTB$ZUB%D8 O'V+M/P__T"M[C,NHYL3O:W=*.BN9>D@S=TW&=:Q^EZ//'<
>/N#J__^XQIX?Q\!!62@B8=_9/)$!K#!CEMD*@A0,A.7[) J0C5[RH[ 5O="^[*,6!@ ]_7[
0[CZ4(D$W%Y#&,CTB$ZUB%D8 O'V+M/P__T",@3N:VG A (R=*.BN9>D@S=T)9-;"4%1-GLE
@M)T1S5+S"."?P/T#O1&O$Q_@)2Y1G8;MK> [KEBL0S7(Y/NB##56"Q<\5V(GAWJ]1M!_N2>
'SO>#4W#%8@?5QCD@Q95PN=7,.-L]%)QLL<PC+OK#?!&*$",42=8PO"\B5!10C5[RH[ 5O="
55=NU495KTA5T-Z\;TP'4AG0HR$^D=>DGKNC'?(_C(,].)$=/&(\SR=C1C@\)I_Q!J/1-L F
$SC9ZHOT5A432.TIB6RY8W=(2.TIB6RY8W=(2.TIB6RY8W=(2.TIB6RY8W=(2.TIB6RY8W=(
2.TIB6RY8W=(2.TIB6RY8W=(2.TIB6RY8W=(1I8N2D0E)LQ&__"H=TH[MRO_;<=G9FJL+PMM
'X.;R5&B@TD?WS)9V3@XO=G?3] KWA\+&5]/!:/,SW"[Z(L%:H&TTHDF:<5JI+8H)O8>-6FD
):D/"9F=Y38E0R&L\[NWYX1#_&/@?L(SOK;\"F^M1@]R^88*$I=GR_7CNM@2WN"+C,FX!'_>
FARPH-5NUZ>:7C.X86HJ<8Y>=K_MG!\2X6-VK-4_C!P^I">L,0\0R95&UXTQQ%"KU2*-0 O$
M*M/%U3 L>ZTLNA5Q:<ENQRRI#.%+3C=(">D F+*7R;RJJ "W!HMN7 V]@_<0Q'$A+']TL)#
NA^(21RK7!*Z;$X4%B>BX;!L(O(Z +6#O$(B_N8)_R%&W<_^;K>%2H7"ZB!N[#,9\51O?J7L
]%<A7QN[%#KTF)'?WK:TYP68DT2 "F$)*MJ3'9DB.V8V$V =2/AV@0TY &M(C7_Y$A#^@7^-
]Y,[Y_4DS=[W>LXJH9UW-.=ZA)N51^RXZO>$FA85GW\Z::^:=/:BO49QNJ!TP95I)^=K\P#!
,[I;GZQ1SC<S/150KHJ8^2 ]
#pragma PXL encrypted end
#pragma PXL encrypted begin
I8L1%;_*DEVE"FF@R7JNU$ *-MYVDD3+JPHVN_)SS3A]WC*[0MG$?>//JV5"T1#_X#7A8(W1
#YH7CJUT 2$/RY88?5_NAZ'+
#pragma PXL encrypted end







#endif

#ifdef FILL_DM14

M14_MAIN_CHK = M14_MAIN and CHIP_snps;
DM14_O_CHK = DM14_O and CHIP_snps;
DM14_CHK = DM14 and CHIP_snps;
// DUMMY SPEC : DM14_yy

//***DM14_DMM***
PATTERN_SPEC_DM14_0 = get_single_polygon_pattern(
	cell_prefix = "DMM14",
#ifdef VERTICAL_M14
    output = "OUTPUT_DM14", width = DMYYM_W, height = DMYYM_L,
	step_x = DMYYM_SX, step_y = DMYYM_SY,
	offset_x = DMYYM_OX, offset_y = DMYYM_OY,
#else
    output = "OUTPUT_DM14", width = DMYYM_L, height =  DMYYM_W,
	step_x = DMYYM_SY, step_y = DMYYM_SX,
	offset_x = DMYYM_OY, offset_y = DMYYM_OX,
#endif
    FSS = {
    { CHIP_snps, min_space = DMYYM_CHIP, context = INTERIOR },
#ifdef FULL_CHIP
    { CHIP_BOUNDARY, min_space = DMYYM_CHIP, context = INTERIOR },
#else
    { PRBOUNDARY, min_space = DMYYM_CHIP, context = INTERIOR },
#endif
    { INDDMY, min_space = DM_INDDMY },
    { TCDDMY_M14, min_space = DM_TCDDMY_MX },
    { M14_HOLE, min_space = 0 },
    { ALL_M14_GT1350, min_space = DMYY_MYYW },
    { ALL_M14_GT4050, min_space = DMYY_MYYWB },
    { BEOLBLK_FINAL, min_space = DMYYM_MYY },
    { DM14EXCL_FINAL, min_space = DMYYM_MYY },
    { CSR66_3485, min_space = DMYYM_MYY },
    { M14_MAIN, min_space = DMYYM_MYY },
    { DM14_O, min_space = DMYYM_DMYYO },
    { DM14, min_space = DMYYM_DMYY },
         { WRAPPER_DM14_O_L, min_space = DMYYM_DMYYO },
    },
	shift = 2,
	repeat = 3,
    starting_point = CENTER
);



//----------------------------------------------------------------------
//***DM14_DMS***
PATTERN_SPEC_DM14_1 = get_single_polygon_pattern(
	cell_prefix = "DMS14",
#ifdef VERTICAL_M14
    output = "OUTPUT_DM14", width =  DMYYS_W, height = DMYYS_L,
	step_x = DMYYS_SX, step_y = DMYYS_SY,
	offset_x = DMYYS_OX, offset_y = DMYYS_OY,
#else
    output = "OUTPUT_DM14", width = DMYYS_L, height = DMYYS_W,
	step_x = DMYYS_SY, step_y = DMYYS_SX,
	offset_x = DMYYS_OY, offset_y = DMYYS_OX,
#endif
    FSS = {
    { CHIP_snps, min_space = DMYYS_CHIP, context = INTERIOR },
#ifdef FULL_CHIP
    { CHIP_BOUNDARY, min_space = DMYYS_CHIP, context = INTERIOR },
#else
    { PRBOUNDARY, min_space = DMYYS_CHIP, context = INTERIOR },
#endif
    { INDDMY, min_space = DM_INDDMY },
    { TCDDMY_M14, min_space = DM_TCDDMY_MX },
    { M14_HOLE, min_space = 0 },
    { ALL_M14_GT1350, min_space = DMYY_MYYW },
    { ALL_M14_GT4050, min_space = DMYY_MYYWB },
    { BEOLBLK_FINAL, min_space = DMYYS_MYY },
    { DM14EXCL_FINAL, min_space = DMYYS_MYY },
    { CSR66_3485, min_space = DMYYS_MYY },
    { M14_MAIN, min_space = DMYYS_MYY },
    { DM14_O, min_space = DMYYS_DMYYO },
    { DM14, min_space = DMYYS_DMYY },
         { WRAPPER_DM14_O_L, min_space = DMYYS_DMYYO },
    },
	shift = 2,
	repeat = 3,
    starting_point = CENTER
);


//----------------------------------------------------------------------
//***DM14_O***
PATTERN_SPEC_DM14_2 = get_single_polygon_pattern(
    cell_prefix = "DMO14",
    output = "OUTPUT_DM14_O", width = DMYYO_W, height = DMYYO_L,
	step_x = DMYYO_SX, step_y = DMYYO_SY,
	offset_x = DMYYO_OX, offset_y = DMYYO_OY,
    FSS = {
#ifdef FULL_CHIP
    { CHIP_BOUNDARY, min_space = DMYY_CHIP, context = INTERIOR },
#else
    { PRBOUNDARY, min_space = DMYY_CHIP, context = INTERIOR },
#endif
    { CHIP_snps, min_space = DMYY_CHIP, context = INTERIOR },
    { INDDMY, min_space = DM_INDDMY },
    { TCDDMY_M14, min_space = DM_TCDDMY_MX },
    { M14_HOLE, min_space = 0 },
    { ALL_M14_GT1350, min_space = DMYY_MYYW },
    { ALL_M14_GT4050, min_space = DMYY_MYYWB },
    { BEOLBLK_FINAL, min_space = 0.144 },
    { DM14EXCL_FINAL, min_space = DM_DMXEXCL },
    { CSR66_3485, min_space = 0.144 },
    { M14_MAIN, min_space = DMYYO_MYY },
    { DM14_O, min_space = 0.54 },
    { DM14, min_space = DMYYO_DMYY },
         { WRAPPER_DM14_O_L, min_space = DMYYO_DMYYO },
    },
	shift = 2,
	repeat = 3,
    starting_point = CENTER
);

PATTERN_SPEC_DM14_2.polygon_fill.insertion.auto_rotate = PRIMARY_AXIS;


PATTERN_SPEC_DM14_0.polygon_fill.pattern_spec.other_pattern_spacing = {
    1 => > DMYYM_DMYY,
    2 => > DMYYM_DMYY,
};
PATTERN_SPEC_DM14_1.polygon_fill.pattern_spec.other_pattern_spacing = {
    0 => > DMYYS_DMYY,
    2 => > DMYYS_DMYY,
};
PATTERN_SPEC_DM14_2.polygon_fill.pattern_spec.other_pattern_spacing = {
    0 => > DMYYO_DMYY,
    1 => > DMYYO_DMYY,
};


SPEC_DM14 = unified_fill(
    fill_boundary = {
        layer = CHIP_snps,
        type = LAYER
    },
    fill_patterns = {
        PATTERN_SPEC_DM14_0,
        PATTERN_SPEC_DM14_1,
        PATTERN_SPEC_DM14_2,
    },
    criteria = {
        { 
            target = { target = MYY_DN_2_1 }, 
            fill_layer_keys = {"OUTPUT_DM14","OUTPUT_DM14_O"}, 
            design_layers = { M14_MAIN_CHK, DM14_CHK, DM14_O_CHK, WRAPPER_DM14_O_L} 
        }
    }, 
    delta_window = { MYY_DN_2_1_W, MYY_DN_2_1_W}, 
    delta_x = MYY_DN_2_1_S,
    delta_y = MYY_DN_2_1_S,
    window_layer = CHIP_snps,
    boundary = ALIGN,
	grid = vGRID

);



//***** fill *******************************************************************
DM14_C   = SPEC_DM14["OUTPUT_DM14"][0];
DM14_O_C = SPEC_DM14["OUTPUT_DM14_O"][0];
DM14_L   = SPEC_DM14["OUTPUT_DM14"][0];
#pragma PXL encrypted begin
9'1'4Q)^MGMD<)0'-M.2IPUP'Z7*D&-5%E\?UZ\E,^OEFP+7O#$ \31?5NF\34@G9H4Y#")-
7D\-9;)%@#I>$3!$\F!*J>L1+MO <I:,11@N8IY3 /7R;!MB
#pragma PXL encrypted end


DM14_O_L1 = SPEC_DM14["OUTPUT_DM14_O"][0];
#pragma PXL encrypted begin
 +4=0+4(*04 !T59O;CT&0T'^9UGT&1$[R_Y-<,2/=AH6DXUJ6_(E]7%#&:I^_KG"+X=?R[[
V<\U'PZ.U?+9V=[&THI8$VK99>"IT+<Y7J5E!*K62Q1QGW8$.=<ST&/O.6TYU4D=586+>.75
\*^B@**T.^/P&F%J0U(_BW<:_[.J_=;W8=S_TT<N8Q4/I>?3XBI/V=]52OWB -6W!5+S# H 
0.T(8X-8B:9 H<:AK'1*C)NA.Y;UO]*);%H[
#pragma PXL encrypted end


#pragma PXL encrypted begin
G??S+%>3FPZ=51(L9>"F'3I5>CX1-12-/&AZ;?QG=WF]\?!MP58#N3)#LGK!!B&@R*9JB 4&
4Z\+/,X#"\U3"J(P+0[^$] *=S:T._0UJ;5WXB1KF<''7?_B
#pragma PXL encrypted end


//=======================================================



// DUMMY SPEC : DM14_O_62
//***DM14_O_62***
PATTERN_SPEC_DM14_O_62 = get_single_adjustable_pattern(
    adj_type = SHRINK,
#ifdef VERTICAL_M14
    min_bound = { DMYYORW62_W, DMYYORW62_L },
    max_bound = { DMYYORW62_W, DMYYORW62_L_MAX },
    cell_prefix = "DMORW6214V",
    output = "OUTPUT_DM14_ORW62",
    spacing = { DMYYORW62_SX, DMYYORW62_SY },
#else
    min_bound = { DMYYORW62_L, DMYYORW62_W },
    max_bound = { DMYYORW62_L_MAX, DMYYORW62_W },
    cell_prefix = "DMORW6214H",
    output = "OUTPUT_DM14_ORW62",
    spacing = { DMYYORW62_SY, DMYYORW62_SX },
#endif
    FSS = {
#ifdef FULL_CHIP
    { CHIP_BOUNDARY, min_space = DMYY_CHIP, context = INTERIOR },
#else
    { PRBOUNDARY, min_space = DMYY_CHIP, context = INTERIOR },
#endif
    { CHIP_snps, min_space = DMYY_CHIP, context = INTERIOR },
    { INDDMY, min_space = DM_INDDMY },
    { TCDDMY_M14, min_space = DM_TCDDMY_MX },
    { M14_HOLE, min_space = 0 },
    { ALL_M14_GT1350, min_space = DMYY_MYYW },
    { ALL_M14_GT4050, min_space = DMYY_MYYWB },
    { BEOLBLK_FINAL, min_space = 0.144 },
    { DM14EXCL_FINAL, min_space = DM_DMXEXCL },
    { CSR66_3485, min_space = 0.144 },
    { M14_MAIN, min_space = DMYYORW62_MYY },
    { DM14_O, min_space = DMYYORW62_SX },
#ifdef VERTICAL_M14
    { DM14_O_W62, min_space_x = DMYYORW62_SX, min_space_y = DMYYORW62_SY, space_extension_x = DMYYORW62_SX, space_extension_y = DMYYORW62_SY },
#else
    { DM14_O_W62, min_space_x = DMYYORW62_SY, min_space_y = DMYYORW62_SX, space_extension_x = DMYYORW62_SY, space_extension_y = DMYYORW62_SX },
#endif
    { DM14_O_W90, min_space = DMYYORW62_DMYYO_W90 },
    { DM14, min_space = DMYYORW62_DMYY },
             { WRAPPER_DM14_O_L, min_space = DMYYORW62_DMYYO_W90 },
             { DM14_O_L1, min_space = DMYYORW62_DMYYO_W90 },
             { DM14_L, min_space = DMYYORW62_DMYY },
#pragma PXL encrypted begin
:_FZ(0ULWF!K7KK5H\T7'\5>/4N@SV@+4B4]U%F6F&UU B[4[=IK7.]EL,GM![I5.7U^TMX'
9MH/S9-+<"!F)KD!HF1LWK4FQ9C$DSQH3Q#%X8*-#S!IEV7ALHAHQ)^[M*:R"K>AR!+K7! *
I&!C?@6P:4JD JD=4KS$! 0"@!*4G1DGA(V YA^XLQ\%EY?F7+F/XX[(3P)<^5Y&8U/=K]#Y
R=1T,8Q#(A_)48YL XV:Y:!1O,FW\$! 4V:\J$'8_F4M*NFH
#pragma PXL encrypted end


    },
    shift = 2,
#pragma PXL encrypted begin
/JX'?N3[@$0^_<&A5SZPV(S]VV<B 98 '-7;BE8::ZR7/R2*E3+O=.9:9[Z5'O$LY1K\;R8>
(2\*\  L/+XAPM/!*!S)5$C"PR@@D%PXEEG#C2-N.76KU<.-ND5/128,K["ZM%[DI)0XW>"T
#pragma PXL encrypted end
    repeat = 3,
#pragma PXL encrypted begin
 "($+;5Q,V4 )?G_$J$8MW,EB,"C>4Z[06F(DU6[&=8IH(23WT33%AV*'[W?Q?R;N!C@J@3%
=^5R^%$=6P)WRE(TC=7$=R3*
#pragma PXL encrypted end
    starting_point = CENTER
);

PATTERN_SPEC_DM14_O_62.adjustable_fill.pattern_spec.pattern_spacing = {
    allowed_spacing_x = { > DMYYORW62_SC },
    allowed_spacing_y = { > DMYYORW62_SC },
    corner_extension_x = DMYYORW62_SC,
    corner_extension_y = DMYYORW62_SC,
    extension = INTERSECTION,
};

SPEC_DM14_O_62 = unified_fill(
	fill_patterns = {
        PATTERN_SPEC_DM14_O_62
    },
	fill_boundary = {
	    layer = CHIP_snps,
	    type = LAYER,
	},
    criteria = {
        {
           target = { range = ( MYY_DN_2ND, MYY_DN_VALUE - MYY_DN_MARGIN) },
#pragma PXL encrypted begin
,'[M.N[Q13HPLI6*]F_OH/JRK]%IN[+6H[2OUF6%LVN4I6;655%(><]J&%U5><4(3ZSH6/=Y
+',4+*F3S6TLD\WA(A8Q(L^36:S4\Z8D-QY9FM.PVUM"JI2:T2)PA):?9"G1&B"+8TG7-N :
7"$!]KO^OC%<N<Q9K-B]!K^YB[G=Y5>RIOJ+UT-H>N9Q)HO7EH3TFI6@*+J6+-92+:-#<[ L
:\C^6::K4HYK@_9^J'7_$,J#=._8%]*0L[QT@$"2[8Z[B.N L0M,D7_.;<:QT2)PA):?9"G1
&B"+8TG7-N :7"$!]KO^OC%<N<Q9K-B]!K^YB[G=Y5>RIOJ+UT-H>N9Q)HO7EH3TFI6@*+J6
+-92+:-#<[ L:\C^6::K4HYK@_9^J'7_$,J#=._8%]*0L[QTO3$S; GQA>>]EI/_I[/X8U>6
7C6U2T3DK[!>&7'0,GATI+4954)[\AAL6@M5[?$J3S>LI+;M
#pragma PXL encrypted end
           design_layers = { or_list({ M14_MAIN, DM14_O, DM14, DM14_O_L1, WRAPPER_DM14_O_L }) }, 
#pragma PXL encrypted begin
W?\359>6J ;=69F+7A5OWRQ9N5@NKU7.X*RY PYRPQD[W4 #SH;%74BH@G3.26RNE"X^--%)
!3VK8_N"_"P%7-#\IWY;( Q<
#pragma PXL encrypted end
           fill_layer_keys = "OUTPUT_DM14_ORW62", 
        },
    },
    delta_window = { MYY_DN_W, MYY_DN_W }, 
    delta_x = MYY_DN_S,
    delta_y = MYY_DN_S,
    boundary = ALIGN,
#pragma PXL encrypted begin
GW00!&@,6R>??Y_+FA'4^VU_&R)^\S5+ 68;IV>XCU5+YTRGU<)GO*X;W$756=$WO1)-GH]9
CAIX_@]RM<R.B!D\15^?(R.(^Y+XZ-7:GA7[-$E$8" 2% 8T3'E@,0,8-(I,\]7]B]4%*U?S
 49XDA9I<AP!J29'SFE&M *IQ3*S@/45%%S%HU8S*7JU'"2CMT%HP 1X7.VW(B%DLV7:YE8B
0"E4C. [ F% C*!+D)!_*_2,R1NOX9_>H(3)U6S@59.X2W#5
#pragma PXL encrypted end
    window_layer = CHIP_snps,
#pragma PXL encrypted begin
/+;F< J7S3 \Y9!!LN555J;EF1"EY=R&ZLB9 O*$U^4XN/\"M\6UM;4NAT6W&%)765:@/\X8
"C FZUDSD!T*B6=B&ZH-5/B)
#pragma PXL encrypted end

    grid = vGRID
);
//=======================================================

DM14W62_O_L_PRE = SPEC_DM14_O_62["OUTPUT_DM14_ORW62"][0];
DM14W62_O_L = SPEC_DM14_O_62["OUTPUT_DM14_ORW62"][0];

#pragma PXL encrypted begin
R+=L,*8'4'?(6RNI8$>F<0A;=;/[A3&"1 5U87IZH%Y)\!9A@=C"^XX;Q+B!:G),#_A)<;YJ
H]K%UU7EC&6CY1_S3A7XM*?E.J4,7XZB#H(ZZY';6"0Y'.WK<.HV&[#-O9UPHJ Y"ZNH"1>B
WG9]&JE"\L#>+$F868 (@/<L.9N. OL1@G8Y%\4:-F[,JN\7'POOY5@W8=$?;%AT%JP8_'ML
K7W41?(;EHRMH&2*>J&4,IR@STBEX8D3AN#/9[4=_#]1(%QG#<(9"J^SFGD-:<[YJX=((HUI
J=OP+_<=P>.I14RMP-"ZQ/-%U5O2DD8:XT;5Z3!PI +HPCKIK#XKH[=3,M6LIA^*\VP<OOJF
W7&<G<\M'W_=^15WZN;&J'/Y_:1HAT#R\Q_];@E)Y@[O3T5N>-"G!%67AHEXH]K%UU7EC&6C
YZ=OZI(V"KGG-,C]BDL1OK8TA:+9NA1TXJ^%B).<MR/H4X&(+>IB2+\MRD@M(]5N;=XQ0ZPC
Q\#"#K&@U/#'M8 ---LP4?2U8;U!DF6)#>AAI%2J)^8/:1ZDAAMYK^D[F=>&@9N:.7OD*_&!
I,)%SSC=:\RD>>%D*<4&^?QYX6KIQC=\LT3AZ5/78?]I4U3I&M;9FMVS3=<:X0=J>6RHTN[A
ZUJ-HO/:8C/KZBWX4Z(YN#CJRQ^I$'?G;]W+-B,&A!>K->\VEV" !CE<H667* W'H/QA=UTH
MK-/4"D.EC^VF=55.AR-,]69"H->4%EI0L@*'8Q#725$Z $=-!K-V?&OHE0T00NZYZ_1*ZI!
2:Z(?R<M8Z!)EV" !CE<H667* W'H/QA=UTH.UL77.06>B\[F=55.AR-,]69"H->4%EI0L@*
'8Q#725$Z $=-!K-V?&OHE0T-0J-"VLJ@&DU\D9P"L^\KP[RSSD FRYX#O'/C,7DYRL/:OV,
B;\I+T21:@B))^3 6T&(/E<GD<D3\#T\$6B14*YVD@W0I#%0Y +;5GF^\=7DP'(Q(EC89JC 
.3(I\(=;Q3$YV2N]3=#U!4#9_\+A]W8J&DK_..$X*&6>VXLXVD_^%DPMW(G:1KG84Y+=P*Y&
RCZ99POJ1VK*!UEZ4:E(T+('F@I$GR=BWB^:8U/) /;2/:QCTQPCI'-4L#_3\M\W#<(VB8[R
\ND7L7(AWS_RQTQ>5@(XK__'[)7[@@T0J$'L%T=G?T'RP007\ND7L7(AWS_R#']!P4-H&Q\,
/N(D01?#"_T^@<U5RB&A_)J!Y.G^T>-/*=WD0T1Y;A5S2]]#GW)A1/#(OJJ?M5HX4/EV1A6U
\H$=%0V1L_[R[E%%<G3/;A_NQK]T)C&;T6O&QK]T)C&;T6O&QK]T)C&;T6O&U;4NGKO%+J#5
;%56/ RH"U1L_7$=&AM?R/O]48]2E[TB,351G&S52-;. 5J<:_O4YGA=Z3MKX'=;54?S65;@
QK]T)C&;T6O&U2 V+#],H?C5@+;[>\T[TH: X9W]A_YOM4'A8 %W7@N?:%=@( $6D&<CL18@
FR2RWI:7ZQ2;;2X7[A.I>\IMQK]T)C&;T6O&BG^PVUWD-F"*9O676><5U6MFQE">+.;(7[?&
QK]T)C&;T6O&A'9D94L(N7F$)0Y%=$1_RC<E,D&3!7VK@$DRQK]T)C&;T6O&QK]T)C&;T6O&
@KG_MVY2R9B")(97!PORR+XD'KB:M@"?4D$>3'@ZI7, /=E,,Z/&]EQE[O0S0C_TL9)U?+!"
QK]T)C&;T6O&;.!W#0KHX\QLK?X!I:S*#E^M%^?;:ZO 1< 7^ W[?Y2[E"+X)FZ^;5I+G6 F
BM\Y-\CH %V*QK]T)C&;T6O&2/>B7, A#X=(B]E1#/&(Y?:+0J<3U+'], !"'2T*1_L1=*H=
5S"P#8=0("A7AX-G]3X=AWJ'TO]>Y-("?/#2PVZ9<PRFR';#&@!X1<1ZA\\:,!JKR>+?5(LP
7<WC9$!6QSE=CG6'U4_82M:.D92'3<:CZVF1J,,#P%S<3X"H%BCK&6M%)?(6Z.J_QAI_EIKH
<@?#I#\%KG)R!T.1@;0]_)L'14RMP-"ZQ/-%IH&7]VH1YDBFPH1I?-FG?+7"G$K;1=^7EC"<
9$O(6N?@[-QDRX]YD=?U%_K+X;VNJ!S3=*_AV2N]3=#U!4#9NC\]ZU/O'4NZ] ]=GT%#VG;T
$]R/IB^F:TL3O!&3T69V,U:\4*YVD@W0I#%0"C=!$)I#OGL*K3W9 Q3^/B>M4*YVD@W0I#%0
RHK@MR %GN?*F^-ZT.2)OFJ;=IB7RPLS$DAV#^_^%F(V%8L/>@]<P+3Z:8-ZAPJRYIKRZ/6'
V+E-9(FMG+S8B>S'H23ZT8B)-N8VJ"C9<:HV%%$&SGBG%>P4)5[J8 ;!YBXE;JI7L]\9FOMN
H*! .\@YO;&@
#pragma PXL encrypted end
M14_EXCEPT = copy( TCDDMY_ALL, ancestry = true ); 
M14X_T = or_list( { M14_MAIN, DM14_O, DM14, DM14_L, DM14_O_L1, WRAPPER_DM14_O_L, DM14W62_O_L } ); 
M14_CHK_METAL = ( M14X_T and gCHIP ) not M14_EXCEPT; 
M14_CHIP = gCHIP not M14_EXCEPT; 
_den_con = < MYY_DN_2ND;
_den_polygon_area_clip = false;
_den_print = false;
_den_print_only = false;

den_save_window_62_14 : function (void) returning void
{
    areaL1 = den_polygon_area("layer1", clip = _den_polygon_area_clip);
    areaL2 = den_polygon_area("layer2", clip = _den_polygon_area_clip);
    
    ratio = areaL1 / areaL2 + dblnp( areaL2 - MYY_DN_2ND_E ) * dblnz( areaL2 - MYY_DN_2ND_E ) * 1;

    if (dblccon(_den_con, ratio) && !isinf(ratio) && !isnan(ratio)) {
        if (!_den_print_only) {
            den_save_window(error_names = { "ratio", "areaL1", "areaL2" },
                            values      = { ratio, areaL1, areaL2 }
            );
        }
    
        if (_den_print || _den_print_only) {
            den_window_statistics(
                which_file  = 0,
                error_names = { "ratio", "areaL1", "areaL2" },
                values      = { ratio, areaL1, areaL2 }
            );
        }
    }
}
M14_LOW_DN_WINDON = density( output_type = CLIPPED_DELTA_WINDOW, window_layer = gCHIP, layer_hash = { "layer1" => M14_CHK_METAL, "layer2" => M14_CHIP }, delta_window = { MYY_DN_2ND_W,MYY_DN_2ND_W }, delta_x = MYY_DN_2ND_S, delta_y = MYY_DN_2ND_S, boundary = BACKUP, window_function = den_save_window_62_14 );
#pragma PXL encrypted begin
_Q-:$T@H9'O_S__L$+SI@;_/<P\W([2\"2-SFDF65H<NIK::RWA7"9\P9LW+L4.@6+_7!(*Q
D]+%1@MVN.:3D0^<=41F U21
#pragma PXL encrypted end

//***** spec *******************************************************************
// DUMMY SPEC : DM14_w62_O_DN
//***DM14_w62_O_DN***
PATTERN_SPEC_DM14_w62_O_DN = get_single_adjustable_pattern(
    adj_type = SHRINK,
#ifdef VERTICAL_M14
    min_bound = { DMYYORW62_W, DMYYORW62_L },
    max_bound = { DMYYORW62_W, DMYYORW62_L_MAX },
    cell_prefix = "DMORW62DN14V",
    output = "OUTPUT_DM14_ORW62_DN",
    spacing = { DMYYORW62_SX, DMYYORW62_SY },
#else
    min_bound = { DMYYORW62_L, DMYYORW62_W },
    max_bound = { DMYYORW62_L_MAX, DMYYORW62_W },
    cell_prefix = "DMORW62DN14H",
    output = "OUTPUT_DM14_ORW62_DN",
    spacing = { DMYYORW62_SY, DMYYORW62_SX },
#endif
    FSS = {
#ifdef FULL_CHIP
    { CHIP_BOUNDARY, min_space = DMYY_CHIP, context = INTERIOR },
#else
    { PRBOUNDARY, min_space = DMYY_CHIP, context = INTERIOR },
#endif
    { CHIP_snps, min_space = DMYY_CHIP, context = INTERIOR },
    { INDDMY, min_space = DM_INDDMY },
    { TCDDMY_M14, min_space = DM_TCDDMY_MX },
    { M14_HOLE, min_space = 0 },
    { ALL_M14_GT1350, min_space = DMYY_MYYW },
    { ALL_M14_GT4050, min_space = DMYY_MYYWB },
    { BEOLBLK_FINAL, min_space = 0.144 },
    { DM14EXCL_FINAL, min_space = DM_DMXEXCL },
    { CSR66_3485, min_space = 0.144 },
    { M14_MAIN, min_space = DMYYORW62_MYY },
    { DM14_O, min_space = DMYYORW62_SX },
#ifdef VERTICAL_M14
    { DM14_O_W62, min_space_x = DMYYORW62_SX, min_space_y = DMYYORW62_SY, space_extension_x = DMYYORW62_SX, space_extension_y = DMYYORW62_SY },
#else
    { DM14_O_W62, min_space_x = DMYYORW62_SY, min_space_y = DMYYORW62_SX, space_extension_x = DMYYORW62_SY, space_extension_y = DMYYORW62_SX },
#endif
    { DM14_O_W90, min_space = DMYYORW62_DMYYO_W90 },
    { DM14, min_space = DMYYORW62_DMYY },
             { WRAPPER_DM14_O_L, min_space = DMYYORW62_DMYYO_W90 },
             { DM14_O_L1, min_space = DMYYORW62_DMYYO_W90 },
             { DM14_L, min_space = DMYYORW62_DMYY },
              { DM14W62_O_L, min_space = DMYYORW62_DMYYO_W90 },
              { M14_LOW_DN_WINDON, min_space = 0, context = INTERIOR },

    },
    shift = 2,
#pragma PXL encrypted begin
8"\T*97V1AE@P7;*)TK/YJ;!5D[K/V^\T\M6V=N85G?:W5W9$M(\-T:F8!42]FMUK=^EL?[V
GVL"-2>VWQ2?#"!RPW,3KY\,AZ8YH8"@Q=6'6C1+6W+N\V1:W 6!TMZ6\0W<K)*Z@#@8CZ^L
#pragma PXL encrypted end
    repeat = 3,
#pragma PXL encrypted begin
61>G1YIQ*119CTT7"WBCZF:/C.Q%!1)3F@6,_C/Q):F"A4[^8S,BU8,<@ YC?1;W5ONU"JU]
'IQGS$A$KM,>66(1G[KG2O%9
#pragma PXL encrypted end
    starting_point = CENTER
);

PATTERN_SPEC_DM14_w62_O_DN.adjustable_fill.pattern_spec.pattern_spacing = {
    allowed_spacing_x = { > DMYYORW62_SC },
    allowed_spacing_y = { > DMYYORW62_SC },
    corner_extension_x = DMYYORW62_SC,
    corner_extension_y = DMYYORW62_SC,
    extension = INTERSECTION,
};


//=======================================================
//---------------------------------------------------------------------
SPEC_DM14_w62_O_DN = unified_fill(
    fill_patterns = {
        PATTERN_SPEC_DM14_w62_O_DN         
    },
    fill_boundary = {
        layer = CHIP_snps,
        type = LAYER,
    },
    grid = vGRID
);
//***** fill *******************************************************************
DM14W62_DN_O_L = SPEC_DM14_w62_O_DN["OUTPUT_DM14_ORW62_DN"][0];

DM14_O_L = or_list( { DM14_O_L1, DM14W62_O_L, DM14W62_DN_O_L } );

#pragma PXL encrypted begin
B7*05=/Q.VF),#7M,L<#HK$PH ;^'9KUS%N@5Q;9PE=+:"%7U 'AK7/O-"34'Q$DB_O;YI8?
G?J);%DJ,E2==\/?IT$", MW
#pragma PXL encrypted end



#endif

#ifdef FILL_DM15

M15_MAIN_CHK = M15_MAIN and CHIP_snps;
DM15_O_CHK = DM15_O and CHIP_snps;
DM15_CHK = DM15 and CHIP_snps;
// DUMMY SPEC : DM15_yy

//***DM15_DMM***
PATTERN_SPEC_DM15_0 = get_single_polygon_pattern(
	cell_prefix = "DMM15",
#ifdef VERTICAL_M15
    output = "OUTPUT_DM15", width = DMYYM_W, height = DMYYM_L,
	step_x = DMYYM_SX, step_y = DMYYM_SY,
	offset_x = DMYYM_OX, offset_y = DMYYM_OY,
#else
    output = "OUTPUT_DM15", width = DMYYM_L, height =  DMYYM_W,
	step_x = DMYYM_SY, step_y = DMYYM_SX,
	offset_x = DMYYM_OY, offset_y = DMYYM_OX,
#endif
    FSS = {
    { CHIP_snps, min_space = DMYYM_CHIP, context = INTERIOR },
#ifdef FULL_CHIP
    { CHIP_BOUNDARY, min_space = DMYYM_CHIP, context = INTERIOR },
#else
    { PRBOUNDARY, min_space = DMYYM_CHIP, context = INTERIOR },
#endif
    { INDDMY, min_space = DM_INDDMY },
    { TCDDMY_M15, min_space = DM_TCDDMY_MX },
    { M15_HOLE, min_space = 0 },
    { ALL_M15_GT1350, min_space = DMYY_MYYW },
    { ALL_M15_GT4050, min_space = DMYY_MYYWB },
    { BEOLBLK_FINAL, min_space = DMYYM_MYY },
    { DM15EXCL_FINAL, min_space = DMYYM_MYY },
    { CSR66_3485, min_space = DMYYM_MYY },
    { M15_MAIN, min_space = DMYYM_MYY },
    { DM15_O, min_space = DMYYM_DMYYO },
    { DM15, min_space = DMYYM_DMYY },
         { WRAPPER_DM15_O_L, min_space = DMYYM_DMYYO },
    },
	shift = 2,
	repeat = 3,
    starting_point = CENTER
);



//----------------------------------------------------------------------
//***DM15_DMS***
PATTERN_SPEC_DM15_1 = get_single_polygon_pattern(
	cell_prefix = "DMS15",
#ifdef VERTICAL_M15
    output = "OUTPUT_DM15", width =  DMYYS_W, height = DMYYS_L,
	step_x = DMYYS_SX, step_y = DMYYS_SY,
	offset_x = DMYYS_OX, offset_y = DMYYS_OY,
#else
    output = "OUTPUT_DM15", width = DMYYS_L, height = DMYYS_W,
	step_x = DMYYS_SY, step_y = DMYYS_SX,
	offset_x = DMYYS_OY, offset_y = DMYYS_OX,
#endif
    FSS = {
    { CHIP_snps, min_space = DMYYS_CHIP, context = INTERIOR },
#ifdef FULL_CHIP
    { CHIP_BOUNDARY, min_space = DMYYS_CHIP, context = INTERIOR },
#else
    { PRBOUNDARY, min_space = DMYYS_CHIP, context = INTERIOR },
#endif
    { INDDMY, min_space = DM_INDDMY },
    { TCDDMY_M15, min_space = DM_TCDDMY_MX },
    { M15_HOLE, min_space = 0 },
    { ALL_M15_GT1350, min_space = DMYY_MYYW },
    { ALL_M15_GT4050, min_space = DMYY_MYYWB },
    { BEOLBLK_FINAL, min_space = DMYYS_MYY },
    { DM15EXCL_FINAL, min_space = DMYYS_MYY },
    { CSR66_3485, min_space = DMYYS_MYY },
    { M15_MAIN, min_space = DMYYS_MYY },
    { DM15_O, min_space = DMYYS_DMYYO },
    { DM15, min_space = DMYYS_DMYY },
         { WRAPPER_DM15_O_L, min_space = DMYYS_DMYYO },
    },
	shift = 2,
	repeat = 3,
    starting_point = CENTER
);


//----------------------------------------------------------------------
//***DM15_O***
PATTERN_SPEC_DM15_2 = get_single_polygon_pattern(
    cell_prefix = "DMO15",
    output = "OUTPUT_DM15_O", width = DMYYO_W, height = DMYYO_L,
	step_x = DMYYO_SX, step_y = DMYYO_SY,
	offset_x = DMYYO_OX, offset_y = DMYYO_OY,
    FSS = {
#ifdef FULL_CHIP
    { CHIP_BOUNDARY, min_space = DMYY_CHIP, context = INTERIOR },
#else
    { PRBOUNDARY, min_space = DMYY_CHIP, context = INTERIOR },
#endif
    { CHIP_snps, min_space = DMYY_CHIP, context = INTERIOR },
    { INDDMY, min_space = DM_INDDMY },
    { TCDDMY_M15, min_space = DM_TCDDMY_MX },
    { M15_HOLE, min_space = 0 },
    { ALL_M15_GT1350, min_space = DMYY_MYYW },
    { ALL_M15_GT4050, min_space = DMYY_MYYWB },
    { BEOLBLK_FINAL, min_space = 0.144 },
    { DM15EXCL_FINAL, min_space = DM_DMXEXCL },
    { CSR66_3485, min_space = 0.144 },
    { M15_MAIN, min_space = DMYYO_MYY },
    { DM15_O, min_space = 0.54 },
    { DM15, min_space = DMYYO_DMYY },
         { WRAPPER_DM15_O_L, min_space = DMYYO_DMYYO },
    },
	shift = 2,
	repeat = 3,
    starting_point = CENTER
);

PATTERN_SPEC_DM15_2.polygon_fill.insertion.auto_rotate = PRIMARY_AXIS;


PATTERN_SPEC_DM15_0.polygon_fill.pattern_spec.other_pattern_spacing = {
    1 => > DMYYM_DMYY,
    2 => > DMYYM_DMYY,
};
PATTERN_SPEC_DM15_1.polygon_fill.pattern_spec.other_pattern_spacing = {
    0 => > DMYYS_DMYY,
    2 => > DMYYS_DMYY,
};
PATTERN_SPEC_DM15_2.polygon_fill.pattern_spec.other_pattern_spacing = {
    0 => > DMYYO_DMYY,
    1 => > DMYYO_DMYY,
};


SPEC_DM15 = unified_fill(
    fill_boundary = {
        layer = CHIP_snps,
        type = LAYER
    },
    fill_patterns = {
        PATTERN_SPEC_DM15_0,
        PATTERN_SPEC_DM15_1,
        PATTERN_SPEC_DM15_2,
    },
    criteria = {
        { 
            target = { target = MYY_DN_2_1 }, 
            fill_layer_keys = {"OUTPUT_DM15","OUTPUT_DM15_O"}, 
            design_layers = { M15_MAIN_CHK, DM15_CHK, DM15_O_CHK, WRAPPER_DM15_O_L} 
        }
    }, 
    delta_window = { MYY_DN_2_1_W, MYY_DN_2_1_W}, 
    delta_x = MYY_DN_2_1_S,
    delta_y = MYY_DN_2_1_S,
    window_layer = CHIP_snps,
    boundary = ALIGN,
	grid = vGRID

);



//***** fill *******************************************************************
DM15_C   = SPEC_DM15["OUTPUT_DM15"][0];
DM15_O_C = SPEC_DM15["OUTPUT_DM15_O"][0];
DM15_L   = SPEC_DM15["OUTPUT_DM15"][0];
#pragma PXL encrypted begin
;H[L5520GQYN7^A:(J9?/!-?\-LQ,("PD=;P]X@17Y(MM-3W,(Z%H_*.4$DP&.Y5"+0\W5L8
!-H-?^JU](4$4.JZ0>Z&9)I0@&OB9WU8^CJ 6C>--8#Q@A-:
#pragma PXL encrypted end


DM15_O_L1 = SPEC_DM15["OUTPUT_DM15_O"][0];
#pragma PXL encrypted begin
^H]R%?  (67ZR*):572I/53([O< HNC,:W[NQCKJ+]_FH"3&?".(^<_!HZ%\'&# ^^W/OJH<
A7MZIK8CP9R%&P-7O<ASGQT;/<R;(1S.D2,]Y+7C9 G;)(?D#EI:\1?0+U\.SR_*3C=O#US/
QM D6UR /<?&K@N$>5Y!#0*N109J [?D_*-%,>Y2.;I5V/ Q4RJPHV.U-4535JAR1TB6K]Y6
K9>N%OG:BS&MMSH]JUWZ%BJW7MZ.48PE;,U>
#pragma PXL encrypted end


#pragma PXL encrypted begin
8%[2$EZ&9!1@=%,E/=4VA5]TG'05R;&2_YB<P^9PZC?JT'G#.3U 8U\.:30Y(HO2*B<BO8,B
C%,U0\G.0B^,MPQ>/2L,RL2WL\(XJJJ[Z8VS'XV=]"\YM:4?
#pragma PXL encrypted end


//=======================================================



// DUMMY SPEC : DM15_O_62
//***DM15_O_62***
PATTERN_SPEC_DM15_O_62 = get_single_adjustable_pattern(
    adj_type = SHRINK,
#ifdef VERTICAL_M15
    min_bound = { DMYYORW62_W, DMYYORW62_L },
    max_bound = { DMYYORW62_W, DMYYORW62_L_MAX },
    cell_prefix = "DMORW6215V",
    output = "OUTPUT_DM15_ORW62",
    spacing = { DMYYORW62_SX, DMYYORW62_SY },
#else
    min_bound = { DMYYORW62_L, DMYYORW62_W },
    max_bound = { DMYYORW62_L_MAX, DMYYORW62_W },
    cell_prefix = "DMORW6215H",
    output = "OUTPUT_DM15_ORW62",
    spacing = { DMYYORW62_SY, DMYYORW62_SX },
#endif
    FSS = {
#ifdef FULL_CHIP
    { CHIP_BOUNDARY, min_space = DMYY_CHIP, context = INTERIOR },
#else
    { PRBOUNDARY, min_space = DMYY_CHIP, context = INTERIOR },
#endif
    { CHIP_snps, min_space = DMYY_CHIP, context = INTERIOR },
    { INDDMY, min_space = DM_INDDMY },
    { TCDDMY_M15, min_space = DM_TCDDMY_MX },
    { M15_HOLE, min_space = 0 },
    { ALL_M15_GT1350, min_space = DMYY_MYYW },
    { ALL_M15_GT4050, min_space = DMYY_MYYWB },
    { BEOLBLK_FINAL, min_space = 0.144 },
    { DM15EXCL_FINAL, min_space = DM_DMXEXCL },
    { CSR66_3485, min_space = 0.144 },
    { M15_MAIN, min_space = DMYYORW62_MYY },
    { DM15_O, min_space = DMYYORW62_SX },
#ifdef VERTICAL_M15
    { DM15_O_W62, min_space_x = DMYYORW62_SX, min_space_y = DMYYORW62_SY, space_extension_x = DMYYORW62_SX, space_extension_y = DMYYORW62_SY },
#else
    { DM15_O_W62, min_space_x = DMYYORW62_SY, min_space_y = DMYYORW62_SX, space_extension_x = DMYYORW62_SY, space_extension_y = DMYYORW62_SX },
#endif
    { DM15_O_W90, min_space = DMYYORW62_DMYYO_W90 },
    { DM15, min_space = DMYYORW62_DMYY },
             { WRAPPER_DM15_O_L, min_space = DMYYORW62_DMYYO_W90 },
             { DM15_O_L1, min_space = DMYYORW62_DMYYO_W90 },
             { DM15_L, min_space = DMYYORW62_DMYY },
#pragma PXL encrypted begin
+F"9!Q1?IV8NU*TOER [#F#4%%& @@'W<UX4V!T(Z:ZV-?_8N=,\?"&P9[FY!9R"7F3_<DT%
\NXXHRF/V97RM]C,II\L[ *WC3?\TUUAW:6-&CYH &",?LT:98-F[E4</JUE%=5'@XYIWU\5
+9(FGA7A[-TM&,6@@J130N,8;+#B3T#L@1)LX3C T?PQ'Z[A=;U2O$]#;+MU3!@IJ1T&8.1,
$7@& +W)40<15X4AV[O Y,-7_M,6?'R$&FW^BT=@<@)==@R+
#pragma PXL encrypted end


    },
    shift = 2,
#pragma PXL encrypted begin
RJ%O=+?I&7#*Y[X0;'*2P WGZO0"Z'&$E>KJ6"F"XX_18*E8"J+LOU1!1G\*S&[1?K43U>7,
,.0G.O+P270P9OTJ7Q*NMV=F"KSY_$.R(> *4T0SC1\JM&93)C\CM(87 I8F-7H'0$',T<XU
#pragma PXL encrypted end
    repeat = 3,
#pragma PXL encrypted begin
5J/U,U-:G#96%[[DFE5 O=,7+"@!M%$Z7^PLYC2ET'[HL;GF=1;">G0.:NMU#UG3$/R/B4D/
K7$U+!>X]TVM#!;W_A")#@<,
#pragma PXL encrypted end
    starting_point = CENTER
);

PATTERN_SPEC_DM15_O_62.adjustable_fill.pattern_spec.pattern_spacing = {
    allowed_spacing_x = { > DMYYORW62_SC },
    allowed_spacing_y = { > DMYYORW62_SC },
    corner_extension_x = DMYYORW62_SC,
    corner_extension_y = DMYYORW62_SC,
    extension = INTERSECTION,
};

SPEC_DM15_O_62 = unified_fill(
	fill_patterns = {
        PATTERN_SPEC_DM15_O_62
    },
	fill_boundary = {
	    layer = CHIP_snps,
	    type = LAYER,
	},
    criteria = {
        {
           target = { range = ( MYY_DN_2ND, MYY_DN_VALUE - MYY_DN_MARGIN) },
#pragma PXL encrypted begin
AO[>08S:K@N&*#D+16]#E @H:JKO^*#M;35J7975%-+@/ZU=^-OX1IP[U_7X%.04)*9CX ,4
1 -"_!+<IXM$V&MEQZM=1PW8<9LQEL&V$!)Q6)%I& YE7$Q8E2-9+&Y[>U657OYCDW%I_J1>
3B49[?/X;5%.TIEG\C-JKG[2^64<FJ.'137Y[F\A949K5W'N4'O28QVZZ.U0@#M+%U>*L$. 
IS^YZG;XWLBG94GLY)N6>HYE_>$RY;>176W]*D?8D_. +)PJ/BI1\*[(1KX^E2-9+&Y[>U65
7OYCDW%I_J1>3B49[?/X;5%.TIEG\C-JKG[2^64<FJ.'137Y[F\A949K5W'N4'O28QVZZ.U0
@#M+%U>*L$. IS^YZG;XWLBG94GLY)N6>HYE_>$RY;>176W]W9#YPR19\S#=P\R, JV6 &S#
>[OY?Z.VXP][D='(;,:MA-613%[!IH%X[KA,F2*F"(HN\%Z9
#pragma PXL encrypted end
           design_layers = { or_list({ M15_MAIN, DM15_O, DM15, DM15_O_L1, WRAPPER_DM15_O_L }) }, 
#pragma PXL encrypted begin
,X %7#5_$5@SL@(*Q[=PS*.RNX3=ER[U-H6[AB\&[^E:6]6&L76)7L3ODQJQG!Z):)OTGCJ<
T^P0BS%)N[G3Z&;[KYTY:'SH
#pragma PXL encrypted end
           fill_layer_keys = "OUTPUT_DM15_ORW62", 
        },
    },
    delta_window = { MYY_DN_W, MYY_DN_W }, 
    delta_x = MYY_DN_S,
    delta_y = MYY_DN_S,
    boundary = ALIGN,
#pragma PXL encrypted begin
8MON:6__(RUBG@;MG^/QD):>.<.[(@*%RX$Y&8N$H%]6\0\93<4E%'<&B9I-Q$,F$K#&2PC$
%,*UO;$4G6,4<!S$"8BY6P5P6M"N]?V@]#Q:9!Z"V<KS!LMDBOJ)'>EC<&:*0^4CX<--'9=#
3E\2@L<1AJI.OP;/8(O7(;F_77/DYL&!HH%=P9.M8<RK$VS!Q]2Q)P ,7;S'B+<AJ8/Q_C^(
OLX&U55B-P6^6UF4T*_D;HU;*QH]R4CO4L0K!Z&,[0*F#J@'
#pragma PXL encrypted end
    window_layer = CHIP_snps,
#pragma PXL encrypted begin
_QS%5A&*EC;_NY\!5$#+[.^[%5#$O?OG(J45[@KU^40"+:3N3Z5:+.[,$.]/6?>,#[IDZJ19
X4AKA%A/S4OA*$!:;Q[9P6,H
#pragma PXL encrypted end

    grid = vGRID
);
//=======================================================

DM15W62_O_L_PRE = SPEC_DM15_O_62["OUTPUT_DM15_ORW62"][0];
DM15W62_O_L = SPEC_DM15_O_62["OUTPUT_DM15_ORW62"][0];

#pragma PXL encrypted begin
5*O4)GGUZ")4D*8G!^XS\D*0P\+W6]1E!Q[#' ,6"T$GB3\<PBTBJU7C('G"5-_>P,]"*R]4
CO^:)@67R9&.1J.F^J,_ANA&_"77I%AO@O#\BHY#W@YK35V*K?;/]&H$(8"M'"!51_TYDW8<
GBCZ0-+;Y\^>/DJNK_YRE+(^R9^[Q<?:I:;);OE._:/3>DQN@:<MS20V%G>!(4M_VQ1 \SPA
RG2!PTX2E-+*G+5MT_MO0/J<-U/TEOI:08 W=[-I9DV/7ZAW?9(IAE@U4TI]OG1*OJ'O&&2^
DHL*608=N6F21!FQEXTN0)5$_04*;J9!E0;]-JD]7RKCA2(VI@[XLGK"Z7"FA>X6OOJHRU.%
=W\P_VK@NN5WT2$6)G419O[1,( $#2$%S] PR*Z-HD:,;^+(XFWJ=O(A!VKBCO^:)@67R9&.
96L+NW>4@ UE5Z*L:O/H]G-7H:DSK&>75K.AK0ZHX.!RUIJM\?<I;22C33#QTSAIH/\W*273
Q?3+JQ$2BD'%2E@+I'I-KIE*#_8CS/>L!>\/8#9TZ'@J<H9@'-)E/7!!G\ <H& CFTJMJ1B@
(TWX5V5'WTLC:E<Y*MG\9AMJ,!:QC 1/J(0PC5\HEB)=@>*-K,?62(:EDPVL,J(/IU&[(YPR
LZK>(!:%]$RS8Z.R,5BANX=CV8XOBAT0O(C9DU PO'SJQ-:3ZL^#1'Z.._OJ$=.N5PQND4P1
-740L?R[CVDU[UHW\9Q>[_SON";K;]/KIW"XS""[:@CLE4#,#!*,CO;AS+X,*OJL1*X54"8J
V?7 'Z63:B39ZL^#1'Z.._OJ$=.N5PQND4P1#\7LM!];C.@/[UHW\9Q>[_SON";K;]/KIW"X
S""[:@CLE4#,#!*,CO;AS+X,M9=)\C^M7ZNUL:L&?K$N),*Q_+ G;V R>,;\#2(9G2O_8^H-
T6T;TGOY%+/1]$QG@3Z)UH[T38X!3B\9CE--JBJ1*BU1FLFJ%<X+S+Q$8005=^#CNM;1IUMW
Q;D%<HLS=_;%7@C*1:@]-V5>PXLCX2ZDO&_#>0B0'):1.=!YE!!/923;(#24AR52M:.<P[:'
K^"5<"#])$&O2+_P"QX'<^9(\E(QQA"+Y8?RC".Y6X1\L5V,E@)KU7F@3I:6BPUM$.,V\2>+
BI#RSH_ C3"*G\<0[V),5T"?I!K0U= J ("DZ)0T7>RWE@KHBI#RSH_ C3"*<7FY$@*?34]Q
*?//7[9V:X I<>D$X?)A79IQY(;Q?X\4/7GDB(BB:&@2: >(U#4<5+<,J'C4?YVL6$8H-/=_
044<D,1Y0:-!"(*LM,G"VJ (> M%N8H!E9-X> M%N8H!E9-X> M%N8H!E9-XW=JP7E+^7'[=
K-L/Q5^JOFVLY\!BKQD9-!CG/<KD--NY,( ]-$5SU/HO\$ TL6E096Q='8"QD[J7?S=2#1>3
> M%N8H!E9-XJB;I=@\%A;NJXT9\FX-_E^WC-M:J+9 ?BG0VSVUI<W4/;)//\XC#R\KF8\_S
+F$5*D>ZCO0N[<(H^"H?WJ;M> M%N8H!E9-XB/_:YV4=!5N(.U)LH_F+RNH[_JOA5, \ "C^
> M%N8H!E9-X=>O&Y,2&2E=USL/=]PA8[LW.]$<GU5=%'93T> M%N8H!E9-X> M%N8H!E9-X
L4GL^0H3B_:Q_3[^D3&K=K_]*JZ!)VM&,#,JL5L :P%M-&"Q1L?H8#)3?[-&!!-NWW#%\MX$
> M%N8H!E9-X>%W.>/9PKW!XFUB,$H%%M22;GK4'J >F2LB>?K:L/A1?HR-^\$)\21D!5%CP
4,+E==1#D#=0> M%N8H!E9-X/(DC7U&:BT \HSH:B,V;<3:CWY!;3U^[N5C?=D$$*;+6I2=V
R/GEX;9D:+;(U$Z(VQ 1Q2;4\.S=2Z#Q\-CPL\W'>/F&&$FSVDVG]RJ^=K?:4AX\_6X!!/)2
860JC6V;U\=A .O^@L3):8$ /\P.Y5 S=58_1QE'3\Y$2Y5':-F*L8_1(0]H;K3Z&U/KBYAN
@@]ZDWF_A@N"]<*G9*]1?5WU1!FQEXTN0)5$R]?I';WPACW+([SN )-MV9@C"!]1,/,0M%((
@7+GO8_*_4Z!! FB@1V"%P($Z2J1MV3"4&SI7@C*1:@]-V5> /-YU! W$Y8 %M)ORK29OY 6
&1W_22U]+<D9W#03CW+H#FS<JBJ1*BU1FLFJW=[45 GBC57=D@\@]-4AD)"2JBJ1*BU1FLFJ
YM__!^Z+^K'FI6:2>=5DT)RE#Q']<RW2*-P/X VZ)R]J([?@Z\GA8&09EY_KCS;_%G.#\6J/
B,,Q/D/6W[^(S7+/X:$S+M#-4QOAW8LLY@]3;-AUZ6CUIG!LQC/M63NA\)K&2L(RW+.DPRM*
:SWA'%":NOIK
#pragma PXL encrypted end
M15_EXCEPT = copy( TCDDMY_ALL, ancestry = true ); 
M15X_T = or_list( { M15_MAIN, DM15_O, DM15, DM15_L, DM15_O_L1, WRAPPER_DM15_O_L, DM15W62_O_L } ); 
M15_CHK_METAL = ( M15X_T and gCHIP ) not M15_EXCEPT; 
M15_CHIP = gCHIP not M15_EXCEPT; 
_den_con = < MYY_DN_2ND;
_den_polygon_area_clip = false;
_den_print = false;
_den_print_only = false;

den_save_window_62_15 : function (void) returning void
{
    areaL1 = den_polygon_area("layer1", clip = _den_polygon_area_clip);
    areaL2 = den_polygon_area("layer2", clip = _den_polygon_area_clip);
    
    ratio = areaL1 / areaL2 + dblnp( areaL2 - MYY_DN_2ND_E ) * dblnz( areaL2 - MYY_DN_2ND_E ) * 1;

    if (dblccon(_den_con, ratio) && !isinf(ratio) && !isnan(ratio)) {
        if (!_den_print_only) {
            den_save_window(error_names = { "ratio", "areaL1", "areaL2" },
                            values      = { ratio, areaL1, areaL2 }
            );
        }
    
        if (_den_print || _den_print_only) {
            den_window_statistics(
                which_file  = 0,
                error_names = { "ratio", "areaL1", "areaL2" },
                values      = { ratio, areaL1, areaL2 }
            );
        }
    }
}
M15_LOW_DN_WINDON = density( output_type = CLIPPED_DELTA_WINDOW, window_layer = gCHIP, layer_hash = { "layer1" => M15_CHK_METAL, "layer2" => M15_CHIP }, delta_window = { MYY_DN_2ND_W,MYY_DN_2ND_W }, delta_x = MYY_DN_2ND_S, delta_y = MYY_DN_2ND_S, boundary = BACKUP, window_function = den_save_window_62_15 );
#pragma PXL encrypted begin
>\=Q7!3\#&1[,N1;Y D&*/XRPRDC%$-D"*?#-^ITF4YF]GXWJ"=20ZO*'6FH\H8H106MI&SR
09HNCXLSVVQ!6U,0BA/Z_MU;
#pragma PXL encrypted end

//***** spec *******************************************************************
// DUMMY SPEC : DM15_w62_O_DN
//***DM15_w62_O_DN***
PATTERN_SPEC_DM15_w62_O_DN = get_single_adjustable_pattern(
    adj_type = SHRINK,
#ifdef VERTICAL_M15
    min_bound = { DMYYORW62_W, DMYYORW62_L },
    max_bound = { DMYYORW62_W, DMYYORW62_L_MAX },
    cell_prefix = "DMORW62DN15V",
    output = "OUTPUT_DM15_ORW62_DN",
    spacing = { DMYYORW62_SX, DMYYORW62_SY },
#else
    min_bound = { DMYYORW62_L, DMYYORW62_W },
    max_bound = { DMYYORW62_L_MAX, DMYYORW62_W },
    cell_prefix = "DMORW62DN15H",
    output = "OUTPUT_DM15_ORW62_DN",
    spacing = { DMYYORW62_SY, DMYYORW62_SX },
#endif
    FSS = {
#ifdef FULL_CHIP
    { CHIP_BOUNDARY, min_space = DMYY_CHIP, context = INTERIOR },
#else
    { PRBOUNDARY, min_space = DMYY_CHIP, context = INTERIOR },
#endif
    { CHIP_snps, min_space = DMYY_CHIP, context = INTERIOR },
    { INDDMY, min_space = DM_INDDMY },
    { TCDDMY_M15, min_space = DM_TCDDMY_MX },
    { M15_HOLE, min_space = 0 },
    { ALL_M15_GT1350, min_space = DMYY_MYYW },
    { ALL_M15_GT4050, min_space = DMYY_MYYWB },
    { BEOLBLK_FINAL, min_space = 0.144 },
    { DM15EXCL_FINAL, min_space = DM_DMXEXCL },
    { CSR66_3485, min_space = 0.144 },
    { M15_MAIN, min_space = DMYYORW62_MYY },
    { DM15_O, min_space = DMYYORW62_SX },
#ifdef VERTICAL_M15
    { DM15_O_W62, min_space_x = DMYYORW62_SX, min_space_y = DMYYORW62_SY, space_extension_x = DMYYORW62_SX, space_extension_y = DMYYORW62_SY },
#else
    { DM15_O_W62, min_space_x = DMYYORW62_SY, min_space_y = DMYYORW62_SX, space_extension_x = DMYYORW62_SY, space_extension_y = DMYYORW62_SX },
#endif
    { DM15_O_W90, min_space = DMYYORW62_DMYYO_W90 },
    { DM15, min_space = DMYYORW62_DMYY },
             { WRAPPER_DM15_O_L, min_space = DMYYORW62_DMYYO_W90 },
             { DM15_O_L1, min_space = DMYYORW62_DMYYO_W90 },
             { DM15_L, min_space = DMYYORW62_DMYY },
              { DM15W62_O_L, min_space = DMYYORW62_DMYYO_W90 },
              { M15_LOW_DN_WINDON, min_space = 0, context = INTERIOR },

    },
    shift = 2,
#pragma PXL encrypted begin
W.)+<F'*[P'<5C5HNJ[12[)6A):-])KY@6&$ 188?)9*N(4!TT30BZ5F]W;3"#4X>,D>Y=D(
.DN "LUHD>(Z8$5(G;H\II-@MC";-R>=SQBV\CRJ X8AI1_R3!CI4V[R]I1,!PS'ABK7EC '
#pragma PXL encrypted end
    repeat = 3,
#pragma PXL encrypted begin
GU=((3% HB*?W'J#^E0T.NC<;:0K#U[%=<1MW=<EF1,Y(F'=0I*+L$OS-8Y"KQY='F3;<=RO
2=# $\]J/,M)K**4H+,U[%>L
#pragma PXL encrypted end
    starting_point = CENTER
);

PATTERN_SPEC_DM15_w62_O_DN.adjustable_fill.pattern_spec.pattern_spacing = {
    allowed_spacing_x = { > DMYYORW62_SC },
    allowed_spacing_y = { > DMYYORW62_SC },
    corner_extension_x = DMYYORW62_SC,
    corner_extension_y = DMYYORW62_SC,
    extension = INTERSECTION,
};


//=======================================================
//---------------------------------------------------------------------
SPEC_DM15_w62_O_DN = unified_fill(
    fill_patterns = {
        PATTERN_SPEC_DM15_w62_O_DN         
    },
    fill_boundary = {
        layer = CHIP_snps,
        type = LAYER,
    },
    grid = vGRID
);
//***** fill *******************************************************************
DM15W62_DN_O_L = SPEC_DM15_w62_O_DN["OUTPUT_DM15_ORW62_DN"][0];

DM15_O_L = or_list( { DM15_O_L1, DM15W62_O_L, DM15W62_DN_O_L } );

#pragma PXL encrypted begin
@DSE*@_J-$F"P9^_'% ]FT'!(7XIXR/4ZXTAL"?KL/E^)1RP^(4UPI4UHS#XQ"DIB;]-).W$
SK\2JK*/W;O."6QG"G[A3E$)
#pragma PXL encrypted end



#endif

#ifdef FILL_DM16

M16_MAIN_CHK = M16_MAIN and CHIP_snps;
DM16_CHK = DM16 and CHIP_snps;

// DUMMY SPEC : DM16_yx
//***DM16_DMB***
PATTERN_SPEC_DM16_0 = get_single_polygon_pattern(
	"DMB16", "OUTPUT_DM16", DMYXB_W, DMYXB_L,
	step_x = DMYXB_SX, step_y = DMYXB_SY,
	offset_x = DMYXB_OX, offset_y = DMYXB_OY,
    FSS = {
    { CHIP_snps, min_space = DMYX_CHIP, context = INTERIOR },
#ifdef FULL_CHIP
    { CHIP_BOUNDARY, min_space = DMYX_CHIP, context = INTERIOR },
#else
    { PRBOUNDARY, min_space = DMYX_CHIP, context = INTERIOR },
#endif
    { BEOLBLK_FINAL, min_space = DM_BEOLBLK },
    { INDDMY, min_space = DM_INDDMY },

    { DM16EXCL_FINAL, min_space = DM_DMXEXCL },
    { CSR66_3485, min_space = DM_BEOLBLK },
    { TCDDMY_M16, min_space = DM_TCDDMY_MX },

    { M16_HOLE, min_space = 0 },
    { ALL_M16_GT1350, min_space = DMYX_MYXW },
    { ALL_M16_GT4050, min_space = DMYX_MYXWB },
    { M16_MAIN, min_space = DMYXB_MYX },
    { DM16, min_space = DMYXB_DMYX },
    },
	shift = 2,
	repeat = 3,
    starting_point = CENTER
); //end of get_single_polygon_pattern


PATTERN_SPEC_DM16_1 = get_single_polygon_pattern(
//----------------------------------------------------------------------
//***DM16_DMM***
	"DMM16", "OUTPUT_DM16", DMYXM_W, DMYXM_L,
	step_x = DMYXM_SX, step_y = DMYXM_SY,
	offset_x = DMYXM_OX, offset_y = DMYXM_OY,
    FSS = {
    { CHIP_snps, min_space = DMYX_CHIP, context = INTERIOR },
#ifdef FULL_CHIP
    { CHIP_BOUNDARY, min_space = DMYX_CHIP, context = INTERIOR },
#else
    { PRBOUNDARY, min_space = DMYX_CHIP, context = INTERIOR },
#endif
    { BEOLBLK_FINAL, min_space = DM_BEOLBLK },
    { INDDMY, min_space = DM_INDDMY },

    { DM16EXCL_FINAL, min_space = DM_DMXEXCL },
    { CSR66_3485, min_space = DM_BEOLBLK },
    { TCDDMY_M16, min_space = DM_TCDDMY_MX },

    { M16_HOLE, min_space = 0 },
    { ALL_M16_GT1350, min_space = DMYX_MYXW },
    { ALL_M16_GT4050, min_space = DMYX_MYXWB },
    { M16_MAIN, min_space = DMYXM_MYX },
    { DM16, min_space = DMYXM_DMYX },
    },
    shift = 2,
	repeat = 3,
    starting_point = CENTER
); //end of get_single_polygon_pattern


//----------------------------------------------------------------------
//***DM16_DMS***

PATTERN_SPEC_DM16_2 = get_single_polygon_pattern(
	"DMS16", "OUTPUT_DM16", DMYXS_W, DMYXS_L,
	step_x = DMYXS_SX, step_y = DMYXS_SY,
	offset_x = DMYXS_OX, offset_y = DMYXS_OY,
    FSS = {
    { CHIP_snps, min_space = DMYX_CHIP, context = INTERIOR },
#ifdef FULL_CHIP
    { CHIP_BOUNDARY, min_space = DMYX_CHIP, context = INTERIOR },
#else
    { PRBOUNDARY, min_space = DMYX_CHIP, context = INTERIOR },
#endif
    { BEOLBLK_FINAL, min_space = DM_BEOLBLK },
    { INDDMY, min_space = DM_INDDMY },

    { DM16EXCL_FINAL, min_space = DM_DMXEXCL },
    { CSR66_3485, min_space = DM_BEOLBLK },
    { TCDDMY_M16, min_space = DM_TCDDMY_MX },

    { M16_HOLE, min_space = 0 },
    { ALL_M16_GT1350, min_space = DMYX_MYXW },
    { ALL_M16_GT4050, min_space = DMYX_MYXWB },
    { M16_MAIN, min_space = DMYXS_MYX },
    { DM16, min_space = DMYXS_DMYX },
    },
	shift = 2,
	repeat = 3,
    starting_point = CENTER
); //end of get_single_polygon_pattern

PATTERN_SPEC_DM16_2.polygon_fill.insertion.auto_rotate = PRIMARY_AXIS;

PATTERN_SPEC_DM16_0.polygon_fill.pattern_spec.other_pattern_spacing = {
    1 => > DMYXB_DMYX,
    2 => > DMYXB_DMYX,
};

PATTERN_SPEC_DM16_1.polygon_fill.pattern_spec.other_pattern_spacing = {
    0 => > DMYXM_DMYX,
    2 => > DMYXM_DMYX,
};

PATTERN_SPEC_DM16_2.polygon_fill.pattern_spec.other_pattern_spacing = {
    0 => > DMYXS_DMYX,
    1 => > DMYXS_DMYX,
};


SPEC_DM16 = unified_fill(
    fill_boundary = {
        layer = CHIP_snps,
        type = LAYER
    },
    fill_patterns = {
        PATTERN_SPEC_DM16_0,
        PATTERN_SPEC_DM16_1,
        PATTERN_SPEC_DM16_2,
    },
    criteria = {
        { 
            target = { target = MYX_DN_2 }, 
            fill_layer_keys = "OUTPUT_DM16", 
            design_layers = { M16_MAIN_CHK, DM16_CHK } 
        }
    }, 
    delta_window = { MYX_DN_2_W, MYX_DN_2_W }, 
    delta_x = MYX_DN_2_S,
    delta_y = MYX_DN_2_S,
    window_layer = CHIP_snps,
    boundary = ALIGN,
	grid = vGRID
);

//***** fill *******************************************************************
DM16_C = SPEC_DM16["OUTPUT_DM16"][0];
DM16_L = SPEC_DM16["OUTPUT_DM16"][0];
//=======================================================
#endif

#ifdef FILL_DM17

M17_MAIN_CHK = M17_MAIN and CHIP_snps;
DM17_CHK = DM17 and CHIP_snps;

// DUMMY SPEC : DM17_yx
//***DM17_DMB***
PATTERN_SPEC_DM17_0 = get_single_polygon_pattern(
	"DMB17", "OUTPUT_DM17", DMYXB_W, DMYXB_L,
	step_x = DMYXB_SX, step_y = DMYXB_SY,
	offset_x = DMYXB_OX, offset_y = DMYXB_OY,
    FSS = {
    { CHIP_snps, min_space = DMYX_CHIP, context = INTERIOR },
#ifdef FULL_CHIP
    { CHIP_BOUNDARY, min_space = DMYX_CHIP, context = INTERIOR },
#else
    { PRBOUNDARY, min_space = DMYX_CHIP, context = INTERIOR },
#endif
    { BEOLBLK_FINAL, min_space = DM_BEOLBLK },
    { INDDMY, min_space = DM_INDDMY },

    { DM17EXCL_FINAL, min_space = DM_DMXEXCL },
    { CSR66_3485, min_space = DM_BEOLBLK },
    { TCDDMY_M17, min_space = DM_TCDDMY_MX },

    { M17_HOLE, min_space = 0 },
    { ALL_M17_GT1350, min_space = DMYX_MYXW },
    { ALL_M17_GT4050, min_space = DMYX_MYXWB },
    { M17_MAIN, min_space = DMYXB_MYX },
    { DM17, min_space = DMYXB_DMYX },
    },
	shift = 2,
	repeat = 3,
    starting_point = CENTER
); //end of get_single_polygon_pattern


PATTERN_SPEC_DM17_1 = get_single_polygon_pattern(
//----------------------------------------------------------------------
//***DM17_DMM***
	"DMM17", "OUTPUT_DM17", DMYXM_W, DMYXM_L,
	step_x = DMYXM_SX, step_y = DMYXM_SY,
	offset_x = DMYXM_OX, offset_y = DMYXM_OY,
    FSS = {
    { CHIP_snps, min_space = DMYX_CHIP, context = INTERIOR },
#ifdef FULL_CHIP
    { CHIP_BOUNDARY, min_space = DMYX_CHIP, context = INTERIOR },
#else
    { PRBOUNDARY, min_space = DMYX_CHIP, context = INTERIOR },
#endif
    { BEOLBLK_FINAL, min_space = DM_BEOLBLK },
    { INDDMY, min_space = DM_INDDMY },

    { DM17EXCL_FINAL, min_space = DM_DMXEXCL },
    { CSR66_3485, min_space = DM_BEOLBLK },
    { TCDDMY_M17, min_space = DM_TCDDMY_MX },

    { M17_HOLE, min_space = 0 },
    { ALL_M17_GT1350, min_space = DMYX_MYXW },
    { ALL_M17_GT4050, min_space = DMYX_MYXWB },
    { M17_MAIN, min_space = DMYXM_MYX },
    { DM17, min_space = DMYXM_DMYX },
    },
    shift = 2,
	repeat = 3,
    starting_point = CENTER
); //end of get_single_polygon_pattern


//----------------------------------------------------------------------
//***DM17_DMS***

PATTERN_SPEC_DM17_2 = get_single_polygon_pattern(
	"DMS17", "OUTPUT_DM17", DMYXS_W, DMYXS_L,
	step_x = DMYXS_SX, step_y = DMYXS_SY,
	offset_x = DMYXS_OX, offset_y = DMYXS_OY,
    FSS = {
    { CHIP_snps, min_space = DMYX_CHIP, context = INTERIOR },
#ifdef FULL_CHIP
    { CHIP_BOUNDARY, min_space = DMYX_CHIP, context = INTERIOR },
#else
    { PRBOUNDARY, min_space = DMYX_CHIP, context = INTERIOR },
#endif
    { BEOLBLK_FINAL, min_space = DM_BEOLBLK },
    { INDDMY, min_space = DM_INDDMY },

    { DM17EXCL_FINAL, min_space = DM_DMXEXCL },
    { CSR66_3485, min_space = DM_BEOLBLK },
    { TCDDMY_M17, min_space = DM_TCDDMY_MX },

    { M17_HOLE, min_space = 0 },
    { ALL_M17_GT1350, min_space = DMYX_MYXW },
    { ALL_M17_GT4050, min_space = DMYX_MYXWB },
    { M17_MAIN, min_space = DMYXS_MYX },
    { DM17, min_space = DMYXS_DMYX },
    },
	shift = 2,
	repeat = 3,
    starting_point = CENTER
); //end of get_single_polygon_pattern

PATTERN_SPEC_DM17_2.polygon_fill.insertion.auto_rotate = PRIMARY_AXIS;

PATTERN_SPEC_DM17_0.polygon_fill.pattern_spec.other_pattern_spacing = {
    1 => > DMYXB_DMYX,
    2 => > DMYXB_DMYX,
};

PATTERN_SPEC_DM17_1.polygon_fill.pattern_spec.other_pattern_spacing = {
    0 => > DMYXM_DMYX,
    2 => > DMYXM_DMYX,
};

PATTERN_SPEC_DM17_2.polygon_fill.pattern_spec.other_pattern_spacing = {
    0 => > DMYXS_DMYX,
    1 => > DMYXS_DMYX,
};


SPEC_DM17 = unified_fill(
    fill_boundary = {
        layer = CHIP_snps,
        type = LAYER
    },
    fill_patterns = {
        PATTERN_SPEC_DM17_0,
        PATTERN_SPEC_DM17_1,
        PATTERN_SPEC_DM17_2,
    },
    criteria = {
        { 
            target = { target = MYX_DN_2 }, 
            fill_layer_keys = "OUTPUT_DM17", 
            design_layers = { M17_MAIN_CHK, DM17_CHK } 
        }
    }, 
    delta_window = { MYX_DN_2_W, MYX_DN_2_W }, 
    delta_x = MYX_DN_2_S,
    delta_y = MYX_DN_2_S,
    window_layer = CHIP_snps,
    boundary = ALIGN,
	grid = vGRID
);

//***** fill *******************************************************************
DM17_C = SPEC_DM17["OUTPUT_DM17"][0];
DM17_L = SPEC_DM17["OUTPUT_DM17"][0];
//=======================================================
#endif

#ifdef FILL_DM18
M18_MAIN_CHK = M18_MAIN and CHIP_snps;
DM18_CHK = DM18 and CHIP_snps;
// DUMMY SPEC : DM18_r
PATTERN_SPEC_DM18_0 = get_single_polygon_pattern(
//***DM18_B***
	"DMB18", "OUTPUT_DM18", DMRB_W, DMRB_L,
	step_x = DMRB_SX, step_y = DMRB_SY,
	offset_x = DMRB_OX, offset_y = DMRB_OY,
    FSS = {
    { CHIP_snps, min_space = DMR_CHIP, context = INTERIOR },
#ifdef FULL_CHIP
    { CHIP_BOUNDARY, min_space = DMR_CHIP, context = INTERIOR },
#else
    { PRBOUNDARY, min_space = DMR_CHIP, context = INTERIOR },
#endif
    { BEOLBLK_FINAL, min_space = DM_BEOLBLK },
    { CSR66_3485, min_space = DM_BEOLBLK },
    { DM18EXCL_FINAL, min_space = DM_DMXEXCL },
    { TCDDMY_M18, min_space = DM_TCDDMY_MX },
    { M18_HOLE, min_space = 0 },
    { ALL_M18_GT1350, min_space = DMR_MRW },
    { ALL_M18_GT4050, min_space = DMR_MRWB },
    { M18_MAIN, min_space = DMRB_MR },
    { DM18, min_space = DMRB_DMR },
    { INDDMY, min_space = DMRB_IND },
    },
	shift = 2,
	repeat = 3,
    starting_point = CENTER
);

//----------------------------------------------------------------------
//***DM18_M***
PATTERN_SPEC_DM18_1 = get_single_polygon_pattern(
	"DMM18", "OUTPUT_DM18", DMRM_W, DMRM_L,
	step_x = DMRM_SX, step_y = DMRM_SY,
	offset_x = DMRM_OX, offset_y = DMRM_OY,
    FSS = {
    { CHIP_snps, min_space = DMR_CHIP, context = INTERIOR },
#ifdef FULL_CHIP
    { CHIP_BOUNDARY, min_space = DMR_CHIP, context = INTERIOR },
#else
    { PRBOUNDARY, min_space = DMR_CHIP, context = INTERIOR },
#endif
    { BEOLBLK_FINAL, min_space = DM_BEOLBLK },
    { CSR66_3485, min_space = DM_BEOLBLK },
    { DM18EXCL_FINAL, min_space = DM_DMXEXCL },
    { TCDDMY_M18, min_space = DM_TCDDMY_MX },
    { M18_HOLE, min_space = 0 },
    { ALL_M18_GT1350, min_space = DMR_MRW },
    { ALL_M18_GT4050, min_space = DMR_MRWB },
    { M18_MAIN, min_space = DMRM_MR },
    { DM18, min_space = DMRM_DMR },
    { INDDMY, min_space = DMRM_IND },
    },
	shift = 2,
	repeat = 3,
    starting_point = CENTER
);
//----------------------------------------------------------------------
//***DM18_S***
PATTERN_SPEC_DM18_2 = get_single_polygon_pattern(
	"DMS18", "OUTPUT_DM18", DMRS_W, DMRS_L,
	step_x = DMRS_SX, step_y = DMRS_SY,
	offset_x = DMRS_OX, offset_y = DMRS_OY,
    FSS = {
    { CHIP_snps, min_space = DMR_CHIP, context = INTERIOR },
#ifdef FULL_CHIP
    { CHIP_BOUNDARY, min_space = DMR_CHIP, context = INTERIOR },
#else
    { PRBOUNDARY, min_space = DMR_CHIP, context = INTERIOR },
#endif
    { BEOLBLK_FINAL, min_space = DM_BEOLBLK },
    { CSR66_3485, min_space = DM_BEOLBLK },
    { DM18EXCL_FINAL, min_space = DM_DMXEXCL },
    { TCDDMY_M18, min_space = DM_TCDDMY_MX },
    { M18_HOLE, min_space = 0 },
    { ALL_M18_GT1350, min_space = DMR_MRW },
    { ALL_M18_GT4050, min_space = DMR_MRWB },
    { M18_MAIN, min_space = DMRS_MR },
    { DM18, min_space = DMRS_DMR },
    { INDDMY, min_space = DMRS_IND },
    },
	shift = 2,
	repeat = 3,
    starting_point = CENTER
);
//----------------------------------------------------------------------
//***DM18_I***
PATTERN_SPEC_DM18_3 = get_single_polygon_pattern(
	"DMI18", "OUTPUT_DM18", DMRIND_W, DMRIND_L,
	step_x = DMRIND_SX, step_y = DMRIND_SY,
	offset_x = DMRIND_OX, offset_y = DMRIND_OY,
    FSS = {
    { CHIP_snps, min_space = DMR_CHIP, context = INTERIOR },
#ifdef FULL_CHIP
    { CHIP_BOUNDARY, min_space = DMR_CHIP, context = INTERIOR },
#else
    { PRBOUNDARY, min_space = DMR_CHIP, context = INTERIOR },
#endif
    { BEOLBLK_FINAL, min_space = DM_BEOLBLK },
    { CSR66_3485, min_space = DM_BEOLBLK },
    { DM18EXCL_FINAL, min_space = DM_DMXEXCL },
    { TCDDMY_M18, min_space = DM_TCDDMY_MX },
    { M18_HOLE, min_space = 0 },
    { ALL_M18_GT1350, min_space = DMR_MRW },
    { ALL_M18_GT4050, min_space = DMR_MRWB },
    { INDDMY, min_space = DM_INDDMY },
    { M18_MAIN, min_space = DMRIND_MR },
    { DM18, min_space = DMRIND_DMR },
    { INDDMY_BUFFER, min_space = 0, context = INTERIOR },
    },
	shift = 2,
	repeat = 3,
    starting_point = CENTER
);

PATTERN_SPEC_DM18_2.polygon_fill.insertion.auto_rotate = PRIMARY_AXIS;


PATTERN_SPEC_DM18_0.polygon_fill.pattern_spec.other_pattern_spacing = {
    1 => > DMRB_DMR,
    2 => > DMRB_DMR,
    3 => > DMRB_DMR,
};

PATTERN_SPEC_DM18_1.polygon_fill.pattern_spec.other_pattern_spacing = {
    0 => > DMRM_DMR,
    2 => > DMRM_DMR,
    3 => > DMRM_DMR,
};

PATTERN_SPEC_DM18_2.polygon_fill.pattern_spec.other_pattern_spacing = {
    0 => > DMRS_DMR,
    1 => > DMRS_DMR,
    3 => > DMRS_DMR,
};

PATTERN_SPEC_DM18_3.polygon_fill.pattern_spec.other_pattern_spacing = {
    0 => > DMRIND_DMR,
    1 => > DMRIND_DMR,
    2 => > DMRIND_DMR,
};




SPEC_DM18 = unified_fill(
    fill_boundary = {
        layer = CHIP_snps,
        type = LAYER
    },
    fill_patterns = {
        PATTERN_SPEC_DM18_0,
        PATTERN_SPEC_DM18_1,
        PATTERN_SPEC_DM18_2,
        PATTERN_SPEC_DM18_3,
    },
    criteria = {
        { 
            target = { target = MR_DN_2_1 }, 
            fill_layer_keys = "OUTPUT_DM18", 
            design_layers = { M18_MAIN_CHK, DM18_CHK } 
        }
    }, 
    delta_window = { MR_DN_2_1_W, MR_DN_2_1_W }, 
    delta_x = MR_DN_2_1_S,
    delta_y = MR_DN_2_1_S,
    window_layer = CHIP_snps,
    boundary = ALIGN,
	grid = vGRID
);

//***** fill *******************************************************************
DM18_C = SPEC_DM18["OUTPUT_DM18"][0];
DM18_L = SPEC_DM18["OUTPUT_DM18"][0];
//=======================================================
#endif

#ifdef FILL_DM19
M19_MAIN_CHK = M19_MAIN and CHIP_snps;
DM19_CHK = DM19 and CHIP_snps;
// DUMMY SPEC : DM19_r
PATTERN_SPEC_DM19_0 = get_single_polygon_pattern(
//***DM19_B***
	"DMB19", "OUTPUT_DM19", DMRB_W, DMRB_L,
	step_x = DMRB_SX, step_y = DMRB_SY,
	offset_x = DMRB_OX, offset_y = DMRB_OY,
    FSS = {
    { CHIP_snps, min_space = DMR_CHIP, context = INTERIOR },
#ifdef FULL_CHIP
    { CHIP_BOUNDARY, min_space = DMR_CHIP, context = INTERIOR },
#else
    { PRBOUNDARY, min_space = DMR_CHIP, context = INTERIOR },
#endif
    { BEOLBLK_FINAL, min_space = DM_BEOLBLK },
    { CSR66_3485, min_space = DM_BEOLBLK },
    { DM19EXCL_FINAL, min_space = DM_DMXEXCL },
    { TCDDMY_M19, min_space = DM_TCDDMY_MX },
    { M19_HOLE, min_space = 0 },
    { ALL_M19_GT1350, min_space = DMR_MRW },
    { ALL_M19_GT4050, min_space = DMR_MRWB },
    { M19_MAIN, min_space = DMRB_MR },
    { DM19, min_space = DMRB_DMR },
    { INDDMY, min_space = DMRB_IND },
    },
	shift = 2,
	repeat = 3,
    starting_point = CENTER
);

//----------------------------------------------------------------------
//***DM19_M***
PATTERN_SPEC_DM19_1 = get_single_polygon_pattern(
	"DMM19", "OUTPUT_DM19", DMRM_W, DMRM_L,
	step_x = DMRM_SX, step_y = DMRM_SY,
	offset_x = DMRM_OX, offset_y = DMRM_OY,
    FSS = {
    { CHIP_snps, min_space = DMR_CHIP, context = INTERIOR },
#ifdef FULL_CHIP
    { CHIP_BOUNDARY, min_space = DMR_CHIP, context = INTERIOR },
#else
    { PRBOUNDARY, min_space = DMR_CHIP, context = INTERIOR },
#endif
    { BEOLBLK_FINAL, min_space = DM_BEOLBLK },
    { CSR66_3485, min_space = DM_BEOLBLK },
    { DM19EXCL_FINAL, min_space = DM_DMXEXCL },
    { TCDDMY_M19, min_space = DM_TCDDMY_MX },
    { M19_HOLE, min_space = 0 },
    { ALL_M19_GT1350, min_space = DMR_MRW },
    { ALL_M19_GT4050, min_space = DMR_MRWB },
    { M19_MAIN, min_space = DMRM_MR },
    { DM19, min_space = DMRM_DMR },
    { INDDMY, min_space = DMRM_IND },
    },
	shift = 2,
	repeat = 3,
    starting_point = CENTER
);
//----------------------------------------------------------------------
//***DM19_S***
PATTERN_SPEC_DM19_2 = get_single_polygon_pattern(
	"DMS19", "OUTPUT_DM19", DMRS_W, DMRS_L,
	step_x = DMRS_SX, step_y = DMRS_SY,
	offset_x = DMRS_OX, offset_y = DMRS_OY,
    FSS = {
    { CHIP_snps, min_space = DMR_CHIP, context = INTERIOR },
#ifdef FULL_CHIP
    { CHIP_BOUNDARY, min_space = DMR_CHIP, context = INTERIOR },
#else
    { PRBOUNDARY, min_space = DMR_CHIP, context = INTERIOR },
#endif
    { BEOLBLK_FINAL, min_space = DM_BEOLBLK },
    { CSR66_3485, min_space = DM_BEOLBLK },
    { DM19EXCL_FINAL, min_space = DM_DMXEXCL },
    { TCDDMY_M19, min_space = DM_TCDDMY_MX },
    { M19_HOLE, min_space = 0 },
    { ALL_M19_GT1350, min_space = DMR_MRW },
    { ALL_M19_GT4050, min_space = DMR_MRWB },
    { M19_MAIN, min_space = DMRS_MR },
    { DM19, min_space = DMRS_DMR },
    { INDDMY, min_space = DMRS_IND },
    },
	shift = 2,
	repeat = 3,
    starting_point = CENTER
);
//----------------------------------------------------------------------
//***DM19_I***
PATTERN_SPEC_DM19_3 = get_single_polygon_pattern(
	"DMI19", "OUTPUT_DM19", DMRIND_W, DMRIND_L,
	step_x = DMRIND_SX, step_y = DMRIND_SY,
	offset_x = DMRIND_OX, offset_y = DMRIND_OY,
    FSS = {
    { CHIP_snps, min_space = DMR_CHIP, context = INTERIOR },
#ifdef FULL_CHIP
    { CHIP_BOUNDARY, min_space = DMR_CHIP, context = INTERIOR },
#else
    { PRBOUNDARY, min_space = DMR_CHIP, context = INTERIOR },
#endif
    { BEOLBLK_FINAL, min_space = DM_BEOLBLK },
    { CSR66_3485, min_space = DM_BEOLBLK },
    { DM19EXCL_FINAL, min_space = DM_DMXEXCL },
    { TCDDMY_M19, min_space = DM_TCDDMY_MX },
    { M19_HOLE, min_space = 0 },
    { ALL_M19_GT1350, min_space = DMR_MRW },
    { ALL_M19_GT4050, min_space = DMR_MRWB },
    { INDDMY, min_space = DM_INDDMY },
    { M19_MAIN, min_space = DMRIND_MR },
    { DM19, min_space = DMRIND_DMR },
    { INDDMY_BUFFER, min_space = 0, context = INTERIOR },
    },
	shift = 2,
	repeat = 3,
    starting_point = CENTER
);

PATTERN_SPEC_DM19_2.polygon_fill.insertion.auto_rotate = PRIMARY_AXIS;


PATTERN_SPEC_DM19_0.polygon_fill.pattern_spec.other_pattern_spacing = {
    1 => > DMRB_DMR,
    2 => > DMRB_DMR,
    3 => > DMRB_DMR,
};

PATTERN_SPEC_DM19_1.polygon_fill.pattern_spec.other_pattern_spacing = {
    0 => > DMRM_DMR,
    2 => > DMRM_DMR,
    3 => > DMRM_DMR,
};

PATTERN_SPEC_DM19_2.polygon_fill.pattern_spec.other_pattern_spacing = {
    0 => > DMRS_DMR,
    1 => > DMRS_DMR,
    3 => > DMRS_DMR,
};

PATTERN_SPEC_DM19_3.polygon_fill.pattern_spec.other_pattern_spacing = {
    0 => > DMRIND_DMR,
    1 => > DMRIND_DMR,
    2 => > DMRIND_DMR,
};




SPEC_DM19 = unified_fill(
    fill_boundary = {
        layer = CHIP_snps,
        type = LAYER
    },
    fill_patterns = {
        PATTERN_SPEC_DM19_0,
        PATTERN_SPEC_DM19_1,
        PATTERN_SPEC_DM19_2,
        PATTERN_SPEC_DM19_3,
    },
    criteria = {
        { 
            target = { target = MR_DN_2_1 }, 
            fill_layer_keys = "OUTPUT_DM19", 
            design_layers = { M19_MAIN_CHK, DM19_CHK } 
        }
    }, 
    delta_window = { MR_DN_2_1_W, MR_DN_2_1_W }, 
    delta_x = MR_DN_2_1_S,
    delta_y = MR_DN_2_1_S,
    window_layer = CHIP_snps,
    boundary = ALIGN,
	grid = vGRID
);

//***** fill *******************************************************************
DM19_C = SPEC_DM19["OUTPUT_DM19"][0];
DM19_L = SPEC_DM19["OUTPUT_DM19"][0];
//=======================================================
#endif



//***** DmyVIA *******************************************************************






#ifdef FILL_DmyVIA1

VIA1_EXCL_REGION = BEOLBLK_FINAL or DV1EXCL or over_size( DVIA1_O, 0.15);

DM1_DV1_ORI = rectangles( (DM1 or DM1_O)) not_interacting VIA1_EXCL_REGION;
DM2_DV1_ORI     = rectangles( (DM2 or DM2_O)) not_interacting VIA1_EXCL_REGION;

#ifdef FILL_DM1
DM1_REGION_DV1_PRE = or_list( { DM1_DV1_ORI, DM1_L, WRAPPER_DM1_O_L, DM1_O_L } );
#else
DM1_REGION_DV1_PRE = copy(DM1_DV1_ORI);
#endif

#ifdef FILL_DM2
DM2_REGION_DV1_PRE = or_list( { DM2_DV1_ORI, DM2_L, WRAPPER_DM2_O_L, DM2_O_L } );
#else
DM2_REGION_DV1_PRE = copy(DM2_DV1_ORI);
#endif


VIA1W : const double = DVXA_W; 
LINEEND_M2V1 : const double = DVXA_E; 
LINEEND_M1V1 : const double = DVXA_E; 

VIA1FORBIDDENRING     =  over_size( M2_MAIN, DVXA_FORB2) not over_size( M2_MAIN, DVXA_FORB1);

#endif

#ifdef FILL_DmyVIA2

VIA2_EXCL_REGION = BEOLBLK_FINAL or DV2EXCL or over_size( DVIA2_O, 0.15);

DM2_DV2_ORI = rectangles( (DM2 or DM2_O)) not_interacting VIA2_EXCL_REGION;
DM3_DV2_ORI     = rectangles( (DM3 or DM3_O)) not_interacting VIA2_EXCL_REGION;

#ifdef FILL_DM2
DM2_REGION_DV2_PRE = or_list( { DM2_DV2_ORI, DM2_L, WRAPPER_DM2_O_L, DM2_O_L } );
#else
DM2_REGION_DV2_PRE = copy(DM2_DV2_ORI);
#endif

#ifdef FILL_DM3
DM3_REGION_DV2_PRE = or_list( { DM3_DV2_ORI, DM3_L, WRAPPER_DM3_O_L, DM3_O_L } );
#else
DM3_REGION_DV2_PRE = copy(DM3_DV2_ORI);
#endif


VIA2W : const double = DVXB_W;	
LINEEND_M3V2 : const double = DVXB_E;	
LINEEND_M2V2 : const double = DVXB_E;	

VIA2FORBIDDENRING = over_size( M3_MAIN, DVXB_FORB2) not over_size( M3_MAIN, DVXB_FORB1 );

#endif

#ifdef FILL_DmyVIA3

VIA3_EXCL_REGION = BEOLBLK_FINAL or DV3EXCL or over_size( DVIA3_O, 0.15);

DM3_DV3_ORI = rectangles( (DM3 or DM3_O)) not_interacting VIA3_EXCL_REGION;
DM4_DV3_ORI     = rectangles( (DM4 or DM4_O)) not_interacting VIA3_EXCL_REGION;

#ifdef FILL_DM3
DM3_REGION_DV3_PRE = or_list( { DM3_DV3_ORI, DM3_L, WRAPPER_DM3_O_L, DM3_O_L } );
#else
DM3_REGION_DV3_PRE = copy(DM3_DV3_ORI);
#endif

#ifdef FILL_DM4
DM4_REGION_DV3_PRE = or_list( { DM4_DV3_ORI, DM4_L, WRAPPER_DM4_O_L, DM4_O_L } );
#else
DM4_REGION_DV3_PRE = copy(DM4_DV3_ORI);
#endif


VIA3W : const double = DVXC_W;	
LINEEND_M4V3 : const double = DVXC_E;	
LINEEND_M3V3 : const double = DVXC_E;	

VIA3FORBIDDENRING = over_size( M4_MAIN, DVXC_FORB2) not over_size( M4_MAIN, DVXC_FORB1);

#endif

#ifdef FILL_DmyVIA4

VIA4_EXCL_REGION = BEOLBLK_FINAL or DV4EXCL or over_size( DVIA4_O, 0.15);

DM4_DV4_ORI = rectangles( (DM4 or DM4_O)) not_interacting VIA4_EXCL_REGION;
DM5_DV4_ORI     = rectangles( (DM5 or DM5_O)) not_interacting VIA4_EXCL_REGION;

#ifdef FILL_DM4
DM4_REGION_DV4_PRE = or_list( { DM4_DV4_ORI, DM4_L, WRAPPER_DM4_O_L, DM4_O_L } );
#else
DM4_REGION_DV4_PRE = copy(DM4_DV4_ORI);
#endif

#ifdef FILL_DM5
DM5_REGION_DV4_PRE = or_list( { DM5_DV4_ORI, DM5_L, WRAPPER_DM5_O_L, DM5_O_L } );
#else
DM5_REGION_DV4_PRE = copy(DM5_DV4_ORI);
#endif


VIA4W : const double = DVXD_W;	
LINEEND_M5V4 : const double = DVXD_E;	
LINEEND_M4V4 : const double = DVXD_E;	

VIA4FORBIDDENRING = over_size( M5_MAIN, DVXD_FORB2) not over_size( M5_MAIN, DVXD_FORB1);

#endif

#ifdef FILL_DmyVIA5

VIA5_EXCL_REGION = BEOLBLK_FINAL or DV5EXCL or over_size( DVIA5, 0.4);

DM5_DV5_ORI = rectangles( DM5) not_interacting VIA5_EXCL_REGION;
DM6_DV5_ORI     = rectangles( DM6) not_interacting VIA5_EXCL_REGION;

#ifdef FILL_DM5
DM5_REGION_DV5_PRE = DM5_DV5_ORI or DM5_L;
#else
DM5_REGION_DV5_PRE = copy(DM5_DV5_ORI);
#endif

#ifdef FILL_DM6
DM6_REGION_DV5_PRE = DM6_DV5_ORI or DM6_L;
#else
DM6_REGION_DV5_PRE = copy(DM6_DV5_ORI);
#endif


VIA5W : const double = DVYA_W;	
LINEEND_M6V5 : const double = DVYA_E;	
LINEEND_M5V5 : const double = DVYA_E;	

VIA5FORBIDDENRING = empty_layer();

#endif

#ifdef FILL_DmyVIA6

VIA6_EXCL_REGION = BEOLBLK_FINAL or DV6EXCL or over_size( DVIA6, 0.4);

DM6_DV6_ORI = rectangles( DM6) not_interacting VIA6_EXCL_REGION;
DM7_DV6_ORI     = rectangles( DM7) not_interacting VIA6_EXCL_REGION;

#ifdef FILL_DM6
DM6_REGION_DV6_PRE = DM6_DV6_ORI or DM6_L;
#else
DM6_REGION_DV6_PRE = copy(DM6_DV6_ORI);
#endif

#ifdef FILL_DM7
DM7_REGION_DV6_PRE = DM7_DV6_ORI or DM7_L;
#else
DM7_REGION_DV6_PRE = copy(DM7_DV6_ORI);
#endif


VIA6W : const double = DVYA_W;	
LINEEND_M7V6 : const double = DVYA_E;	
LINEEND_M6V6 : const double = DVYA_E;	

VIA6FORBIDDENRING = empty_layer();

#endif

#ifdef FILL_DmyVIA7

VIA7_EXCL_REGION = BEOLBLK_FINAL or DV7EXCL or over_size( DVIA7, 0.4);

DM7_DV7_ORI = rectangles( DM7) not_interacting VIA7_EXCL_REGION;
DM8_DV7_ORI     = rectangles( DM8) not_interacting VIA7_EXCL_REGION;

#ifdef FILL_DM7
DM7_REGION_DV7_PRE = DM7_DV7_ORI or DM7_L;
#else
DM7_REGION_DV7_PRE = copy(DM7_DV7_ORI);
#endif

#ifdef FILL_DM8
DM8_REGION_DV7_PRE = DM8_DV7_ORI or DM8_L;
#else
DM8_REGION_DV7_PRE = copy(DM8_DV7_ORI);
#endif


VIA7W : const double = DVY_W;	
LINEEND_M8V7 : const double = DVY_E;	
LINEEND_M7V7 : const double = DVY_E;	

VIA7FORBIDDENRING = empty_layer();

#endif

#ifdef FILL_DmyVIA8

VIA8_EXCL_REGION = BEOLBLK_FINAL or DV8EXCL or over_size( DVIA8, 0.4);

DM8_DV8_ORI = rectangles( DM8) not_interacting VIA8_EXCL_REGION;
DM9_DV8_ORI     = rectangles( DM9) not_interacting VIA8_EXCL_REGION;

#ifdef FILL_DM8
DM8_REGION_DV8_PRE = DM8_DV8_ORI or DM8_L;
#else
DM8_REGION_DV8_PRE = copy(DM8_DV8_ORI);
#endif

#ifdef FILL_DM9
DM9_REGION_DV8_PRE = DM9_DV8_ORI or DM9_L;
#else
DM9_REGION_DV8_PRE = copy(DM9_DV8_ORI);
#endif


VIA8W : const double = DVY_W;	
LINEEND_M9V8 : const double = DVY_E;	
LINEEND_M8V8 : const double = DVY_E;	

VIA8FORBIDDENRING = empty_layer();

#endif

#ifdef FILL_DmyVIA9

VIA9_EXCL_REGION = BEOLBLK_FINAL or DV9EXCL or over_size( DVIA9, 0.4);

DM9_DV9_ORI = rectangles( DM9) not_interacting VIA9_EXCL_REGION;
DM10_DV9_ORI     = rectangles( DM10) not_interacting VIA9_EXCL_REGION;

#ifdef FILL_DM9
DM9_REGION_DV9_PRE = DM9_DV9_ORI or DM9_L;
#else
DM9_REGION_DV9_PRE = copy(DM9_DV9_ORI);
#endif

#ifdef FILL_DM10
DM10_REGION_DV9_PRE = DM10_DV9_ORI or DM10_L;
#else
DM10_REGION_DV9_PRE = copy(DM10_DV9_ORI);
#endif


VIA9W : const double = DVY_W;	
LINEEND_M10V9 : const double = DVY_E;	
LINEEND_M9V9 : const double = DVY_E;	

VIA9FORBIDDENRING = empty_layer();

#endif

#ifdef FILL_DmyVIA10

VIA10_EXCL_REGION = BEOLBLK_FINAL or DV10EXCL or over_size( DVIA10, 0.4);

DM10_DV10_ORI = rectangles( DM10) not_interacting VIA10_EXCL_REGION;
DM11_DV10_ORI     = rectangles( DM11) not_interacting VIA10_EXCL_REGION;

#ifdef FILL_DM10
DM10_REGION_DV10_PRE = DM10_DV10_ORI or DM10_L;
#else
DM10_REGION_DV10_PRE = copy(DM10_DV10_ORI);
#endif

#ifdef FILL_DM11
DM11_REGION_DV10_PRE = DM11_DV10_ORI or DM11_L;
#else
DM11_REGION_DV10_PRE = copy(DM11_DV10_ORI);
#endif


VIA10W : const double = DVY_W;	
LINEEND_M11V10 : const double = DVY_E;	
LINEEND_M10V10 : const double = DVY_E;	

VIA10FORBIDDENRING = empty_layer();

#endif

#ifdef FILL_DmyVIA11

VIA11_EXCL_REGION = BEOLBLK_FINAL or DV11EXCL or over_size( DVIA11, 0.4);

DM11_DV11_ORI = rectangles( DM11) not_interacting VIA11_EXCL_REGION;
DM12_DV11_ORI     = rectangles( DM12) not_interacting VIA11_EXCL_REGION;

#ifdef FILL_DM11
DM11_REGION_DV11_PRE = DM11_DV11_ORI or DM11_L;
#else
DM11_REGION_DV11_PRE = copy(DM11_DV11_ORI);
#endif

#ifdef FILL_DM12
DM12_REGION_DV11_PRE = DM12_DV11_ORI or DM12_L;
#else
DM12_REGION_DV11_PRE = copy(DM12_DV11_ORI);
#endif


VIA11W : const double = DVY_W;	
LINEEND_M12V11 : const double = DVY_E;	
LINEEND_M11V11 : const double = DVY_E;	

VIA11FORBIDDENRING = empty_layer();

#endif

#ifdef FILL_DmyVIA12

VIA12_EXCL_REGION = BEOLBLK_FINAL or DV12EXCL or over_size( DVIA12, 0.4);

DM12_DV12_ORI = rectangles( DM12) not_interacting VIA12_EXCL_REGION;
DM13_DV12_ORI     = rectangles( DM13) not_interacting VIA12_EXCL_REGION;

#ifdef FILL_DM12
DM12_REGION_DV12_PRE = DM12_DV12_ORI or DM12_L;
#else
DM12_REGION_DV12_PRE = copy(DM12_DV12_ORI);
#endif

#ifdef FILL_DM13
DM13_REGION_DV12_PRE = DM13_DV12_ORI or DM13_L;
#else
DM13_REGION_DV12_PRE = copy(DM13_DV12_ORI);
#endif


VIA12W : const double = DVY_W;	
LINEEND_M13V12 : const double = DVY_E;	
LINEEND_M12V12 : const double = DVY_E;	

VIA12FORBIDDENRING = empty_layer();

#endif

#ifdef FILL_DM13
DM13_REGION_DV13_PRE = DM13 or DM13_L;
#else
DM13_REGION_DV13_PRE = copy(DM13);
#endif

#ifdef FILL_DM14
DM14_REGION_DV13_PRE  = DM14 or DM14_L;
#else
DM14_REGION_DV13_PRE  = copy(DM14);
#endif


VIA13W : const double = DVYY_W;	
LINEEND_M14V13 : const double = DVYY_EYY;	
LINEEND_M13V13 : const double = DVYY_EY;	

VIA13FORBIDDENRING = empty_layer();



#ifdef FILL_DM14
DM14_REGION_DV14_PRE = DM14 or DM14_L;
#else
DM14_REGION_DV14_PRE = copy(DM14);
#endif

#ifdef FILL_DM15
DM15_REGION_DV14_PRE  = DM15 or DM15_L;
#else
DM15_REGION_DV14_PRE  = copy(DM15);
#endif


VIA14W : const double = DVYY_W;	
LINEEND_M15V14 : const double = DVYY_EYY;	
LINEEND_M14V14 : const double = DVYY_EY;	

VIA14FORBIDDENRING = empty_layer();











#ifdef FILL_DmyVIA0


VIA0_EXCL_REGION = BEOLBLK_FINAL or DV0EXCL or over_size( DVIA0_O, 0.15);

DM0_DV0_ORI = rectangles( (DM0 or DM0_O)) not_interacting VIA0_EXCL_REGION;
DM1_DV0_ORI     = rectangles( (DM1 or DM1_O)) not_interacting VIA0_EXCL_REGION;

#ifdef FILL_DM0
DM0_REGION_DV0_PRE = or_list( { DM0_DV0_ORI, DM0_L, WRAPPER_DM0_O_L, DM0_O_L } );
#else
DM0_REGION_DV0_PRE = copy(DM0_DV0_ORI);
#endif

#ifdef FILL_DM1
DM1_REGION_DV0_PRE = or_list( { DM1_DV0_ORI, DM1_L, WRAPPER_DM1_O_L, DM1_O_L } );
#else
DM1_REGION_DV0_PRE = copy(DM1_DV0_ORI);
#endif


VIA0W : const double = DV0_W;	
LINEEND_M1V0 : const double = DV0_E;	
LINEEND_M0V0 : const double = DV0_E;	

VIA0FORBIDDENRING     =  over_size( M1_MAIN, DV0_FORB2) not over_size( M1_MAIN, DV0_FORB1);
DM1_REGION_DV0_PRE1 = copy( DM1_REGION_DV0_PRE );

#ifdef VERTICAL_M1
DM1_LEEDGE_DV0 = angle_edge( DM1_REGION_DV0_PRE1, == 0 );
#else
DM1_LEEDGE_DV0 = angle_edge( DM1_REGION_DV0_PRE1, == 90 );
#endif

CENTER_BAR_VALUE = VIA0W;
DM1_REGION_DV0_PRO = drc_features( primary_layer = DM1_REGION_DV0_PRE1, secondary_layers = { "layer2" => DM1_LEEDGE_DV0 }, output_from_layer = DM1_REGION_DV0_PRE1, include_touch = EDGE, drc_function = dfm_property_func_DV, combine_errors = OPPOSING ); 
DM1_REGION_DV0_RE = DM1_REGION_DV0_PRO not edge_size_by_property( DM1_REGION_DV0_PRO, inside_property = "Metal_W" );
DM1_REGION_DV0_LESHRINK = edge_size( DM1_LEEDGE_DV0, inside = LINEEND_M1V0 ); 
DM1_REGION_DV0 = DM1_REGION_DV0_RE not DM1_REGION_DV0_LESHRINK; 




DM0_REGION_DV0_PRE1 = DM0_REGION_DV0_PRE or CM0CELL_E_330_151 or CM0CELL_E_330_152;

#ifdef VERTICAL_M0
DM0_LEEDGE_DV0 = angle_edge( DM0_REGION_DV0_PRE1, == 0 );
#else
DM0_LEEDGE_DV0 = angle_edge( DM0_REGION_DV0_PRE1, == 90 );
#endif

CENTER_BAR_VALUE = VIA0W;
DM0_REGION_DV0_PRO = drc_features( primary_layer = DM0_REGION_DV0_PRE1, secondary_layers = { "layer2" => DM0_LEEDGE_DV0 }, output_from_layer = DM0_REGION_DV0_PRE1, include_touch = EDGE, drc_function = dfm_property_func_DV, combine_errors = OPPOSING ); 
DM0_REGION_DV0_RE = DM0_REGION_DV0_PRO not edge_size_by_property( DM0_REGION_DV0_PRO, inside_property = "Metal_W" );
DM0_REGION_DV0_LESHRINK = edge_size( DM0_LEEDGE_DV0, inside = LINEEND_M0V0 ); 
DM0_REGION_DV0 = DM0_REGION_DV0_RE not DM0_REGION_DV0_LESHRINK; 


REGION_DV0 = DM1_REGION_DV0 and DM0_REGION_DV0;
REGION_DV0_4 = REGION_DV0 not over_size( VIA0, 4);
REGION_DV0_4_PRE1 = size( size( size( REGION_DV0_4, 0.05, clip_acute = TRUNCATE ), - 0.05, clip_acute = TRUNCATE ), clip_acute = TRUNCATE, distance = - 0.1 ); 
REGION_DV0_4_BLOCK = grow( REGION_DV0_4_PRE1, north = 0.1, south = 0.1, west = 0.1, east = 0.1 );
// DUMMY SPEC : DV0
PATTERN_SPEC_DV0 = get_single_polygon_pattern(
	"DV0", "OUTPUT_DV0", DV0_W, DV0_W,
	step_x = DV0_S, step_y = DV0_S,
    setback = DV0_S,
    FSS = {
    { CHIP_snps, min_space = DMX1O_CHIP, context = INTERIOR },
    { BEOLBLK_FINAL, min_space = DM_BEOLBLK },
    { INDDMY, min_space = DM_INDDMY },

    { DV0EXCL, min_space = DV_DVXEXCL },
    { TCDDMY_V0, min_space = DV_TCDDMY_VX },
    { VIA0I, min_space = DV0_V0 },
    { M0_MAIN, min_space = DV0_M0 },
    { M1_MAIN, min_space = DV0_M1 },
    { DVIA0_O, min_space = DV0_DV0 },
#ifdef FILL_M0_VIA0_M1_BTCD
    { BTCD_M0_V0_M1_E, min_space = DV_TCDDMY_VX },
#endif	
    { DCM0, min_space = DV0_DCM0AB },
    { SRM, min_space = DV0_SRM },
    { SRAMDMY, min_space = DV0_SRM },
              { CM0CELL_E_530_150, min_space = 0.02 },
              { CM0CELL_E_530_155, min_space = 0.02 },
              { VIA0FORBIDDENRING, min_space = 0 },
              { REGION_DV0_4_BLOCK, min_space = 0 },
              { REGION_DV0, min_space = 0, context = INTERIOR },
    }
);
PATTERN_SPEC_DV0.polygon_fill.color = true;
PATTERN_SPEC_DV0.polygon_fill.region_stagger = VERTICAL;
SPEC_DV0 = unified_fill(
	fill_patterns = {
        PATTERN_SPEC_DV0 
    },
	fill_boundary = {
	    layer = CHIP_snps,
	    type = LAYER,
	},
    boundary = ALIGN,
	grid = vGRID
);
DV0_C   = SPEC_DV0["OUTPUT_DV0"][0];

gDV0_E   = SPEC_DV0["OUTPUT_DV0"][0];

//===============================================================================
CONNECTDM1 = DM1_REGION_DV0_PRE1 interacting gDV0_E;
#else
CONNECTDM1 = empty_layer();
REGION_DV0_4_BLOCK = empty_layer();
gDV0_E   = empty_layer();
#endif




#ifdef FILL_DmyVIA1

#ifdef VERTICAL_M2
DM2_LEEDGE_DV1 = angle_edge( DM2_REGION_DV1_PRE, == 0 );
#else
DM2_LEEDGE_DV1 = angle_edge( DM2_REGION_DV1_PRE, == 90 );
#endif



DM2_REGION_DV1_PRO_PRE1 = not_length_edge( DM2_LEEDGE_DV1, < VIA1W ); 
DM2_REGION_DV1_PRO_PRE2 = touching( DM2_REGION_DV1_PRE, DM2_REGION_DV1_PRO_PRE1, > 0 ); 

CENTER_BAR_VALUE = VIA1W;
DM2_REGION_DV1_PRO = drc_features( primary_layer = DM2_REGION_DV1_PRO_PRE2, secondary_layers = { "layer2" => DM2_LEEDGE_DV1 }, output_from_layer = DM2_REGION_DV1_PRO_PRE2, include_touch = EDGE, drc_function = dfm_property_func_DV, combine_errors = OPPOSING ); 
DM2_REGION_DV1_RE = DM2_REGION_DV1_PRO not edge_size_by_property( DM2_REGION_DV1_PRO, inside_property = "Metal_W" );
DM2_REGION_DV1_LESHRINK = edge_size( DM2_LEEDGE_DV1, inside = LINEEND_M2V1 ); 
DM2_REGION_DV1 = DM2_REGION_DV1_RE not DM2_REGION_DV1_LESHRINK; 


DM1_REGION_DV1_PRE1 = copy(DM1_REGION_DV1_PRE);

#ifdef VERTICAL_M1
DM1_LEEDGE_DV1 = angle_edge( DM1_REGION_DV1_PRE1, == 0 );
#else
DM1_LEEDGE_DV1 = angle_edge( DM1_REGION_DV1_PRE1, == 90 );
#endif



DM1_REGION_DV1_PRO_PRE1 = not_length_edge( DM1_LEEDGE_DV1, < VIA1W ); 
DM1_REGION_DV1_PRO_PRE2 = touching( DM1_REGION_DV1_PRE1, DM1_REGION_DV1_PRO_PRE1, > 0 ); 

CENTER_BAR_VALUE = VIA1W;
DM1_REGION_DV1_PRO = drc_features( primary_layer = DM1_REGION_DV1_PRO_PRE2, secondary_layers = { "layer2" => DM1_LEEDGE_DV1 }, output_from_layer = DM1_REGION_DV1_PRO_PRE2, include_touch = EDGE, drc_function = dfm_property_func_DV, combine_errors = OPPOSING ); 
DM1_REGION_DV1_RE = DM1_REGION_DV1_PRO not edge_size_by_property( DM1_REGION_DV1_PRO, inside_property = "Metal_W" );
DM1_REGION_DV1_LESHRINK = edge_size( DM1_LEEDGE_DV1, inside = LINEEND_M1V1 ); 
DM1_REGION_DV1 = DM1_REGION_DV1_RE not DM1_REGION_DV1_LESHRINK; 

REGION_DV1_PRE = DM2_REGION_DV1 and not_interacting( DM1_REGION_DV1, CONNECTDM1 ); 
REGION_DV1_4 = REGION_DV1_PRE not size( VIA1, clip_acute = TRUNCATE, distance = 4 ); 
REGION_DV1_4_PRE1 = size( size( size( REGION_DV1_4, 0.05, clip_acute = TRUNCATE ), - 0.05, clip_acute = TRUNCATE ), clip_acute = TRUNCATE, distance = - 0.1 ); 
REGION_DV1_4_BLOCK_PRE = grow( REGION_DV1_4_PRE1, north = 0.1, south = 0.1 ) or grow( REGION_DV1_4_PRE1, east = 0.1, west = 0.1 ); 
REGION_DV1_4_BLOCK = not_interacting( REGION_DV1_4_BLOCK_PRE, REGION_DV0_4_BLOCK ); 

ALL_DV0_CHK = gDV0_E or ALL_DVIA0; 
DV0_FAR_AWAY_MAIN4 = ( ALL_DV0_CHK not size( VIA0, clip_acute = TRUNCATE, distance = 4 ) ) not size( M2_MAIN, clip_acute = TRUNCATE, distance = 0.35 ); 
REGION_DV1 = not_interacting( REGION_DV1_PRE, ( ( grow( DV0_FAR_AWAY_MAIN4, north = 0.19, south = 0.19 ) or grow( DV0_FAR_AWAY_MAIN4, east = 0.19, west = 0.19 ) ) or size( DV0_FAR_AWAY_MAIN4, clip_acute = TRUNCATE, distance = 0.10 ) ) ); 
// DUMMY SPEC : DV1
//***** spec *******************************************************************
PATTERN_SPEC_DV1 = get_single_polygon_pattern(
    "DV1", "OUTPUT_DV1", DVXA_W, DVXA_W,
	step_x = DVXA_S, step_y = DVXA_S,
	setback = DVXA_S, setback_type = INTERSECTION,
	FSS = {
    { CHIP_snps, min_space = DMX1O_CHIP, context = INTERIOR },
    { BEOLBLK_FINAL, min_space = DM_BEOLBLK },
    { INDDMY, min_space = DM_INDDMY },

    { DV1EXCL, min_space = DV_DVXEXCL },
    { TCDDMY_V1, min_space = DV_TCDDMY_VX },
    { VIA1I, min_space = DVXA_VXA },
    { M1_MAIN, min_space = DVXA_MXA },
    { M2_MAIN, min_space = DVXA_MXA },
    { DVIA1_O, min_space = DVXA_DVXA },
    { SRM, min_space = DVXA_SRM },
    { SRAMDMY, min_space = DVXA_SRM },
#ifdef FILL_M1_VIA1_M2_BTCD
    { BTCD_M1_V1_M2_E, min_space = DV_TCDDMY_VX },
#endif
    } );
PATTERN_SPEC_DV1.polygon_fill.region_stagger = VERTICAL;




PATTERN_SPEC_DV1.polygon_fill.fill_to_signal_spacing.push_back( { VIA1FORBIDDENRING, min_space = 0 } );
PATTERN_SPEC_DV1.polygon_fill.fill_to_signal_spacing.push_back( { REGION_DV1_4_BLOCK, min_space = 0 } );
PATTERN_SPEC_DV1.polygon_fill.fill_to_signal_spacing.push_back( { REGION_DV1, min_space = 0, context = INTERIOR } );

SPEC_DV1 : layer_groups_h;
PATTERN_SPEC_DV1.polygon_fill.color = true;
SPEC_DV1 = unified_fill(
    fill_boundary = {
        layer = CHIP_snps,
        type = LAYER
    },
    boundary = ALIGN,
    grid = vGRID,
    fill_patterns = { PATTERN_SPEC_DV1 }
);
//============================================================================

DV1_C   = SPEC_DV1["OUTPUT_DV1"][0];
gDV1_E   = SPEC_DV1["OUTPUT_DV1"][0];


CONNECTDM2 = DM2_REGION_DV1_PRE interacting gDV1_E;


#else
CONNECTDM2 = empty_layer();
REGION_DV1_4_BLOCK = empty_layer();
gDV1_E   = empty_layer();
#endif
//============================================================================

#ifdef FILL_DmyVIA2

#ifdef VERTICAL_M3
DM3_LEEDGE_DV2 = angle_edge( DM3_REGION_DV2_PRE, == 0 );
#else
DM3_LEEDGE_DV2 = angle_edge( DM3_REGION_DV2_PRE, == 90 );
#endif



DM3_REGION_DV2_PRO_PRE1 = not_length_edge( DM3_LEEDGE_DV2, < VIA2W ); 
DM3_REGION_DV2_PRO_PRE2 = touching( DM3_REGION_DV2_PRE, DM3_REGION_DV2_PRO_PRE1, > 0 ); 

CENTER_BAR_VALUE = VIA2W;
DM3_REGION_DV2_PRO = drc_features( primary_layer = DM3_REGION_DV2_PRO_PRE2, secondary_layers = { "layer2" => DM3_LEEDGE_DV2 }, output_from_layer = DM3_REGION_DV2_PRO_PRE2, include_touch = EDGE, drc_function = dfm_property_func_DV, combine_errors = OPPOSING ); 
DM3_REGION_DV2_RE = DM3_REGION_DV2_PRO not edge_size_by_property( DM3_REGION_DV2_PRO, inside_property = "Metal_W" );
DM3_REGION_DV2_LESHRINK = edge_size( DM3_LEEDGE_DV2, inside = LINEEND_M3V2 ); 
DM3_REGION_DV2 = DM3_REGION_DV2_RE not DM3_REGION_DV2_LESHRINK; 


#ifdef VERTICAL_M2
DM2_LEEDGE_DV2 = angle_edge( DM2_REGION_DV2_PRE, == 0 );
#else
DM2_LEEDGE_DV2 = angle_edge( DM2_REGION_DV2_PRE, == 90 );
#endif



DM2_REGION_DV2_PRO_PRE1 = not_length_edge( DM2_LEEDGE_DV2, < VIA2W ); 
DM2_REGION_DV2_PRO_PRE2 = touching( DM2_REGION_DV2_PRE, DM2_REGION_DV2_PRO_PRE1, > 0 ); 

CENTER_BAR_VALUE = VIA2W;
DM2_REGION_DV2_PRO = drc_features( primary_layer = DM2_REGION_DV2_PRO_PRE2, secondary_layers = { "layer2" => DM2_LEEDGE_DV2 }, output_from_layer = DM2_REGION_DV2_PRO_PRE2, include_touch = EDGE, drc_function = dfm_property_func_DV, combine_errors = OPPOSING ); 
DM2_REGION_DV2_RE = DM2_REGION_DV2_PRO not edge_size_by_property( DM2_REGION_DV2_PRO, inside_property = "Metal_W" );
DM2_REGION_DV2_LESHRINK = edge_size( DM2_LEEDGE_DV2, inside = LINEEND_M2V2 ); 
DM2_REGION_DV2 = DM2_REGION_DV2_RE not DM2_REGION_DV2_LESHRINK; 

REGION_DV2_PRE = DM3_REGION_DV2 and not_interacting( DM2_REGION_DV2, CONNECTDM2 ); 
REGION_DV2_4 = REGION_DV2_PRE not size( VIA2, clip_acute = TRUNCATE, distance = 4 ); 
REGION_DV2_4_PRE1 = size( size( size( REGION_DV2_4, 0.05, clip_acute = TRUNCATE ), - 0.05, clip_acute = TRUNCATE ), clip_acute = TRUNCATE, distance = - 0.1 ); 
REGION_DV2_4_BLOCK_PRE = grow( REGION_DV2_4_PRE1, north = 0.1, south = 0.1 ) or grow( REGION_DV2_4_PRE1, east = 0.1, west = 0.1 ); 
REGION_DV2_4_BLOCK = not_interacting( REGION_DV2_4_BLOCK_PRE, REGION_DV1_4_BLOCK ); 

ALL_DV1_CHK = gDV1_E or ALL_DVIA1; 
DV1_FAR_AWAY_MAIN4 = ( ALL_DV1_CHK not size( VIA1, clip_acute = TRUNCATE, distance = 4 ) ) not size( M3_MAIN, clip_acute = TRUNCATE, distance = 0.35 ); 
REGION_DV2 = not_interacting( REGION_DV2_PRE, ( ( grow( DV1_FAR_AWAY_MAIN4, north = 0.19, south = 0.19 ) or grow( DV1_FAR_AWAY_MAIN4, east = 0.19, west = 0.19 ) ) or size( DV1_FAR_AWAY_MAIN4, clip_acute = TRUNCATE, distance = 0.10 ) ) ); 
// DUMMY SPEC : DV2
//***** spec *******************************************************************
PATTERN_SPEC_DV2 = get_single_polygon_pattern(
    "DV2", "OUTPUT_DV2", DVXB_W, DVXB_W,
	step_x = DVXB_S, step_y = DVXB_S,
	setback = DVXB_S, setback_type = INTERSECTION,
	FSS = {
    { CHIP_snps, min_space = DMX2O_CHIP, context = INTERIOR },
    { BEOLBLK_FINAL, min_space = DM_BEOLBLK },
    { INDDMY, min_space = DM_INDDMY },

    { DV2EXCL, min_space = DV_DVXEXCL },
    { TCDDMY_V2, min_space = DV_TCDDMY_VX },
    { VIA2I, min_space = DVXB_VXB },
    { M2_MAIN, min_space = DVXB_MXB },
    { M3_MAIN, min_space = DVXB_MXB },
    { DVIA2_O, min_space = DVXB_DVXB },
#ifdef FILL_M2_VIA2_M3_BTCD
    { BTCD_M2_V2_M3_E, min_space = DV_TCDDMY_VX },
#endif
    } );
PATTERN_SPEC_DV2.polygon_fill.region_stagger = VERTICAL;




PATTERN_SPEC_DV2.polygon_fill.fill_to_signal_spacing.push_back( { VIA2FORBIDDENRING, min_space = 0 } );
PATTERN_SPEC_DV2.polygon_fill.fill_to_signal_spacing.push_back( { REGION_DV2_4_BLOCK, min_space = 0 } );
PATTERN_SPEC_DV2.polygon_fill.fill_to_signal_spacing.push_back( { REGION_DV2, min_space = 0, context = INTERIOR } );

SPEC_DV2 : layer_groups_h;
PATTERN_SPEC_DV2.polygon_fill.color = true;
SPEC_DV2 = unified_fill(
    fill_boundary = {
        layer = CHIP_snps,
        type = LAYER
    },
    boundary = ALIGN,
    grid = vGRID,
    fill_patterns = { PATTERN_SPEC_DV2 }
);
//============================================================================


DV2_C   = SPEC_DV2["OUTPUT_DV2"][0];
gDV2_E   = SPEC_DV2["OUTPUT_DV2"][0];


CONNECTDM3 = DM3_REGION_DV2_PRE interacting gDV2_E;


#else
CONNECTDM3 = empty_layer();
REGION_DV2_4_BLOCK = empty_layer();
gDV2_E   = empty_layer();
#endif
//============================================================================

#ifdef FILL_DmyVIA3

#ifdef VERTICAL_M4
DM4_LEEDGE_DV3 = angle_edge( DM4_REGION_DV3_PRE, == 0 );
#else
DM4_LEEDGE_DV3 = angle_edge( DM4_REGION_DV3_PRE, == 90 );
#endif



DM4_REGION_DV3_PRO_PRE1 = not_length_edge( DM4_LEEDGE_DV3, < VIA3W ); 
DM4_REGION_DV3_PRO_PRE2 = touching( DM4_REGION_DV3_PRE, DM4_REGION_DV3_PRO_PRE1, > 0 ); 

CENTER_BAR_VALUE = VIA3W;
DM4_REGION_DV3_PRO = drc_features( primary_layer = DM4_REGION_DV3_PRO_PRE2, secondary_layers = { "layer2" => DM4_LEEDGE_DV3 }, output_from_layer = DM4_REGION_DV3_PRO_PRE2, include_touch = EDGE, drc_function = dfm_property_func_DV, combine_errors = OPPOSING ); 
DM4_REGION_DV3_RE = DM4_REGION_DV3_PRO not edge_size_by_property( DM4_REGION_DV3_PRO, inside_property = "Metal_W" );
DM4_REGION_DV3_LESHRINK = edge_size( DM4_LEEDGE_DV3, inside = LINEEND_M4V3 ); 
DM4_REGION_DV3 = DM4_REGION_DV3_RE not DM4_REGION_DV3_LESHRINK; 


#ifdef VERTICAL_M3
DM3_LEEDGE_DV3 = angle_edge( DM3_REGION_DV3_PRE, == 0 );
#else
DM3_LEEDGE_DV3 = angle_edge( DM3_REGION_DV3_PRE, == 90 );
#endif



DM3_REGION_DV3_PRO_PRE1 = not_length_edge( DM3_LEEDGE_DV3, < VIA3W ); 
DM3_REGION_DV3_PRO_PRE2 = touching( DM3_REGION_DV3_PRE, DM3_REGION_DV3_PRO_PRE1, > 0 ); 

CENTER_BAR_VALUE = VIA3W;
DM3_REGION_DV3_PRO = drc_features( primary_layer = DM3_REGION_DV3_PRO_PRE2, secondary_layers = { "layer2" => DM3_LEEDGE_DV3 }, output_from_layer = DM3_REGION_DV3_PRO_PRE2, include_touch = EDGE, drc_function = dfm_property_func_DV, combine_errors = OPPOSING ); 
DM3_REGION_DV3_RE = DM3_REGION_DV3_PRO not edge_size_by_property( DM3_REGION_DV3_PRO, inside_property = "Metal_W" );
DM3_REGION_DV3_LESHRINK = edge_size( DM3_LEEDGE_DV3, inside = LINEEND_M3V3 ); 
DM3_REGION_DV3 = DM3_REGION_DV3_RE not DM3_REGION_DV3_LESHRINK; 

REGION_DV3_PRE = DM4_REGION_DV3 and not_interacting( DM3_REGION_DV3, CONNECTDM3 ); 
REGION_DV3_4 = REGION_DV3_PRE not size( VIA3, clip_acute = TRUNCATE, distance = 4 ); 
REGION_DV3_4_PRE1 = size( size( size( REGION_DV3_4, 0.05, clip_acute = TRUNCATE ), - 0.05, clip_acute = TRUNCATE ), clip_acute = TRUNCATE, distance = - 0.1 ); 
REGION_DV3_4_BLOCK_PRE = grow( REGION_DV3_4_PRE1, north = 0.1, south = 0.1 ) or grow( REGION_DV3_4_PRE1, east = 0.1, west = 0.1 ); 
REGION_DV3_4_BLOCK = not_interacting( REGION_DV3_4_BLOCK_PRE, REGION_DV2_4_BLOCK ); 

ALL_DV2_CHK = gDV2_E or ALL_DVIA2; 
DV2_FAR_AWAY_MAIN4 = ( ALL_DV2_CHK not size( VIA2, clip_acute = TRUNCATE, distance = 4 ) ) not size( M4_MAIN, clip_acute = TRUNCATE, distance = 0.35 ); 
REGION_DV3 = not_interacting( REGION_DV3_PRE, ( ( grow( DV2_FAR_AWAY_MAIN4, north = 0.19, south = 0.19 ) or grow( DV2_FAR_AWAY_MAIN4, east = 0.19, west = 0.19 ) ) or size( DV2_FAR_AWAY_MAIN4, clip_acute = TRUNCATE, distance = 0.10 ) ) ); 
// DUMMY SPEC : DV3
//***** spec *******************************************************************
PATTERN_SPEC_DV3 = get_single_polygon_pattern(
    "DV3", "OUTPUT_DV3", DVXC_W, DVXC_W,
	step_x = DVXC_S, step_y = DVXC_S,
	setback = DVXC_S, setback_type = INTERSECTION,
	FSS = {
    { CHIP_snps, min_space = DMX2O_CHIP, context = INTERIOR },
    { BEOLBLK_FINAL, min_space = DM_BEOLBLK },
    { INDDMY, min_space = DM_INDDMY },

    { DV3EXCL, min_space = DV_DVXEXCL },
    { TCDDMY_V3, min_space = DV_TCDDMY_VX },
    { VIA3I, min_space = DVXC_VXC },
    { M3_MAIN, min_space = DVXC_MXC },
    { M4_MAIN, min_space = DVXC_MXC },
    { DVIA3_O, min_space = DVXC_DVXC },
#ifdef FILL_M3_VIA3_M4_BTCD
    { BTCD_M3_V3_M4_E, min_space = DV_TCDDMY_VX },
#endif
      { BIG_VIA3, min_space = 0.130 },
      { SLOT_VIA3, min_space = 0.134 },
    } );
PATTERN_SPEC_DV3.polygon_fill.region_stagger = VERTICAL;




PATTERN_SPEC_DV3.polygon_fill.fill_to_signal_spacing.push_back( { VIA3FORBIDDENRING, min_space = 0 } );
PATTERN_SPEC_DV3.polygon_fill.fill_to_signal_spacing.push_back( { REGION_DV3_4_BLOCK, min_space = 0 } );
PATTERN_SPEC_DV3.polygon_fill.fill_to_signal_spacing.push_back( { REGION_DV3, min_space = 0, context = INTERIOR } );

SPEC_DV3 : layer_groups_h;
PATTERN_SPEC_DV3.polygon_fill.color = true;
SPEC_DV3 = unified_fill(
    fill_boundary = {
        layer = CHIP_snps,
        type = LAYER
    },
    boundary = ALIGN,
    grid = vGRID,
    fill_patterns = { PATTERN_SPEC_DV3 }
);
//============================================================================



DV3_A_C = SPEC_DV3["OUTPUT_DV3"][1];
DV3_B_C = SPEC_DV3["OUTPUT_DV3"][2];
gDV3_E   = SPEC_DV3["OUTPUT_DV3"][0];



CONNECTDM4 = DM4_REGION_DV3_PRE interacting gDV3_E;


#else
CONNECTDM4 = empty_layer();
REGION_DV3_4_BLOCK = empty_layer();
gDV3_E   = empty_layer();
#endif
//============================================================================

#ifdef FILL_DmyVIA4

#ifdef VERTICAL_M5
DM5_LEEDGE_DV4 = angle_edge( DM5_REGION_DV4_PRE, == 0 );
#else
DM5_LEEDGE_DV4 = angle_edge( DM5_REGION_DV4_PRE, == 90 );
#endif



DM5_REGION_DV4_PRO_PRE1 = not_length_edge( DM5_LEEDGE_DV4, < VIA4W ); 
DM5_REGION_DV4_PRO_PRE2 = touching( DM5_REGION_DV4_PRE, DM5_REGION_DV4_PRO_PRE1, > 0 ); 

CENTER_BAR_VALUE = VIA4W;
DM5_REGION_DV4_PRO = drc_features( primary_layer = DM5_REGION_DV4_PRO_PRE2, secondary_layers = { "layer2" => DM5_LEEDGE_DV4 }, output_from_layer = DM5_REGION_DV4_PRO_PRE2, include_touch = EDGE, drc_function = dfm_property_func_DV, combine_errors = OPPOSING ); 
DM5_REGION_DV4_RE = DM5_REGION_DV4_PRO not edge_size_by_property( DM5_REGION_DV4_PRO, inside_property = "Metal_W" );
DM5_REGION_DV4_LESHRINK = edge_size( DM5_LEEDGE_DV4, inside = LINEEND_M5V4 ); 
DM5_REGION_DV4 = DM5_REGION_DV4_RE not DM5_REGION_DV4_LESHRINK; 


#ifdef VERTICAL_M4
DM4_LEEDGE_DV4 = angle_edge( DM4_REGION_DV4_PRE, == 0 );
#else
DM4_LEEDGE_DV4 = angle_edge( DM4_REGION_DV4_PRE, == 90 );
#endif



DM4_REGION_DV4_PRO_PRE1 = not_length_edge( DM4_LEEDGE_DV4, < VIA4W ); 
DM4_REGION_DV4_PRO_PRE2 = touching( DM4_REGION_DV4_PRE, DM4_REGION_DV4_PRO_PRE1, > 0 ); 

CENTER_BAR_VALUE = VIA4W;
DM4_REGION_DV4_PRO = drc_features( primary_layer = DM4_REGION_DV4_PRO_PRE2, secondary_layers = { "layer2" => DM4_LEEDGE_DV4 }, output_from_layer = DM4_REGION_DV4_PRO_PRE2, include_touch = EDGE, drc_function = dfm_property_func_DV, combine_errors = OPPOSING ); 
DM4_REGION_DV4_RE = DM4_REGION_DV4_PRO not edge_size_by_property( DM4_REGION_DV4_PRO, inside_property = "Metal_W" );
DM4_REGION_DV4_LESHRINK = edge_size( DM4_LEEDGE_DV4, inside = LINEEND_M4V4 ); 
DM4_REGION_DV4 = DM4_REGION_DV4_RE not DM4_REGION_DV4_LESHRINK; 

REGION_DV4_PRE = DM5_REGION_DV4 and not_interacting( DM4_REGION_DV4, CONNECTDM4 ); 
REGION_DV4_4 = REGION_DV4_PRE not size( VIA4, clip_acute = TRUNCATE, distance = 4 ); 
REGION_DV4_4_PRE1 = size( size( size( REGION_DV4_4, 0.05, clip_acute = TRUNCATE ), - 0.05, clip_acute = TRUNCATE ), clip_acute = TRUNCATE, distance = - 0.1 ); 
REGION_DV4_4_BLOCK_PRE = grow( REGION_DV4_4_PRE1, north = 0.1, south = 0.1 ) or grow( REGION_DV4_4_PRE1, east = 0.1, west = 0.1 ); 
REGION_DV4_4_BLOCK = not_interacting( REGION_DV4_4_BLOCK_PRE, REGION_DV3_4_BLOCK ); 

ALL_DV3_CHK = gDV3_E or ALL_DVIA3; 
DV3_FAR_AWAY_MAIN4 = ( ALL_DV3_CHK not size( VIA3, clip_acute = TRUNCATE, distance = 4 ) ) not size( M5_MAIN, clip_acute = TRUNCATE, distance = 0.35 ); 
REGION_DV4 = not_interacting( REGION_DV4_PRE, ( ( grow( DV3_FAR_AWAY_MAIN4, north = 0.19, south = 0.19 ) or grow( DV3_FAR_AWAY_MAIN4, east = 0.19, west = 0.19 ) ) or size( DV3_FAR_AWAY_MAIN4, clip_acute = TRUNCATE, distance = 0.10 ) ) ); 
// DUMMY SPEC : DV4
//***** spec *******************************************************************
PATTERN_SPEC_DV4 = get_single_polygon_pattern(
    "DV4", "OUTPUT_DV4", DVXD_W, DVXD_W,
	step_x = DVXD_S, step_y = DVXD_S,
	setback = DVXD_S, setback_type = INTERSECTION,
	FSS = {
    { CHIP_snps, min_space = DMX3O_CHIP, context = INTERIOR },
    { BEOLBLK_FINAL, min_space = DM_BEOLBLK },
    { DV4EXCL, min_space = DV_DVXEXCL },
    { TCDDMY_V4, min_space = DV_TCDDMY_VX },
	{ ICOVL_SINGLE, min_space = 0.115 }, // DVIAn_O.S.5
	{ TCDDMY_M4, min_space = 0.115 }, // DVIAn_O.S.5
	{ INDDMY, min_space = 0.115 }, // DVIAn_O.S.5
	{ SEALRING_ALL, min_space = 0.115 }, // DVIAn_O.S.5
    { VIA4I, min_space = DVXD_VXD },
    { M4_MAIN, min_space = DVXD_MXD },
    { M5_MAIN, min_space = DVXD_MXD },
    { DVIA4, min_space = DVXD_DVXD },
    { DVIA4_O, min_space = DVXD_DVXD },
#ifdef FILL_M4_VIA4_M5_BTCD
    { BTCD_M4_V4_M5_E, min_space = DV_TCDDMY_VX },
#endif
      { BIG_VIA4, min_space = 0.130 },
      { SLOT_VIA4, min_space = 0.134 },
    } );
PATTERN_SPEC_DV4.polygon_fill.region_stagger = VERTICAL;



PATTERN_SPEC_DV4.polygon_fill.fill_to_signal_spacing.push_back( { VIA4FORBIDDENRING, min_space = 0 } );
PATTERN_SPEC_DV4.polygon_fill.fill_to_signal_spacing.push_back( { REGION_DV4_4_BLOCK, min_space = 0 } );
PATTERN_SPEC_DV4.polygon_fill.fill_to_signal_spacing.push_back( { REGION_DV4, min_space = 0, context = INTERIOR } );

SPEC_DV4 : layer_groups_h;
PATTERN_SPEC_DV4.polygon_fill.color = true;
SPEC_DV4 = unified_fill(
    fill_boundary = {
        layer = CHIP_snps,
        type = LAYER
    },
    boundary = ALIGN,
    grid = vGRID,
    fill_patterns = { PATTERN_SPEC_DV4 }
);
//============================================================================



DV4_A_C = SPEC_DV4["OUTPUT_DV4"][1];
DV4_B_C = SPEC_DV4["OUTPUT_DV4"][2];
gDV4_E   = SPEC_DV4["OUTPUT_DV4"][0];



CONNECTDM5 = DM5_REGION_DV4_PRE interacting gDV4_E;


#else
CONNECTDM5 = empty_layer();
REGION_DV4_4_BLOCK = empty_layer();
gDV4_E   = empty_layer();
#endif
//============================================================================

#ifdef FILL_DmyVIA5

#ifdef VERTICAL_M6
DM6_LEEDGE_DV5 = angle_edge( DM6_REGION_DV5_PRE, == 0 );
#else
DM6_LEEDGE_DV5 = angle_edge( DM6_REGION_DV5_PRE, == 90 );
#endif



DM6_REGION_DV5_PRO_PRE1 = not_length_edge( DM6_LEEDGE_DV5, < VIA5W ); 
DM6_REGION_DV5_PRO_PRE2 = touching( DM6_REGION_DV5_PRE, DM6_REGION_DV5_PRO_PRE1, > 0 ); 

CENTER_BAR_VALUE = VIA5W;
DM6_REGION_DV5_PRO = drc_features( primary_layer = DM6_REGION_DV5_PRO_PRE2, secondary_layers = { "layer2" => DM6_LEEDGE_DV5 }, output_from_layer = DM6_REGION_DV5_PRO_PRE2, include_touch = EDGE, drc_function = dfm_property_func_DV, combine_errors = OPPOSING ); 
DM6_REGION_DV5_RE = DM6_REGION_DV5_PRO not edge_size_by_property( DM6_REGION_DV5_PRO, inside_property = "Metal_W" );
DM6_REGION_DV5_LESHRINK = edge_size( DM6_LEEDGE_DV5, inside = LINEEND_M6V5 ); 
DM6_REGION_DV5 = DM6_REGION_DV5_RE not DM6_REGION_DV5_LESHRINK; 


#ifdef VERTICAL_M5
DM5_LEEDGE_DV5 = angle_edge( DM5_REGION_DV5_PRE, == 0 );
#else
DM5_LEEDGE_DV5 = angle_edge( DM5_REGION_DV5_PRE, == 90 );
#endif



DM5_REGION_DV5_PRO_PRE1 = not_length_edge( DM5_LEEDGE_DV5, < VIA5W ); 
DM5_REGION_DV5_PRO_PRE2 = touching( DM5_REGION_DV5_PRE, DM5_REGION_DV5_PRO_PRE1, > 0 ); 

CENTER_BAR_VALUE = VIA5W;
DM5_REGION_DV5_PRO = drc_features( primary_layer = DM5_REGION_DV5_PRO_PRE2, secondary_layers = { "layer2" => DM5_LEEDGE_DV5 }, output_from_layer = DM5_REGION_DV5_PRO_PRE2, include_touch = EDGE, drc_function = dfm_property_func_DV, combine_errors = OPPOSING ); 
DM5_REGION_DV5_RE = DM5_REGION_DV5_PRO not edge_size_by_property( DM5_REGION_DV5_PRO, inside_property = "Metal_W" );
DM5_REGION_DV5_LESHRINK = edge_size( DM5_LEEDGE_DV5, inside = LINEEND_M5V5 ); 
DM5_REGION_DV5 = DM5_REGION_DV5_RE not DM5_REGION_DV5_LESHRINK; 

REGION_DV5_PRE = DM6_REGION_DV5 and not_interacting( DM5_REGION_DV5, CONNECTDM5 ); 
REGION_DV5 =  copy(REGION_DV5_PRE);
// DUMMY SPEC : DV5
//***** spec *******************************************************************

PATTERN_SPEC_DV5_1st = get_single_polygon_pattern(
    "DV5", "OUTPUT_DV5", DVYA_W, DVYA_W,
	step_x = 0.4, step_y = 0.4,
	setback = 0.4, setback_type = INTERSECTION,
	FSS = {
    { CHIP_snps, min_space = DMY1_CHIP, context = INTERIOR },
    { BEOLBLK_FINAL, min_space = DM_BEOLBLK },
    { INDDMY, min_space = DM_INDDMY },

    { DV5EXCL, min_space = DV_DVXEXCL },
    { TCDDMY_V5, min_space = DV_TCDDMY_VX },
    { VIA5I, min_space = DVYA_VYA },
    { DVIA5, min_space = DVYA_DVYA },
    { DVIA5_O, min_space = DVYA_DVYA_O },
#ifdef FILL_M5_VIA5_M6_BTCD
    { BTCD_M5_V5_M6_E, min_space = DV_TCDDMY_VX },
#endif
#ifdef ANTPrevention
{ FORBIDDEN_RING, min_space = 0 },
#endif
    } );
PATTERN_SPEC_DV5_1st.polygon_fill.fill_to_signal_spacing.push_back( { VIA5FORBIDDENRING, min_space = 0 } );
PATTERN_SPEC_DV5_1st.polygon_fill.fill_to_signal_spacing.push_back( { REGION_DV5, min_space = 0, context = INTERIOR } );

SPEC_DV5_1st : layer_groups_h;
PATTERN_SPEC_DV5_1st.polygon_fill.color = true;
SPEC_DV5_1st = unified_fill(
    fill_boundary = {
        layer = CHIP_snps,
        type = LAYER
    },
    boundary = ALIGN,
    grid = vGRID,
    fill_patterns = { PATTERN_SPEC_DV5_1st }
);
DV5_C_1st   = SPEC_DV5_1st["OUTPUT_DV5"][0];
gDV5_E_1st   = SPEC_DV5_1st["OUTPUT_DV5"][0];

PATTERN_SPEC_DV5_2nd = get_single_polygon_pattern(
    "DV5", "OUTPUT_DV5", DVYA_W, DVYA_W,
	step_x = DVYA_S, step_y = DVYA_S,
	setback = DVYA_S, setback_type = INTERSECTION,
	FSS = {
    { CHIP_snps, min_space = DMY1_CHIP, context = INTERIOR },
    { BEOLBLK_FINAL, min_space = DM_BEOLBLK },
    { INDDMY, min_space = DM_INDDMY },

    { DV5EXCL, min_space = DV_DVXEXCL },
    { TCDDMY_V5, min_space = DV_TCDDMY_VX },
    { VIA5I, min_space = DVYA_VYA },
    { DVIA5, min_space = DVYA_DVYA },
    { DVIA5_O, min_space = DVYA_DVYA_O },
#ifdef FILL_M5_VIA5_M6_BTCD
    { BTCD_M5_V5_M6_E, min_space = DV_TCDDMY_VX },
#endif
#ifdef ANTPrevention
{ FORBIDDEN_RING, min_space = 0 },
#endif
{ DV5_C_1st, min_space = DVYA_S },
    } );
PATTERN_SPEC_DV5_2nd.polygon_fill.fill_to_signal_spacing.push_back( { VIA5FORBIDDENRING, min_space = 0 } );
PATTERN_SPEC_DV5_2nd.polygon_fill.fill_to_signal_spacing.push_back( { REGION_DV5, min_space = 0, context = INTERIOR } );

SPEC_DV5_2nd : layer_groups_h;
PATTERN_SPEC_DV5_2nd.polygon_fill.color = true;
SPEC_DV5_2nd = unified_fill(
    fill_boundary = {
        layer = CHIP_snps,
        type = LAYER
    },
    boundary = ALIGN,
    grid = vGRID,
    fill_patterns = { PATTERN_SPEC_DV5_2nd }
);

DV5_C_2nd   = SPEC_DV5_2nd["OUTPUT_DV5"][0];
gDV5_E_2nd   = SPEC_DV5_2nd["OUTPUT_DV5"][0];

DV5_C   = DV5_C_1st or DV5_C_2nd;
gDV5_E   = gDV5_E_1st or gDV5_E_2nd ;



CONNECTDM6 = empty_layer();

#else
CONNECTDM6 = empty_layer();
REGION_DV5_4_BLOCK = empty_layer();
gDV5_E   = empty_layer();
#endif
//============================================================================

#ifdef FILL_DmyVIA6

#ifdef VERTICAL_M7
DM7_LEEDGE_DV6 = angle_edge( DM7_REGION_DV6_PRE, == 0 );
#else
DM7_LEEDGE_DV6 = angle_edge( DM7_REGION_DV6_PRE, == 90 );
#endif



DM7_REGION_DV6_PRO_PRE1 = not_length_edge( DM7_LEEDGE_DV6, < VIA6W ); 
DM7_REGION_DV6_PRO_PRE2 = touching( DM7_REGION_DV6_PRE, DM7_REGION_DV6_PRO_PRE1, > 0 ); 

CENTER_BAR_VALUE = VIA6W;
DM7_REGION_DV6_PRO = drc_features( primary_layer = DM7_REGION_DV6_PRO_PRE2, secondary_layers = { "layer2" => DM7_LEEDGE_DV6 }, output_from_layer = DM7_REGION_DV6_PRO_PRE2, include_touch = EDGE, drc_function = dfm_property_func_DV, combine_errors = OPPOSING ); 
DM7_REGION_DV6_RE = DM7_REGION_DV6_PRO not edge_size_by_property( DM7_REGION_DV6_PRO, inside_property = "Metal_W" );
DM7_REGION_DV6_LESHRINK = edge_size( DM7_LEEDGE_DV6, inside = LINEEND_M7V6 ); 
DM7_REGION_DV6 = DM7_REGION_DV6_RE not DM7_REGION_DV6_LESHRINK; 


#ifdef VERTICAL_M6
DM6_LEEDGE_DV6 = angle_edge( DM6_REGION_DV6_PRE, == 0 );
#else
DM6_LEEDGE_DV6 = angle_edge( DM6_REGION_DV6_PRE, == 90 );
#endif



DM6_REGION_DV6_PRO_PRE1 = not_length_edge( DM6_LEEDGE_DV6, < VIA6W ); 
DM6_REGION_DV6_PRO_PRE2 = touching( DM6_REGION_DV6_PRE, DM6_REGION_DV6_PRO_PRE1, > 0 ); 

CENTER_BAR_VALUE = VIA6W;
DM6_REGION_DV6_PRO = drc_features( primary_layer = DM6_REGION_DV6_PRO_PRE2, secondary_layers = { "layer2" => DM6_LEEDGE_DV6 }, output_from_layer = DM6_REGION_DV6_PRO_PRE2, include_touch = EDGE, drc_function = dfm_property_func_DV, combine_errors = OPPOSING ); 
DM6_REGION_DV6_RE = DM6_REGION_DV6_PRO not edge_size_by_property( DM6_REGION_DV6_PRO, inside_property = "Metal_W" );
DM6_REGION_DV6_LESHRINK = edge_size( DM6_LEEDGE_DV6, inside = LINEEND_M6V6 ); 
DM6_REGION_DV6 = DM6_REGION_DV6_RE not DM6_REGION_DV6_LESHRINK; 

REGION_DV6_PRE = DM7_REGION_DV6 and not_interacting( DM6_REGION_DV6, CONNECTDM6 ); 
REGION_DV6 =  copy(REGION_DV6_PRE);
// DUMMY SPEC : DV6
//***** spec *******************************************************************

PATTERN_SPEC_DV6_1st = get_single_polygon_pattern(
    "DV6", "OUTPUT_DV6", DVY_W, DVY_W,
	step_x = 0.4, step_y = 0.4,
	setback = 0.4, setback_type = INTERSECTION,
	FSS = {
    { CHIP_snps, min_space = DMY1_CHIP, context = INTERIOR },
    { BEOLBLK_FINAL, min_space = DM_BEOLBLK },
    { INDDMY, min_space = DM_INDDMY },

    { DV6EXCL, min_space = DV_DVXEXCL },
    { TCDDMY_V6, min_space = DV_TCDDMY_VX },
    { VIA6I, min_space = DVY_VY },
    { DVIA6, min_space = DVY_DVY },
    { RH_TNB, min_space = DVY_RHTNB },

#ifdef ANTPrevention
    { FORBIDDEN_RING, min_space = 0 },
#endif
    { DVIA6_O, min_space = 0.300 },
#ifdef FILL_M6_VIA6_M7_BTCD
    { BTCD_M6_V6_M7_E, min_space = DV_TCDDMY_VX },
#endif
    } );
PATTERN_SPEC_DV6_1st.polygon_fill.fill_to_signal_spacing.push_back( { VIA6FORBIDDENRING, min_space = 0 } );
PATTERN_SPEC_DV6_1st.polygon_fill.fill_to_signal_spacing.push_back( { REGION_DV6, min_space = 0, context = INTERIOR } );

SPEC_DV6_1st : layer_groups_h;
PATTERN_SPEC_DV6_1st.polygon_fill.color = true;
SPEC_DV6_1st = unified_fill(
    fill_boundary = {
        layer = CHIP_snps,
        type = LAYER
    },
    boundary = ALIGN,
    grid = vGRID,
    fill_patterns = { PATTERN_SPEC_DV6_1st }
);
DV6_C_1st   = SPEC_DV6_1st["OUTPUT_DV6"][0];
gDV6_E_1st   = SPEC_DV6_1st["OUTPUT_DV6"][0];

PATTERN_SPEC_DV6_2nd = get_single_polygon_pattern(
    "DV6", "OUTPUT_DV6", DVY_W, DVY_W,
	step_x = DVY_S, step_y = DVY_S,
	setback = DVY_S, setback_type = INTERSECTION,
	FSS = {
    { CHIP_snps, min_space = DMY1_CHIP, context = INTERIOR },
    { BEOLBLK_FINAL, min_space = DM_BEOLBLK },
    { INDDMY, min_space = DM_INDDMY },

    { DV6EXCL, min_space = DV_DVXEXCL },
    { TCDDMY_V6, min_space = DV_TCDDMY_VX },
    { VIA6I, min_space = DVY_VY },
    { DVIA6, min_space = DVY_DVY },
    { RH_TNB, min_space = DVY_RHTNB },

#ifdef ANTPrevention
    { FORBIDDEN_RING, min_space = 0 },
#endif
    { DVIA6_O, min_space = 0.300 },
#ifdef FILL_M6_VIA6_M7_BTCD
    { BTCD_M6_V6_M7_E, min_space = DV_TCDDMY_VX },
#endif
{ DV6_C_1st, min_space = DVY_S },
    } );
PATTERN_SPEC_DV6_2nd.polygon_fill.fill_to_signal_spacing.push_back( { VIA6FORBIDDENRING, min_space = 0 } );
PATTERN_SPEC_DV6_2nd.polygon_fill.fill_to_signal_spacing.push_back( { REGION_DV6, min_space = 0, context = INTERIOR } );

SPEC_DV6_2nd : layer_groups_h;
PATTERN_SPEC_DV6_2nd.polygon_fill.color = true;
SPEC_DV6_2nd = unified_fill(
    fill_boundary = {
        layer = CHIP_snps,
        type = LAYER
    },
    boundary = ALIGN,
    grid = vGRID,
    fill_patterns = { PATTERN_SPEC_DV6_2nd }
);

DV6_C_2nd   = SPEC_DV6_2nd["OUTPUT_DV6"][0];
gDV6_E_2nd   = SPEC_DV6_2nd["OUTPUT_DV6"][0];

DV6_C   = DV6_C_1st or DV6_C_2nd;
gDV6_E   = gDV6_E_1st or gDV6_E_2nd ;



CONNECTDM7 = empty_layer();

#else
CONNECTDM7 = empty_layer();
REGION_DV6_4_BLOCK = empty_layer();
gDV6_E   = empty_layer();
#endif
//============================================================================

#ifdef FILL_DmyVIA7

#ifdef VERTICAL_M8
DM8_LEEDGE_DV7 = angle_edge( DM8_REGION_DV7_PRE, == 0 );
#else
DM8_LEEDGE_DV7 = angle_edge( DM8_REGION_DV7_PRE, == 90 );
#endif



DM8_REGION_DV7_PRO_PRE1 = not_length_edge( DM8_LEEDGE_DV7, < VIA7W ); 
DM8_REGION_DV7_PRO_PRE2 = touching( DM8_REGION_DV7_PRE, DM8_REGION_DV7_PRO_PRE1, > 0 ); 

CENTER_BAR_VALUE = VIA7W;
DM8_REGION_DV7_PRO = drc_features( primary_layer = DM8_REGION_DV7_PRO_PRE2, secondary_layers = { "layer2" => DM8_LEEDGE_DV7 }, output_from_layer = DM8_REGION_DV7_PRO_PRE2, include_touch = EDGE, drc_function = dfm_property_func_DV, combine_errors = OPPOSING ); 
DM8_REGION_DV7_RE = DM8_REGION_DV7_PRO not edge_size_by_property( DM8_REGION_DV7_PRO, inside_property = "Metal_W" );
DM8_REGION_DV7_LESHRINK = edge_size( DM8_LEEDGE_DV7, inside = LINEEND_M8V7 ); 
DM8_REGION_DV7 = DM8_REGION_DV7_RE not DM8_REGION_DV7_LESHRINK; 


#ifdef VERTICAL_M7
DM7_LEEDGE_DV7 = angle_edge( DM7_REGION_DV7_PRE, == 0 );
#else
DM7_LEEDGE_DV7 = angle_edge( DM7_REGION_DV7_PRE, == 90 );
#endif



DM7_REGION_DV7_PRO_PRE1 = not_length_edge( DM7_LEEDGE_DV7, < VIA7W ); 
DM7_REGION_DV7_PRO_PRE2 = touching( DM7_REGION_DV7_PRE, DM7_REGION_DV7_PRO_PRE1, > 0 ); 

CENTER_BAR_VALUE = VIA7W;
DM7_REGION_DV7_PRO = drc_features( primary_layer = DM7_REGION_DV7_PRO_PRE2, secondary_layers = { "layer2" => DM7_LEEDGE_DV7 }, output_from_layer = DM7_REGION_DV7_PRO_PRE2, include_touch = EDGE, drc_function = dfm_property_func_DV, combine_errors = OPPOSING ); 
DM7_REGION_DV7_RE = DM7_REGION_DV7_PRO not edge_size_by_property( DM7_REGION_DV7_PRO, inside_property = "Metal_W" );
DM7_REGION_DV7_LESHRINK = edge_size( DM7_LEEDGE_DV7, inside = LINEEND_M7V7 ); 
DM7_REGION_DV7 = DM7_REGION_DV7_RE not DM7_REGION_DV7_LESHRINK; 

REGION_DV7_PRE = DM8_REGION_DV7 and not_interacting( DM7_REGION_DV7, CONNECTDM7 ); 
REGION_DV7 =  copy(REGION_DV7_PRE);
// DUMMY SPEC : DV7
//***** spec *******************************************************************

PATTERN_SPEC_DV7_1st = get_single_polygon_pattern(
    "DV7", "OUTPUT_DV7", DVY_W, DVY_W,
	step_x = 0.4, step_y = 0.4,
	setback = 0.4, setback_type = INTERSECTION,
	FSS = {
    { CHIP_snps, min_space = DMY1_CHIP, context = INTERIOR },
    { BEOLBLK_FINAL, min_space = DM_BEOLBLK },
    { INDDMY, min_space = DM_INDDMY },

    { DV7EXCL, min_space = DV_DVXEXCL },
    { TCDDMY_V7, min_space = DV_TCDDMY_VX },
    { VIA7I, min_space = DVY_VY },
    { DVIA7, min_space = DVY_DVY },
#ifdef ANTPrevention
    { FORBIDDEN_RING, min_space = 0 },
#endif
    { DVIA7_O, min_space = 0.300 },
#ifdef FILL_M7_VIA7_M8_BTCD
    { BTCD_M7_V7_M8_E, min_space = DV_TCDDMY_VX },
#endif
    } );
PATTERN_SPEC_DV7_1st.polygon_fill.fill_to_signal_spacing.push_back( { VIA7FORBIDDENRING, min_space = 0 } );
PATTERN_SPEC_DV7_1st.polygon_fill.fill_to_signal_spacing.push_back( { REGION_DV7, min_space = 0, context = INTERIOR } );

SPEC_DV7_1st : layer_groups_h;
PATTERN_SPEC_DV7_1st.polygon_fill.color = true;
SPEC_DV7_1st = unified_fill(
    fill_boundary = {
        layer = CHIP_snps,
        type = LAYER
    },
    boundary = ALIGN,
    grid = vGRID,
    fill_patterns = { PATTERN_SPEC_DV7_1st }
);
DV7_C_1st   = SPEC_DV7_1st["OUTPUT_DV7"][0];
gDV7_E_1st   = SPEC_DV7_1st["OUTPUT_DV7"][0];

PATTERN_SPEC_DV7_2nd = get_single_polygon_pattern(
    "DV7", "OUTPUT_DV7", DVY_W, DVY_W,
	step_x = DVY_S, step_y = DVY_S,
	setback = DVY_S, setback_type = INTERSECTION,
	FSS = {
    { CHIP_snps, min_space = DMY1_CHIP, context = INTERIOR },
    { BEOLBLK_FINAL, min_space = DM_BEOLBLK },
    { INDDMY, min_space = DM_INDDMY },

    { DV7EXCL, min_space = DV_DVXEXCL },
    { TCDDMY_V7, min_space = DV_TCDDMY_VX },
    { VIA7I, min_space = DVY_VY },
    { DVIA7, min_space = DVY_DVY },
#ifdef ANTPrevention
    { FORBIDDEN_RING, min_space = 0 },
#endif
    { DVIA7_O, min_space = 0.300 },
#ifdef FILL_M7_VIA7_M8_BTCD
    { BTCD_M7_V7_M8_E, min_space = DV_TCDDMY_VX },
#endif
{ DV7_C_1st, min_space = DVY_S },
    } );
PATTERN_SPEC_DV7_2nd.polygon_fill.fill_to_signal_spacing.push_back( { VIA7FORBIDDENRING, min_space = 0 } );
PATTERN_SPEC_DV7_2nd.polygon_fill.fill_to_signal_spacing.push_back( { REGION_DV7, min_space = 0, context = INTERIOR } );

SPEC_DV7_2nd : layer_groups_h;
PATTERN_SPEC_DV7_2nd.polygon_fill.color = true;
SPEC_DV7_2nd = unified_fill(
    fill_boundary = {
        layer = CHIP_snps,
        type = LAYER
    },
    boundary = ALIGN,
    grid = vGRID,
    fill_patterns = { PATTERN_SPEC_DV7_2nd }
);

DV7_C_2nd   = SPEC_DV7_2nd["OUTPUT_DV7"][0];
gDV7_E_2nd   = SPEC_DV7_2nd["OUTPUT_DV7"][0];

DV7_C   = DV7_C_1st or DV7_C_2nd;
gDV7_E   = gDV7_E_1st or gDV7_E_2nd ;



CONNECTDM8 = empty_layer();

#else
CONNECTDM8 = empty_layer();
REGION_DV7_4_BLOCK = empty_layer();
gDV7_E   = empty_layer();
#endif
//============================================================================

#ifdef FILL_DmyVIA8

#ifdef VERTICAL_M9
DM9_LEEDGE_DV8 = angle_edge( DM9_REGION_DV8_PRE, == 0 );
#else
DM9_LEEDGE_DV8 = angle_edge( DM9_REGION_DV8_PRE, == 90 );
#endif



DM9_REGION_DV8_PRO_PRE1 = not_length_edge( DM9_LEEDGE_DV8, < VIA8W ); 
DM9_REGION_DV8_PRO_PRE2 = touching( DM9_REGION_DV8_PRE, DM9_REGION_DV8_PRO_PRE1, > 0 ); 

CENTER_BAR_VALUE = VIA8W;
DM9_REGION_DV8_PRO = drc_features( primary_layer = DM9_REGION_DV8_PRO_PRE2, secondary_layers = { "layer2" => DM9_LEEDGE_DV8 }, output_from_layer = DM9_REGION_DV8_PRO_PRE2, include_touch = EDGE, drc_function = dfm_property_func_DV, combine_errors = OPPOSING ); 
DM9_REGION_DV8_RE = DM9_REGION_DV8_PRO not edge_size_by_property( DM9_REGION_DV8_PRO, inside_property = "Metal_W" );
DM9_REGION_DV8_LESHRINK = edge_size( DM9_LEEDGE_DV8, inside = LINEEND_M9V8 ); 
DM9_REGION_DV8 = DM9_REGION_DV8_RE not DM9_REGION_DV8_LESHRINK; 


#ifdef VERTICAL_M8
DM8_LEEDGE_DV8 = angle_edge( DM8_REGION_DV8_PRE, == 0 );
#else
DM8_LEEDGE_DV8 = angle_edge( DM8_REGION_DV8_PRE, == 90 );
#endif



DM8_REGION_DV8_PRO_PRE1 = not_length_edge( DM8_LEEDGE_DV8, < VIA8W ); 
DM8_REGION_DV8_PRO_PRE2 = touching( DM8_REGION_DV8_PRE, DM8_REGION_DV8_PRO_PRE1, > 0 ); 

CENTER_BAR_VALUE = VIA8W;
DM8_REGION_DV8_PRO = drc_features( primary_layer = DM8_REGION_DV8_PRO_PRE2, secondary_layers = { "layer2" => DM8_LEEDGE_DV8 }, output_from_layer = DM8_REGION_DV8_PRO_PRE2, include_touch = EDGE, drc_function = dfm_property_func_DV, combine_errors = OPPOSING ); 
DM8_REGION_DV8_RE = DM8_REGION_DV8_PRO not edge_size_by_property( DM8_REGION_DV8_PRO, inside_property = "Metal_W" );
DM8_REGION_DV8_LESHRINK = edge_size( DM8_LEEDGE_DV8, inside = LINEEND_M8V8 ); 
DM8_REGION_DV8 = DM8_REGION_DV8_RE not DM8_REGION_DV8_LESHRINK; 

REGION_DV8_PRE = DM9_REGION_DV8 and not_interacting( DM8_REGION_DV8, CONNECTDM8 ); 
REGION_DV8 =  copy(REGION_DV8_PRE);
// DUMMY SPEC : DV8
//***** spec *******************************************************************

PATTERN_SPEC_DV8_1st = get_single_polygon_pattern(
    "DV8", "OUTPUT_DV8", DVY_W, DVY_W,
	step_x = 0.4, step_y = 0.4,
	setback = 0.4, setback_type = INTERSECTION,
	FSS = {
    { CHIP_snps, min_space = DMY1_CHIP, context = INTERIOR },
    { BEOLBLK_FINAL, min_space = DM_BEOLBLK },
    { INDDMY, min_space = DM_INDDMY },

    { DV8EXCL, min_space = DV_DVXEXCL },
    { TCDDMY_V8, min_space = DV_TCDDMY_VX },
    { VIA8I, min_space = DVY_VY },
    { DVIA8, min_space = DVY_DVY },
#ifdef ANTPrevention
    { FORBIDDEN_RING, min_space = 0 },
#endif
    { DVIA8_O, min_space = 0.300 },
#ifdef FILL_M8_VIA8_M9_BTCD
    { BTCD_M8_V8_M9_E, min_space = DV_TCDDMY_VX },
#endif
    } );
PATTERN_SPEC_DV8_1st.polygon_fill.fill_to_signal_spacing.push_back( { VIA8FORBIDDENRING, min_space = 0 } );
PATTERN_SPEC_DV8_1st.polygon_fill.fill_to_signal_spacing.push_back( { REGION_DV8, min_space = 0, context = INTERIOR } );

SPEC_DV8_1st : layer_groups_h;
PATTERN_SPEC_DV8_1st.polygon_fill.color = true;
SPEC_DV8_1st = unified_fill(
    fill_boundary = {
        layer = CHIP_snps,
        type = LAYER
    },
    boundary = ALIGN,
    grid = vGRID,
    fill_patterns = { PATTERN_SPEC_DV8_1st }
);
DV8_C_1st   = SPEC_DV8_1st["OUTPUT_DV8"][0];
gDV8_E_1st   = SPEC_DV8_1st["OUTPUT_DV8"][0];

PATTERN_SPEC_DV8_2nd = get_single_polygon_pattern(
    "DV8", "OUTPUT_DV8", DVY_W, DVY_W,
	step_x = DVY_S, step_y = DVY_S,
	setback = DVY_S, setback_type = INTERSECTION,
	FSS = {
    { CHIP_snps, min_space = DMY1_CHIP, context = INTERIOR },
    { BEOLBLK_FINAL, min_space = DM_BEOLBLK },
    { INDDMY, min_space = DM_INDDMY },

    { DV8EXCL, min_space = DV_DVXEXCL },
    { TCDDMY_V8, min_space = DV_TCDDMY_VX },
    { VIA8I, min_space = DVY_VY },
    { DVIA8, min_space = DVY_DVY },
#ifdef ANTPrevention
    { FORBIDDEN_RING, min_space = 0 },
#endif
    { DVIA8_O, min_space = 0.300 },
#ifdef FILL_M8_VIA8_M9_BTCD
    { BTCD_M8_V8_M9_E, min_space = DV_TCDDMY_VX },
#endif
{ DV8_C_1st, min_space = DVY_S },
    } );
PATTERN_SPEC_DV8_2nd.polygon_fill.fill_to_signal_spacing.push_back( { VIA8FORBIDDENRING, min_space = 0 } );
PATTERN_SPEC_DV8_2nd.polygon_fill.fill_to_signal_spacing.push_back( { REGION_DV8, min_space = 0, context = INTERIOR } );

SPEC_DV8_2nd : layer_groups_h;
PATTERN_SPEC_DV8_2nd.polygon_fill.color = true;
SPEC_DV8_2nd = unified_fill(
    fill_boundary = {
        layer = CHIP_snps,
        type = LAYER
    },
    boundary = ALIGN,
    grid = vGRID,
    fill_patterns = { PATTERN_SPEC_DV8_2nd }
);

DV8_C_2nd   = SPEC_DV8_2nd["OUTPUT_DV8"][0];
gDV8_E_2nd   = SPEC_DV8_2nd["OUTPUT_DV8"][0];

DV8_C   = DV8_C_1st or DV8_C_2nd;
gDV8_E   = gDV8_E_1st or gDV8_E_2nd ;



CONNECTDM9 = empty_layer();

#else
CONNECTDM9 = empty_layer();
REGION_DV8_4_BLOCK = empty_layer();
gDV8_E   = empty_layer();
#endif
//============================================================================

#ifdef FILL_DmyVIA9

#ifdef VERTICAL_M10
DM10_LEEDGE_DV9 = angle_edge( DM10_REGION_DV9_PRE, == 0 );
#else
DM10_LEEDGE_DV9 = angle_edge( DM10_REGION_DV9_PRE, == 90 );
#endif



DM10_REGION_DV9_PRO_PRE1 = not_length_edge( DM10_LEEDGE_DV9, < VIA9W ); 
DM10_REGION_DV9_PRO_PRE2 = touching( DM10_REGION_DV9_PRE, DM10_REGION_DV9_PRO_PRE1, > 0 ); 

CENTER_BAR_VALUE = VIA9W;
DM10_REGION_DV9_PRO = drc_features( primary_layer = DM10_REGION_DV9_PRO_PRE2, secondary_layers = { "layer2" => DM10_LEEDGE_DV9 }, output_from_layer = DM10_REGION_DV9_PRO_PRE2, include_touch = EDGE, drc_function = dfm_property_func_DV, combine_errors = OPPOSING ); 
DM10_REGION_DV9_RE = DM10_REGION_DV9_PRO not edge_size_by_property( DM10_REGION_DV9_PRO, inside_property = "Metal_W" );
DM10_REGION_DV9_LESHRINK = edge_size( DM10_LEEDGE_DV9, inside = LINEEND_M10V9 ); 
DM10_REGION_DV9 = DM10_REGION_DV9_RE not DM10_REGION_DV9_LESHRINK; 


#ifdef VERTICAL_M9
DM9_LEEDGE_DV9 = angle_edge( DM9_REGION_DV9_PRE, == 0 );
#else
DM9_LEEDGE_DV9 = angle_edge( DM9_REGION_DV9_PRE, == 90 );
#endif



DM9_REGION_DV9_PRO_PRE1 = not_length_edge( DM9_LEEDGE_DV9, < VIA9W ); 
DM9_REGION_DV9_PRO_PRE2 = touching( DM9_REGION_DV9_PRE, DM9_REGION_DV9_PRO_PRE1, > 0 ); 

CENTER_BAR_VALUE = VIA9W;
DM9_REGION_DV9_PRO = drc_features( primary_layer = DM9_REGION_DV9_PRO_PRE2, secondary_layers = { "layer2" => DM9_LEEDGE_DV9 }, output_from_layer = DM9_REGION_DV9_PRO_PRE2, include_touch = EDGE, drc_function = dfm_property_func_DV, combine_errors = OPPOSING ); 
DM9_REGION_DV9_RE = DM9_REGION_DV9_PRO not edge_size_by_property( DM9_REGION_DV9_PRO, inside_property = "Metal_W" );
DM9_REGION_DV9_LESHRINK = edge_size( DM9_LEEDGE_DV9, inside = LINEEND_M9V9 ); 
DM9_REGION_DV9 = DM9_REGION_DV9_RE not DM9_REGION_DV9_LESHRINK; 

REGION_DV9_PRE = DM10_REGION_DV9 and not_interacting( DM9_REGION_DV9, CONNECTDM9 ); 
REGION_DV9 =  copy(REGION_DV9_PRE);
// DUMMY SPEC : DV9
//***** spec *******************************************************************

PATTERN_SPEC_DV9_1st = get_single_polygon_pattern(
    "DV9", "OUTPUT_DV9", DVY_W, DVY_W,
	step_x = 0.4, step_y = 0.4,
	setback = 0.4, setback_type = INTERSECTION,
	FSS = {
    { CHIP_snps, min_space = DMY1_CHIP, context = INTERIOR },
    { BEOLBLK_FINAL, min_space = DM_BEOLBLK },
    { INDDMY, min_space = DM_INDDMY },

    { DV9EXCL, min_space = DV_DVXEXCL },
    { TCDDMY_V9, min_space = DV_TCDDMY_VX },
    { VIA9I, min_space = DVY_VY },
    { DVIA9, min_space = DVY_DVY },
#ifdef ANTPrevention
    { FORBIDDEN_RING, min_space = 0 },
#endif
    { DVIA9_O, min_space = 0.300 },
#ifdef FILL_M9_VIA9_M10_BTCD
    { BTCD_M9_V9_M10_E, min_space = DV_TCDDMY_VX },
#endif
    } );
PATTERN_SPEC_DV9_1st.polygon_fill.fill_to_signal_spacing.push_back( { VIA9FORBIDDENRING, min_space = 0 } );
PATTERN_SPEC_DV9_1st.polygon_fill.fill_to_signal_spacing.push_back( { REGION_DV9, min_space = 0, context = INTERIOR } );

SPEC_DV9_1st : layer_groups_h;
PATTERN_SPEC_DV9_1st.polygon_fill.color = true;
SPEC_DV9_1st = unified_fill(
    fill_boundary = {
        layer = CHIP_snps,
        type = LAYER
    },
    boundary = ALIGN,
    grid = vGRID,
    fill_patterns = { PATTERN_SPEC_DV9_1st }
);
DV9_C_1st   = SPEC_DV9_1st["OUTPUT_DV9"][0];
gDV9_E_1st   = SPEC_DV9_1st["OUTPUT_DV9"][0];

PATTERN_SPEC_DV9_2nd = get_single_polygon_pattern(
    "DV9", "OUTPUT_DV9", DVY_W, DVY_W,
	step_x = DVY_S, step_y = DVY_S,
	setback = DVY_S, setback_type = INTERSECTION,
	FSS = {
    { CHIP_snps, min_space = DMY1_CHIP, context = INTERIOR },
    { BEOLBLK_FINAL, min_space = DM_BEOLBLK },
    { INDDMY, min_space = DM_INDDMY },

    { DV9EXCL, min_space = DV_DVXEXCL },
    { TCDDMY_V9, min_space = DV_TCDDMY_VX },
    { VIA9I, min_space = DVY_VY },
    { DVIA9, min_space = DVY_DVY },
#ifdef ANTPrevention
    { FORBIDDEN_RING, min_space = 0 },
#endif
    { DVIA9_O, min_space = 0.300 },
#ifdef FILL_M9_VIA9_M10_BTCD
    { BTCD_M9_V9_M10_E, min_space = DV_TCDDMY_VX },
#endif
{ DV9_C_1st, min_space = DVY_S },
    } );
PATTERN_SPEC_DV9_2nd.polygon_fill.fill_to_signal_spacing.push_back( { VIA9FORBIDDENRING, min_space = 0 } );
PATTERN_SPEC_DV9_2nd.polygon_fill.fill_to_signal_spacing.push_back( { REGION_DV9, min_space = 0, context = INTERIOR } );

SPEC_DV9_2nd : layer_groups_h;
PATTERN_SPEC_DV9_2nd.polygon_fill.color = true;
SPEC_DV9_2nd = unified_fill(
    fill_boundary = {
        layer = CHIP_snps,
        type = LAYER
    },
    boundary = ALIGN,
    grid = vGRID,
    fill_patterns = { PATTERN_SPEC_DV9_2nd }
);

DV9_C_2nd   = SPEC_DV9_2nd["OUTPUT_DV9"][0];
gDV9_E_2nd   = SPEC_DV9_2nd["OUTPUT_DV9"][0];

DV9_C   = DV9_C_1st or DV9_C_2nd;
gDV9_E   = gDV9_E_1st or gDV9_E_2nd ;



CONNECTDM10 = empty_layer();

#else
CONNECTDM10 = empty_layer();
REGION_DV9_4_BLOCK = empty_layer();
gDV9_E   = empty_layer();
#endif
//============================================================================

#ifdef FILL_DmyVIA10

#ifdef VERTICAL_M11
DM11_LEEDGE_DV10 = angle_edge( DM11_REGION_DV10_PRE, == 0 );
#else
DM11_LEEDGE_DV10 = angle_edge( DM11_REGION_DV10_PRE, == 90 );
#endif



DM11_REGION_DV10_PRO_PRE1 = not_length_edge( DM11_LEEDGE_DV10, < VIA10W ); 
DM11_REGION_DV10_PRO_PRE2 = touching( DM11_REGION_DV10_PRE, DM11_REGION_DV10_PRO_PRE1, > 0 ); 

CENTER_BAR_VALUE = VIA10W;
DM11_REGION_DV10_PRO = drc_features( primary_layer = DM11_REGION_DV10_PRO_PRE2, secondary_layers = { "layer2" => DM11_LEEDGE_DV10 }, output_from_layer = DM11_REGION_DV10_PRO_PRE2, include_touch = EDGE, drc_function = dfm_property_func_DV, combine_errors = OPPOSING ); 
DM11_REGION_DV10_RE = DM11_REGION_DV10_PRO not edge_size_by_property( DM11_REGION_DV10_PRO, inside_property = "Metal_W" );
DM11_REGION_DV10_LESHRINK = edge_size( DM11_LEEDGE_DV10, inside = LINEEND_M11V10 ); 
DM11_REGION_DV10 = DM11_REGION_DV10_RE not DM11_REGION_DV10_LESHRINK; 


#ifdef VERTICAL_M10
DM10_LEEDGE_DV10 = angle_edge( DM10_REGION_DV10_PRE, == 0 );
#else
DM10_LEEDGE_DV10 = angle_edge( DM10_REGION_DV10_PRE, == 90 );
#endif



DM10_REGION_DV10_PRO_PRE1 = not_length_edge( DM10_LEEDGE_DV10, < VIA10W ); 
DM10_REGION_DV10_PRO_PRE2 = touching( DM10_REGION_DV10_PRE, DM10_REGION_DV10_PRO_PRE1, > 0 ); 

CENTER_BAR_VALUE = VIA10W;
DM10_REGION_DV10_PRO = drc_features( primary_layer = DM10_REGION_DV10_PRO_PRE2, secondary_layers = { "layer2" => DM10_LEEDGE_DV10 }, output_from_layer = DM10_REGION_DV10_PRO_PRE2, include_touch = EDGE, drc_function = dfm_property_func_DV, combine_errors = OPPOSING ); 
DM10_REGION_DV10_RE = DM10_REGION_DV10_PRO not edge_size_by_property( DM10_REGION_DV10_PRO, inside_property = "Metal_W" );
DM10_REGION_DV10_LESHRINK = edge_size( DM10_LEEDGE_DV10, inside = LINEEND_M10V10 ); 
DM10_REGION_DV10 = DM10_REGION_DV10_RE not DM10_REGION_DV10_LESHRINK; 

REGION_DV10_PRE = DM11_REGION_DV10 and not_interacting( DM10_REGION_DV10, CONNECTDM10 ); 
REGION_DV10 =  copy(REGION_DV10_PRE);
// DUMMY SPEC : DV10
//***** spec *******************************************************************

PATTERN_SPEC_DV10_1st = get_single_polygon_pattern(
    "DV10", "OUTPUT_DV10", DVY_W, DVY_W,
	step_x = 0.4, step_y = 0.4,
	setback = 0.4, setback_type = INTERSECTION,
	FSS = {
    { CHIP_snps, min_space = DMY1_CHIP, context = INTERIOR },
    { BEOLBLK_FINAL, min_space = DM_BEOLBLK },
    { INDDMY, min_space = DM_INDDMY },

    { DV10EXCL, min_space = DV_DVXEXCL },
    { TCDDMY_V10, min_space = DV_TCDDMY_VX },
    { VIA10I, min_space = DVY_VY },
    { DVIA10, min_space = DVY_DVY },
#ifdef ANTPrevention
    { FORBIDDEN_RING, min_space = 0 },
#endif
    { DVIA10_O, min_space = 0.300 },
#ifdef FILL_M10_VIA10_M11_BTCD
    { BTCD_M10_V10_M11_E, min_space = DV_TCDDMY_VX },
#endif
    } );
PATTERN_SPEC_DV10_1st.polygon_fill.fill_to_signal_spacing.push_back( { VIA10FORBIDDENRING, min_space = 0 } );
PATTERN_SPEC_DV10_1st.polygon_fill.fill_to_signal_spacing.push_back( { REGION_DV10, min_space = 0, context = INTERIOR } );

SPEC_DV10_1st : layer_groups_h;
PATTERN_SPEC_DV10_1st.polygon_fill.color = true;
SPEC_DV10_1st = unified_fill(
    fill_boundary = {
        layer = CHIP_snps,
        type = LAYER
    },
    boundary = ALIGN,
    grid = vGRID,
    fill_patterns = { PATTERN_SPEC_DV10_1st }
);
DV10_C_1st   = SPEC_DV10_1st["OUTPUT_DV10"][0];
gDV10_E_1st   = SPEC_DV10_1st["OUTPUT_DV10"][0];

PATTERN_SPEC_DV10_2nd = get_single_polygon_pattern(
    "DV10", "OUTPUT_DV10", DVY_W, DVY_W,
	step_x = DVY_S, step_y = DVY_S,
	setback = DVY_S, setback_type = INTERSECTION,
	FSS = {
    { CHIP_snps, min_space = DMY1_CHIP, context = INTERIOR },
    { BEOLBLK_FINAL, min_space = DM_BEOLBLK },
    { INDDMY, min_space = DM_INDDMY },

    { DV10EXCL, min_space = DV_DVXEXCL },
    { TCDDMY_V10, min_space = DV_TCDDMY_VX },
    { VIA10I, min_space = DVY_VY },
    { DVIA10, min_space = DVY_DVY },
#ifdef ANTPrevention
    { FORBIDDEN_RING, min_space = 0 },
#endif
    { DVIA10_O, min_space = 0.300 },
#ifdef FILL_M10_VIA10_M11_BTCD
    { BTCD_M10_V10_M11_E, min_space = DV_TCDDMY_VX },
#endif
{ DV10_C_1st, min_space = DVY_S },
    } );
PATTERN_SPEC_DV10_2nd.polygon_fill.fill_to_signal_spacing.push_back( { VIA10FORBIDDENRING, min_space = 0 } );
PATTERN_SPEC_DV10_2nd.polygon_fill.fill_to_signal_spacing.push_back( { REGION_DV10, min_space = 0, context = INTERIOR } );

SPEC_DV10_2nd : layer_groups_h;
PATTERN_SPEC_DV10_2nd.polygon_fill.color = true;
SPEC_DV10_2nd = unified_fill(
    fill_boundary = {
        layer = CHIP_snps,
        type = LAYER
    },
    boundary = ALIGN,
    grid = vGRID,
    fill_patterns = { PATTERN_SPEC_DV10_2nd }
);

DV10_C_2nd   = SPEC_DV10_2nd["OUTPUT_DV10"][0];
gDV10_E_2nd   = SPEC_DV10_2nd["OUTPUT_DV10"][0];

DV10_C   = DV10_C_1st or DV10_C_2nd;
gDV10_E   = gDV10_E_1st or gDV10_E_2nd ;



CONNECTDM11 = empty_layer();

#else
CONNECTDM11 = empty_layer();
REGION_DV10_4_BLOCK = empty_layer();
gDV10_E   = empty_layer();
#endif
//============================================================================

#ifdef FILL_DmyVIA11

#ifdef VERTICAL_M12
DM12_LEEDGE_DV11 = angle_edge( DM12_REGION_DV11_PRE, == 0 );
#else
DM12_LEEDGE_DV11 = angle_edge( DM12_REGION_DV11_PRE, == 90 );
#endif



DM12_REGION_DV11_PRO_PRE1 = not_length_edge( DM12_LEEDGE_DV11, < VIA11W ); 
DM12_REGION_DV11_PRO_PRE2 = touching( DM12_REGION_DV11_PRE, DM12_REGION_DV11_PRO_PRE1, > 0 ); 

CENTER_BAR_VALUE = VIA11W;
DM12_REGION_DV11_PRO = drc_features( primary_layer = DM12_REGION_DV11_PRO_PRE2, secondary_layers = { "layer2" => DM12_LEEDGE_DV11 }, output_from_layer = DM12_REGION_DV11_PRO_PRE2, include_touch = EDGE, drc_function = dfm_property_func_DV, combine_errors = OPPOSING ); 
DM12_REGION_DV11_RE = DM12_REGION_DV11_PRO not edge_size_by_property( DM12_REGION_DV11_PRO, inside_property = "Metal_W" );
DM12_REGION_DV11_LESHRINK = edge_size( DM12_LEEDGE_DV11, inside = LINEEND_M12V11 ); 
DM12_REGION_DV11 = DM12_REGION_DV11_RE not DM12_REGION_DV11_LESHRINK; 


#ifdef VERTICAL_M11
DM11_LEEDGE_DV11 = angle_edge( DM11_REGION_DV11_PRE, == 0 );
#else
DM11_LEEDGE_DV11 = angle_edge( DM11_REGION_DV11_PRE, == 90 );
#endif



DM11_REGION_DV11_PRO_PRE1 = not_length_edge( DM11_LEEDGE_DV11, < VIA11W ); 
DM11_REGION_DV11_PRO_PRE2 = touching( DM11_REGION_DV11_PRE, DM11_REGION_DV11_PRO_PRE1, > 0 ); 

CENTER_BAR_VALUE = VIA11W;
DM11_REGION_DV11_PRO = drc_features( primary_layer = DM11_REGION_DV11_PRO_PRE2, secondary_layers = { "layer2" => DM11_LEEDGE_DV11 }, output_from_layer = DM11_REGION_DV11_PRO_PRE2, include_touch = EDGE, drc_function = dfm_property_func_DV, combine_errors = OPPOSING ); 
DM11_REGION_DV11_RE = DM11_REGION_DV11_PRO not edge_size_by_property( DM11_REGION_DV11_PRO, inside_property = "Metal_W" );
DM11_REGION_DV11_LESHRINK = edge_size( DM11_LEEDGE_DV11, inside = LINEEND_M11V11 ); 
DM11_REGION_DV11 = DM11_REGION_DV11_RE not DM11_REGION_DV11_LESHRINK; 

REGION_DV11_PRE = DM12_REGION_DV11 and not_interacting( DM11_REGION_DV11, CONNECTDM11 ); 
REGION_DV11 =  copy(REGION_DV11_PRE);
// DUMMY SPEC : DV11
//***** spec *******************************************************************

PATTERN_SPEC_DV11_1st = get_single_polygon_pattern(
    "DV11", "OUTPUT_DV11", DVY_W, DVY_W,
	step_x = 0.4, step_y = 0.4,
	setback = 0.4, setback_type = INTERSECTION,
	FSS = {
    { CHIP_snps, min_space = DMY1_CHIP, context = INTERIOR },
    { BEOLBLK_FINAL, min_space = DM_BEOLBLK },
    { INDDMY, min_space = DM_INDDMY },

    { DV11EXCL, min_space = DV_DVXEXCL },
    { TCDDMY_V11, min_space = DV_TCDDMY_VX },
    { VIA11I, min_space = DVY_VY },
    { DVIA11, min_space = DVY_DVY },
#ifdef ANTPrevention
    { FORBIDDEN_RING, min_space = 0 },
#endif
    { DVIA11_O, min_space = 0.300 },
#ifdef FILL_M11_VIA11_M12_BTCD
    { BTCD_M11_V11_M12_E, min_space = DV_TCDDMY_VX },
#endif
    } );
PATTERN_SPEC_DV11_1st.polygon_fill.fill_to_signal_spacing.push_back( { VIA11FORBIDDENRING, min_space = 0 } );
PATTERN_SPEC_DV11_1st.polygon_fill.fill_to_signal_spacing.push_back( { REGION_DV11, min_space = 0, context = INTERIOR } );

SPEC_DV11_1st : layer_groups_h;
PATTERN_SPEC_DV11_1st.polygon_fill.color = true;
SPEC_DV11_1st = unified_fill(
    fill_boundary = {
        layer = CHIP_snps,
        type = LAYER
    },
    boundary = ALIGN,
    grid = vGRID,
    fill_patterns = { PATTERN_SPEC_DV11_1st }
);
DV11_C_1st   = SPEC_DV11_1st["OUTPUT_DV11"][0];
gDV11_E_1st   = SPEC_DV11_1st["OUTPUT_DV11"][0];

PATTERN_SPEC_DV11_2nd = get_single_polygon_pattern(
    "DV11", "OUTPUT_DV11", DVY_W, DVY_W,
	step_x = DVY_S, step_y = DVY_S,
	setback = DVY_S, setback_type = INTERSECTION,
	FSS = {
    { CHIP_snps, min_space = DMY1_CHIP, context = INTERIOR },
    { BEOLBLK_FINAL, min_space = DM_BEOLBLK },
    { INDDMY, min_space = DM_INDDMY },

    { DV11EXCL, min_space = DV_DVXEXCL },
    { TCDDMY_V11, min_space = DV_TCDDMY_VX },
    { VIA11I, min_space = DVY_VY },
    { DVIA11, min_space = DVY_DVY },
#ifdef ANTPrevention
    { FORBIDDEN_RING, min_space = 0 },
#endif
    { DVIA11_O, min_space = 0.300 },
#ifdef FILL_M11_VIA11_M12_BTCD
    { BTCD_M11_V11_M12_E, min_space = DV_TCDDMY_VX },
#endif
{ DV11_C_1st, min_space = DVY_S },
    } );
PATTERN_SPEC_DV11_2nd.polygon_fill.fill_to_signal_spacing.push_back( { VIA11FORBIDDENRING, min_space = 0 } );
PATTERN_SPEC_DV11_2nd.polygon_fill.fill_to_signal_spacing.push_back( { REGION_DV11, min_space = 0, context = INTERIOR } );

SPEC_DV11_2nd : layer_groups_h;
PATTERN_SPEC_DV11_2nd.polygon_fill.color = true;
SPEC_DV11_2nd = unified_fill(
    fill_boundary = {
        layer = CHIP_snps,
        type = LAYER
    },
    boundary = ALIGN,
    grid = vGRID,
    fill_patterns = { PATTERN_SPEC_DV11_2nd }
);

DV11_C_2nd   = SPEC_DV11_2nd["OUTPUT_DV11"][0];
gDV11_E_2nd   = SPEC_DV11_2nd["OUTPUT_DV11"][0];

DV11_C   = DV11_C_1st or DV11_C_2nd;
gDV11_E   = gDV11_E_1st or gDV11_E_2nd ;



CONNECTDM12 = empty_layer();

#else
CONNECTDM12 = empty_layer();
REGION_DV11_4_BLOCK = empty_layer();
gDV11_E   = empty_layer();
#endif
//============================================================================

#ifdef FILL_DmyVIA12

#ifdef VERTICAL_M13
DM13_LEEDGE_DV12 = angle_edge( DM13_REGION_DV12_PRE, == 0 );
#else
DM13_LEEDGE_DV12 = angle_edge( DM13_REGION_DV12_PRE, == 90 );
#endif



DM13_REGION_DV12_PRO_PRE1 = not_length_edge( DM13_LEEDGE_DV12, < VIA12W ); 
DM13_REGION_DV12_PRO_PRE2 = touching( DM13_REGION_DV12_PRE, DM13_REGION_DV12_PRO_PRE1, > 0 ); 

CENTER_BAR_VALUE = VIA12W;
DM13_REGION_DV12_PRO = drc_features( primary_layer = DM13_REGION_DV12_PRO_PRE2, secondary_layers = { "layer2" => DM13_LEEDGE_DV12 }, output_from_layer = DM13_REGION_DV12_PRO_PRE2, include_touch = EDGE, drc_function = dfm_property_func_DV, combine_errors = OPPOSING ); 
DM13_REGION_DV12_RE = DM13_REGION_DV12_PRO not edge_size_by_property( DM13_REGION_DV12_PRO, inside_property = "Metal_W" );
DM13_REGION_DV12_LESHRINK = edge_size( DM13_LEEDGE_DV12, inside = LINEEND_M13V12 ); 
DM13_REGION_DV12 = DM13_REGION_DV12_RE not DM13_REGION_DV12_LESHRINK; 


#ifdef VERTICAL_M12
DM12_LEEDGE_DV12 = angle_edge( DM12_REGION_DV12_PRE, == 0 );
#else
DM12_LEEDGE_DV12 = angle_edge( DM12_REGION_DV12_PRE, == 90 );
#endif



DM12_REGION_DV12_PRO_PRE1 = not_length_edge( DM12_LEEDGE_DV12, < VIA12W ); 
DM12_REGION_DV12_PRO_PRE2 = touching( DM12_REGION_DV12_PRE, DM12_REGION_DV12_PRO_PRE1, > 0 ); 

CENTER_BAR_VALUE = VIA12W;
DM12_REGION_DV12_PRO = drc_features( primary_layer = DM12_REGION_DV12_PRO_PRE2, secondary_layers = { "layer2" => DM12_LEEDGE_DV12 }, output_from_layer = DM12_REGION_DV12_PRO_PRE2, include_touch = EDGE, drc_function = dfm_property_func_DV, combine_errors = OPPOSING ); 
DM12_REGION_DV12_RE = DM12_REGION_DV12_PRO not edge_size_by_property( DM12_REGION_DV12_PRO, inside_property = "Metal_W" );
DM12_REGION_DV12_LESHRINK = edge_size( DM12_LEEDGE_DV12, inside = LINEEND_M12V12 ); 
DM12_REGION_DV12 = DM12_REGION_DV12_RE not DM12_REGION_DV12_LESHRINK; 

REGION_DV12_PRE = DM13_REGION_DV12 and not_interacting( DM12_REGION_DV12, CONNECTDM12 ); 
REGION_DV12 =  copy(REGION_DV12_PRE);
// DUMMY SPEC : DV12
//***** spec *******************************************************************

PATTERN_SPEC_DV12_1st = get_single_polygon_pattern(
    "DV12", "OUTPUT_DV12", DVY_W, DVY_W,
	step_x = 0.4, step_y = 0.4,
	setback = 0.4, setback_type = INTERSECTION,
	FSS = {
    { CHIP_snps, min_space = DMY1_CHIP, context = INTERIOR },
    { BEOLBLK_FINAL, min_space = DM_BEOLBLK },
    { INDDMY, min_space = DM_INDDMY },

    { DV12EXCL, min_space = DV_DVXEXCL },
    { TCDDMY_V12, min_space = DV_TCDDMY_VX },
    { VIA12I, min_space = DVY_VY },
    { DVIA12, min_space = DVY_DVY },
#ifdef ANTPrevention
    { FORBIDDEN_RING, min_space = 0 },
#endif
    { DVIA12_O, min_space = 0.300 },
#ifdef FILL_M12_VIA12_M13_BTCD
    { BTCD_M12_V12_M13_E, min_space = DV_TCDDMY_VX },
#endif
    } );
PATTERN_SPEC_DV12_1st.polygon_fill.fill_to_signal_spacing.push_back( { VIA12FORBIDDENRING, min_space = 0 } );
PATTERN_SPEC_DV12_1st.polygon_fill.fill_to_signal_spacing.push_back( { REGION_DV12, min_space = 0, context = INTERIOR } );

SPEC_DV12_1st : layer_groups_h;
PATTERN_SPEC_DV12_1st.polygon_fill.color = true;
SPEC_DV12_1st = unified_fill(
    fill_boundary = {
        layer = CHIP_snps,
        type = LAYER
    },
    boundary = ALIGN,
    grid = vGRID,
    fill_patterns = { PATTERN_SPEC_DV12_1st }
);
DV12_C_1st   = SPEC_DV12_1st["OUTPUT_DV12"][0];
gDV12_E_1st   = SPEC_DV12_1st["OUTPUT_DV12"][0];

PATTERN_SPEC_DV12_2nd = get_single_polygon_pattern(
    "DV12", "OUTPUT_DV12", DVY_W, DVY_W,
	step_x = DVY_S, step_y = DVY_S,
	setback = DVY_S, setback_type = INTERSECTION,
	FSS = {
    { CHIP_snps, min_space = DMY1_CHIP, context = INTERIOR },
    { BEOLBLK_FINAL, min_space = DM_BEOLBLK },
    { INDDMY, min_space = DM_INDDMY },

    { DV12EXCL, min_space = DV_DVXEXCL },
    { TCDDMY_V12, min_space = DV_TCDDMY_VX },
    { VIA12I, min_space = DVY_VY },
    { DVIA12, min_space = DVY_DVY },
#ifdef ANTPrevention
    { FORBIDDEN_RING, min_space = 0 },
#endif
    { DVIA12_O, min_space = 0.300 },
#ifdef FILL_M12_VIA12_M13_BTCD
    { BTCD_M12_V12_M13_E, min_space = DV_TCDDMY_VX },
#endif
{ DV12_C_1st, min_space = DVY_S },
    } );
PATTERN_SPEC_DV12_2nd.polygon_fill.fill_to_signal_spacing.push_back( { VIA12FORBIDDENRING, min_space = 0 } );
PATTERN_SPEC_DV12_2nd.polygon_fill.fill_to_signal_spacing.push_back( { REGION_DV12, min_space = 0, context = INTERIOR } );

SPEC_DV12_2nd : layer_groups_h;
PATTERN_SPEC_DV12_2nd.polygon_fill.color = true;
SPEC_DV12_2nd = unified_fill(
    fill_boundary = {
        layer = CHIP_snps,
        type = LAYER
    },
    boundary = ALIGN,
    grid = vGRID,
    fill_patterns = { PATTERN_SPEC_DV12_2nd }
);

DV12_C_2nd   = SPEC_DV12_2nd["OUTPUT_DV12"][0];
gDV12_E_2nd   = SPEC_DV12_2nd["OUTPUT_DV12"][0];

DV12_C   = DV12_C_1st or DV12_C_2nd;
gDV12_E   = gDV12_E_1st or gDV12_E_2nd ;



CONNECTDM13 = DM13_REGION_DV12_PRE interacting gDV12_E;


#else
CONNECTDM13 = empty_layer();
REGION_DV12_4_BLOCK = empty_layer();
gDV12_E   = empty_layer();
#endif
//============================================================================

#ifdef FILL_DmyVIA13

#ifdef VERTICAL_M14
DM14_LEEDGE_DV13 = angle_edge( DM14_REGION_DV13_PRE, == 0 );
#else
DM14_LEEDGE_DV13 = angle_edge( DM14_REGION_DV13_PRE, == 90 );
#endif



DM14_REGION_DV13_PRO_PRE1 = not_length_edge( DM14_LEEDGE_DV13, < VIA13W ); 
DM14_REGION_DV13_PRO_PRE2 = touching( DM14_REGION_DV13_PRE, DM14_REGION_DV13_PRO_PRE1, > 0 ); 

CENTER_BAR_VALUE = VIA13W;
DM14_REGION_DV13_PRO = drc_features( primary_layer = DM14_REGION_DV13_PRO_PRE2, secondary_layers = { "layer2" => DM14_LEEDGE_DV13 }, output_from_layer = DM14_REGION_DV13_PRO_PRE2, include_touch = EDGE, drc_function = dfm_property_func_DV, combine_errors = OPPOSING ); 
DM14_REGION_DV13_RE = DM14_REGION_DV13_PRO not edge_size_by_property( DM14_REGION_DV13_PRO, inside_property = "Metal_W" );
DM14_REGION_DV13_LESHRINK = edge_size( DM14_LEEDGE_DV13, inside = LINEEND_M14V13 ); 
DM14_REGION_DV13 = DM14_REGION_DV13_RE not DM14_REGION_DV13_LESHRINK; 


#ifdef VERTICAL_M13
DM13_LEEDGE_DV13 = angle_edge( DM13_REGION_DV13_PRE, == 0 );
#else
DM13_LEEDGE_DV13 = angle_edge( DM13_REGION_DV13_PRE, == 90 );
#endif



DM13_REGION_DV13_PRO_PRE1 = not_length_edge( DM13_LEEDGE_DV13, < VIA13W ); 
DM13_REGION_DV13_PRO_PRE2 = touching( DM13_REGION_DV13_PRE, DM13_REGION_DV13_PRO_PRE1, > 0 ); 

CENTER_BAR_VALUE = VIA13W;
DM13_REGION_DV13_PRO = drc_features( primary_layer = DM13_REGION_DV13_PRO_PRE2, secondary_layers = { "layer2" => DM13_LEEDGE_DV13 }, output_from_layer = DM13_REGION_DV13_PRO_PRE2, include_touch = EDGE, drc_function = dfm_property_func_DV, combine_errors = OPPOSING ); 
DM13_REGION_DV13_RE = DM13_REGION_DV13_PRO not edge_size_by_property( DM13_REGION_DV13_PRO, inside_property = "Metal_W" );
DM13_REGION_DV13_LESHRINK = edge_size( DM13_LEEDGE_DV13, inside = LINEEND_M13V13 ); 
DM13_REGION_DV13 = DM13_REGION_DV13_RE not DM13_REGION_DV13_LESHRINK; 

REGION_DV13_PRE = DM14_REGION_DV13 and not_interacting( DM13_REGION_DV13, CONNECTDM13 ); 
REGION_DV13 =  copy(REGION_DV13_PRE);
// DUMMY SPEC : DV13
//***** spec *******************************************************************
PATTERN_SPEC_DV13 = get_single_polygon_pattern(
    "DV13", "OUTPUT_DV13", DVYY_W, DVYY_W,
	step_x = DVYY_S, step_y = DVYY_S,
	setback = DVYY_S, setback_type = INTERSECTION,
	FSS = {
    { CHIP_snps, min_space = DMYY_CHIP, context = INTERIOR },
    { BEOLBLK_FINAL, min_space = DM_BEOLBLK },
    { INDDMY, min_space = DM_INDDMY },

    { DV13EXCL, min_space = DV_DVXEXCL },
    { TCDDMY_V13, min_space = DV_TCDDMY_VX },
    { VIA13I, min_space = DVYY_VYY },
    { DVIA13, min_space = DVYY_DVYY },
#ifdef ANTPrevention
    { FORBIDDEN_RING, min_space = 0 },
#endif

    { DVIA13_O, min_space = 0.180 },
    } );



PATTERN_SPEC_DV13.polygon_fill.fill_to_signal_spacing.push_back( { VIA13FORBIDDENRING, min_space = 0 } );
PATTERN_SPEC_DV13.polygon_fill.fill_to_signal_spacing.push_back( { REGION_DV13, min_space = 0, context = INTERIOR } );

SPEC_DV13 : layer_groups_h;
PATTERN_SPEC_DV13.polygon_fill.color = true;
SPEC_DV13 = unified_fill(
    fill_boundary = {
        layer = CHIP_snps,
        type = LAYER
    },
    boundary = ALIGN,
    grid = vGRID,
    fill_patterns = { PATTERN_SPEC_DV13 }
);
//============================================================================


DV13_C   = SPEC_DV13["OUTPUT_DV13"][0];
gDV13_E   = SPEC_DV13["OUTPUT_DV13"][0];


CONNECTDM14 = empty_layer();

#else
CONNECTDM14 = empty_layer();
REGION_DV13_4_BLOCK = empty_layer();
gDV13_E   = empty_layer();
#endif
//============================================================================

#ifdef FILL_DmyVIA14

#ifdef VERTICAL_M15
DM15_LEEDGE_DV14 = angle_edge( DM15_REGION_DV14_PRE, == 0 );
#else
DM15_LEEDGE_DV14 = angle_edge( DM15_REGION_DV14_PRE, == 90 );
#endif



DM15_REGION_DV14_PRO_PRE1 = not_length_edge( DM15_LEEDGE_DV14, < VIA14W ); 
DM15_REGION_DV14_PRO_PRE2 = touching( DM15_REGION_DV14_PRE, DM15_REGION_DV14_PRO_PRE1, > 0 ); 

CENTER_BAR_VALUE = VIA14W;
DM15_REGION_DV14_PRO = drc_features( primary_layer = DM15_REGION_DV14_PRO_PRE2, secondary_layers = { "layer2" => DM15_LEEDGE_DV14 }, output_from_layer = DM15_REGION_DV14_PRO_PRE2, include_touch = EDGE, drc_function = dfm_property_func_DV, combine_errors = OPPOSING ); 
DM15_REGION_DV14_RE = DM15_REGION_DV14_PRO not edge_size_by_property( DM15_REGION_DV14_PRO, inside_property = "Metal_W" );
DM15_REGION_DV14_LESHRINK = edge_size( DM15_LEEDGE_DV14, inside = LINEEND_M15V14 ); 
DM15_REGION_DV14 = DM15_REGION_DV14_RE not DM15_REGION_DV14_LESHRINK; 


#ifdef VERTICAL_M14
DM14_LEEDGE_DV14 = angle_edge( DM14_REGION_DV14_PRE, == 0 );
#else
DM14_LEEDGE_DV14 = angle_edge( DM14_REGION_DV14_PRE, == 90 );
#endif



DM14_REGION_DV14_PRO_PRE1 = not_length_edge( DM14_LEEDGE_DV14, < VIA14W ); 
DM14_REGION_DV14_PRO_PRE2 = touching( DM14_REGION_DV14_PRE, DM14_REGION_DV14_PRO_PRE1, > 0 ); 

CENTER_BAR_VALUE = VIA14W;
DM14_REGION_DV14_PRO = drc_features( primary_layer = DM14_REGION_DV14_PRO_PRE2, secondary_layers = { "layer2" => DM14_LEEDGE_DV14 }, output_from_layer = DM14_REGION_DV14_PRO_PRE2, include_touch = EDGE, drc_function = dfm_property_func_DV, combine_errors = OPPOSING ); 
DM14_REGION_DV14_RE = DM14_REGION_DV14_PRO not edge_size_by_property( DM14_REGION_DV14_PRO, inside_property = "Metal_W" );
DM14_REGION_DV14_LESHRINK = edge_size( DM14_LEEDGE_DV14, inside = LINEEND_M14V14 ); 
DM14_REGION_DV14 = DM14_REGION_DV14_RE not DM14_REGION_DV14_LESHRINK; 

REGION_DV14_PRE = DM15_REGION_DV14 and not_interacting( DM14_REGION_DV14, CONNECTDM14 ); 
REGION_DV14 =  copy(REGION_DV14_PRE);
// DUMMY SPEC : DV14
//***** spec *******************************************************************
PATTERN_SPEC_DV14 = get_single_polygon_pattern(
    "DV14", "OUTPUT_DV14", DVYY_W, DVYY_W,
	step_x = DVYY_S, step_y = DVYY_S,
	setback = DVYY_S, setback_type = INTERSECTION,
	FSS = {
    { CHIP_snps, min_space = DMYY_CHIP, context = INTERIOR },
    { BEOLBLK_FINAL, min_space = DM_BEOLBLK },
    { INDDMY, min_space = DM_INDDMY },

    { DV14EXCL, min_space = DV_DVXEXCL },
    { TCDDMY_V14, min_space = DV_TCDDMY_VX },
    { VIA14I, min_space = DVYY_VYY },
    { DVIA14, min_space = DVYY_DVYY },
#ifdef ANTPrevention
    { FORBIDDEN_RING, min_space = 0 },
#endif

    { DVIA14_O, min_space = 0.180 },
    } );



PATTERN_SPEC_DV14.polygon_fill.fill_to_signal_spacing.push_back( { VIA14FORBIDDENRING, min_space = 0 } );
PATTERN_SPEC_DV14.polygon_fill.fill_to_signal_spacing.push_back( { REGION_DV14, min_space = 0, context = INTERIOR } );

SPEC_DV14 : layer_groups_h;
PATTERN_SPEC_DV14.polygon_fill.color = true;
SPEC_DV14 = unified_fill(
    fill_boundary = {
        layer = CHIP_snps,
        type = LAYER
    },
    boundary = ALIGN,
    grid = vGRID,
    fill_patterns = { PATTERN_SPEC_DV14 }
);
//============================================================================


DV14_C   = SPEC_DV14["OUTPUT_DV14"][0];
gDV14_E   = SPEC_DV14["OUTPUT_DV14"][0];


CONNECTDM15 = empty_layer();

#else
CONNECTDM15 = empty_layer();
REGION_DV14_4_BLOCK = empty_layer();
gDV14_E   = empty_layer();
#endif
//============================================================================










#pragma PXL encrypted begin
:PP=>43V*"9K!R:)VCM<9.@'NH<Y_,YU75RZ6D^%^P<0# U:BKR=P\!PN5B*F@HWK$L%",>:
\JBR\Q3G;1;R0?&=5?;G_'=!R/6Y;X0DX$;(\"S%.PM/YK[P
#pragma PXL encrypted end

DVIAYY_O_MYY_E0 : const double = 0.045;
DVIAYY_O_MYY_E1 : const double = 0.027;
DVIAYY_O_MYY_E2 : const double = 0.009;
DVIAYY_N_MYY_E1 : const double = 0.031;
DVIAYY_N_MYY_E2 : const double = 0.112;
DVIAYY_N_MYY_E3 : const double = DVIAYY_N_MYY_E2-DVIAYY_N_MYY_E1;
DVIAYY_O_MY_E1 : const double = 0.02;
DVIAYY_O_MY_E2 : const double = 0.026;
DVIAYY_O_MY_E3 : const double = DVIAYY_O_MY_E2-DVIAYY_O_MY_E1;	
DVIAYY_N_MY_E1 : const double = 0.022;
DVIAYY_N_MY_E2 : const double = 0.031;
DVIAYY_N_MY_E3 : const double = DVIAYY_N_MY_E2-DVIAYY_N_MY_E1;	










#ifdef FILL_DmyVIA6
#ifdef FILL_DM6 
   OPC_M6_D = CHIP_snps and or_list( { WRAPPER_DM6_O_L, DM6_O_L, DM6_O } ); 
   NON_OPC_M6_D = CHIP_snps and ( DM6 or DM6_L ); 
#else
   OPC_M6_D = CHIP_snps and DM6_O; 
   NON_OPC_M6_D = CHIP_snps and DM6; 
#endif
#ifdef FILL_DM7
   OPC_M7_U = CHIP_snps and or_list( { WRAPPER_DM7_O_L, DM7_O_L, DM7_O } ); 
   NON_OPC_M7_U = CHIP_snps and ( DM7 or DM7_L ); 
#else
   OPC_M7_U = CHIP_snps and DM7_O; 
   NON_OPC_M7_U = CHIP_snps and DM7; 
#endif

VIA6W_O : const double = 0.038;	
LINEEND_O_58_M7V6 : const double = 0.065;	
LINEEND_O_114_M7V6 : const double = 0.065;	
LINEEND_N_M7V6 : const double = 0.116;
OPC_M7_U_58 = wide( OPC_M7_U, < 0.114, angled = TRUNCATE ); 
OPC_M7_U_114 = wide( OPC_M7_U, >= 0.114, angled = TRUNCATE ); 
OPC_M6_D_58 = wide( OPC_M6_D, < 0.114, angled = TRUNCATE ); 
OPC_M6_D_114 = wide( OPC_M6_D, >= 0.114, angled = TRUNCATE ); 
#ifdef VERTICAL_M7 
   DM7_O_58_LEEDGE_DV6_O = angle_edge( wide( OPC_M7_U, < 0.114, angled = TRUNCATE ), == 0 ); 
   DM7_O_114_LEEDGE_DV6_O = angle_edge( wide( OPC_M7_U, >= 0.114, angled = TRUNCATE ), == 0 ); 
   DM7_NON_LEEDGE_DV6_O = angle_edge( NON_OPC_M7_U, == 0 ); 
#else
   DM7_O_58_LEEDGE_DV6_O = angle_edge( wide( OPC_M7_U, < 0.114, angled = TRUNCATE ), == 90 ); 
   DM7_O_114_LEEDGE_DV6_O = angle_edge( wide( OPC_M7_U, >= 0.114, angled = TRUNCATE ), == 90 ); 
   DM7_NON_LEEDGE_DV6_O = angle_edge( NON_OPC_M7_U, == 90 ); 
#endif

CENTER_BAR_VALUE = VIA6W_O;
DM7_O_58_REGION_DV6_O_PRO = drc_features( primary_layer = OPC_M7_U_58, secondary_layers = { "layer2" => DM7_O_58_LEEDGE_DV6_O }, output_from_layer = OPC_M7_U_58, include_touch = EDGE, drc_function = dfm_property_func_DV, combine_errors = OPPOSING ); 
DM7_O_58_REGION_DV6_O_RE = DM7_O_58_REGION_DV6_O_PRO not edge_size_by_property( DM7_O_58_REGION_DV6_O_PRO, inside_property = "Metal_W" );
DM7_O_58_REGION_DV6_O_LESHRINK = edge_size( DM7_O_58_LEEDGE_DV6_O, inside = LINEEND_O_58_M7V6 ); 
DM7_O_58_REGION_DV6_O = DM7_O_58_REGION_DV6_O_RE not DM7_O_58_REGION_DV6_O_LESHRINK; 
DM7_O_114_REGION_DV6_O_PRO = drc_features( primary_layer = OPC_M7_U_114, secondary_layers = { "layer2" => DM7_O_114_LEEDGE_DV6_O }, output_from_layer = OPC_M7_U_114, include_touch = EDGE, drc_function = dfm_property_func_DV, combine_errors = OPPOSING ); 
DM7_O_114_REGION_DV6_O_RE = DM7_O_114_REGION_DV6_O_PRO not edge_size_by_property( DM7_O_114_REGION_DV6_O_PRO, inside_property = "Metal_W" );
DM7_O_114_REGION_DV6_O_LESHRINK = edge_size( DM7_O_114_LEEDGE_DV6_O, inside = LINEEND_O_114_M7V6 ); 
DM7_O_114_REGION_DV6_O = DM7_O_114_REGION_DV6_O_RE not DM7_O_114_REGION_DV6_O_LESHRINK; 
DM7_NON_REGION_DV6_O_PRO = drc_features( primary_layer = NON_OPC_M7_U, secondary_layers = { "layer2" => DM7_NON_LEEDGE_DV6_O }, output_from_layer = NON_OPC_M7_U, include_touch = EDGE, drc_function = dfm_property_func_DV, combine_errors = OPPOSING ); 
DM7_NON_REGION_DV6_O_RE = DM7_NON_REGION_DV6_O_PRO not edge_size_by_property( DM7_NON_REGION_DV6_O_PRO, inside_property = "Metal_W" );
DM7_NON_REGION_DV6_O_LESHRINK = edge_size( DM7_NON_LEEDGE_DV6_O, inside = LINEEND_N_M7V6 ); 
DM7_NON_REGION_DV6_O = DM7_NON_REGION_DV6_O_RE not DM7_NON_REGION_DV6_O_LESHRINK; 


DM7_UP_R = or_list( { DM7_O_58_REGION_DV6_O, DM7_O_114_REGION_DV6_O, DM7_NON_REGION_DV6_O } ); 


#ifdef VERTICAL_M6 
   DM6_O_58_LEEDGE_DV6_O = angle_edge( wide( OPC_M6_D, < 0.114, angled = TRUNCATE ), == 0 ); 
   DM6_O_114_LEEDGE_DV6_O = angle_edge( wide( OPC_M6_D, >= 0.114, angled = TRUNCATE ), == 0 ); 
   DM6_NON_LEEDGE_DV6_O = angle_edge( NON_OPC_M6_D, == 0 ); 
#else
   DM6_O_58_LEEDGE_DV6_O = angle_edge( wide( OPC_M6_D, < 0.114, angled = TRUNCATE ), == 90 ); 
   DM6_O_114_LEEDGE_DV6_O = angle_edge( wide( OPC_M6_D, >= 0.114, angled = TRUNCATE ), == 90 ); 
   DM6_NON_LEEDGE_DV6_O = angle_edge( NON_OPC_M6_D, == 90 ); 
#endif

CENTER_BAR_VALUE = VIA6W_O;
DM6_O_58_REGION_DV6_O_PRO = drc_features( primary_layer = OPC_M6_D_58, secondary_layers = { "layer2" => DM6_O_58_LEEDGE_DV6_O }, output_from_layer = OPC_M6_D_58, include_touch = EDGE, drc_function = dfm_property_func_DV, combine_errors = OPPOSING ); 
DM6_O_58_REGION_DV6_O_RE = DM6_O_58_REGION_DV6_O_PRO not edge_size_by_property( DM6_O_58_REGION_DV6_O_PRO, inside_property = "Metal_W" );
DM6_O_58_REGION_DV6_O_LESHRINK = edge_size( DM6_O_58_LEEDGE_DV6_O, inside = LINEEND_O_58_M7V6 ); 
DM6_O_58_REGION_DV6_O = DM6_O_58_REGION_DV6_O_RE not DM6_O_58_REGION_DV6_O_LESHRINK; 
DM6_O_114_REGION_DV6_O_PRO = drc_features( primary_layer = OPC_M6_D_114, secondary_layers = { "layer2" => DM6_O_114_LEEDGE_DV6_O }, output_from_layer = OPC_M6_D_114, include_touch = EDGE, drc_function = dfm_property_func_DV, combine_errors = OPPOSING ); 
DM6_O_114_REGION_DV6_O_RE = DM6_O_114_REGION_DV6_O_PRO not edge_size_by_property( DM6_O_114_REGION_DV6_O_PRO, inside_property = "Metal_W" );
DM6_O_114_REGION_DV6_O_LESHRINK = edge_size( DM6_O_114_LEEDGE_DV6_O, inside = LINEEND_O_114_M7V6 ); 
DM6_O_114_REGION_DV6_O = DM6_O_114_REGION_DV6_O_RE not DM6_O_114_REGION_DV6_O_LESHRINK; 
DM6_NON_REGION_DV6_O_PRO = drc_features( primary_layer = NON_OPC_M6_D, secondary_layers = { "layer2" => DM6_NON_LEEDGE_DV6_O }, output_from_layer = NON_OPC_M6_D, include_touch = EDGE, drc_function = dfm_property_func_DV, combine_errors = OPPOSING ); 
DM6_NON_REGION_DV6_O_RE = DM6_NON_REGION_DV6_O_PRO not edge_size_by_property( DM6_NON_REGION_DV6_O_PRO, inside_property = "Metal_W" );
DM6_NON_REGION_DV6_O_LESHRINK = edge_size( DM6_NON_LEEDGE_DV6_O, inside = LINEEND_N_M7V6 ); 
DM6_NON_REGION_DV6_O = DM6_NON_REGION_DV6_O_RE not DM6_NON_REGION_DV6_O_LESHRINK; 


DM6_DOWN_R = or_list( { DM6_O_58_REGION_DV6_O, DM6_O_114_REGION_DV6_O, DM6_NON_REGION_DV6_O } ); 
REGION_DV6_O = DM7_UP_R and DM6_DOWN_R; 


//***** spec *******************************************************************
// DUMMY SPEC : DV6_O
PATTERN_SPEC_DV6_O = get_single_polygon_pattern(
    "DV6OQ" , "OUTPUT_DV6_O", DVYB_O_W, DVYB_O_W,
    step_x = DVYB_O_S, step_y = DVYB_O_S,
    setback = DVYB_O_S, setback_type = INTERSECTION,
	FSS = {
#ifdef ANTPrevention
               { FORBIDDEN_RING, min_space = 0 },
#endif            
               { REGION_DV6_O, min_space = 0, context = INTERIOR },
    { CHIP_snps, min_space = DMY1_CHIP, context = INTERIOR },
    { BEOLBLK_FINAL, min_space = DM_BEOLBLK },
    { INDDMY, min_space = DM_INDDMY },

    { DV6EXCL, min_space = DV_DVXEXCL },
    { TCDDMY_V6, min_space = DV_TCDDMY_VX },
    { VIA6I, min_space = 0.150 },
    { DVIA6, min_space = 0.300 },
    { DVIA6_O, min_space = 0.096 },
    { VIA6_40, min_space = 0.3 },
    { RH_TNB, min_space = DVY_RHTNB },
#ifdef FILL_M6_VIA6_M7_BTCD
    { BTCD_M6_V6_M7_E, min_space = DV_TCDDMY_VX },
#endif
#ifdef FILL_DmyVIA6
               { gDV6_E, min_space = 0.3 },
#endif
    } );

SPEC_DV6_O = unified_fill(
    fill_boundary = {
        layer = CHIP_snps,
        type = LAYER
    },
    grid = vGRID,
    fill_patterns = { PATTERN_SPEC_DV6_O }
);
//***** fill *******************************************************************
OPC_VIA6   = SPEC_DV6_O["OUTPUT_DV6_O"][0];


//============================================================================
#endif


#ifdef FILL_DmyVIA7
#ifdef FILL_DM7 
   OPC_M7_D = CHIP_snps and or_list( { WRAPPER_DM7_O_L, DM7_O_L, DM7_O } ); 
   NON_OPC_M7_D = CHIP_snps and ( DM7 or DM7_L ); 
#else
   OPC_M7_D = CHIP_snps and DM7_O; 
   NON_OPC_M7_D = CHIP_snps and DM7; 
#endif
#ifdef FILL_DM8
   OPC_M8_U = CHIP_snps and or_list( { WRAPPER_DM8_O_L, DM8_O_L, DM8_O } ); 
   NON_OPC_M8_U = CHIP_snps and ( DM8 or DM8_L ); 
#else
   OPC_M8_U = CHIP_snps and DM8_O; 
   NON_OPC_M8_U = CHIP_snps and DM8; 
#endif


VIA7W_O : const double = 0.038;	
LINEEND_O_58_M8V7 : const double = 0.065;	
LINEEND_O_114_M8V7 : const double = 0.065;	
LINEEND_N_M8V7 : const double = 0.116;	

OPC_M8_U_58 = wide( OPC_M8_U, < 0.114, angled = TRUNCATE ); 
OPC_M8_U_114 = wide( OPC_M8_U, >= 0.114, angled = TRUNCATE ); 
OPC_M7_D_58 = wide( OPC_M7_D, < 0.114, angled = TRUNCATE ); 
OPC_M7_D_114 = wide( OPC_M7_D, >= 0.114, angled = TRUNCATE ); 
#ifdef VERTICAL_M8 
   DM8_O_58_LEEDGE_DV7_O = angle_edge( wide( OPC_M8_U, < 0.114, angled = TRUNCATE ), == 0 ); 
   DM8_O_114_LEEDGE_DV7_O = angle_edge( wide( OPC_M8_U, >= 0.114, angled = TRUNCATE ), == 0 ); 
   DM8_NON_LEEDGE_DV7_O = angle_edge( NON_OPC_M8_U, == 0 ); 
#else
   DM8_O_58_LEEDGE_DV7_O = angle_edge( wide( OPC_M8_U, < 0.114, angled = TRUNCATE ), == 90 ); 
   DM8_O_114_LEEDGE_DV7_O = angle_edge( wide( OPC_M8_U, >= 0.114, angled = TRUNCATE ), == 90 ); 
   DM8_NON_LEEDGE_DV7_O = angle_edge( NON_OPC_M8_U, == 90 ); 
#endif

CENTER_BAR_VALUE = VIA7W_O;
DM8_O_58_REGION_DV7_O_PRO = drc_features( primary_layer = OPC_M8_U_58, secondary_layers = { "layer2" => DM8_O_58_LEEDGE_DV7_O }, output_from_layer = OPC_M8_U_58, include_touch = EDGE, drc_function = dfm_property_func_DV, combine_errors = OPPOSING ); 
DM8_O_58_REGION_DV7_O_RE = DM8_O_58_REGION_DV7_O_PRO not edge_size_by_property( DM8_O_58_REGION_DV7_O_PRO, inside_property = "Metal_W" );
DM8_O_58_REGION_DV7_O_LESHRINK = edge_size( DM8_O_58_LEEDGE_DV7_O, inside = LINEEND_O_58_M8V7 ); 
DM8_O_58_REGION_DV7_O = DM8_O_58_REGION_DV7_O_RE not DM8_O_58_REGION_DV7_O_LESHRINK; 
DM8_O_114_REGION_DV7_O_PRO = drc_features( primary_layer = OPC_M8_U_114, secondary_layers = { "layer2" => DM8_O_114_LEEDGE_DV7_O }, output_from_layer = OPC_M8_U_114, include_touch = EDGE, drc_function = dfm_property_func_DV, combine_errors = OPPOSING ); 
DM8_O_114_REGION_DV7_O_RE = DM8_O_114_REGION_DV7_O_PRO not edge_size_by_property( DM8_O_114_REGION_DV7_O_PRO, inside_property = "Metal_W" );
DM8_O_114_REGION_DV7_O_LESHRINK = edge_size( DM8_O_114_LEEDGE_DV7_O, inside = LINEEND_O_114_M8V7 ); 
DM8_O_114_REGION_DV7_O = DM8_O_114_REGION_DV7_O_RE not DM8_O_114_REGION_DV7_O_LESHRINK; 
DM8_NON_REGION_DV7_O_PRO = drc_features( primary_layer = NON_OPC_M8_U, secondary_layers = { "layer2" => DM8_NON_LEEDGE_DV7_O }, output_from_layer = NON_OPC_M8_U, include_touch = EDGE, drc_function = dfm_property_func_DV, combine_errors = OPPOSING ); 
DM8_NON_REGION_DV7_O_RE = DM8_NON_REGION_DV7_O_PRO not edge_size_by_property( DM8_NON_REGION_DV7_O_PRO, inside_property = "Metal_W" );
DM8_NON_REGION_DV7_O_LESHRINK = edge_size( DM8_NON_LEEDGE_DV7_O, inside = LINEEND_N_M8V7 ); 
DM8_NON_REGION_DV7_O = DM8_NON_REGION_DV7_O_RE not DM8_NON_REGION_DV7_O_LESHRINK; 

DM8_UP_R = or_list( { DM8_O_58_REGION_DV7_O, DM8_O_114_REGION_DV7_O, DM8_NON_REGION_DV7_O } ); 

#ifdef VERTICAL_M7 
   DM7_O_58_LEEDGE_DV7_O = angle_edge( wide( OPC_M7_D, < 0.114, angled = TRUNCATE ), == 0 ); 
   DM7_O_114_LEEDGE_DV7_O = angle_edge( wide( OPC_M7_D, >= 0.114, angled = TRUNCATE ), == 0 ); 
   DM7_NON_LEEDGE_DV7_O = angle_edge( NON_OPC_M7_D, == 0 ); 
#else
   DM7_O_58_LEEDGE_DV7_O = angle_edge( wide( OPC_M7_D, < 0.114, angled = TRUNCATE ), == 90 ); 
   DM7_O_114_LEEDGE_DV7_O = angle_edge( wide( OPC_M7_D, >= 0.114, angled = TRUNCATE ), == 90 ); 
   DM7_NON_LEEDGE_DV7_O = angle_edge( NON_OPC_M7_D, == 90 ); 
#endif

CENTER_BAR_VALUE = VIA7W_O;
DM7_O_58_REGION_DV7_O_PRO = drc_features( primary_layer = OPC_M7_D_58, secondary_layers = { "layer2" => DM7_O_58_LEEDGE_DV7_O }, output_from_layer = OPC_M7_D_58, include_touch = EDGE, drc_function = dfm_property_func_DV, combine_errors = OPPOSING ); 
DM7_O_58_REGION_DV7_O_RE = DM7_O_58_REGION_DV7_O_PRO not edge_size_by_property( DM7_O_58_REGION_DV7_O_PRO, inside_property = "Metal_W" );
DM7_O_58_REGION_DV7_O_LESHRINK = edge_size( DM7_O_58_LEEDGE_DV7_O, inside = LINEEND_O_58_M8V7 ); 
DM7_O_58_REGION_DV7_O = DM7_O_58_REGION_DV7_O_RE not DM7_O_58_REGION_DV7_O_LESHRINK; 
DM7_O_114_REGION_DV7_O_PRO = drc_features( primary_layer = OPC_M7_D_114, secondary_layers = { "layer2" => DM7_O_114_LEEDGE_DV7_O }, output_from_layer = OPC_M7_D_114, include_touch = EDGE, drc_function = dfm_property_func_DV, combine_errors = OPPOSING ); 
DM7_O_114_REGION_DV7_O_RE = DM7_O_114_REGION_DV7_O_PRO not edge_size_by_property( DM7_O_114_REGION_DV7_O_PRO, inside_property = "Metal_W" );
DM7_O_114_REGION_DV7_O_LESHRINK = edge_size( DM7_O_114_LEEDGE_DV7_O, inside = LINEEND_O_114_M8V7 ); 
DM7_O_114_REGION_DV7_O = DM7_O_114_REGION_DV7_O_RE not DM7_O_114_REGION_DV7_O_LESHRINK; 
DM7_NON_REGION_DV7_O_PRO = drc_features( primary_layer = NON_OPC_M7_D, secondary_layers = { "layer2" => DM7_NON_LEEDGE_DV7_O }, output_from_layer = NON_OPC_M7_D, include_touch = EDGE, drc_function = dfm_property_func_DV, combine_errors = OPPOSING ); 
DM7_NON_REGION_DV7_O_RE = DM7_NON_REGION_DV7_O_PRO not edge_size_by_property( DM7_NON_REGION_DV7_O_PRO, inside_property = "Metal_W" );
DM7_NON_REGION_DV7_O_LESHRINK = edge_size( DM7_NON_LEEDGE_DV7_O, inside = LINEEND_N_M8V7 ); 
DM7_NON_REGION_DV7_O = DM7_NON_REGION_DV7_O_RE not DM7_NON_REGION_DV7_O_LESHRINK; 

DM7_DOWN_R = or_list( { DM7_O_58_REGION_DV7_O, DM7_O_114_REGION_DV7_O, DM7_NON_REGION_DV7_O } ); 

REGION_DV7_O = DM8_UP_R and DM7_DOWN_R; 




//***** spec *******************************************************************
// DUMMY SPEC : DV7_O
PATTERN_SPEC_DV7_O = get_single_polygon_pattern(
    "DV7OQ" , "OUTPUT_DV7_O", DVY_O_W, DVY_O_W,
    step_x = DVY_O_S, step_y = DVY_O_S,
    setback = DVY_O_S, setback_type = INTERSECTION,
	FSS = {
#ifdef ANTPrevention
               { FORBIDDEN_RING, min_space = 0 },
#endif            
               { REGION_DV7_O, min_space = 0, context = INTERIOR },
    { CHIP_snps, min_space = DMY1_CHIP, context = INTERIOR },
    { BEOLBLK_FINAL, min_space = DM_BEOLBLK },
    { INDDMY, min_space = DM_INDDMY },

    { DV7EXCL, min_space = DV_DVXEXCL },
    { TCDDMY_V7, min_space = DV_TCDDMY_VX },
    { VIA7I, min_space = 0.150 },
    { DVIA7, min_space = 0.300 },
    { DVIA7_O, min_space = 0.096 },
    { VIA7_40, min_space = 0.3 },
#ifdef FILL_M7_VIA7_M8_BTCD
    { BTCD_M7_V7_M8_E, min_space = DV_TCDDMY_VX },
#endif
#ifdef FILL_DmyVIA7
               { gDV7_E, min_space = 0.3 },
#endif
    } );

SPEC_DV7_O = unified_fill(
    fill_boundary = {
        layer = CHIP_snps,
        type = LAYER
    },
    grid = vGRID,
    fill_patterns = { PATTERN_SPEC_DV7_O }
);
//***** fill *******************************************************************
OPC_VIA7   = SPEC_DV7_O["OUTPUT_DV7_O"][0];
#endif

//============================================================================


#ifdef FILL_DmyVIA8
#ifdef FILL_DM8 
   OPC_M8_D = CHIP_snps and or_list( { WRAPPER_DM8_O_L, DM8_O_L, DM8_O } ); 
   NON_OPC_M8_D = CHIP_snps and ( DM8 or DM8_L ); 
#else
   OPC_M8_D = CHIP_snps and DM8_O; 
   NON_OPC_M8_D = CHIP_snps and DM8; 
#endif
#ifdef FILL_DM9
   OPC_M9_U = CHIP_snps and or_list( { WRAPPER_DM9_O_L, DM9_O_L, DM9_O } ); 
   NON_OPC_M9_U = CHIP_snps and ( DM9 or DM9_L ); 
#else
   OPC_M9_U = CHIP_snps and DM9_O; 
   NON_OPC_M9_U = CHIP_snps and DM9; 
#endif


VIA8W_O : const double = 0.038;	
LINEEND_O_58_M9V8 : const double = 0.065;	
LINEEND_O_114_M9V8 : const double = 0.065;	
LINEEND_N_M9V8 : const double = 0.116;	

OPC_M9_U_58 = wide( OPC_M9_U, < 0.114, angled = TRUNCATE ); 
OPC_M9_U_114 = wide( OPC_M9_U, >= 0.114, angled = TRUNCATE ); 
OPC_M8_D_58 = wide( OPC_M8_D, < 0.114, angled = TRUNCATE ); 
OPC_M8_D_114 = wide( OPC_M8_D, >= 0.114, angled = TRUNCATE ); 
#ifdef VERTICAL_M9 
   DM9_O_58_LEEDGE_DV8_O = angle_edge( wide( OPC_M9_U, < 0.114, angled = TRUNCATE ), == 0 ); 
   DM9_O_114_LEEDGE_DV8_O = angle_edge( wide( OPC_M9_U, >= 0.114, angled = TRUNCATE ), == 0 ); 
   DM9_NON_LEEDGE_DV8_O = angle_edge( NON_OPC_M9_U, == 0 ); 
#else
   DM9_O_58_LEEDGE_DV8_O = angle_edge( wide( OPC_M9_U, < 0.114, angled = TRUNCATE ), == 90 ); 
   DM9_O_114_LEEDGE_DV8_O = angle_edge( wide( OPC_M9_U, >= 0.114, angled = TRUNCATE ), == 90 ); 
   DM9_NON_LEEDGE_DV8_O = angle_edge( NON_OPC_M9_U, == 90 ); 
#endif

CENTER_BAR_VALUE = VIA8W_O;
DM9_O_58_REGION_DV8_O_PRO = drc_features( primary_layer = OPC_M9_U_58, secondary_layers = { "layer2" => DM9_O_58_LEEDGE_DV8_O }, output_from_layer = OPC_M9_U_58, include_touch = EDGE, drc_function = dfm_property_func_DV, combine_errors = OPPOSING ); 
DM9_O_58_REGION_DV8_O_RE = DM9_O_58_REGION_DV8_O_PRO not edge_size_by_property( DM9_O_58_REGION_DV8_O_PRO, inside_property = "Metal_W" );
DM9_O_58_REGION_DV8_O_LESHRINK = edge_size( DM9_O_58_LEEDGE_DV8_O, inside = LINEEND_O_58_M9V8 ); 
DM9_O_58_REGION_DV8_O = DM9_O_58_REGION_DV8_O_RE not DM9_O_58_REGION_DV8_O_LESHRINK; 
DM9_O_114_REGION_DV8_O_PRO = drc_features( primary_layer = OPC_M9_U_114, secondary_layers = { "layer2" => DM9_O_114_LEEDGE_DV8_O }, output_from_layer = OPC_M9_U_114, include_touch = EDGE, drc_function = dfm_property_func_DV, combine_errors = OPPOSING ); 
DM9_O_114_REGION_DV8_O_RE = DM9_O_114_REGION_DV8_O_PRO not edge_size_by_property( DM9_O_114_REGION_DV8_O_PRO, inside_property = "Metal_W" );
DM9_O_114_REGION_DV8_O_LESHRINK = edge_size( DM9_O_114_LEEDGE_DV8_O, inside = LINEEND_O_114_M9V8 ); 
DM9_O_114_REGION_DV8_O = DM9_O_114_REGION_DV8_O_RE not DM9_O_114_REGION_DV8_O_LESHRINK; 
DM9_NON_REGION_DV8_O_PRO = drc_features( primary_layer = NON_OPC_M9_U, secondary_layers = { "layer2" => DM9_NON_LEEDGE_DV8_O }, output_from_layer = NON_OPC_M9_U, include_touch = EDGE, drc_function = dfm_property_func_DV, combine_errors = OPPOSING ); 
DM9_NON_REGION_DV8_O_RE = DM9_NON_REGION_DV8_O_PRO not edge_size_by_property( DM9_NON_REGION_DV8_O_PRO, inside_property = "Metal_W" );
DM9_NON_REGION_DV8_O_LESHRINK = edge_size( DM9_NON_LEEDGE_DV8_O, inside = LINEEND_N_M9V8 ); 
DM9_NON_REGION_DV8_O = DM9_NON_REGION_DV8_O_RE not DM9_NON_REGION_DV8_O_LESHRINK; 

DM9_UP_R = or_list( { DM9_O_58_REGION_DV8_O, DM9_O_114_REGION_DV8_O, DM9_NON_REGION_DV8_O } ); 

#ifdef VERTICAL_M8 
   DM8_O_58_LEEDGE_DV8_O = angle_edge( wide( OPC_M8_D, < 0.114, angled = TRUNCATE ), == 0 ); 
   DM8_O_114_LEEDGE_DV8_O = angle_edge( wide( OPC_M8_D, >= 0.114, angled = TRUNCATE ), == 0 ); 
   DM8_NON_LEEDGE_DV8_O = angle_edge( NON_OPC_M8_D, == 0 ); 
#else
   DM8_O_58_LEEDGE_DV8_O = angle_edge( wide( OPC_M8_D, < 0.114, angled = TRUNCATE ), == 90 ); 
   DM8_O_114_LEEDGE_DV8_O = angle_edge( wide( OPC_M8_D, >= 0.114, angled = TRUNCATE ), == 90 ); 
   DM8_NON_LEEDGE_DV8_O = angle_edge( NON_OPC_M8_D, == 90 ); 
#endif

CENTER_BAR_VALUE = VIA8W_O;
DM8_O_58_REGION_DV8_O_PRO = drc_features( primary_layer = OPC_M8_D_58, secondary_layers = { "layer2" => DM8_O_58_LEEDGE_DV8_O }, output_from_layer = OPC_M8_D_58, include_touch = EDGE, drc_function = dfm_property_func_DV, combine_errors = OPPOSING ); 
DM8_O_58_REGION_DV8_O_RE = DM8_O_58_REGION_DV8_O_PRO not edge_size_by_property( DM8_O_58_REGION_DV8_O_PRO, inside_property = "Metal_W" );
DM8_O_58_REGION_DV8_O_LESHRINK = edge_size( DM8_O_58_LEEDGE_DV8_O, inside = LINEEND_O_58_M9V8 ); 
DM8_O_58_REGION_DV8_O = DM8_O_58_REGION_DV8_O_RE not DM8_O_58_REGION_DV8_O_LESHRINK; 
DM8_O_114_REGION_DV8_O_PRO = drc_features( primary_layer = OPC_M8_D_114, secondary_layers = { "layer2" => DM8_O_114_LEEDGE_DV8_O }, output_from_layer = OPC_M8_D_114, include_touch = EDGE, drc_function = dfm_property_func_DV, combine_errors = OPPOSING ); 
DM8_O_114_REGION_DV8_O_RE = DM8_O_114_REGION_DV8_O_PRO not edge_size_by_property( DM8_O_114_REGION_DV8_O_PRO, inside_property = "Metal_W" );
DM8_O_114_REGION_DV8_O_LESHRINK = edge_size( DM8_O_114_LEEDGE_DV8_O, inside = LINEEND_O_114_M9V8 ); 
DM8_O_114_REGION_DV8_O = DM8_O_114_REGION_DV8_O_RE not DM8_O_114_REGION_DV8_O_LESHRINK; 
DM8_NON_REGION_DV8_O_PRO = drc_features( primary_layer = NON_OPC_M8_D, secondary_layers = { "layer2" => DM8_NON_LEEDGE_DV8_O }, output_from_layer = NON_OPC_M8_D, include_touch = EDGE, drc_function = dfm_property_func_DV, combine_errors = OPPOSING ); 
DM8_NON_REGION_DV8_O_RE = DM8_NON_REGION_DV8_O_PRO not edge_size_by_property( DM8_NON_REGION_DV8_O_PRO, inside_property = "Metal_W" );
DM8_NON_REGION_DV8_O_LESHRINK = edge_size( DM8_NON_LEEDGE_DV8_O, inside = LINEEND_N_M9V8 ); 
DM8_NON_REGION_DV8_O = DM8_NON_REGION_DV8_O_RE not DM8_NON_REGION_DV8_O_LESHRINK; 

DM8_DOWN_R = or_list( { DM8_O_58_REGION_DV8_O, DM8_O_114_REGION_DV8_O, DM8_NON_REGION_DV8_O } ); 

REGION_DV8_O = DM9_UP_R and DM8_DOWN_R; 




//***** spec *******************************************************************
// DUMMY SPEC : DV8_O
PATTERN_SPEC_DV8_O = get_single_polygon_pattern(
    "DV8OQ" , "OUTPUT_DV8_O", DVY_O_W, DVY_O_W,
    step_x = DVY_O_S, step_y = DVY_O_S,
    setback = DVY_O_S, setback_type = INTERSECTION,
	FSS = {
#ifdef ANTPrevention
               { FORBIDDEN_RING, min_space = 0 },
#endif            
               { REGION_DV8_O, min_space = 0, context = INTERIOR },
    { CHIP_snps, min_space = DMY1_CHIP, context = INTERIOR },
    { BEOLBLK_FINAL, min_space = DM_BEOLBLK },
    { INDDMY, min_space = DM_INDDMY },

    { DV8EXCL, min_space = DV_DVXEXCL },
    { TCDDMY_V8, min_space = DV_TCDDMY_VX },
    { VIA8I, min_space = 0.150 },
    { DVIA8, min_space = 0.300 },
    { DVIA8_O, min_space = 0.096 },
    { VIA8_40, min_space = 0.3 },
#ifdef FILL_M8_VIA8_M9_BTCD
    { BTCD_M8_V8_M9_E, min_space = DV_TCDDMY_VX },
#endif
#ifdef FILL_DmyVIA8
               { gDV8_E, min_space = 0.3 },
#endif
    } );

SPEC_DV8_O = unified_fill(
    fill_boundary = {
        layer = CHIP_snps,
        type = LAYER
    },
    grid = vGRID,
    fill_patterns = { PATTERN_SPEC_DV8_O }
);
//***** fill *******************************************************************
OPC_VIA8   = SPEC_DV8_O["OUTPUT_DV8_O"][0];
#endif

//============================================================================


#ifdef FILL_DmyVIA9
#ifdef FILL_DM9 
   OPC_M9_D = CHIP_snps and or_list( { WRAPPER_DM9_O_L, DM9_O_L, DM9_O } ); 
   NON_OPC_M9_D = CHIP_snps and ( DM9 or DM9_L ); 
#else
   OPC_M9_D = CHIP_snps and DM9_O; 
   NON_OPC_M9_D = CHIP_snps and DM9; 
#endif
#ifdef FILL_DM10
   OPC_M10_U = CHIP_snps and or_list( { WRAPPER_DM10_O_L, DM10_O_L, DM10_O } ); 
   NON_OPC_M10_U = CHIP_snps and ( DM10 or DM10_L ); 
#else
   OPC_M10_U = CHIP_snps and DM10_O; 
   NON_OPC_M10_U = CHIP_snps and DM10; 
#endif


VIA9W_O : const double = 0.038;	
LINEEND_O_58_M10V9 : const double = 0.065;	
LINEEND_O_114_M10V9 : const double = 0.065;	
LINEEND_N_M10V9 : const double = 0.116;	

OPC_M10_U_58 = wide( OPC_M10_U, < 0.114, angled = TRUNCATE ); 
OPC_M10_U_114 = wide( OPC_M10_U, >= 0.114, angled = TRUNCATE ); 
OPC_M9_D_58 = wide( OPC_M9_D, < 0.114, angled = TRUNCATE ); 
OPC_M9_D_114 = wide( OPC_M9_D, >= 0.114, angled = TRUNCATE ); 
#ifdef VERTICAL_M10 
   DM10_O_58_LEEDGE_DV9_O = angle_edge( wide( OPC_M10_U, < 0.114, angled = TRUNCATE ), == 0 ); 
   DM10_O_114_LEEDGE_DV9_O = angle_edge( wide( OPC_M10_U, >= 0.114, angled = TRUNCATE ), == 0 ); 
   DM10_NON_LEEDGE_DV9_O = angle_edge( NON_OPC_M10_U, == 0 ); 
#else
   DM10_O_58_LEEDGE_DV9_O = angle_edge( wide( OPC_M10_U, < 0.114, angled = TRUNCATE ), == 90 ); 
   DM10_O_114_LEEDGE_DV9_O = angle_edge( wide( OPC_M10_U, >= 0.114, angled = TRUNCATE ), == 90 ); 
   DM10_NON_LEEDGE_DV9_O = angle_edge( NON_OPC_M10_U, == 90 ); 
#endif

CENTER_BAR_VALUE = VIA9W_O;
DM10_O_58_REGION_DV9_O_PRO = drc_features( primary_layer = OPC_M10_U_58, secondary_layers = { "layer2" => DM10_O_58_LEEDGE_DV9_O }, output_from_layer = OPC_M10_U_58, include_touch = EDGE, drc_function = dfm_property_func_DV, combine_errors = OPPOSING ); 
DM10_O_58_REGION_DV9_O_RE = DM10_O_58_REGION_DV9_O_PRO not edge_size_by_property( DM10_O_58_REGION_DV9_O_PRO, inside_property = "Metal_W" );
DM10_O_58_REGION_DV9_O_LESHRINK = edge_size( DM10_O_58_LEEDGE_DV9_O, inside = LINEEND_O_58_M10V9 ); 
DM10_O_58_REGION_DV9_O = DM10_O_58_REGION_DV9_O_RE not DM10_O_58_REGION_DV9_O_LESHRINK; 
DM10_O_114_REGION_DV9_O_PRO = drc_features( primary_layer = OPC_M10_U_114, secondary_layers = { "layer2" => DM10_O_114_LEEDGE_DV9_O }, output_from_layer = OPC_M10_U_114, include_touch = EDGE, drc_function = dfm_property_func_DV, combine_errors = OPPOSING ); 
DM10_O_114_REGION_DV9_O_RE = DM10_O_114_REGION_DV9_O_PRO not edge_size_by_property( DM10_O_114_REGION_DV9_O_PRO, inside_property = "Metal_W" );
DM10_O_114_REGION_DV9_O_LESHRINK = edge_size( DM10_O_114_LEEDGE_DV9_O, inside = LINEEND_O_114_M10V9 ); 
DM10_O_114_REGION_DV9_O = DM10_O_114_REGION_DV9_O_RE not DM10_O_114_REGION_DV9_O_LESHRINK; 
DM10_NON_REGION_DV9_O_PRO = drc_features( primary_layer = NON_OPC_M10_U, secondary_layers = { "layer2" => DM10_NON_LEEDGE_DV9_O }, output_from_layer = NON_OPC_M10_U, include_touch = EDGE, drc_function = dfm_property_func_DV, combine_errors = OPPOSING ); 
DM10_NON_REGION_DV9_O_RE = DM10_NON_REGION_DV9_O_PRO not edge_size_by_property( DM10_NON_REGION_DV9_O_PRO, inside_property = "Metal_W" );
DM10_NON_REGION_DV9_O_LESHRINK = edge_size( DM10_NON_LEEDGE_DV9_O, inside = LINEEND_N_M10V9 ); 
DM10_NON_REGION_DV9_O = DM10_NON_REGION_DV9_O_RE not DM10_NON_REGION_DV9_O_LESHRINK; 

DM10_UP_R = or_list( { DM10_O_58_REGION_DV9_O, DM10_O_114_REGION_DV9_O, DM10_NON_REGION_DV9_O } ); 

#ifdef VERTICAL_M9 
   DM9_O_58_LEEDGE_DV9_O = angle_edge( wide( OPC_M9_D, < 0.114, angled = TRUNCATE ), == 0 ); 
   DM9_O_114_LEEDGE_DV9_O = angle_edge( wide( OPC_M9_D, >= 0.114, angled = TRUNCATE ), == 0 ); 
   DM9_NON_LEEDGE_DV9_O = angle_edge( NON_OPC_M9_D, == 0 ); 
#else
   DM9_O_58_LEEDGE_DV9_O = angle_edge( wide( OPC_M9_D, < 0.114, angled = TRUNCATE ), == 90 ); 
   DM9_O_114_LEEDGE_DV9_O = angle_edge( wide( OPC_M9_D, >= 0.114, angled = TRUNCATE ), == 90 ); 
   DM9_NON_LEEDGE_DV9_O = angle_edge( NON_OPC_M9_D, == 90 ); 
#endif

CENTER_BAR_VALUE = VIA9W_O;
DM9_O_58_REGION_DV9_O_PRO = drc_features( primary_layer = OPC_M9_D_58, secondary_layers = { "layer2" => DM9_O_58_LEEDGE_DV9_O }, output_from_layer = OPC_M9_D_58, include_touch = EDGE, drc_function = dfm_property_func_DV, combine_errors = OPPOSING ); 
DM9_O_58_REGION_DV9_O_RE = DM9_O_58_REGION_DV9_O_PRO not edge_size_by_property( DM9_O_58_REGION_DV9_O_PRO, inside_property = "Metal_W" );
DM9_O_58_REGION_DV9_O_LESHRINK = edge_size( DM9_O_58_LEEDGE_DV9_O, inside = LINEEND_O_58_M10V9 ); 
DM9_O_58_REGION_DV9_O = DM9_O_58_REGION_DV9_O_RE not DM9_O_58_REGION_DV9_O_LESHRINK; 
DM9_O_114_REGION_DV9_O_PRO = drc_features( primary_layer = OPC_M9_D_114, secondary_layers = { "layer2" => DM9_O_114_LEEDGE_DV9_O }, output_from_layer = OPC_M9_D_114, include_touch = EDGE, drc_function = dfm_property_func_DV, combine_errors = OPPOSING ); 
DM9_O_114_REGION_DV9_O_RE = DM9_O_114_REGION_DV9_O_PRO not edge_size_by_property( DM9_O_114_REGION_DV9_O_PRO, inside_property = "Metal_W" );
DM9_O_114_REGION_DV9_O_LESHRINK = edge_size( DM9_O_114_LEEDGE_DV9_O, inside = LINEEND_O_114_M10V9 ); 
DM9_O_114_REGION_DV9_O = DM9_O_114_REGION_DV9_O_RE not DM9_O_114_REGION_DV9_O_LESHRINK; 
DM9_NON_REGION_DV9_O_PRO = drc_features( primary_layer = NON_OPC_M9_D, secondary_layers = { "layer2" => DM9_NON_LEEDGE_DV9_O }, output_from_layer = NON_OPC_M9_D, include_touch = EDGE, drc_function = dfm_property_func_DV, combine_errors = OPPOSING ); 
DM9_NON_REGION_DV9_O_RE = DM9_NON_REGION_DV9_O_PRO not edge_size_by_property( DM9_NON_REGION_DV9_O_PRO, inside_property = "Metal_W" );
DM9_NON_REGION_DV9_O_LESHRINK = edge_size( DM9_NON_LEEDGE_DV9_O, inside = LINEEND_N_M10V9 ); 
DM9_NON_REGION_DV9_O = DM9_NON_REGION_DV9_O_RE not DM9_NON_REGION_DV9_O_LESHRINK; 

DM9_DOWN_R = or_list( { DM9_O_58_REGION_DV9_O, DM9_O_114_REGION_DV9_O, DM9_NON_REGION_DV9_O } ); 

REGION_DV9_O = DM10_UP_R and DM9_DOWN_R; 




//***** spec *******************************************************************
// DUMMY SPEC : DV9_O
PATTERN_SPEC_DV9_O = get_single_polygon_pattern(
    "DV9OQ" , "OUTPUT_DV9_O", DVY_O_W, DVY_O_W,
    step_x = DVY_O_S, step_y = DVY_O_S,
    setback = DVY_O_S, setback_type = INTERSECTION,
	FSS = {
#ifdef ANTPrevention
               { FORBIDDEN_RING, min_space = 0 },
#endif            
               { REGION_DV9_O, min_space = 0, context = INTERIOR },
    { CHIP_snps, min_space = DMY1_CHIP, context = INTERIOR },
    { BEOLBLK_FINAL, min_space = DM_BEOLBLK },
    { INDDMY, min_space = DM_INDDMY },

    { DV9EXCL, min_space = DV_DVXEXCL },
    { TCDDMY_V9, min_space = DV_TCDDMY_VX },
    { VIA9I, min_space = 0.150 },
    { DVIA9, min_space = 0.300 },
    { DVIA9_O, min_space = 0.096 },
    { VIA9_40, min_space = 0.3 },
#ifdef FILL_M9_VIA9_M10_BTCD
    { BTCD_M9_V9_M10_E, min_space = DV_TCDDMY_VX },
#endif
#ifdef FILL_DmyVIA9
               { gDV9_E, min_space = 0.3 },
#endif
    } );

SPEC_DV9_O = unified_fill(
    fill_boundary = {
        layer = CHIP_snps,
        type = LAYER
    },
    grid = vGRID,
    fill_patterns = { PATTERN_SPEC_DV9_O }
);
//***** fill *******************************************************************
OPC_VIA9   = SPEC_DV9_O["OUTPUT_DV9_O"][0];
#endif

//============================================================================


#ifdef FILL_DmyVIA10
#ifdef FILL_DM10 
   OPC_M10_D = CHIP_snps and or_list( { WRAPPER_DM10_O_L, DM10_O_L, DM10_O } ); 
   NON_OPC_M10_D = CHIP_snps and ( DM10 or DM10_L ); 
#else
   OPC_M10_D = CHIP_snps and DM10_O; 
   NON_OPC_M10_D = CHIP_snps and DM10; 
#endif
#ifdef FILL_DM11
   OPC_M11_U = CHIP_snps and or_list( { WRAPPER_DM11_O_L, DM11_O_L, DM11_O } ); 
   NON_OPC_M11_U = CHIP_snps and ( DM11 or DM11_L ); 
#else
   OPC_M11_U = CHIP_snps and DM11_O; 
   NON_OPC_M11_U = CHIP_snps and DM11; 
#endif


VIA10W_O : const double = 0.038;	
LINEEND_O_58_M11V10 : const double = 0.065;	
LINEEND_O_114_M11V10 : const double = 0.065;	
LINEEND_N_M11V10 : const double = 0.116;	

OPC_M11_U_58 = wide( OPC_M11_U, < 0.114, angled = TRUNCATE ); 
OPC_M11_U_114 = wide( OPC_M11_U, >= 0.114, angled = TRUNCATE ); 
OPC_M10_D_58 = wide( OPC_M10_D, < 0.114, angled = TRUNCATE ); 
OPC_M10_D_114 = wide( OPC_M10_D, >= 0.114, angled = TRUNCATE ); 
#ifdef VERTICAL_M11 
   DM11_O_58_LEEDGE_DV10_O = angle_edge( wide( OPC_M11_U, < 0.114, angled = TRUNCATE ), == 0 ); 
   DM11_O_114_LEEDGE_DV10_O = angle_edge( wide( OPC_M11_U, >= 0.114, angled = TRUNCATE ), == 0 ); 
   DM11_NON_LEEDGE_DV10_O = angle_edge( NON_OPC_M11_U, == 0 ); 
#else
   DM11_O_58_LEEDGE_DV10_O = angle_edge( wide( OPC_M11_U, < 0.114, angled = TRUNCATE ), == 90 ); 
   DM11_O_114_LEEDGE_DV10_O = angle_edge( wide( OPC_M11_U, >= 0.114, angled = TRUNCATE ), == 90 ); 
   DM11_NON_LEEDGE_DV10_O = angle_edge( NON_OPC_M11_U, == 90 ); 
#endif

CENTER_BAR_VALUE = VIA10W_O;
DM11_O_58_REGION_DV10_O_PRO = drc_features( primary_layer = OPC_M11_U_58, secondary_layers = { "layer2" => DM11_O_58_LEEDGE_DV10_O }, output_from_layer = OPC_M11_U_58, include_touch = EDGE, drc_function = dfm_property_func_DV, combine_errors = OPPOSING ); 
DM11_O_58_REGION_DV10_O_RE = DM11_O_58_REGION_DV10_O_PRO not edge_size_by_property( DM11_O_58_REGION_DV10_O_PRO, inside_property = "Metal_W" );
DM11_O_58_REGION_DV10_O_LESHRINK = edge_size( DM11_O_58_LEEDGE_DV10_O, inside = LINEEND_O_58_M11V10 ); 
DM11_O_58_REGION_DV10_O = DM11_O_58_REGION_DV10_O_RE not DM11_O_58_REGION_DV10_O_LESHRINK; 
DM11_O_114_REGION_DV10_O_PRO = drc_features( primary_layer = OPC_M11_U_114, secondary_layers = { "layer2" => DM11_O_114_LEEDGE_DV10_O }, output_from_layer = OPC_M11_U_114, include_touch = EDGE, drc_function = dfm_property_func_DV, combine_errors = OPPOSING ); 
DM11_O_114_REGION_DV10_O_RE = DM11_O_114_REGION_DV10_O_PRO not edge_size_by_property( DM11_O_114_REGION_DV10_O_PRO, inside_property = "Metal_W" );
DM11_O_114_REGION_DV10_O_LESHRINK = edge_size( DM11_O_114_LEEDGE_DV10_O, inside = LINEEND_O_114_M11V10 ); 
DM11_O_114_REGION_DV10_O = DM11_O_114_REGION_DV10_O_RE not DM11_O_114_REGION_DV10_O_LESHRINK; 
DM11_NON_REGION_DV10_O_PRO = drc_features( primary_layer = NON_OPC_M11_U, secondary_layers = { "layer2" => DM11_NON_LEEDGE_DV10_O }, output_from_layer = NON_OPC_M11_U, include_touch = EDGE, drc_function = dfm_property_func_DV, combine_errors = OPPOSING ); 
DM11_NON_REGION_DV10_O_RE = DM11_NON_REGION_DV10_O_PRO not edge_size_by_property( DM11_NON_REGION_DV10_O_PRO, inside_property = "Metal_W" );
DM11_NON_REGION_DV10_O_LESHRINK = edge_size( DM11_NON_LEEDGE_DV10_O, inside = LINEEND_N_M11V10 ); 
DM11_NON_REGION_DV10_O = DM11_NON_REGION_DV10_O_RE not DM11_NON_REGION_DV10_O_LESHRINK; 

DM11_UP_R = or_list( { DM11_O_58_REGION_DV10_O, DM11_O_114_REGION_DV10_O, DM11_NON_REGION_DV10_O } ); 

#ifdef VERTICAL_M10 
   DM10_O_58_LEEDGE_DV10_O = angle_edge( wide( OPC_M10_D, < 0.114, angled = TRUNCATE ), == 0 ); 
   DM10_O_114_LEEDGE_DV10_O = angle_edge( wide( OPC_M10_D, >= 0.114, angled = TRUNCATE ), == 0 ); 
   DM10_NON_LEEDGE_DV10_O = angle_edge( NON_OPC_M10_D, == 0 ); 
#else
   DM10_O_58_LEEDGE_DV10_O = angle_edge( wide( OPC_M10_D, < 0.114, angled = TRUNCATE ), == 90 ); 
   DM10_O_114_LEEDGE_DV10_O = angle_edge( wide( OPC_M10_D, >= 0.114, angled = TRUNCATE ), == 90 ); 
   DM10_NON_LEEDGE_DV10_O = angle_edge( NON_OPC_M10_D, == 90 ); 
#endif

CENTER_BAR_VALUE = VIA10W_O;
DM10_O_58_REGION_DV10_O_PRO = drc_features( primary_layer = OPC_M10_D_58, secondary_layers = { "layer2" => DM10_O_58_LEEDGE_DV10_O }, output_from_layer = OPC_M10_D_58, include_touch = EDGE, drc_function = dfm_property_func_DV, combine_errors = OPPOSING ); 
DM10_O_58_REGION_DV10_O_RE = DM10_O_58_REGION_DV10_O_PRO not edge_size_by_property( DM10_O_58_REGION_DV10_O_PRO, inside_property = "Metal_W" );
DM10_O_58_REGION_DV10_O_LESHRINK = edge_size( DM10_O_58_LEEDGE_DV10_O, inside = LINEEND_O_58_M11V10 ); 
DM10_O_58_REGION_DV10_O = DM10_O_58_REGION_DV10_O_RE not DM10_O_58_REGION_DV10_O_LESHRINK; 
DM10_O_114_REGION_DV10_O_PRO = drc_features( primary_layer = OPC_M10_D_114, secondary_layers = { "layer2" => DM10_O_114_LEEDGE_DV10_O }, output_from_layer = OPC_M10_D_114, include_touch = EDGE, drc_function = dfm_property_func_DV, combine_errors = OPPOSING ); 
DM10_O_114_REGION_DV10_O_RE = DM10_O_114_REGION_DV10_O_PRO not edge_size_by_property( DM10_O_114_REGION_DV10_O_PRO, inside_property = "Metal_W" );
DM10_O_114_REGION_DV10_O_LESHRINK = edge_size( DM10_O_114_LEEDGE_DV10_O, inside = LINEEND_O_114_M11V10 ); 
DM10_O_114_REGION_DV10_O = DM10_O_114_REGION_DV10_O_RE not DM10_O_114_REGION_DV10_O_LESHRINK; 
DM10_NON_REGION_DV10_O_PRO = drc_features( primary_layer = NON_OPC_M10_D, secondary_layers = { "layer2" => DM10_NON_LEEDGE_DV10_O }, output_from_layer = NON_OPC_M10_D, include_touch = EDGE, drc_function = dfm_property_func_DV, combine_errors = OPPOSING ); 
DM10_NON_REGION_DV10_O_RE = DM10_NON_REGION_DV10_O_PRO not edge_size_by_property( DM10_NON_REGION_DV10_O_PRO, inside_property = "Metal_W" );
DM10_NON_REGION_DV10_O_LESHRINK = edge_size( DM10_NON_LEEDGE_DV10_O, inside = LINEEND_N_M11V10 ); 
DM10_NON_REGION_DV10_O = DM10_NON_REGION_DV10_O_RE not DM10_NON_REGION_DV10_O_LESHRINK; 

DM10_DOWN_R = or_list( { DM10_O_58_REGION_DV10_O, DM10_O_114_REGION_DV10_O, DM10_NON_REGION_DV10_O } ); 

REGION_DV10_O = DM11_UP_R and DM10_DOWN_R; 




//***** spec *******************************************************************
// DUMMY SPEC : DV10_O
PATTERN_SPEC_DV10_O = get_single_polygon_pattern(
    "DV10OQ" , "OUTPUT_DV10_O", DVY_O_W, DVY_O_W,
    step_x = DVY_O_S, step_y = DVY_O_S,
    setback = DVY_O_S, setback_type = INTERSECTION,
	FSS = {
#ifdef ANTPrevention
               { FORBIDDEN_RING, min_space = 0 },
#endif            
               { REGION_DV10_O, min_space = 0, context = INTERIOR },
    { CHIP_snps, min_space = DMY1_CHIP, context = INTERIOR },
    { BEOLBLK_FINAL, min_space = DM_BEOLBLK },
    { INDDMY, min_space = DM_INDDMY },

    { DV10EXCL, min_space = DV_DVXEXCL },
    { TCDDMY_V10, min_space = DV_TCDDMY_VX },
    { VIA10I, min_space = 0.150 },
    { DVIA10, min_space = 0.300 },
    { DVIA10_O, min_space = 0.096 },
    { VIA10_40, min_space = 0.3 },
#ifdef FILL_M10_VIA10_M11_BTCD
    { BTCD_M10_V10_M11_E, min_space = DV_TCDDMY_VX },
#endif
#ifdef FILL_DmyVIA10
               { gDV10_E, min_space = 0.3 },
#endif
    } );

SPEC_DV10_O = unified_fill(
    fill_boundary = {
        layer = CHIP_snps,
        type = LAYER
    },
    grid = vGRID,
    fill_patterns = { PATTERN_SPEC_DV10_O }
);
//***** fill *******************************************************************
OPC_VIA10   = SPEC_DV10_O["OUTPUT_DV10_O"][0];
#endif

//============================================================================


#ifdef FILL_DmyVIA11
#ifdef FILL_DM11 
   OPC_M11_D = CHIP_snps and or_list( { WRAPPER_DM11_O_L, DM11_O_L, DM11_O } ); 
   NON_OPC_M11_D = CHIP_snps and ( DM11 or DM11_L ); 
#else
   OPC_M11_D = CHIP_snps and DM11_O; 
   NON_OPC_M11_D = CHIP_snps and DM11; 
#endif
#ifdef FILL_DM12
   OPC_M12_U = CHIP_snps and or_list( { WRAPPER_DM12_O_L, DM12_O_L, DM12_O } ); 
   NON_OPC_M12_U = CHIP_snps and ( DM12 or DM12_L ); 
#else
   OPC_M12_U = CHIP_snps and DM12_O; 
   NON_OPC_M12_U = CHIP_snps and DM12; 
#endif


VIA11W_O : const double = 0.038;	
LINEEND_O_58_M12V11 : const double = 0.065;	
LINEEND_O_114_M12V11 : const double = 0.065;	
LINEEND_N_M12V11 : const double = 0.116;	

OPC_M12_U_58 = wide( OPC_M12_U, < 0.114, angled = TRUNCATE ); 
OPC_M12_U_114 = wide( OPC_M12_U, >= 0.114, angled = TRUNCATE ); 
OPC_M11_D_58 = wide( OPC_M11_D, < 0.114, angled = TRUNCATE ); 
OPC_M11_D_114 = wide( OPC_M11_D, >= 0.114, angled = TRUNCATE ); 
#ifdef VERTICAL_M12 
   DM12_O_58_LEEDGE_DV11_O = angle_edge( wide( OPC_M12_U, < 0.114, angled = TRUNCATE ), == 0 ); 
   DM12_O_114_LEEDGE_DV11_O = angle_edge( wide( OPC_M12_U, >= 0.114, angled = TRUNCATE ), == 0 ); 
   DM12_NON_LEEDGE_DV11_O = angle_edge( NON_OPC_M12_U, == 0 ); 
#else
   DM12_O_58_LEEDGE_DV11_O = angle_edge( wide( OPC_M12_U, < 0.114, angled = TRUNCATE ), == 90 ); 
   DM12_O_114_LEEDGE_DV11_O = angle_edge( wide( OPC_M12_U, >= 0.114, angled = TRUNCATE ), == 90 ); 
   DM12_NON_LEEDGE_DV11_O = angle_edge( NON_OPC_M12_U, == 90 ); 
#endif

CENTER_BAR_VALUE = VIA11W_O;
DM12_O_58_REGION_DV11_O_PRO = drc_features( primary_layer = OPC_M12_U_58, secondary_layers = { "layer2" => DM12_O_58_LEEDGE_DV11_O }, output_from_layer = OPC_M12_U_58, include_touch = EDGE, drc_function = dfm_property_func_DV, combine_errors = OPPOSING ); 
DM12_O_58_REGION_DV11_O_RE = DM12_O_58_REGION_DV11_O_PRO not edge_size_by_property( DM12_O_58_REGION_DV11_O_PRO, inside_property = "Metal_W" );
DM12_O_58_REGION_DV11_O_LESHRINK = edge_size( DM12_O_58_LEEDGE_DV11_O, inside = LINEEND_O_58_M12V11 ); 
DM12_O_58_REGION_DV11_O = DM12_O_58_REGION_DV11_O_RE not DM12_O_58_REGION_DV11_O_LESHRINK; 
DM12_O_114_REGION_DV11_O_PRO = drc_features( primary_layer = OPC_M12_U_114, secondary_layers = { "layer2" => DM12_O_114_LEEDGE_DV11_O }, output_from_layer = OPC_M12_U_114, include_touch = EDGE, drc_function = dfm_property_func_DV, combine_errors = OPPOSING ); 
DM12_O_114_REGION_DV11_O_RE = DM12_O_114_REGION_DV11_O_PRO not edge_size_by_property( DM12_O_114_REGION_DV11_O_PRO, inside_property = "Metal_W" );
DM12_O_114_REGION_DV11_O_LESHRINK = edge_size( DM12_O_114_LEEDGE_DV11_O, inside = LINEEND_O_114_M12V11 ); 
DM12_O_114_REGION_DV11_O = DM12_O_114_REGION_DV11_O_RE not DM12_O_114_REGION_DV11_O_LESHRINK; 
DM12_NON_REGION_DV11_O_PRO = drc_features( primary_layer = NON_OPC_M12_U, secondary_layers = { "layer2" => DM12_NON_LEEDGE_DV11_O }, output_from_layer = NON_OPC_M12_U, include_touch = EDGE, drc_function = dfm_property_func_DV, combine_errors = OPPOSING ); 
DM12_NON_REGION_DV11_O_RE = DM12_NON_REGION_DV11_O_PRO not edge_size_by_property( DM12_NON_REGION_DV11_O_PRO, inside_property = "Metal_W" );
DM12_NON_REGION_DV11_O_LESHRINK = edge_size( DM12_NON_LEEDGE_DV11_O, inside = LINEEND_N_M12V11 ); 
DM12_NON_REGION_DV11_O = DM12_NON_REGION_DV11_O_RE not DM12_NON_REGION_DV11_O_LESHRINK; 

DM12_UP_R = or_list( { DM12_O_58_REGION_DV11_O, DM12_O_114_REGION_DV11_O, DM12_NON_REGION_DV11_O } ); 

#ifdef VERTICAL_M11 
   DM11_O_58_LEEDGE_DV11_O = angle_edge( wide( OPC_M11_D, < 0.114, angled = TRUNCATE ), == 0 ); 
   DM11_O_114_LEEDGE_DV11_O = angle_edge( wide( OPC_M11_D, >= 0.114, angled = TRUNCATE ), == 0 ); 
   DM11_NON_LEEDGE_DV11_O = angle_edge( NON_OPC_M11_D, == 0 ); 
#else
   DM11_O_58_LEEDGE_DV11_O = angle_edge( wide( OPC_M11_D, < 0.114, angled = TRUNCATE ), == 90 ); 
   DM11_O_114_LEEDGE_DV11_O = angle_edge( wide( OPC_M11_D, >= 0.114, angled = TRUNCATE ), == 90 ); 
   DM11_NON_LEEDGE_DV11_O = angle_edge( NON_OPC_M11_D, == 90 ); 
#endif

CENTER_BAR_VALUE = VIA11W_O;
DM11_O_58_REGION_DV11_O_PRO = drc_features( primary_layer = OPC_M11_D_58, secondary_layers = { "layer2" => DM11_O_58_LEEDGE_DV11_O }, output_from_layer = OPC_M11_D_58, include_touch = EDGE, drc_function = dfm_property_func_DV, combine_errors = OPPOSING ); 
DM11_O_58_REGION_DV11_O_RE = DM11_O_58_REGION_DV11_O_PRO not edge_size_by_property( DM11_O_58_REGION_DV11_O_PRO, inside_property = "Metal_W" );
DM11_O_58_REGION_DV11_O_LESHRINK = edge_size( DM11_O_58_LEEDGE_DV11_O, inside = LINEEND_O_58_M12V11 ); 
DM11_O_58_REGION_DV11_O = DM11_O_58_REGION_DV11_O_RE not DM11_O_58_REGION_DV11_O_LESHRINK; 
DM11_O_114_REGION_DV11_O_PRO = drc_features( primary_layer = OPC_M11_D_114, secondary_layers = { "layer2" => DM11_O_114_LEEDGE_DV11_O }, output_from_layer = OPC_M11_D_114, include_touch = EDGE, drc_function = dfm_property_func_DV, combine_errors = OPPOSING ); 
DM11_O_114_REGION_DV11_O_RE = DM11_O_114_REGION_DV11_O_PRO not edge_size_by_property( DM11_O_114_REGION_DV11_O_PRO, inside_property = "Metal_W" );
DM11_O_114_REGION_DV11_O_LESHRINK = edge_size( DM11_O_114_LEEDGE_DV11_O, inside = LINEEND_O_114_M12V11 ); 
DM11_O_114_REGION_DV11_O = DM11_O_114_REGION_DV11_O_RE not DM11_O_114_REGION_DV11_O_LESHRINK; 
DM11_NON_REGION_DV11_O_PRO = drc_features( primary_layer = NON_OPC_M11_D, secondary_layers = { "layer2" => DM11_NON_LEEDGE_DV11_O }, output_from_layer = NON_OPC_M11_D, include_touch = EDGE, drc_function = dfm_property_func_DV, combine_errors = OPPOSING ); 
DM11_NON_REGION_DV11_O_RE = DM11_NON_REGION_DV11_O_PRO not edge_size_by_property( DM11_NON_REGION_DV11_O_PRO, inside_property = "Metal_W" );
DM11_NON_REGION_DV11_O_LESHRINK = edge_size( DM11_NON_LEEDGE_DV11_O, inside = LINEEND_N_M12V11 ); 
DM11_NON_REGION_DV11_O = DM11_NON_REGION_DV11_O_RE not DM11_NON_REGION_DV11_O_LESHRINK; 

DM11_DOWN_R = or_list( { DM11_O_58_REGION_DV11_O, DM11_O_114_REGION_DV11_O, DM11_NON_REGION_DV11_O } ); 

REGION_DV11_O = DM12_UP_R and DM11_DOWN_R; 




//***** spec *******************************************************************
// DUMMY SPEC : DV11_O
PATTERN_SPEC_DV11_O = get_single_polygon_pattern(
    "DV11OQ" , "OUTPUT_DV11_O", DVY_O_W, DVY_O_W,
    step_x = DVY_O_S, step_y = DVY_O_S,
    setback = DVY_O_S, setback_type = INTERSECTION,
	FSS = {
#ifdef ANTPrevention
               { FORBIDDEN_RING, min_space = 0 },
#endif            
               { REGION_DV11_O, min_space = 0, context = INTERIOR },
    { CHIP_snps, min_space = DMY1_CHIP, context = INTERIOR },
    { BEOLBLK_FINAL, min_space = DM_BEOLBLK },
    { INDDMY, min_space = DM_INDDMY },

    { DV11EXCL, min_space = DV_DVXEXCL },
    { TCDDMY_V11, min_space = DV_TCDDMY_VX },
    { VIA11I, min_space = 0.150 },
    { DVIA11, min_space = 0.300 },
    { DVIA11_O, min_space = 0.096 },
    { VIA11_40, min_space = 0.3 },
#ifdef FILL_M11_VIA11_M12_BTCD
    { BTCD_M11_V11_M12_E, min_space = DV_TCDDMY_VX },
#endif
#ifdef FILL_DmyVIA11
               { gDV11_E, min_space = 0.3 },
#endif
    } );

SPEC_DV11_O = unified_fill(
    fill_boundary = {
        layer = CHIP_snps,
        type = LAYER
    },
    grid = vGRID,
    fill_patterns = { PATTERN_SPEC_DV11_O }
);
//***** fill *******************************************************************
OPC_VIA11   = SPEC_DV11_O["OUTPUT_DV11_O"][0];
#endif

//============================================================================


#ifdef FILL_DmyVIA12
#ifdef FILL_DM12 
   OPC_M12_D = CHIP_snps and or_list( { WRAPPER_DM12_O_L, DM12_O_L, DM12_O } ); 
   NON_OPC_M12_D = CHIP_snps and ( DM12 or DM12_L ); 
#else
   OPC_M12_D = CHIP_snps and DM12_O; 
   NON_OPC_M12_D = CHIP_snps and DM12; 
#endif
#ifdef FILL_DM13
   OPC_M13_U = CHIP_snps and or_list( { WRAPPER_DM13_O_L, DM13_O_L, DM13_O } ); 
   NON_OPC_M13_U = CHIP_snps and ( DM13 or DM13_L ); 
#else
   OPC_M13_U = CHIP_snps and DM13_O; 
   NON_OPC_M13_U = CHIP_snps and DM13; 
#endif


VIA12W_O : const double = 0.038;	
LINEEND_O_58_M13V12 : const double = 0.065;	
LINEEND_O_114_M13V12 : const double = 0.065;	
LINEEND_N_M13V12 : const double = 0.116;	

OPC_M13_U_58 = wide( OPC_M13_U, < 0.114, angled = TRUNCATE ); 
OPC_M13_U_114 = wide( OPC_M13_U, >= 0.114, angled = TRUNCATE ); 
OPC_M12_D_58 = wide( OPC_M12_D, < 0.114, angled = TRUNCATE ); 
OPC_M12_D_114 = wide( OPC_M12_D, >= 0.114, angled = TRUNCATE ); 
#ifdef VERTICAL_M13 
   DM13_O_58_LEEDGE_DV12_O = angle_edge( wide( OPC_M13_U, < 0.114, angled = TRUNCATE ), == 0 ); 
   DM13_O_114_LEEDGE_DV12_O = angle_edge( wide( OPC_M13_U, >= 0.114, angled = TRUNCATE ), == 0 ); 
   DM13_NON_LEEDGE_DV12_O = angle_edge( NON_OPC_M13_U, == 0 ); 
#else
   DM13_O_58_LEEDGE_DV12_O = angle_edge( wide( OPC_M13_U, < 0.114, angled = TRUNCATE ), == 90 ); 
   DM13_O_114_LEEDGE_DV12_O = angle_edge( wide( OPC_M13_U, >= 0.114, angled = TRUNCATE ), == 90 ); 
   DM13_NON_LEEDGE_DV12_O = angle_edge( NON_OPC_M13_U, == 90 ); 
#endif

CENTER_BAR_VALUE = VIA12W_O;
DM13_O_58_REGION_DV12_O_PRO = drc_features( primary_layer = OPC_M13_U_58, secondary_layers = { "layer2" => DM13_O_58_LEEDGE_DV12_O }, output_from_layer = OPC_M13_U_58, include_touch = EDGE, drc_function = dfm_property_func_DV, combine_errors = OPPOSING ); 
DM13_O_58_REGION_DV12_O_RE = DM13_O_58_REGION_DV12_O_PRO not edge_size_by_property( DM13_O_58_REGION_DV12_O_PRO, inside_property = "Metal_W" );
DM13_O_58_REGION_DV12_O_LESHRINK = edge_size( DM13_O_58_LEEDGE_DV12_O, inside = LINEEND_O_58_M13V12 ); 
DM13_O_58_REGION_DV12_O = DM13_O_58_REGION_DV12_O_RE not DM13_O_58_REGION_DV12_O_LESHRINK; 
DM13_O_114_REGION_DV12_O_PRO = drc_features( primary_layer = OPC_M13_U_114, secondary_layers = { "layer2" => DM13_O_114_LEEDGE_DV12_O }, output_from_layer = OPC_M13_U_114, include_touch = EDGE, drc_function = dfm_property_func_DV, combine_errors = OPPOSING ); 
DM13_O_114_REGION_DV12_O_RE = DM13_O_114_REGION_DV12_O_PRO not edge_size_by_property( DM13_O_114_REGION_DV12_O_PRO, inside_property = "Metal_W" );
DM13_O_114_REGION_DV12_O_LESHRINK = edge_size( DM13_O_114_LEEDGE_DV12_O, inside = LINEEND_O_114_M13V12 ); 
DM13_O_114_REGION_DV12_O = DM13_O_114_REGION_DV12_O_RE not DM13_O_114_REGION_DV12_O_LESHRINK; 
DM13_NON_REGION_DV12_O_PRO = drc_features( primary_layer = NON_OPC_M13_U, secondary_layers = { "layer2" => DM13_NON_LEEDGE_DV12_O }, output_from_layer = NON_OPC_M13_U, include_touch = EDGE, drc_function = dfm_property_func_DV, combine_errors = OPPOSING ); 
DM13_NON_REGION_DV12_O_RE = DM13_NON_REGION_DV12_O_PRO not edge_size_by_property( DM13_NON_REGION_DV12_O_PRO, inside_property = "Metal_W" );
DM13_NON_REGION_DV12_O_LESHRINK = edge_size( DM13_NON_LEEDGE_DV12_O, inside = LINEEND_N_M13V12 ); 
DM13_NON_REGION_DV12_O = DM13_NON_REGION_DV12_O_RE not DM13_NON_REGION_DV12_O_LESHRINK; 

DM13_UP_R = or_list( { DM13_O_58_REGION_DV12_O, DM13_O_114_REGION_DV12_O, DM13_NON_REGION_DV12_O } ); 

#ifdef VERTICAL_M12 
   DM12_O_58_LEEDGE_DV12_O = angle_edge( wide( OPC_M12_D, < 0.114, angled = TRUNCATE ), == 0 ); 
   DM12_O_114_LEEDGE_DV12_O = angle_edge( wide( OPC_M12_D, >= 0.114, angled = TRUNCATE ), == 0 ); 
   DM12_NON_LEEDGE_DV12_O = angle_edge( NON_OPC_M12_D, == 0 ); 
#else
   DM12_O_58_LEEDGE_DV12_O = angle_edge( wide( OPC_M12_D, < 0.114, angled = TRUNCATE ), == 90 ); 
   DM12_O_114_LEEDGE_DV12_O = angle_edge( wide( OPC_M12_D, >= 0.114, angled = TRUNCATE ), == 90 ); 
   DM12_NON_LEEDGE_DV12_O = angle_edge( NON_OPC_M12_D, == 90 ); 
#endif

CENTER_BAR_VALUE = VIA12W_O;
DM12_O_58_REGION_DV12_O_PRO = drc_features( primary_layer = OPC_M12_D_58, secondary_layers = { "layer2" => DM12_O_58_LEEDGE_DV12_O }, output_from_layer = OPC_M12_D_58, include_touch = EDGE, drc_function = dfm_property_func_DV, combine_errors = OPPOSING ); 
DM12_O_58_REGION_DV12_O_RE = DM12_O_58_REGION_DV12_O_PRO not edge_size_by_property( DM12_O_58_REGION_DV12_O_PRO, inside_property = "Metal_W" );
DM12_O_58_REGION_DV12_O_LESHRINK = edge_size( DM12_O_58_LEEDGE_DV12_O, inside = LINEEND_O_58_M13V12 ); 
DM12_O_58_REGION_DV12_O = DM12_O_58_REGION_DV12_O_RE not DM12_O_58_REGION_DV12_O_LESHRINK; 
DM12_O_114_REGION_DV12_O_PRO = drc_features( primary_layer = OPC_M12_D_114, secondary_layers = { "layer2" => DM12_O_114_LEEDGE_DV12_O }, output_from_layer = OPC_M12_D_114, include_touch = EDGE, drc_function = dfm_property_func_DV, combine_errors = OPPOSING ); 
DM12_O_114_REGION_DV12_O_RE = DM12_O_114_REGION_DV12_O_PRO not edge_size_by_property( DM12_O_114_REGION_DV12_O_PRO, inside_property = "Metal_W" );
DM12_O_114_REGION_DV12_O_LESHRINK = edge_size( DM12_O_114_LEEDGE_DV12_O, inside = LINEEND_O_114_M13V12 ); 
DM12_O_114_REGION_DV12_O = DM12_O_114_REGION_DV12_O_RE not DM12_O_114_REGION_DV12_O_LESHRINK; 
DM12_NON_REGION_DV12_O_PRO = drc_features( primary_layer = NON_OPC_M12_D, secondary_layers = { "layer2" => DM12_NON_LEEDGE_DV12_O }, output_from_layer = NON_OPC_M12_D, include_touch = EDGE, drc_function = dfm_property_func_DV, combine_errors = OPPOSING ); 
DM12_NON_REGION_DV12_O_RE = DM12_NON_REGION_DV12_O_PRO not edge_size_by_property( DM12_NON_REGION_DV12_O_PRO, inside_property = "Metal_W" );
DM12_NON_REGION_DV12_O_LESHRINK = edge_size( DM12_NON_LEEDGE_DV12_O, inside = LINEEND_N_M13V12 ); 
DM12_NON_REGION_DV12_O = DM12_NON_REGION_DV12_O_RE not DM12_NON_REGION_DV12_O_LESHRINK; 

DM12_DOWN_R = or_list( { DM12_O_58_REGION_DV12_O, DM12_O_114_REGION_DV12_O, DM12_NON_REGION_DV12_O } ); 

REGION_DV12_O = DM13_UP_R and DM12_DOWN_R; 




//***** spec *******************************************************************
// DUMMY SPEC : DV12_O
PATTERN_SPEC_DV12_O = get_single_polygon_pattern(
    "DV12OQ" , "OUTPUT_DV12_O", DVY_O_W, DVY_O_W,
    step_x = DVY_O_S, step_y = DVY_O_S,
    setback = DVY_O_S, setback_type = INTERSECTION,
	FSS = {
#ifdef ANTPrevention
               { FORBIDDEN_RING, min_space = 0 },
#endif            
               { REGION_DV12_O, min_space = 0, context = INTERIOR },
    { CHIP_snps, min_space = DMY1_CHIP, context = INTERIOR },
    { BEOLBLK_FINAL, min_space = DM_BEOLBLK },
    { INDDMY, min_space = DM_INDDMY },

    { DV12EXCL, min_space = DV_DVXEXCL },
    { TCDDMY_V12, min_space = DV_TCDDMY_VX },
    { VIA12I, min_space = 0.150 },
    { DVIA12, min_space = 0.300 },
    { DVIA12_O, min_space = 0.096 },
    { VIA12_40, min_space = 0.3 },
#ifdef FILL_M12_VIA12_M13_BTCD
    { BTCD_M12_V12_M13_E, min_space = DV_TCDDMY_VX },
#endif
#ifdef FILL_DmyVIA12
               { gDV12_E, min_space = 0.3 },
#endif
    } );

SPEC_DV12_O = unified_fill(
    fill_boundary = {
        layer = CHIP_snps,
        type = LAYER
    },
    grid = vGRID,
    fill_patterns = { PATTERN_SPEC_DV12_O }
);
//***** fill *******************************************************************
OPC_VIA12   = SPEC_DV12_O["OUTPUT_DV12_O"][0];
#endif

//============================================================================


#ifdef FILL_DmyVIA13
#ifdef FILL_DM13
OPC_M13_D = CHIP_snps and or_list( { WRAPPER_DM13_O_L, DM13_O_L, DM13_O } ); 
NON_OPC_M13_D = CHIP_snps and ( DM13 or DM13_L ); 
#else
OPC_M13_D = CHIP_snps and DM13_O; 
NON_OPC_M13_D = CHIP_snps and DM13; 
#endif



OPC_M13_D_H = aspect_ratio( OPC_M13_D, > 1, orientation = ORTHOGONAL, direction = X_BY_Y );
OPC_M13_D_V = aspect_ratio( OPC_M13_D, < 1, orientation = ORTHOGONAL, direction = X_BY_Y );
OPC_M13_D_short_edges = angle_edge(OPC_M13_D_H, == 90 ) or_edge angle_edge(OPC_M13_D_V, == 0 );
DM13_O_114_REGION_DV13_O_RE = OPC_M13_D not edge_size( OPC_M13_D_short_edges, inside = DVIAYY_O_MY_E3 );        /* LELDMY1OPC114YY - SELDMY1OPC114YY */ 

DM13_O_114_REGION_DV13_O = size( DM13_O_114_REGION_DV13_O_RE, clip_acute = TRUNCATE, distance = - DVIAYY_O_MY_E1 );    /* SELDMy1OPC114yy */ 


NON_OPC_M13_D_H = aspect_ratio( NON_OPC_M13_D, > 1, orientation = ORTHOGONAL, direction = X_BY_Y );
NON_OPC_M13_D_V = aspect_ratio( NON_OPC_M13_D, < 1, orientation = ORTHOGONAL, direction = X_BY_Y );
NON_OPC_M13_D_short_edges = angle_edge(NON_OPC_M13_D_H, == 90 ) or_edge angle_edge(NON_OPC_M13_D_V, == 0 );
DM13_NON_REGION_DV13_O_PRE = NON_OPC_M13_D not edge_size( NON_OPC_M13_D_short_edges, inside = DVIAYY_N_MY_E3 );        /* LELDMY1NOPC108YY - SELDMY1NOPC108YY */ 

DM13_NON_REGION_DV13_O = size( DM13_NON_REGION_DV13_O_PRE, clip_acute = TRUNCATE, distance = - DVIAYY_N_MY_E1 );    /* SELDMy1NOPC108yy */ 



DM13_REGION_DV13_O = DM13_O_114_REGION_DV13_O or DM13_NON_REGION_DV13_O; 

#ifdef FILL_DM14 
   OPC_M14_U = CHIP_snps and or_list( { WRAPPER_DM14_O_L, DM14_O_L, DM14_O } ); 
   NON_OPC_M14_U = CHIP_snps and ( DM14 or DM14_L ); 
#else
   OPC_M14_U = CHIP_snps and DM14_O; 
   NON_OPC_M14_U = CHIP_snps and DM14; 
#endif


OPC_M14_U_H = aspect_ratio( OPC_M14_U, > 1, orientation = ORTHOGONAL, direction = X_BY_Y );
OPC_M14_U_V = aspect_ratio( OPC_M14_U, < 1, orientation = ORTHOGONAL, direction = X_BY_Y );
OPC_M14_U_short_edges = angle_edge(OPC_M14_U_H, == 90 ) or_edge angle_edge(OPC_M14_U_V, == 0 );
DM14_O_62_REGION_DV13_O = OPC_M14_U not edge_size( OPC_M14_U_short_edges, inside = DVIAYY_O_MYY_E0 );        /* LEUDMYYOPC62 - SEUDMYYOPC62 */ 

DM14_O_90_LEEDGE_DV13_O = length_edge( OPC_M14_U, == 0.09 ); 
OPC_M14_U_90 = wide( OPC_M14_U, == 0.09, angled = TRUNCATE ); 


OPC_M14_U_90_H = aspect_ratio( OPC_M14_U_90, > 1, orientation = ORTHOGONAL, direction = X_BY_Y );
OPC_M14_U_90_V = aspect_ratio( OPC_M14_U_90, < 1, orientation = ORTHOGONAL, direction = X_BY_Y );
OPC_M14_U_90_short_edges = angle_edge(OPC_M14_U_90_H, == 90 ) or_edge angle_edge(OPC_M14_U_90_V, == 0 );
DM14_O_90_REGION_DV13_O1 = OPC_M14_U_90 not edge_size( OPC_M14_U_90_short_edges, inside = DVIAYY_O_MYY_E1 );        /* LEUDMYYOPC90_1 - SEUDMYYOPC90_1 */ 

OPC_M14_U_OTHER = copy( OPC_M14_U_90, ancestry = true ); 


OPC_M14_U_OTHER_H = aspect_ratio( OPC_M14_U_OTHER, > 1, orientation = ORTHOGONAL, direction = X_BY_Y );
OPC_M14_U_OTHER_V = aspect_ratio( OPC_M14_U_OTHER, < 1, orientation = ORTHOGONAL, direction = X_BY_Y );
OPC_M14_U_OTHER_short_edges = angle_edge(OPC_M14_U_OTHER_H, == 90 ) or_edge angle_edge(OPC_M14_U_OTHER_V, == 0 );
DM14_O_90_REGION_DV13_O_RE2 = OPC_M14_U_OTHER not edge_size( OPC_M14_U_OTHER_short_edges, inside = DVIAYY_O_MYY_E2 );        /* LEUDMYYOPC90_2 - SEUDMYYOPC90_2 */ 

DM14_O_90_REGION_DV13_O2 = size( DM14_O_90_REGION_DV13_O_RE2, clip_acute = TRUNCATE, distance = - DVIAYY_O_MYY_E2 );    /* SEUDMyyOPC90_2 */ 
DM14_O_90_REGION_DV13_O = DM14_O_90_REGION_DV13_O1 or DM14_O_90_REGION_DV13_O2; 


NON_OPC_M14_U_H = aspect_ratio( NON_OPC_M14_U, > 1, orientation = ORTHOGONAL, direction = X_BY_Y );
NON_OPC_M14_U_V = aspect_ratio( NON_OPC_M14_U, < 1, orientation = ORTHOGONAL, direction = X_BY_Y );
NON_OPC_M14_U_short_edges = angle_edge(NON_OPC_M14_U_H, == 90 ) or_edge angle_edge(NON_OPC_M14_U_V, == 0 );
DM14_NON_REGION_DV13_O_PRE = NON_OPC_M14_U not edge_size( NON_OPC_M14_U_short_edges, inside = DVIAYY_N_MYY_E3 );        /* LEUDMYYNOPC - SEUDMYYNOPC */ 

DM14_NON_REGION_DV13_O = size( DM14_NON_REGION_DV13_O_PRE, clip_acute = TRUNCATE, distance = - DVIAYY_N_MYY_E1 );    /* SEUDMyyNOPC */ 


DM14_REGION_DV13_O = or_list( { DM14_O_90_REGION_DV13_O, DM14_NON_REGION_DV13_O, DM14_O_62_REGION_DV13_O } ); 
REGION_DV13_O = DM13_REGION_DV13_O and DM14_REGION_DV13_O; 


//***** spec *******************************************************************
// DUMMY SPEC : DV13_O
PATTERN_SPEC_DV13_O = get_single_polygon_pattern(
    "DV13OQ" , "OUTPUT_DV13_O", DVYY_O_W, DVYY_O_W,
    step_x = DVYY_O_S, step_y = DVYY_O_S,
    setback = DVYY_O_S, setback_type = INTERSECTION,
	FSS = {
#ifdef ANTPrevention
               { FORBIDDEN_RING, min_space = 0 },
#endif            
               { REGION_DV13_O, min_space = 0, context = INTERIOR },
    { CHIP_snps, min_space = DMYY_CHIP, context = INTERIOR },
    { BEOLBLK_FINAL, min_space = DM_BEOLBLK },
    { INDDMY, min_space = DM_INDDMY },

    { DV13EXCL, min_space = DV_DVXEXCL },
    { TCDDMY_V13, min_space = DV_TCDDMY_VX },
    { VIA13I, min_space = 0.150 },
    { DVIA13, min_space = 0.180 },
    { DVIA13_O, min_space = 0.118 },
#ifdef FILL_DmyVIA13
               { gDV13_E, min_space = 0.180 },
#endif
    } );

SPEC_DV13_O = unified_fill(
    fill_boundary = {
        layer = REGION_DV13_O,
        type = LAYER
    },
    grid = vGRID,
    fill_patterns = { PATTERN_SPEC_DV13_O }
);
//***** fill *******************************************************************
OPC_VIA13   = SPEC_DV13_O["OUTPUT_DV13_O"][0];
//============================================================================
#endif



#ifdef FILL_DmyVIA14

#ifdef FILL_DM14 
   OPC_M14_D = CHIP_snps and or_list( { WRAPPER_DM14_O_L, DM14_O_L, DM14_O } ); 
   NON_OPC_M14_D = CHIP_snps and ( DM14 or DM14_L ); 
#else
   OPC_M14_D = CHIP_snps and DM14_O; 
   NON_OPC_M14_D = CHIP_snps and DM14; 
#endif


OPC_M14_D_H = aspect_ratio( OPC_M14_D, > 1, orientation = ORTHOGONAL, direction = X_BY_Y );
OPC_M14_D_V = aspect_ratio( OPC_M14_D, < 1, orientation = ORTHOGONAL, direction = X_BY_Y );
OPC_M14_D_short_edges = angle_edge(OPC_M14_D_H, == 90 ) or_edge angle_edge(OPC_M14_D_V, == 0 );
DM14_O_62_REGION_DV14_O = OPC_M14_D not edge_size( OPC_M14_D_short_edges, inside = DVIAYY_O_MYY_E0 );        /* LELDMYYOPC62 - SELDMYYOPC62 */ 

OPC_M14_D_90 = wide( OPC_M14_D, == 0.09, angled = TRUNCATE ); 


OPC_M14_D_90_H = aspect_ratio( OPC_M14_D_90, > 1, orientation = ORTHOGONAL, direction = X_BY_Y );
OPC_M14_D_90_V = aspect_ratio( OPC_M14_D_90, < 1, orientation = ORTHOGONAL, direction = X_BY_Y );
OPC_M14_D_90_short_edges = angle_edge(OPC_M14_D_90_H, == 90 ) or_edge angle_edge(OPC_M14_D_90_V, == 0 );
DM14_O_90_REGION_DV14_O1 = OPC_M14_D_90 not edge_size( OPC_M14_D_90_short_edges, inside = DVIAYY_O_MYY_E1 );        /* LELDMYYOPC90_1 - SELDMYYOPC90_1 */ 

OPC_M14_D_OTHER = copy( OPC_M14_D_90, ancestry = true ); 


OPC_M14_D_OTHER_H = aspect_ratio( OPC_M14_D_OTHER, > 1, orientation = ORTHOGONAL, direction = X_BY_Y );
OPC_M14_D_OTHER_V = aspect_ratio( OPC_M14_D_OTHER, < 1, orientation = ORTHOGONAL, direction = X_BY_Y );
OPC_M14_D_OTHER_short_edges = angle_edge(OPC_M14_D_OTHER_H, == 90 ) or_edge angle_edge(OPC_M14_D_OTHER_V, == 0 );
DM14_O_90_REGION_DV14_O_RE2 = OPC_M14_D_OTHER not edge_size( OPC_M14_D_OTHER_short_edges, inside = DVIAYY_O_MYY_E2 );        /* LELDMYYOPC90_2 - SELDMYYOPC90_2 */ 

DM14_O_90_REGION_DV14_O2 = size( DM14_O_90_REGION_DV14_O_RE2, clip_acute = TRUNCATE, distance = - DVIAYY_O_MYY_E2 );    /* SEDLMyyOPC90_2 */ 
DM14_O_90_REGION_DV14_O = DM14_O_90_REGION_DV14_O1 or DM14_O_90_REGION_DV14_O2; 


NON_OPC_M14_D_H = aspect_ratio( NON_OPC_M14_D, > 1, orientation = ORTHOGONAL, direction = X_BY_Y );
NON_OPC_M14_D_V = aspect_ratio( NON_OPC_M14_D, < 1, orientation = ORTHOGONAL, direction = X_BY_Y );
NON_OPC_M14_D_short_edges = angle_edge(NON_OPC_M14_D_H, == 90 ) or_edge angle_edge(NON_OPC_M14_D_V, == 0 );
DM14_NON_REGION_DV14_O_PRE = NON_OPC_M14_D not edge_size( NON_OPC_M14_D_short_edges, inside = DVIAYY_N_MYY_E3 );        /* LELDMYYNOPC - SELDMYYNOPC */ 






DM14_NON_REGION_DV14_O = size( DM14_NON_REGION_DV14_O_PRE, clip_acute = TRUNCATE, distance = - DVIAYY_N_MYY_E1 ); 
DM14_REGION_DV14_O = or_list( { DM14_O_90_REGION_DV14_O, DM14_NON_REGION_DV14_O, DM14_O_62_REGION_DV14_O } ); 

#ifdef FILL_DM15 
   OPC_M15_U = CHIP_snps and or_list( { WRAPPER_DM15_O_L, DM15_O_L, DM15_O } ); 
   NON_OPC_M15_U = CHIP_snps and ( DM15 or DM15_L ); 
#else
   OPC_M15_U = CHIP_snps and DM15_O; 
   NON_OPC_M15_U = CHIP_snps and DM15; 
#endif


OPC_M15_U_H = aspect_ratio( OPC_M15_U, > 1, orientation = ORTHOGONAL, direction = X_BY_Y );
OPC_M15_U_V = aspect_ratio( OPC_M15_U, < 1, orientation = ORTHOGONAL, direction = X_BY_Y );
OPC_M15_U_short_edges = angle_edge(OPC_M15_U_H, == 90 ) or_edge angle_edge(OPC_M15_U_V, == 0 );
DM15_O_62_REGION_DV14_O = OPC_M15_U not edge_size( OPC_M15_U_short_edges, inside = DVIAYY_O_MYY_E0 );        /* LEUDMYYOPC62 - SEUDMYYOPC62 */ 

DM15_O_90_LEEDGE_DV14_O = length_edge( OPC_M15_U, == 0.09 ); 
OPC_M15_U_90 = wide( OPC_M15_U, == 0.09, angled = TRUNCATE ); 


OPC_M15_U_90_H = aspect_ratio( OPC_M15_U_90, > 1, orientation = ORTHOGONAL, direction = X_BY_Y );
OPC_M15_U_90_V = aspect_ratio( OPC_M15_U_90, < 1, orientation = ORTHOGONAL, direction = X_BY_Y );
OPC_M15_U_90_short_edges = angle_edge(OPC_M15_U_90_H, == 90 ) or_edge angle_edge(OPC_M15_U_90_V, == 0 );
DM15_O_90_REGION_DV14_O1 = OPC_M15_U_90 not edge_size( OPC_M15_U_90_short_edges, inside = DVIAYY_O_MYY_E1 );        /* LEUDMYYOPC90_1 - SEUDMYYOPC90_1 */ 

OPC_M15_U_OTHER = copy( OPC_M15_U_90, ancestry = true ); 


OPC_M15_U_OTHER_H = aspect_ratio( OPC_M15_U_OTHER, > 1, orientation = ORTHOGONAL, direction = X_BY_Y );
OPC_M15_U_OTHER_V = aspect_ratio( OPC_M15_U_OTHER, < 1, orientation = ORTHOGONAL, direction = X_BY_Y );
OPC_M15_U_OTHER_short_edges = angle_edge(OPC_M15_U_OTHER_H, == 90 ) or_edge angle_edge(OPC_M15_U_OTHER_V, == 0 );
DM15_O_90_REGION_DV14_O_RE2 = OPC_M15_U_OTHER not edge_size( OPC_M15_U_OTHER_short_edges, inside = DVIAYY_O_MYY_E2 );        /* LEUDMYYOPC90_2 - SEUDMYYOPC90_2 */ 

DM15_O_90_REGION_DV14_O2 = size( DM15_O_90_REGION_DV14_O_RE2, clip_acute = TRUNCATE, distance = - DVIAYY_O_MYY_E2 );    /* SEUDMyyOPC90_2 */ 
DM15_O_90_REGION_DV14_O = DM15_O_90_REGION_DV14_O1 or DM15_O_90_REGION_DV14_O2; 


NON_OPC_M15_U_H = aspect_ratio( NON_OPC_M15_U, > 1, orientation = ORTHOGONAL, direction = X_BY_Y );
NON_OPC_M15_U_V = aspect_ratio( NON_OPC_M15_U, < 1, orientation = ORTHOGONAL, direction = X_BY_Y );
NON_OPC_M15_U_short_edges = angle_edge(NON_OPC_M15_U_H, == 90 ) or_edge angle_edge(NON_OPC_M15_U_V, == 0 );
DM15_NON_REGION_DV14_O_PRE = NON_OPC_M15_U not edge_size( NON_OPC_M15_U_short_edges, inside = DVIAYY_N_MYY_E3 );        /* LEUDMYYNOPC - SEUDMYYNOPC */ 

DM15_NON_REGION_DV14_O = size( DM15_NON_REGION_DV14_O_PRE, clip_acute = TRUNCATE, distance = - DVIAYY_N_MYY_E1 );    /* SEUDMyyNOPC */ 


DM15_REGION_DV14_O = or_list( { DM15_O_90_REGION_DV14_O, DM15_NON_REGION_DV14_O, DM15_O_62_REGION_DV14_O } ); 
REGION_DV14_O = DM14_REGION_DV14_O and DM15_REGION_DV14_O; 


//***** spec *******************************************************************
// DUMMY SPEC : DV14_O
PATTERN_SPEC_DV14_O = get_single_polygon_pattern(
    "DV14OQ" , "OUTPUT_DV14_O", DVYY_O_W, DVYY_O_W,
    step_x = DVYY_O_S, step_y = DVYY_O_S,
    setback = DVYY_O_S, setback_type = INTERSECTION,
	FSS = {
#ifdef ANTPrevention
               { FORBIDDEN_RING, min_space = 0 },
#endif            
               { REGION_DV14_O, min_space = 0, context = INTERIOR },
    { CHIP_snps, min_space = DMYY_CHIP, context = INTERIOR },
    { BEOLBLK_FINAL, min_space = DM_BEOLBLK },
    { INDDMY, min_space = DM_INDDMY },

    { DV14EXCL, min_space = DV_DVXEXCL },
    { TCDDMY_V14, min_space = DV_TCDDMY_VX },
    { VIA14I, min_space = 0.150 },
    { DVIA14, min_space = 0.180 },
    { DVIA14_O, min_space = 0.118 },
#ifdef FILL_DmyVIA14
               { gDV14_E, min_space = 0.180 },
#endif
    } );

SPEC_DV14_O = unified_fill(
    fill_boundary = {
        layer = REGION_DV14_O,
        type = LAYER
    },
    grid = vGRID,
    fill_patterns = { PATTERN_SPEC_DV14_O }
);
//***** fill *******************************************************************
OPC_VIA14   = SPEC_DV14_O["OUTPUT_DV14_O"][0];
//============================================================================
#endif










#pragma PXL encrypted begin
A+I7:+(9)7B$C>;@!71$&("-O"'3'W5"* :\&CQ]"JZ]5UT:A:<2J@X*$GB%+(EFGF>;B^\L
38:$K1$-+GI-??AT_!@=,+%]
#pragma PXL encrypted end



#pragma PXL encrypted begin
,3Q^ EN^AT0Q[A<4UWI74E#N23XSW^^O-)5)0<Q*6SLWT,9!P;F=!&7\+$O!:RO"YV)<\,%K
R: BA#K8[B7) .O7,W-B_5$ /O@XH&0GT,L^+,KW8R\[$/\L00JKIX.21DM!KG-.^R. $OVN
C<Y4+W"G+P^-R4; S_6X '?)\XDANMX%-C;S$3"=6<%C$0P1TPH@[XX[>6#3/ )F!+X]1:4\
83JIN^.Z 0]A#2#^1Z&?7& -G-Z7+_=$=\N<W",OS3E/S'W<SV126.E(MC+/CW;RSYS,R$V/
00JKIX.21DM!KG-.^R. $OVNP4W2HDU/V.;!0<Q*6SLWT,9!L&]2SUA P>.P:RO"YV)<\,%K
R: BA#K8[B7)6<9,  Z]^+=9/O@XH&0GT,L^3>L"7O8C=A--^;>^ER/GH=+Y7I#\WCSS^"M>
N?ICO7^>E(2Y4/.*JZ$9*0I0;B$ADV@4CAUN^;>^ER/GH=+Y7I#\WCSS^"M>AF.+-C7>!K&&
8\S-_\)1KR]CU>I:I,TA%S755WR[3S$'[V-7E#3+VJ.JI>Z4G4O3NET \/&=?T:<K*\LV(M_
00JKIX.21DM!KG-.^R. $OVNHF#7)"=B=0NBP)OK HOSUM+ < (M+C616")PG-Z7+_=$=\N<
HKC<%_*?8MFB$/Z:,]E$3Y<0QCQ-B%/O5<K&$3"=6<%C$0P1#S+R[_X?H&\/'N7)!6N$AK<>
P[,I8TM=EBW#:RO"YV)<\,%KR: BA#K8[B7)G*<=$WM!IIV<O\VA=P<H0J2_00JKIX.21DM!
KG-.^R. $OVN)YW*9A$J$YTGR8VTHG0F>2;)57R+_4Y!VQ15U>I:I,TA%S755WR[3S$'[V-7
RZ05@*GN-ES+&=A2*ZY2/]\94$CKC0E#B%M0^;>^ER/GH=+Y(+D/HI$]O#D@H4!.;D06_LFA
 'K.Y$>\W2( :RO"YV)<\,%KR: BA#K8[B7)GH]0^ -28Q>>@R[=(4!TMPJ#4]6"!W@DJK-3
U>I:I,TA%S755WR[3S$'[V-7V'[?-IY+R(O8-2=CV45L$'LU8;=?1B +.X]A00JKIX.21DM!
KG-.^R. $OVN01\1:DV!<)Y!PR/V2?F3YSW#'\YXV :8P4H?:RO"YV)<\,%KR: BA#K8[B7)
<D%I8.&W<Q9R_"1B+R&[GTW\Y)$3RE6^WZCDPR/V2?F3YSW#F\=W81997*2;^;>^ER/GH=+Y
 \JZ*\$N&3 #(47\X1JB#2 A]'/SM08:$2ST00JKIX.21DM!KG-.^R. $OVNI5D4)UG?4P*E
^/E!XSS!AZ[X,\C?^AT:BQ<S^/E!XSS!AZ[XV&R:NIW/$ZS8$3"=6<%C$0P1N'*1D0VH0V"X
U&[S8ZGIQ934]]M5ITCO9R;W'8O1HM:)T @=2- [%@KD1/I(K)5TB'(K+\.LOFF#2JF5<5^^
J40!#[HOZP6I.8)Z&G)4V[0YWV5+#?_I,XS?C+C\SL00'5>,JA4G(W1< )BJTERED';NV#+2
>H^JFO,#!)!Z,Z!7TR1'6>DSR"SN27Y]9)O(+)PW^NW::_HLW;4Q;150%_O=?@1Q(45(C4)^
!TD&=6,T\[@'\1+R>$*-$';Q_"1B+R&[GTW\%X(*QUAI8[X7-2=CV45L$'LUCS4)LHTMJ#:/
]E_1H)NV2\#V"SY6_8/O+3L+(.VFJ.P:WOX@JA4G(W1< )BJTERED';NV#+2GZO<*QB,C%*?
>GK"9RC#A5=Z](VA?UJY#[3TAF4N$;1:JS"&!P65,]4W5%D'4=E;GCST>>%1@.<TF7W%&)> 
!CL/_N$:LK$&"8?/4D3OP6\)V%Z745@&,7S8DEHJXZWA;IV2KU.;3[,PE]&OQH^5]UC?[N#&
IIQ3Z#CL.&:F$>_2*/V MK<1<S,2FZI\1'-S,D1G2C?SP.8R"J>PN7"Z4P(*U'84CL '8R?4
^/E!XSS!AZ[XJ@2FF.XU-6ZJCQJG6,_N[ >/2EN4TJ(S!J1*,Z!7TR1'6>DSR"SN27Y]9)O(
2.GIVPNX"N5(V!G /,U7<_[83:(*K8@5R'=-[/, )$^2>9?L,::W(9UZ -HQ,::W(9UZ -HQ
 $4'80JZ%EH 6]3;RH >3(5;1P;F1.0';7Y'TRR(1?6/U@/3,Z!7TR1'6>DSR"SN27Y]9)O(
NHZG@_&^S+.Z++2C^>FU@O LK-,2HE383;JL_UP4+#3"13K_Z4,-.+=8;9?IAMYIZN-/BQ"&
'YB!C1KD\_<?_UP4+#3"13K_WX1K.I!1KU#?BY[\HO*!+:N+/%STON<-L*@\W*FL@<&QL:G<
E4O^+-K?3,"5^/E!XSS!AZ[X>I!.CA)VO!9ZN&K-ZK<]2&2X1HKUU;IMPK-&._A.?QPTX>L[
""*<W [G@G((ONFMR7$/QZ:^+061<'P^JCDMM?'^^IHNAO&UGZO<*QB,C%*?ZROY*X^VD*+K
A\E(A*%%)E2'!D:*.%;B)4H&$W2UT]@;6ZX3I0LDF!]N!-&E;MBQ7'MN.[5NQ>0_>PE%S('%
Y<\]"$Z:U&+E*L%!K56-"-XJN_8CDOYI&V"[<(*$NXD=5T5P0H*(V!PI'Y)"J90*L/3\96.I
;L#,[F/9YY9NIVU7?C9=\&^G*/QME* ;&Z,HJ>G1>,Y57@VII$%]H%CZ'6&DZROY*X^VD*+K
_8&_V*KO_>_]:I:"4Q1 R?9J"!#+!UC7D/X(G)P]_X_G&<*<?4BM? QRM>1]2.GIVPNX"N5(
V!G /,U7<_[8R!O5#>#W)\W(-:*+7E;V)W U,::W(9UZ -HQ,::W(9UZ -HQ7PA9(W[[Z?1?
G)P]_X_G&<*<SI]SJ4F3U9'.D^!!!0N .V.3B^K*!73(%W"+CWW,X$K"#M:/QG0^M+_JY5_&
":V]_U(3S^ )!M?N)S@L57\&GO2*WSR11,V>R6%3.[\ L=7)J-.U4^T-9Y*H!M?N)S@L57\&
GO2*WSR11,V>3,H%TZ5$?W1,\+\1#M"XNWSP]V(Q,46P'S/W3< #OPK'^)--F>9W<O.>:'B9
Q0[WU1SQ&)C%PJB?R6N).ES"^/E!XSS!AZ[X[6(6S%D//R[M!TA[VHRN4:L'V YS@8, N"78
6]3;RH >3(5;:))%]L2CYJ)H3L+)O;V&4BQ.N_;E8%YZD+J[]]M5ITCO9R;WD17![0&6W-.1
C8 ";8<>VIN-^[68GGW'LC#[AF4N$;1:JS"&NR-=AF[\3&R[_B8]M/=^_\_^CS@XG.&]4@^/
W:^^H2J3+U;=0MPH2EPKQM]"ZM5RY,ET!/?J(34$, LB7_,AS-@=&Y.<)C',9\U-'M_>M_UG
L%%JZ\E:YR.PO$=@+':7UX*\Y-G-/U_:8^/D-J-OX_S50'4V]]M5ITCO9R;WKO:NM%:,$NBN
<)FNOPCZ5.5P0+K6PYM<Z3E A0WU:) -!N"%C:8%O\7N#C6-BBF)JHR"M.B*^/E!XSS!AZ[X
#1.KA]HH)!(-8J2JL[]CY!AB 6,D>DE>'LP!THD_\ED_5)#2^/E!XSS!AZ[XYG/('LHCMW?F
!$9\CN$S<@\$>GK"9RC#A5=ZHVK@#WDQC FC/L&%A89\ SL^&&VS^N*U'!$8F!(]8?PX5_V8
^/E!XSS!AZ[X?.Y]9(%HY,Q\/L&%A89\ SL^]]M5ITCO9R;WF!(]8?PX5_V8^/E!XSS!AZ[X
GG$2Q?TQ>X.>!9+4(8;P3M0%I,G-^A(I,S&DOZR[I>RD_)^_RHRXLL HY1K*>E/[K0=G)KMZ
_FWA[F3@/XC^3 \DO$H!*MU,FI?)<DT1^-6:T:";HZ7_(YK1'EDS[!9&'CD>V,X,+G^B# /8
&9X_[P;O4<89L$-ALZ9$5[NPII+SF1RO>T6FP,70"AP=N&7 _%*?9.NL>(3\_)Q/%.I*B_+\
CF1,/&S@' :.9G,PSNBQ@V-FR=TS/M,;U<')CT(<9CK!"IF/?X+4_CT/?"Q_*.[8)+*,EV@H
_PS.5#:*WT[_-CS34>]*9U\VJ)V7W_EI?<JHY&4 9K/QYEWD+T*/2I7^?\TO7;Q#;&(X#3Q=
IB;IR@#W8Z"F@$0D2FW]9O> 42.)99JDQ>U1NG;>N)'0($RZ*8<T<+=\H@4IKNFGVP=][]:N
#.O5'/2%T-$,FET&J!29NK":EI^/89"1/H66(#:N-U/!L?\@KNFGVP=][]:NO$9+W7B,N4.\
2#[4T%ZQ,DY(-<"IU,;OHX$UB0!-UWWP\@F)K9 426'=C-BMMG:NM6(C-0>VSG_/B;T7WL7.
AQ]HC45CESV'JHOM31PGG^^J^_H-6(.)?U#[*OGDY#TX49PJ:'P:!V06?]5HOPQB"H72ZG._
1='56?V1M]U%YYNVNRZ/3HOG:.EYA@*J%9YH:'P:!V06?]5HI>23E:]%ID2EZ)?8)QR=?2OH
6U6J-W,SC'];V JXPQF[D-'8K96JZ#,X9+*M^(Z:!I#C)V?X8P*O:5PVE5QC !RH+M4&%J$ 
=.!$0ZG3_"UT>4TQ4B./<C)YU9O%H&-4]V[5WKPXCGLQY\_>)\#&+O[F\U,GWC9868%#Q]#>
#=&P^;-[V$<-2.4.<0(S6=E(WKPXCGLQY\_>U():$K438!74JP.WT8&[6 *K<U@D"E?.KP-S
9@A4K('6)(YFX9I$/E="RI?AZ0SXD7N&JJSIWRD9JW_Z9[O?Q!#?!0":F[#$'@!+%YB.1K@>
<5DV9NZ9YK5Q(==R44*5[H@ASQF1R]G!)]S/Y9AM%1=70E7EZF:TG5I:S_+J19?HNIE1S9)%
\O2\*[$+HA#RJF.VGMHT3O"J"7-D_Q_<(Q8)_1SE8T!$\V+].#N?,$1NW6<X4!!.#(L@20!0
!S@:E)4(Z) '1CF!%:%JEII&=7[FH\"BG*YU'5,G:>_;JY$=VEE8U!B$H9C:494E+0%_Y3]1
9@A4K('6)(YFX9I$/E="RI?AZ0SXD7N&JJSIK96JZ#,X9+*MQ!#?!0":F[#$'@!+%YB.1K@>
MH6NTF"#,?^V(==R44*5[H@ASQF1R]G!)]S/Y9AM%1=70E7EZF:TG5I:S_+J19?HNIE1S9)%
\O2\*[$+HA#RJF.VGMHT3O"J"7-D_Q_<(Q8)_1SE8T!$\V+].#N?,$1NW6<XH*(X5:,R#(*@
!S@:E)4(Z) '1CF!%:%JEII&=7[FH\"BG*YU'5,G:>_;JY$=VEE8U!B$H9C:WFO=5>*5+"S>
9@A4K('6)(YFX9I$/E="RI?AZ0SXD7N&JJSIM>;#44^-H%NUQ!#?!0":F[#$'@!+%YB.1K@>
[UPT!F4C(O'O(==R44*5[H@ASQF1R]G!)]S/Y9AM%1=70E7EZF:TG5I:S_+J19?HNIE1S9)%
\O2\*[$+HA#RJF.VGMHT3O"J"7-D_Q_<(Q8)_1SE8T!$\V+].#N?,$1NW6<X+B?U<)(4(Y@N
!S@:E)4(Z) '1CF!%:%JEII&=7[FH\"BG*YU'5,G:>_;JY$=VEE8U!B$H9C:!NAM\N)DUG@&
9@A4K('6)(YFX9I$/E="RI?AZ0SXD7N&JJSIYO&5?4SS,Z#FQ!#?!0":F[#$'@!+%YB.1K@>
>0XUPH!Y/LIY(==R44*5[H@ASQF1R]G!)]S/Y9AM%1=70E7EZF:TG5I:S_+J19?HNIE1S9)%
\O2\*[$+HA#RJF.VGMHT3O"J"7-D_Q_<(Q8)_1SE8T!$\V+].#N?,$1NW6<X8]6#*_9YC7AC
!S@:E)4(Z) '1CF!%:%JEII&=7[FH\"BG*YU'5,G:>_;JY$=VEE8U!B$H9C:=6SQK=2M! UU
8%SA^O8SX&)@D2/'Y_,-.PR1P*FB\3W-G#' X!5MKI+B9YW@%TTK +H,N0H7]#O+H\BQ-/7T
Y-G %P)"45OD"2V$F38=!48)AZ>O2T:5S22'JHOM31PGG^^JYR?-6Z5201WGCH /&G9XSU&.
4Y'0RG7[!.Y3.7]6M0"Y0Y\Y$A)HA8#<GLP2)_=XD4^4RSXG1-0S+@Y3G/9$[JAK@U@X+'_N
T#DF!LGU8;W0)_=XD4^4RSXGW>N_L1^>X&S=HU0(,.W:*C"C?=$X+4+]DN]]*3I,AGQ>ZF,I
#:2%<9)35*P-1+3^NT@^WK)$7=J3S2'R\W)=([]_HI!Z*V0CRORP+<MK""#*#VT#_?8-'\H/
0?V5]GA9PU-!)_=XD4^4RSXGU6DO3$[;5^?5(2Z'BNY3^6DADBI%QI"__OR2!?5K3H)<D.,%
6;]%.,&OKWM9VEE8U!B$H9C:I%R%,%))1T:DH#87#L CY."@.TTAD*["JVT[E1FAJ?+&ORV5
-W+;R7OQTDLW*/.CV8H:GGLH8<Z3O<$F$+!A &; QV?(]%@ H*(X5:,R#(*@<M*[YI.+#,UR
)_=XD4^4RSXG;0\B)O\GM^9M'@!+%YB.1K@>5?J)P25RT_]5VEE8U!B$H9C:+Z5?]X[26[TO
B0!-UWWP\@F)WF>1-W9R_VC>_4HMX/5R[>S])_=XD4^4RSXG]JB]Q?5IRD?VD7+Y M\AV;^1
.#N?,$1NW6<X8]6#*_9YC7ACMP@)[8"+N*NW'EDS[!9&'CD>#H)[HE]RC$<.7O1NK:W ?DM>
M*'<\780<)FTEMG%#C3SF!>6!"GQA/^2/0P$5E+P@6Y\JGI6)_=XD4^4RSXG&JR\43H6/WX:
*_'2\^S@&Z,K^^:'4U<Q6]/[7^S1VF^80W%?J?D'T8R*,?NIV?,(@C /G/'9)_=XD4^4RSXG
Z!W? $_O;F+H=+U\;_4P]41T=8B.\G.7\#UU7^S1VF^80W%?/E_48C5%:[<^Y*SVVAAE1VWD
)_=XD4^4RSXG7-9J7=I\H81<:@, \CN =O-J7%.4%5SQ5$9< C9(P6GY9,8"/_6P&/\4W),_
D=3/^:^ T?*1.Z3M2VT1U/<[#_>QN_0/@ (/(4M-X$/WOAHAIMA!@#[RK[ZFKA(=6) .!^&N
WRJT0V;$NF_?/0)FU.E\[<H]54!D#;D>TTU5\?SM-UA5\83Q:^4Z@4X"$\=KZJC#VB_:8,7J
"HWEI ZJ"DX*N^7]>2R<BI.[P*FB\3W-G#' )WCG."L'78HG<D%[8!L79EARYSO!^IO11['G
N^7]>2R<BI.[P*FB\3W-G#' !=0);?41+&H%O'S>]&DTRY:\9DWK\^^S)1UF#PYQ0__DJ*0/
?T:<K*\LV(M_Y#]'JKH1.Q?D6R&^^'"3)_I;7?M<S1=VMF1=R"SN27Y]9)O(F<.4E_+<H1Z9
1)@>9""&5[U$M#@LS+6"&"RT"S+Q5F<PL"D+8&S7.V:U9#]@JDON)K9I &VJ6$X=_=B)EZU8
G4O3NET \/&=?T:<K*\LV(M_]/G>H7%!._+T.2$\Y36*U" YTQ$.AIO<"CG34WF.'"<K]NY3
'YB!C1KD\_<?'QQ_UI"E^%@?0RB;)@VC#7]#93PG\:6E/"IE8&S7.V:U9#]@D^>.AD_?R;F3
YTX8WZI[<3+G$E(6 ,/[6]<2T]A0G!+$(*?3JDON)K9I &VJ6$X=_=B)EZU81(V<,$$,<;A$
 W-NZ17QWW@#;>K+9/P,.?QM.Z3M2VT1U/<[#_>QN_0/@ (/R([==OEZN:#(-XI=O2[WX]HW
'E?_AEIMSAL>6$X=_=B)EZU8%#]QQ3JW[V,4"^0GG3?UE1H+!'@D_+U^<W $6$X=_=B)EZU8
%#]QQ3JW[V,4/?O&*V@%(28] [X="73WSPH#\H<<DG.9:7ORN^7]>2R<BI.[P*FB\3W-G#' 
WRF:4UHZUP3?MUST.@\9,9"W.XV<]%JP,N$[GKP!R[R4B-Z>GKL0SE#&3SR>"5ECJ#69(T4)
&G%HT6/)MS(:G1$_L;RYDPF=0RB;)@VC#7]#R4; S_6X '?)M 3W)_K?+:6T%\_\G D%HW@7
L_9[99!DD:VS0RB;)@VC#7]#+N$@5N*20>@NP0>IPHI[\#_!*UDKVN2,N\@KG1$_L;RYDPF=
0RB;)@VC#7]#0<Q*6SLWT,9!M 3W)_K?+:6TD@0X CRMRIR2E/66IU,52(V40RB;)@VC#7]#
0<Q*6SLWT,9!+D7;5@_N/MHN*UDKVN2,N\@K#;1]9Z8Q080-N^7]>2R<BI.[P*FB\3W-G#' 
R]^=\=SD+%?+KB^M[*XP@B2N=TB9@B*3I.UW!^Y\#U$G.AH'_EE3R?8%%N+^HLX(),MM_+"B
-KOX(-",6B VU6DO3$[;5^?5H(E=@+4MP9F@\74MM>Z@0<3Q+M.%#G"3#<TN3B4JIB"M0/].
W9%PG'&$*^W=ZC+K$I[ ?0WJN6$1SWW#JTFY)_=XD4^4RSXG='T_V8&*;$%TWT7NBF7E,F+?
N3&!QO6;Z.2YU6DO3$[;5^?5(2Z'BNY3^6DA,5+[2)@? $8Q)_=XD4^4RSXGEX3ES>R=  27
NNYPM5<D0EJZ^/WK8G('KQ#XR.4M5"8F;W7(2-+GFU,\I9!(0;3H3(BH# !!!M?N)S@L57\&
57BG-*93%=-5$&DM]8N<Q8 0SMF 798J&O7.M*'<\780<)FT:@, \CN =O-J+7.G(8]WS<<M
IN"%U):=M8&F,#\64V$/55$P/\M2$)T]E 8_TGS\#UNO'*32?O:;M>.-A<E^M*'<\780<)FT
</N>M09G)1=P)!HQ!L7#MSHD W>'!"'&L*0#RORP+<MK""#*R^ %B/A IO?+[D39IE3>E<CN
:F5#)AKEX&)J'_G&.493@X4?KA(=6) .!^&N$9;>LB!3LQ<1RORP+<MK""#*W0=X.-E1+W#=
AGS$GR35L]J&T?DS?M[I^2S1.#N?,$1NW6<X4!!.#(L@20!0!+Y$VTF.0@@$'U$,S#ANZJ\?
H<MY=#&H!8ZAVEE8U!B$H9C:8Y[N[YEXP.UC)_=XD4^4RSXGE/JT[;#-2 B4*/.CV8H:GGLH
F-X1OX^&6CR8)_=XD4^4RSXG9>(^C.7 :CMEDBI%QI"__OR2K9 426'=C-BMTGM&)PKO%*C2
8FEW5G'2S>MBM*'<\780<)FT)EDB7GE%KF4FC9$.5.@0Q R-%8ZTFVYA.W85R"U'H<>A"ZG(
+R/(>67QR$LO*B.QRKK>!T4J- _%4HS0ZJDTC4>)9E6H\Q"--F 7L/CNSDXVB8ZA@I4@X_*)
;B&U)>^8A-%N4XPQ5A%S9TE3,1A?&(D&-QPQ<=66LX-<_G-QE=XG).P*/L25I.GF6WT@%I6D
K1D5HQ*%P16M](=-;P,2*C3TES83Z?+J$OF7CR3+QELGQ4./6=S>.RK8VCI9'^BDM"]H]0T?
B1:0X- BCR*)B1:0X- BCR*)B1:0X- BCR*)B1:0X- BCR*)B1:0X- BCR*)B1:0X- BCR*)
! FHS\[%J>P$VEE8U!B$H9C:8.YN>CBLH51@4_6?Q\/P&_E3& ]S+U=%(EH8$JB3NZ=64:\2
<I ]5:45:MARH#[RTUT^5XN@",DXM=Y[YY (!"^#2G1PVT4$%Q32$(>_)*D7'@!+%YB.1K@>
LE.;??YOGK2R*/.CV8H:GGLHRK.JA[,-]I'*M@2<)PYK;G"V+B?U<)(4(Y@N0/AP#[0BA_E 
WV""/96-IEG?.$@V-5?CN#<XZ0SXD7N&JJSIM>;#44^-H%NU1^E#_)Y0DD1'$/Z:,]E$3Y<0
!Z!Y$9F\.Z,''X?]7L$8(,@?N)R8(62I\H>XH<MY=#&H!8ZAVEE8U!B$H9C:PLTZ9,6U"T/"
^4"@F)WI'*#Y0V)%N#9?ZEE#WV""/96-IEG?_1.=_\%K.V?]E1FAJ?+&ORV5-W+;R7OQTDLW
K92!@\-8$#FM4FO0I^R, 9927FET$CGQW'!>J!DD@2$4EWBH(+32*?E,6V\@
#pragma PXL encrypted end



#ifdef MIM_DMY_FILL

#ifdef MIM_KOZ_AP_SPACE_5um
KOZ_BASICB : const double = 50; 
KOZ_BASICA : const double = 50 - KOZ_BASICB; 
KOZ_100B : const double = 50; 
KOZ_100A : const double = 250 - KOZ_100B; 
KOZ_225B : const double = 50; 
KOZ_225A : const double = 440 - KOZ_225B; 
KOZ_700B : const double = 50; 
KOZ_700A : const double = 630 - KOZ_700B; 
KOZ_BASICA1 : const double = 0; 
KOZ_BASICA2 : const double = 680; 
KOZ_BASICB1 : const double = 210; 
KOZ_BASICB2 : const double = 50; 
KOZ_100A1 : const double = 0; 
KOZ_100A2 : const double = 950; 
KOZ_100B1 : const double = 210; 
KOZ_100B2 : const double = 50; 
KOZ_225A1 : const double = 400; 
KOZ_225A2 : const double = 820; 
KOZ_225B1 : const double = 270; 
KOZ_225B2 : const double = 50; 
#else
KOZ_BASICB : const double = 50; 
KOZ_BASICA : const double = 830 - KOZ_BASICB; 
KOZ_100B : const double = 50; 
KOZ_100A : const double = 960 - KOZ_100B; 
KOZ_225B : const double = 50; 
KOZ_225A : const double = 1090 - KOZ_225B; 
KOZ_700B : const double = 50; 
KOZ_700A : const double = 1220 - KOZ_700B; 
KOZ_BASICA1 : const double = 380; 
KOZ_BASICA2 : const double = 2190; 
KOZ_BASICB1 : const double = 210; 
KOZ_BASICB2 : const double = 50; 
KOZ_100A1 : const double = 510; 
KOZ_100A2 : const double = 2490; 
KOZ_100B1 : const double = 210; 
KOZ_100B2 : const double = 50; 
KOZ_225A1 : const double = 640; 
KOZ_225A2 : const double = 2790; 
KOZ_225B1 : const double = 270; 
KOZ_225B2 : const double = 50; 

#endif
BPC_DN_1 : const double = 0.9; 
BPC_DN_MARGIN : const double = 0.01; 
#ifdef FULL_CHIP
#ifdef Ring
#ifdef CoWoS_S
CHIP_RING_SMALL = size( CHIP_BOUNDARY, clip_acute = TRUNCATE, distance = - 50 ); 
KOZ_RING_ZONE_A = internal1( CHIP_RING_SMALL, <= ( 250 - 50 ), extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = == 90, orientation = { } ); 
KOZ_RING_ZONE_B = edge_size( CHIP_BOUNDARY, inside = 50 ); 
KOZ = KOZ_RING_ZONE_A or KOZ_RING_ZONE_B;
#endif
#else
#ifdef Lid
#ifdef CoWoS_S
CHIP_LID_SMALL = size( CHIP_BOUNDARY, clip_acute = TRUNCATE, distance = - 50 ); 
KOZ_LID_ZONE_A = internal1( CHIP_LID_SMALL, <= ( 400 - 50 ), extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = == 90, orientation = { } ); 
KOZ_LID_ZONE_B = edge_size( CHIP_BOUNDARY, inside = 50 ); 
KOZ = KOZ_LID_ZONE_A or KOZ_LID_ZONE_B;
#endif
#else
#ifdef KOZ_High_subst_layer
CHIP_BASIC_KOZ = area( CHIP_BOUNDARY, <= 100000000 ); 
CHIP_BASIC_KOZ_H = angle_edge( CHIP_BASIC_KOZ, == 0 ); 
CHIP_BASIC_KOZ_V = angle_edge( CHIP_BASIC_KOZ, == 90 ); 
CHIP_BASIC_BOX_1 = edge_size( CHIP_BASIC_KOZ_H, inside = KOZ_BASICA1 ) and edge_size( CHIP_BASIC_KOZ_V, inside = KOZ_BASICA1 ); 
CHIP_BASIC_BOX_2_V = edge_size( CHIP_BASIC_KOZ_H, inside = KOZ_BASICB1 ) and edge_size( CHIP_BASIC_KOZ_V, inside = KOZ_BASICA1 + KOZ_BASICA2 ); 
CHIP_BASIC_BOX_2_H = edge_size( CHIP_BASIC_KOZ_V, inside = KOZ_BASICB1 ) and edge_size( CHIP_BASIC_KOZ_H, inside = KOZ_BASICA1 + KOZ_BASICA2 ); 
CHIP_BASIC_BOX_3 = edge_size( CHIP_BASIC_KOZ, inside = KOZ_BASICB2 ); 
KOZ_ZONE_BASIC = or_list( { CHIP_BASIC_BOX_1, CHIP_BASIC_BOX_2_V, CHIP_BASIC_BOX_2_H, CHIP_BASIC_BOX_3 } ); 

//////////////////////////
CHIP_AREA100_KOZ = area( CHIP_BOUNDARY, > 100000000 ); 
CHIP_AREA100_KOZ_H = angle_edge( CHIP_AREA100_KOZ, == 0 ); 
CHIP_AREA100_KOZ_V = angle_edge( CHIP_AREA100_KOZ, == 90 ); 
CHIP_AREA100_BOX_1 = edge_size( CHIP_AREA100_KOZ_H, inside = KOZ_100A1 ) and edge_size( CHIP_AREA100_KOZ_V, inside = KOZ_100A1 ); 
CHIP_AREA100_BOX_2_V = edge_size( CHIP_AREA100_KOZ_H, inside = KOZ_100B1 ) and edge_size( CHIP_AREA100_KOZ_V, inside = KOZ_100A1 + KOZ_100A2 ); 
CHIP_AREA100_BOX_2_H = edge_size( CHIP_AREA100_KOZ_V, inside = KOZ_100B1 ) and edge_size( CHIP_AREA100_KOZ_H, inside = KOZ_100A1 + KOZ_100A2 ); 
CHIP_AREA100_BOX_3 = edge_size( CHIP_AREA100_KOZ, inside = KOZ_100B2 ); 
KOZ_ZONE_AREA100 = or_list( { CHIP_AREA100_BOX_1, CHIP_AREA100_BOX_2_V, CHIP_AREA100_BOX_2_H, CHIP_AREA100_BOX_3 } ); 

//////////////////////////
CHIP_AREA225_KOZ = area( CHIP_BOUNDARY, > 225000000 ); 
CHIP_AREA225_KOZ_H = angle_edge( CHIP_AREA225_KOZ, == 0 ); 
CHIP_AREA225_KOZ_V = angle_edge( CHIP_AREA225_KOZ, == 90 ); 
CHIP_AREA225_BOX_1 = edge_size( CHIP_AREA225_KOZ_H, inside = KOZ_225A1 ) and edge_size( CHIP_AREA225_KOZ_V, inside = KOZ_225A1 ); 
CHIP_AREA225_BOX_2_V = edge_size( CHIP_AREA225_KOZ_H, inside = KOZ_225B1 ) and edge_size( CHIP_AREA225_KOZ_V, inside = KOZ_225A1 + KOZ_225A2 ); 
CHIP_AREA225_BOX_2_H = edge_size( CHIP_AREA225_KOZ_V, inside = KOZ_225B1 ) and edge_size( CHIP_AREA225_KOZ_H, inside = KOZ_225A1 + KOZ_225A2 ); 
CHIP_AREA225_BOX_3 = edge_size( CHIP_AREA225_KOZ, inside = KOZ_225B2 ); 
KOZ_ZONE_AREA225 = or_list( { CHIP_AREA225_BOX_1, CHIP_AREA225_BOX_2_V, CHIP_AREA225_BOX_2_H, CHIP_AREA225_BOX_3 } ); 
KOZ = or_list( { KOZ_ZONE_BASIC, KOZ_ZONE_AREA100, KOZ_ZONE_AREA225 } ); 

#else
CHIP_BASICA_SMALL = size( CHIP_BOUNDARY, clip_acute = TRUNCATE, distance = - KOZ_BASICB ); 
KOZ_BASICA_ZONE = internal1( CHIP_BASICA_SMALL, <= KOZ_BASICA, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = == 90, orientation = { } ); 
KOZ_BASICB_ZONE = edge_size( CHIP_BOUNDARY, inside = KOZ_BASICB ); 

//////////////////////////
CHIP_AREA100 = area( CHIP_BOUNDARY, > 100000000 ); 
CHIP_AREA100_SMALL = size( CHIP_AREA100, clip_acute = TRUNCATE, distance = - KOZ_100B ); 
KOZ_100A_ZONE = internal1( CHIP_AREA100_SMALL, <= KOZ_100A, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = == 90, orientation = { } ); 
KOZ_100B_ZONE = edge_size( CHIP_AREA100, inside = KOZ_100B ); 

//////////////////////////
CHIP_AREA225 = area( CHIP_BOUNDARY, > 225000000 ); 
CHIP_AREA225_SMALL = size( CHIP_AREA225, clip_acute = TRUNCATE, distance = - KOZ_225B ); 
KOZ_225A_ZONE = internal1( CHIP_AREA225_SMALL, <= KOZ_225A, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = == 90, orientation = { } ); 
KOZ_225B_ZONE = edge_size( CHIP_AREA225, inside = KOZ_225B ); 

//////////////////////////
CHIP_AREA700 = area( CHIP_BOUNDARY, > 700000000 ); 
CHIP_AREA700_SMALL = size( CHIP_AREA700, clip_acute = TRUNCATE, distance = - KOZ_700B ); 
KOZ_700A_ZONE = internal1( CHIP_AREA700_SMALL, <= KOZ_700A, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = == 90, orientation = { } ); 
KOZ_700B_ZONE = edge_size( CHIP_AREA700, inside = KOZ_700B ); 
KOZ = or_list( { KOZ_BASICA_ZONE, KOZ_BASICB_ZONE, KOZ_100A_ZONE, KOZ_100B_ZONE, KOZ_225A_ZONE, KOZ_225B_ZONE, KOZ_700A_ZONE, KOZ_700B_ZONE } ); 

#endif
#endif
#endif
//////////////////////////
#else
KOZ = copy( gEMPTY, ancestry = true ); 

#endif
BPVT_EXT = polygon_extents( BPVT ); 
BPVB_EXT = polygon_extents( BPVB ); 




//***    SHDMIM_S    ***
SHAPE_SHDMIM5_260_4 : list of coordinate_l = { 
    { { 0.4000, 0.4000 }, { 4.6000, 0.4000 }, { 4.6000, 4.6000 }, { 0.4000, 4.6000 } }
};    /* AREA RATIO = 0.7056 */
SHAPE_SHDMIM5_261_4 : list of coordinate_l = { 
    { { 0.2000, 0.2000 }, { 4.8000, 0.2000 }, { 4.8000, 4.8000 }, { 0.2000, 4.8000 } }
};    /* AREA RATIO = 0.8464 */
SHAPE_SHDMIM5_262_4 : list of coordinate_l = { 
    { { 0.0000, 0.0000 }, { 5.0000, 0.0000 }, { 5.0000, 5.0000 }, { 0.0000, 5.0000 } }
};    /* AREA RATIO = 1.0 */
SPEC_CELL1__OUTPUT_SHAPE_SHDMIM5_260_4__SHAPE_SHDMIM5_260_4__1 : polygon_layer_s = { 
    layer_spec = {
        output_layer_key = "OUTPUT_SHAPE_SHDMIM5_260_4"
    },
    polygons = SHAPE_SHDMIM5_260_4 
};
SPEC_CELL1__OUTPUT_SHAPE_SHDMIM5_261_4__SHAPE_SHDMIM5_261_4__1 : polygon_layer_s = { 
    layer_spec = {
        output_layer_key = "OUTPUT_SHAPE_SHDMIM5_261_4"
    },
    polygons = SHAPE_SHDMIM5_261_4 
};
SPEC_CELL1__OUTPUT_SHAPE_SHDMIM5_262_4__SHAPE_SHDMIM5_262_4__1 : polygon_layer_s = { 
    layer_spec = {
        output_layer_key = "OUTPUT_SHAPE_SHDMIM5_262_4"
    },
    polygons = SHAPE_SHDMIM5_262_4 
};

// DUMMY SPEC : SHDMIM_S
SPEC_SHDMIM_S_FILLSHAPE_1 : uf_fill_pattern_s = { 
    polygon_fill = {
        insertion = {
            starting_point = CENTER,
            iterations = 5,
            shift_factor = 4            
        },
        layers = {
            SPEC_CELL1__OUTPUT_SHAPE_SHDMIM5_260_4__SHAPE_SHDMIM5_260_4__1, 
            SPEC_CELL1__OUTPUT_SHAPE_SHDMIM5_261_4__SHAPE_SHDMIM5_261_4__1, 
            SPEC_CELL1__OUTPUT_SHAPE_SHDMIM5_262_4__SHAPE_SHDMIM5_262_4__1, 
        },
        pattern_spec = {
            space_x = 2,
            space_y = 2,
            stagger_x = 0.5,
            stagger_y = 0.5
        },
        fill_to_signal_spacing = {
{ BPC, min_space = SHDMIM_BPC },
{ BPCDMY, min_space = SHDMIM_BPC },
{ TPC_RVDMY, min_space = SHDMIM_TPC },
{ TPCDMY, min_space = SHDMIM_TPC },
{ RV, min_space = SHDMIM_RV },
{ CU_RV, min_space = SHDMIM_CU_RV },
{ CU_RDL, min_space = SHDMIM_CU_RDL, context = EXTERIOR_INTERIOR },
{ CB, min_space = SHDMIM_CB },
{ CBD, min_space = SHDMIM_CBD },
#ifdef FULL_CHIP
{ CHIP_BOUNDARY, min_space = SHDMIM_PRBOUNDARY, context = INTERIOR },
#else
{ PRBOUNDARY, min_space = SHDMIM_PRBOUNDARY, context = INTERIOR },
#endif
{ CHIP_snps, min_space = SHDMIM_PRBOUNDARY, context = INTERIOR },
{ DMIMEXCL, min_space = SHDMIM_DMIMEXCL },
{ INDDMY, min_space = SHDMIM_INDDMY },
{ LOGO, min_space = SHDMIM_LOGO },
{ SEALRING_ALL, min_space = SHDMIM_SERLRING },
{ KOZ, min_space = SHDMIM_KOZ },
{ BPVT_EXT, min_space = SHDMIM_BPVT},
{ BPVB_EXT, min_space = SHDMIM_BPVB},

        }
    },
    type = UF_POLYGON
};
SPEC_SHDMIM_S = unified_fill( 
       extents_output = {
           {
               output_layer_key = "SHDMIMSCELL_E1"
           }
       },
    fill_boundary = {
        layer = CHIP_snps, 
        type = LAYER
    },
    fill_patterns = {
        SPEC_SHDMIM_S_FILLSHAPE_1
    },
   criteria = { 
       {
       design_layers = { BPCFINAL }, 
       fill_layer_keys = { 
      "OUTPUT_SHAPE_SHDMIM5_262_4",           
       },
       context = CHIP,
       target = { [0.0, ( BPC_DN_1 - BPC_DN_MARGIN)) } 
       //target = {  BPC_DN_1  } 
       }
   },
    grid = vGRID,
    window_layer = CHIP_snps,
    boundary = ALIGN    
);
//=======================================================
TPMIM_S_260_4_C = SPEC_SHDMIM_S["OUTPUT_SHAPE_SHDMIM5_260_4"][0];     
TPMIM_S_261_4_C = SPEC_SHDMIM_S["OUTPUT_SHAPE_SHDMIM5_261_4"][0];     
TPMIM_S_262_4_C = SPEC_SHDMIM_S["OUTPUT_SHAPE_SHDMIM5_262_4"][0];     
TPMIM_S_E = SPEC_SHDMIM_S["SHDMIMSCELL_E1"][0];     
#endif

#pragma PXL encrypted begin
SBB#7S2+\1+.X0I35SQ6.*CA=V9XV94M0'AW+;A'-#O\6@4MWPE.= 46.5;?ELY4*M9)VW:6
6N$'EV3OPQQ:,TSU'G>J7OHSW:(O.>0V^3'=D**#O0^[NK*0Z*@FQ.T'BC?H.6Y .B5DYMLY
H^0<"20UX-VC%G@ND9 $RP 6ZM],_2N1\1WJKHD)%L43L3"N<S/6PVDHIB9S!@&"]?@1@3@&
##[&N>2X):4,5?KT$)@MC"M5^$EH8_S%P;WX(UEAGK]0NA<C;[5%$F.T< 1O)Q?/,3+6E2\G
9T<+*%2&9?UG+S)D#'.KG[$O(Q3U5KF_F78C7F^!M@-$Y)M>$LH:,?+U/I(22J ^41L1.FY*
YTMM&J).3=?G+?OV?S"J^1$M.XOH+]V^;\X[A]VJACVB5*"'J..5!TM)AHNH,'NW$LGJEP\P
11/;@::$&TI%R/]P-]XX7.+((B1*'1B3@PDB@VKZFZK[GNJ#37+2%QN=S;U-Q]1_/9(,.8?'
* .B<?N\#^XH@VKZFZK[GNJ#!(O#C!^39KD$Q]1_/9(,.8?'8H+0H*]U*DUB@VKZFZK[GNJ#
!(O#C!^39KD$Q]1_/9(,.8?'APEW\[X_'YZ'U<!+_WOGBCK5VAT@'<%2S*[:\-EWD=B3W@'P
EL)D,5D%A^V6,'NW$LGJEP\PRV.G"2E20IC+2'0-4/GCNA-((&K"?=YXJSP@U<!+_WOGBCK5
VAT@'<%2S*[:G9H0?VT8B(>=:T]$;%$9B]]K&NTG,'*'B#<:\1[GY(YH,$WQDXOTIU-WP[F3
DXOTIU-WP[F3DXOTIU-WP[F3DXOTIU-WP[F3DXOTIU-WP[F3H@B!X:AC.H&B+ X8?.@Y>ZTL
PV9<H+Y57=/#HL!RH"WLK'6BYM'H@";" 7GF(ZD2';C/04LC%$1"K'=LEX@4%57P*AB]=2D5
=S>NX-$H9?)W2OU%_+5MIO%*0*M6$)U4K;5 G)]Z].$26&2<Z:=[4VX*<!KIA/0QZ.YV/BB$
6?2CXSDQX"!9V,3JK#4>P9O8'P?JMNQ,Q,T?NE<HC:N&4C.ZF@NO2,KMEZ*:J2M2522ED[6I
AF<%R*84[6Z& 3]D#/:HZ/T!>\F_DT,$> E[<CJ/PSDR_K9R1/8^\[C@2NA$?_#W0V6_N 5_
V,<?JK/8UFK8 !N%]$/8V[0 L]E:![67Q2RS=IL?6SB/JFYVF@U73@DA;4B:V^R5>;=$HO?;
CSB??VIQ*Q"/9\RP#A3C;(QGE@RK>2"XU)&6PRZ3)YX?'"[#/=ONDR/MWL,]FNQK40(0?NB:
_6=RD4BE'BG]]?#-0/V#)ZSU6OIW+:Y^@39:ZK"1^.=*O)'J!8F2+V:]'>@%:?^;8H/R.W9I
R<'X(E^6V/') S5.BI#)2]@#:##@DS'U>;)HEJE!3/>MGSV6<Z]5 4(VHSMS#S*EWCYT12D/
^V"RSQD)SG/['PE-)Y)2S]L?@K$H]2Q."TZ",ZX9:< ^/9PS-\Y% *;\0>4W2_R#JXQPM"A+
 PD1;0IRMLT#%>X)2O'FG%H5J4G4*E@ 6(&IH GD5'OBO^B@!=V[%K@@L^ %Y2+1N4R;\]+E
[<I6,%U&8GWM^;8!.M"]!,SYQ%#"S/XJ2MS$<9#Y,20U#.)Q?+^6W1Y'A,)\8">]!L&PQI=@
YU+*E,&#L33G@,XH _Z=0W> 4"P=( 2*U#107%^JB[36)@5<V9H-8 F<;+S9IQT,Z&HL8[NG
ODEWN!JR^S>^J")2/XV4[32HX]C%*=#7%)OC)P(['0V(T1TG7Q\84 7M.*!?M'W)-99?YKVT
@VKZFZK[GNJ#* 412JGE.@DHTA,"KK@#NYC2Q4.KU%+8[8G%Z*P[A_+JD2'H%@W&V5/7)A 6
)P(['0V(T1TG1W?7&HYDYG-']F^\,."M97'V$LH:,?+U/I(237=6,YU ->Y-=:[6W](M/7MU
<R'HU[A]H^US@.$5L]A5)0" RFI)@F/VXU?*:@/8D=YE)H9JD0M$J#V$V<*1_YL<QEW6UBS_
BJ+3K,F&$UJ*V\'W[S?N_V[;3/FUWYW/ZW),?4>>?&V<V/A]$&0^4<:IUSX0,-\O8\\3E]8P
MGP[B41:H\FV,N^V)9TL./ R?*(;#U@_3KM\2[,+4WY%\ZA+3/M,6=\D35M,V%-B%OUJLBO8
GNGARPW< .J>77F8N9M]=@-=4>",EEF;^V%1ZRQ*KD(&W>KKIU5'409+Y,"G\4GKR&AH0T7Q
%T\I?"KL6YL7!FE\[0L07G<&_\<T=T8Y<2__*^8\\VMB5$$KCLOO=]0YA;N.6OIW+:Y^@39:
-\E+<4[ +%4WBO%D8'P7#..*HL-QVW-4K 6B+EG-:XBW"@PNK(DS+@>8^NNL=P 2H?U@>"%W
#S)!FQ7#/U\/^-VH\6G&+[?X?4>>?&V<V/A]$&0^4<:IUSX0T :>TF)05S'0?Q9-&'+'U"=_
[6@VIU%=##CMDKNI/]JO(BV21'W$YCC R5Q$]L=])DWH]N/V[C;-[:CE^0/NNJ"RTB\5<B*Z
^55;H!.7)K'Y>8L/6%+UVP5Y=[.Q#<H+1O%W:R%H*C[*5:9K:##@DS'U>;)HSW9\]RIMT"G/
*""%P!VF$,PH65H'@%9)(359\<C:KH$ MH+Q)]-BMXPO]4HG1WB:76)7$]5'H GD5'OBO^B@
NZ0IT,H,M$"[ PD1;0IRMLT#^(#_.5(5-*OX[/>4!7H7Y@CLW^D^RJP>B@K?=K=?&0/B>H5V
N.J&I2OV:ONXB/N/3531W@.(_.BO6%S72>+\_!]"6:M[= _\82R,Y0@;#X9AASOM0O6GK.^'
^F>UL1E@Z?SZY/U9G!GQ=8WDHD5W]\Y3C9"B8=5!BG;*['5A >"(),F+W\0!.MJY][&Y\;\Z
YM'H@";" 7GF(ZD2';C/04LCU<!+_WOGBCK5$K0;RD<#4CT2NBHZSOVNHX"ZHP4AT=,%.M*C
"?JP_(+7%$L)=*CA-:<]N)YT<Z]5 4(VHSMSE@L^@P+XX6:6#7L#6W#=)Y4-"C$U]\H.R*@*
?OTE%N!,P5Y^=_&<$9"!Q2UW+[W(HI68C9@O?:XK 8.-NTU]7<FQCVEQ-RU=DXOTIU-WP[F3
DXOTIU-WP[F3DXOTIU-WP[F3DXOTIU-WP[F3DXOTIU-WP[F3DXOTIU-WP[F3BWYQNQ#Q^JN+
/=ONDR/MWL,]FNQK40(0?NB:1&.!W$GBV5Y$_0?U?E@XL$;]]QTE+;D\PE_WE;0Z\Q)<YD^5
LW.;ZD3^.Z2SOIO /D&V0T>^'>^R(0.TH8$=@VKZFZK[GNJ#&^ZB-@-=P#4;^['" B[?3"G[
?L9$9%,-A_I^Y@-@F-S0W++FYURM9<NV9RCG_.Y;N003FWC\&(G*9XL2T (8;@#G?7UXHY5N
M58F&&AV!]FUJ[;PA('4O*&KB,WQK[R56L*(C=YAQ]O\K].-E(_[D;!B_;"4-NUDU,>S1^8V
=\>X?;KN%TMWOIO /D&V0T>^'>^R(0.TH8$=A*/9!U7FS)&$FBQX],G65 V:(Q%C?LKS@Z8C
F89A>DZ?V?R99T<+*%2&9?UG6--#:7'H4T%8&E='9"7[&QP:6YDO]E[XLGA; A?.N^X)"K("
;@#G?7UXHY5NM58F&&AV!]FUT!;7HAZ@@/'04!UFIA&<#GM0B=Z*6S#VH3J)#%[@P<X:;\0,
C%8$LV^-.]^,[?12H]."%ROM&XH[$#.QC>\;9A7H8ME7QM]FD&=.N@TZI0&0"JP(KL)TKZ8*
#F-PM>&JW2@.7F^!M@-$Y)M>]APNDXF%O]#V=<M_D8,O^1=UX<>\G@]!?(?A[ZT;=B&^;H[O
D7(3OS0M;\21DB8,*NNEAH*2VHA=X;@[@G3:]=MC#.#?5DOU78H-2\Q1BS1=2E*OQ_??*,9*
(Q%C?LKS@Z8CL]F*4-N9 7.SYU+*E,&#L33GC?/0<UWB)$V-%\$Y7@:Q8NX7GU[BYUV/A?6?
(Q%C?LKS@Z8CL]F*4-N9 7.SYU+*E,&#L33G(V7(V]NAR*LC+ X8?.@Y>ZTL<.-XFI)S !UP
PG,FO9%37<3"PZLV@\G"R)S#53+/! 4?-,-57G18OM_5@$U>#Z!D 0%2*)</DY?0V_NTS2.3
&!?=Q%'7%9T8%AR\)#;LW>@6/^.>]P"NAOL_10?=7T*]RF=%6B7HMDL$D@-:KHXN66)5G>>N
@KWJ'.R TPZ" \R!U-&.\\$#N+BFONFFA"RX)XIK#B^DS,DG2RW[!R5%"T]+MT0>IF,TO2.W
&</!Q;.A"K@9((C7.?U\G]8@!5!W_][AIJ,%/=ONDR/MWL,]FNQK40(0?NB:;L'Z#DUDYPUN
]?#-0/V#)ZSU6OIW+:Y^@39:ZK"1^.=*O)'J!8F2+V:]'>@%:?^;8H/R.W9IR<'X(E^6V/')
 S5.BI#)2]@#:##@DS'U>;)HS4LRD2% )6+-<Z]5 4(VHSMS#S*EWCYT12D/^V"RSQD)SG/[
DRE#&$](7'Z3Z34$^*X2^POIL2-FP0B8F_VQ\^H(.02'N4GSQ,0F#EM_,0G$Q7XE7WIPW\C%
]O!!S%-R*Q[VH4B>.@&7-%^AQPC.&WO%FJ_':739X/X=O^-I:XT68_1:S:QKY-6J3UNL/ZWD
Z]O#I =+5V?KJ# ]3* (G$FH=1*1B0\#[UAU/+6%D-.OU^,\+;=3M5U1%%LMD&JS=!"P:;J0
AF>ASYE:K@V&@85 )*AYG,>!55Q=&?]?N$)5!<&+)W%>$D8%*(Y,!15J3]XH ;U?.@OUY/ !
/OV- 6JR67D^+ X8?.@Y>ZTL@LGLE$7_LXF"Q^Y"2S!/AC+'I)Y)%N0/).BD;D;(69JC:>%N
OB8Q/$0'O8"^)P(['0V(T1TG6!YBCFD4K?E8CN'.;G7 [/R.+%,Z/IUL1S4LM& ^=,R*D2ZT
89*I^F(^TN1A .F6AT2V:=$ <Z]5 4(VHSMS)P(['0V(T1TG?':.:*I=C0U\$LH:,?+U/I(2
$LR:&/?" SX2FW;;=M6W>'^;.MJY][&Y\;\Z69'L7V@!3U-9-=Z0A_(2E)4U'4PTA+P,NN(=
&8I X^<7RH@9)P(['0V(T1TGLQ5U'A@84\VSL(>3Z9^HF+6P'4PTA+P,NN(=C17, X6+@SZ-
)P(['0V(T1TGLQ5U'A@84\VSU3@]NT:_M+;5'4PTA+P,NN(=C17, X6+@SZ-)P(['0V(T1TG
61,<8]1-'I-9_28Q9--2-PG],'NW$LGJEP\P<DJWV/9(@8%R)P(['0V(T1TG EEHFI%M05\"
$LH:,?+U/I(2U\C\H!06OM77<Z]5 4(VHSMS)P(['0V(T1TGQ"L*6S;CW*_$UN4?.M+ :C'6
0B;36?\6GQE"!<&+)W%>$D8%)P(['0V(T1TG\CCQ<+WM:S[R;^"/?;&291!O+%,Z/IUL1S4L
[+ZL]BN5%.OLKR5.<Y<U>(NO:;)PT%E0I/%I5?+)YVSU:"E5+UB?S_K8%3\O-XAP4/38>W<W
^*$M+SY@%PCXEZ8P/>+N'QZ7UY*6WCF"4/77MZ'U_+6@!+JWE<[XLQ?A6;N5(Q%C?LKS@Z8C
O%!U2=@1):V\_0?U?E@XL$;]]QTE+;D\PE_WE;0Z\Q)<YD^5LW.;ZD3^.Z2SOIO /D&V0T>^
'>^R(0.TH8$=@VKZFZK[GNJ#&^ZB-@-=P#4;^['" B[?3"G[?L9$9%,-A_I^Y@-@F-S0W++F
YURM9<NV9RCG_.Y;N003FWC\&(G*9XL2T (8;@#G?7UXHY5NM58F&&AV!]FUJXXC# =U4Z.K
DKNI/]JO(BV2-43X WPU/HTU4)E3BW6Q&?!0L%%7(/QJE-BPBO%D8'P7#..*@'<[\X(6Z%N 
X]C%*=#7%)OC)%<2T\9L&WLD7E'(K5VQ3A%>/=ONDR/MWL,]FNQK40(0?NB:;ZLM#/KZ@UIO
-QS ZE_!D0\W_K9I4F/HL(S^)B2?[L6*NU$FWNA[+!.ZQ:W>@+O;J(DT8RJ JPH&Q]E*Q,>K
GYRT5#Z:S(*?K!48B//L6(^LCA3XIEQ$RC^.*""%P!VF$,PH%%P#TMHO#\<4T<"X/)<I(9'1
<*D@61#89]YP4G&N#T_0-$)2A45B.B(76J&%!_F:20+H!C4'Q,0F#EM_,0G$Q7XE7WIPW\C%
]O!!S%-R*Q[VH4B>.@&7-%^AQPC.&WO%FJ_':739X/X=O^-I:XT68_1:S:QKY-6J3UNL/ZWD
Z]O#I =+5V?KJ# ]3* (G$FH=1*1B0\#[UAU<-M+MU^",7=P'U<]0_^W^A,?*8MS2WEA*UHI
4(V$6H":!D=0[04,N\VP=6[MG26$P*D%J(V=<DJWV/9(@8%R 0W^<W_,:D0!TL?*);L6HO32
,][:=,>],,4SK6;ER>R8V5ZMP/UP_NSTER3 0B;36?\6GQE"LSU]M.KN8?RS1;3/+<5\*9U%
B"Z7Q<) 'QN( ;U?.@OUY/ !/OV- 6JR67D^+G8].63%T-XNU<!+_WOGBCK5:#WBKEJ;S"%H
NBHZSOVNHX"ZHP4AT=,%.M*C\10R=_BIM2;Q)P(['0V(T1TGY[>TM>#W]''G-OL[>RAK_QPV
+:%I&A@2&,TM<Z]5 4(VHSMS)P(['0V(T1TG?':.:*I=C0U\)])3V,3M7VTG+%,Z/IUL1S4L
[_PBU#ULR)OO)P(['0V(T1TGDBF93E:MG#R2J:O;X"UDGD"I+%,Z/IUL1S4L[+ZL]BN5%.OL
)P(['0V(T1TGDBF93E:MG#R20N<S!'1-[%!"+%,Z/IUL1S4L[+ZL]BN5%.OL)P(['0V(T1TG
@&G%/6 46\V KR@(114DW3NO'4PTA+P,NN(=C17, X6+@SZ-)P(['0V(T1TGR1K.5Z;?]U+)
I=:O@WEIJ+"EA A(J11E\F2$*""%P!VF$,PH)P(['0V(T1TG/%K-2RF0-1X\<Y(# R:;Z^IS
,'NW$LGJEP\P<DJWV/9(@8%R)P(['0V(T1TG2'0-4/GCNA-((&K"?=YXJSP@U<!+_WOGBCK5
VAT@'<%2S*[:Z$6];%]@0CWHR?'AZB!RVT_)"8040]?[?2H)?(ZNV6I95^E\.\@:]U3>YWX[
+ZCR.V0+&%4OPGD!M1R^G37",*&,;'*[AJ P^T>L#WX%7EC[DXOTIU-WP[F3DXOTIU-WP[F3
DXOTIU-WP[F3DXOTIU-WP[F3DXOTIU-WP[F3DXOTIU-WP[F3WA*BVTU"4<W>M0.$[H1'5>BU
391%J:+S["I-E!8*G%/@9)>4MGP[B41:H\FV,N^V)9TL./ R?*(;#U@_3KM\2[,+4WY%\ZA+
3/M,6=\D35M,V%-B%OUJLBO8GNGARPW< .J>77F8N9M]=@-=4>",EEF;^V%1ZRQ*KD(&W>KK
IU5'409+Y,"G\4GKR&AH0T7Q%T\I?"KL6YL7!FE\[0L07G<&_\<T=T8Y<2__*^8\\VMB5$$K
Y^1N-252)$[G/C;X9Q<'(G0^2CR$T$* F\E*LW.;ZD3^.Z2SZDPJUG3(=4_J716R<Y10:F-=
3/M,6=\D35M,V%-B%OUJLBO8A1AUG'W:I4B%96[*754)+"=ECE"_X=E!.I>.[]PIH3\@>ECO
TUW2>2&]*@S3*029GQ&;Z04ISR:C<.VU@"+/&&T$4%_X@+L8TL?*);L6HO32T$_W9MVHRV#0
*^8\\VMB5$$K8']2.Z+1F_-@=+8[L>L:?Z]T A?.N^X)"K(";@#G?7UXHY5NM58F&&AV!]FU
_>R1-W"?!,/]=*CA-:<]N)YTZ"/B.A65W1OH>VI"MH=&P^M[*W;9.925% $KYW475*Z2:[GG
 U?8<"B$B\$#8'LKG@O;3;Q@SCUCM!8&Y(#._N*>G7SI\A;^%>V#?14OB5<5CB!]5(.J%T:.
3>.O688-^9=-X;5)^LED1G?A;B(N:/;-@MMN9MD5U! 1U5UF%CF&5".M>JD6+I:U@?TU4LPN
KME>%3*FI$2N*D##QHI;0GPJ6=*\I->/6>-9$!4P> [I-V@0O0VKF \)CN&]^A)>7RGB%R[Z
ADW .9(1AW*&*8MS2WEA*UHIP88$4EY4DHG!-Y1(CLJ'S5@W+!Z2^4-5R8LL FZ$E.O[#;$"
G9.?^%<RA@>=KU19EL.\DW6OI#AT>\D[ -VDH,.8]6_A[)>@*"+F2*^7Q'TH'*]-[WVHO'L<
_[+9N#/GM"'_ZM],_2N1\1WJ<-\J#RXC2P9P-.N;T^ I3[,T+GS.#SX&"2\N.&#<@ ;\$V@X
6_LXMA9-=BY;&TXX<EQJN.(;0#6  4 G*#- W-@UG#C](2+<M=-\/^$(TU*UYC&ERY8Y*?GF
^3RLW[4)MM_Y\PP#@7/PW3+SN$9'=$$@9M*X]LB7=8[U7S7V?>?25WS$/[E]6!AQ<,%Q#K)8
>"1%,R?ILK-X=69$3D^Y+')UQTG&U<,'5Z;'.2PR8M_A(B\Y;XDJI3%6=U]O>0\5Q@J7)PAY
AV("S<ZV/P.'Z(KGO7U'LPCH8O_K=N;%[H)BDAZI3?*-;HF2*9V%SCLIC?\IV,<?JK/8UFK8
 !N%]$/8V[0 L]E:![67Q2RS=IL?6SB/JFYVF@U73@DA;4B:V^R5>;=$HO?;CSB??VIQ*Q"/
9\RP#A3C;(QGE@RK>2"XU)&6^,^?-V"QW37X.^?AV0.]]HL[H^B2&,;EVV>C6!AQ<,%Q#K)8
W)^%.^4:'T3<8:P%?N\D@Q)AN$9'=$$@9M*X]!!M _K:V&3T. XLO6Q8'QPX':!Y\]C4;^@=
6!AQ<,%Q#K)8B$2RE?M#2V&(+"[<,8R.DJLL-N]Q7+CK$N0V_3)*( *T#KK]:26Z3I0EA@5I
JW8K0AO&<\RK"[,[@O#A95$+0+!65>;P$DQ S7X*]TDF:?O-0BBBQ\<W$1M"<H $,S%4#%-R
DD,P:%KO'J>2P:[=TT%FIHK!#M6I('?U+BH.8+1/M@LH^V9@?]6ZPG79U=Q_-6TX<E?PBZ<U
U6LE _\7QVG5!@BO#24ML4$&^Y]ZXZ6TNJ'[:<+$&5,VZP)I?C=*A/8B5+=^#Z2TN]SNH2T/
CD5*5S0T\,*.W=/K2\X@UF/=R3+N=.0;!K/)43O,+AI,%"%18_!/XI>)/"=C6%,+VM!9B(U8
7("S\O4C&X1<>[J[AS/>\FE[>LFHKH.1')MZJ2 )6 7"_8JIX 8:'R2\KIO@%-K+77Y@?F04
8'KRX64?-@A@K-\9,.H#$!BLGABX \P(2#&>62+X669TNE%9:,?+1MK_:]=H@&2X#+AI:RJ 
+$@02R5)!?8L)@M!+DU;7=4F/EB,KO\3^N(^)VQF\DQMY)<G=J/EY=AR\%5V!@BO#24ML4$&
^Y]ZXZ6TNJ'[:<+$&5,VZP)I?C=*A/8B5+=^#Z2TN]SNH2T/CD5*5S0T\,*.9KT"ZZLA"]5F
HJ!@643[T$&BIM50TD#6E<6FUYL!RVH!M677)16X'N_L0Q<E7("S\O4C&X1<<3%-^@_8NC!Q
OF?X6:P/\X2^R1>@)>-;[\#)@Y7)EB+?RS6##+)[XI&FSQ4,CD4 ]G7ELE*.7/L12"EZ"?A<
)T.HV[6\IB8G@&^?0MR^A=^ 3#E''WE'9DU,8#D)N:A07 5@KY_<YJ0=G7&O(N:&\Y%9YP\B
W+UW>C-[N_G<C<N#G]*8NE^-:26Z3I0EA@5IJW8K0AO&<\RK"[,[@O#A95$+0+!65>;P$DQ 
S7X*]TDF:?O-0BBBQ\<W$1M"<H $,S%4#%-R[F-\^OC$^/WNW)N@&KGS>X#<Z*K+!_V]X9KH
S,/Z2'!1//C,?]6ZPG79U=Q_BH3A P<$;G&*^?64;*=98*;Y:26Z3I0EA@5IJW8K0AO&<\RK
"[,[@O#A95$+0+!65>;P$DQ S7X*]TDF:?O-0BBBQ\<W$1M"<H $,S%4#%-R[F-\^OC$^/WN
W)N@&KGS>X#<#M6I('?U+BH.8+1/M@LH^V9@?]6ZPG79U=Q_#PRQ&W(-9^ /VB_P5Z% (3G:
"&M-#5+K"&D(Z"#SXO<45#?H.]=(^^^?TF@[ON:BFMEG/UN^.0D;\3DQCFHYK+71=[>4?62L
/Z>=$F9Z$8P_-#8A>#GMUVXT7AU]WBFV%]9>:2/\[#_L<JYIX'( W"T6S*[@2^(+"?V[U8]+
0WS55!=\Z(E#=GL+C@R^^\EV[ER]F[P]:&7N1,<5C?_B64)$9Z2CE\99^%=G7R(*?3>.@MU?
T)^%4<T;TI[0L&>&5X\0:/JPIM50TD#6E<6F9KT"ZZLA"]5F5,=@W\;EIO!4^JAP0RCG 5[Z
[,]MN:-HX./L)[.9T!WC;F GI'4'YIF5O;FDUALZ!M8D:0S69&3(EESPM9%D);81NWW1M98E
;)<#<K_4V2=L9-UH&@;VD)-D]^X!%"_&):?W-#8A>#GMUVXT;W_U6I4LMPEOX4-@*H,5<TCA
1%(5>UDE:P)$H'.C\6U*B<N@%QA14]7^IQ<7-N]Q7+CK$N0V:TH"6+]8+8=K:26Z3I0EA@5I
JW8K0AO&<\RK"[,[@O#A95$+0+!65>;P$DQ S7X*]TDF:?O-0BBBQ\<W$1M"<H $,S%4#%-R
[F-\^OC$^/WNW)N@&KGS>X#<GH8)9FSS>(N>W.9I>Q&4%(/<?]6ZPG79U=Q__SODN!4;,;3_
4GC&_Z)%1 =2J2 )6 7"_8JIX 8:'R2\KIO@%-K+77Y@?F048'KRX64?-@A@K-\9,.H#$!BL
GABX \P(2#&>3#E''WE'9DU,Y/!!B#70T6;D@&^?0MR^A=^ R<8'4$(-'Y+)X?GE\&T( <;A
/EB,KO\3^N(^B+A[?IDJ(Q"(VOYJ=G0H<-':^>Y YV#EI^WY[ER]F[P]:&7N1,<5C?_B64)$
9Z2CE\99^%=G7R(*?3>.@MU?T)^%4<T;TI[0L&>&5X\0:/JP#L+2^#_L(3P.^SH'&<>S-T+[
)>2[).J0T4$EJ29D4CX?KT"I[L1[VUMCVPGN)[.9T!WC;F G$[U)65@4Q?T37LTAS?$&)=A>
[4)QE4'>09?M,'>5Y-R2[,PP16?V )O [&9%0T^^DEEZJ)Y#0\C]F--CRRU#"P@^5P+KP,$+
N'WDZR35-%6X<H $,S%4#%-RAUIE^IRM]4J']3C.-I/+A0OU(Z18",3V1I C&(%EW94G?E48
GVPGLQC]0]N?3B'\!M%'S9).!@BO#24ML4$&^Y]ZXZ6TNJ'[:<+$&5,VZP)I?C=*A/8B5+=^
#Z2TN]SNH2T/CD5*5S0T\,*.^SH'&<>S-T+[CZ3R17.\9_>/X@957)O\DY+B8_!/XI>)/"=C
6%,+VM!9B(U8[.&USBS-KM[LM*A('^#WY.^TDZA##+<DUN"3.O,?#TMD1F\Z[4)QE4'>09?M
_[3R</UWM"W_HK8[F,=+T>*BX]C%*=#7%)OC@A,9.Q/4/4Z"F#IJT43=)-"8?DW5II0'4FQ^
H#E >"P%.\Z@/S0S(T'+L=8_%'IW%\):8*$4<;3];YLE4[5QZ$6];%]@0CWH/1UBT=3PJ2P]
.86@G1H8;0LYLA/V2,++8SRRGVPGLQC]0]N?[LY?W/=#ELGN%+#Z;D24@V84@^&BYI.^27N#
[#._(B=G$#7LJ2 )6 7"_8JIV7YESVXA0!79-Y=3[))CI%\WA3L5L6?Z"%6%'_6+G"$CDCL?
\5H.)+EIOVCQTL?*);L6HO32P.!8X#8XN_' MM#\FP])F0:VJ1+GKXY)D3FIN/!J?/WMEJFX
GQ,FUVXMGZJ?TW<4?M,H@''33RRO(0KE#KM/ %#9B*)TK9D 0$2Z'$P/M(E :26Z3I0EA@5I
2U9B4<QC8LM+-TP"T:I7<@HW13;3POAA(PU%=GL+C@R^^\EVE-_)#]&H^PB4J.)0EZ+_3TNH
@A,G_ROX4U^"M0]7QX0BS#NUH.;]Q+\G%!V@'>^R(0.TH8$=T(IZ"GC'-=_0PV1/UM6$L'S#
L4V@[!HO*^2Q%'E$=8KT_-<4/H*["FT(*X(^6WI3P]RU5 5;&;L'LY->)%H9NY=0W'K&C4&[
5B&QZ59)K"-6.O,?#TMD1F\Z>WM[]393BX%[!C2%\@2EED$&-72VU/KOHT0U)3!@7HO5"#8E
:26Z3I0EA@5I82\[@\FZ8.YAZRNIP(NNB 3KR;SU%:6AEMG)YW475*Z2:[GG&;[66WQ/=H09
 >"(),F+W\0!AL.^]6/_W.V&2E&6D!Z_@ ]*K2_59])D7(&MOM%<!<V44Q&^@4'R$?7+Y#^!
<Z]5 4(VHSMSX->"#"2&QH3@)=C):%YR-W@E/)MXM7@%OZ0\.O,?#TMD1F\Z>WM[]393BX%[
!C2%\@2EED$&J&$>.7'3^;2H&&$6Y3OJY[88J2 )6 7"_8JIV7YESVXA0!79-Y=3[))CI%\W
A3L5L6?Z"%6%'_6+G"$CDCL?\5H.)+EIOVCQTL?*);L6HO32P.!8X#8XN_' MM#\FP])F0:V
J1+GKXY)D3FIN/!J?/WMEJFXGQ,FUVXMGZJ?TW<4?M,H@''33RRO(0KE#KM/ %#9B*)TK9D 
*W2=R5)O /XK=GL+C@R^^\EV^EE;96.Q&+SZM*A('^#WY.^T,A_ ]E]*JR(R7U>^'$N)JJY?
4A_[>+S1W1U282\[@\FZ8.YAZRNIP(NNB 3KR;SU%:6AEMG)YW475*Z2:[GG&;[66WQ/=H09
 >"(),F+W\0!AL.^]6/_W.V&2E&6D!Z_@ ]*K2_59])D7(&MOM%<!<V44Q&^@4'R$?7+Y#^!
<Z]5 4(VHSMSX->"#"2&QH3@)=C):%YR-W@EVB_P5Z% (3G:$F9LA(_+2AT2[LY?W/=#ELGN
%+#Z;D24@V84*2:</%]=!I$I^-X>94XG%A#X:26Z3I0EA@5I82\[@\FZ8.YAZRNIP(NNB 3K
R;SU%:6AEMG)YW475*Z2:[GG&;[66WQ/=H09 >"(),F+W\0!AL.^]6/_W.V&2E&6D!Z_@ ]*
K2_59])D7(&MOM%<!<V44Q&^@4'R$?7+Y#^!<Z]5 4(VHSMSX->"#"2&QH3@)=C):%YR-W@E
6:V2+HEM<V-9=GL+C@R^^\EV^EE;96.Q&+SZM*A('^#WY.^TF*KL *$8#[^8=GL+C@R^^\EV
E-_)#]&H^PB4J.)0EZ+_3TNH@A,G_ROX4U^"M0]7QX0BS#NUH.;]Q+\G%!V@'>^R(0.TH8$=
T(IZ"GC'-=_0PV1/UM6$L'S#L4V@[!HO*^2Q%'E$=8KT_-<4/H*["FT(*X(^6WI3P]RU5 5;
&;L'LY->)%H9NY=0W'K&C4&[F*KL *$8#[^8=GL+C@R^^\EV^EE;96.Q&+SZM*A('^#WY.^T
Z*D@><4P*AGH.O,?#TMD1F\Z[4)QE4'>09?M_[3R</UWM"W_HK8[F,=+T>*BX]C%*=#7%)OC
@A,9.Q/4/4Z"F#IJT43=)-"8?DW5II0'4FQ^H#E >"P%.\Z@/S0S(T'+L=8_%'IW%\):8*$4
<;3];YLE4[5QZ$6];%]@0CWH/1UBT=3PJ2P].86@G1H8;0LYI_@$;PD]/0RGP?DT1LJ3(\C!
[LY?W/=#ELGN%+#Z;D24@V84S<N?NB;WW"W-X'^7^P'.B;_@5MKL@P0R_-=6.CGW0O!Q&=DZ
-^)3)24LEKXW\>O$>W$XDO/QZ;P<]JY$5*CIEUVJ?2J14GN7E')""O*$V&Z4030LP><BFS=!
/[W*Y Z;%@L_P(WL5O!N1_? 1/WZ)V.;#F9$?&?C7@4"0E)\KR5.<Y<U>(NO2$2F$K8MT6I(
^D%^B;.PS.#Z]ET;)%'OSL#VK(:Q74MS@WZL+6G2"'Q3IS,M2U9B4<QC8LM+-TP"T:I7<@HW
N?@HU[?)T :Y:26Z3I0EA@5I82\[@\FZ8.YAZRNIP(NNB 3KR;SU%:6AEMG)YW475*Z2:[GG
&;[66WQ/=H09 >"(),F+W\0!AL.^]6/_W.V&2E&6D!Z_@ ]*K2_59])D7(&MOM%<!<V44Q&^
@4'R$?7+Y#^!<Z]5 4(VHSMSX->"#"2&QH3@)=C):%YR-W@EN?@HU[?)T :Y:26Z3I0EA@5I
2U9B4<QC8LM+-TP"T:I7<@HW.@$L&-+W 5TZ=GL+C@R^^\EVE-_)#]&H^PB4J.)0EZ+_3TNH
@A,G_ROX4U^"M0]7QX0BS#NUH.;]Q+\G%!V@'>^R(0.TH8$=T(IZ"GC'-=_0PV1/UM6$L'S#
L4V@[!HO*^2Q%'E$=8KT_-<4/H*["FT(*X(^6WI3P]RU5 5;&;L'LY->)%H9NY=0W'K&C4&[
[<X%Y?:'-0'M.O,?#TMD1F\Z>WM[]393BX%[!C2%\@2EED$&".*9BA_I@6 (.O,?#TMD1F\Z
[4)QE4'>09?M_[3R</UWM"W_HK8[F,=+T>*BX]C%*=#7%)OC@A,9.Q/4/4Z"F#IJT43=)-"8
?DW5II0'4FQ^H#E >"P%.\Z@/S0S(T'+L=8_%'IW%\):8*$4<;3];YLE4[5QZ$6];%]@0CWH
/1UBT=3PJ2P].86@G1H8;0LY".*9BA_I@6 (.O,?#TMD1F\Z>WM[]393BX%[!C2%\@2EED$&
B+A[?IDJ(Q"(VOYJ=G0H<-':?A"GR:I\INE^",UBL79F\+<(P<Q 6BA9IG/!K /+Q4C\;'ZL
0L+BPU,?* E"X- )M"41?QO@X]C%*=#7%)OC<X<V 3&]P4IS8J'BN]4TTV)B@7@4(.G*W&*!
!9F0-(:'RWT%6F06PLE033A:K%MO[G&XMZVL/%-<V1!TN#X\@'?\!AFMG"6 GVPGLQC]0]N?
3B'\!M%'S9).[LY?W/=#ELGN%+#Z;D24@V84*2:</%]=!I$ISE\CQTLK(,[.!@BO#24ML4$&
O;\K#3!640.]8_+CP')<&<]C^8?J2\E"Z/WY?EM-14D<,_E^9V#R,#A;&O1G ;U?.@OUY/ !
U\!1G^"6Z337R,\M?"A'&S[(3" 0 S9[!JA,\X_ EMA -5;SMGP0I4W]:EFVM\:+A-XGF5&W
!.F7[<9T6ND$9^*?.,^YJ4=GSE\CQTLK(,[.[LY?W/=#ELGNA$:!1://%DB$!YF^HGD8A4\'
T<C4;^,27T#11Z<M]97).,-'^Y]ZXZ6TNJ'[XR?-HN)B6!/C.<&1.V7 D)LYOIO /D&V0T>^
A3L5L6?Z"%6%6SX6PHS;=19;!717-=*^)),%'4PTA+P,NN(=@QOD'HF0;EF# OX7JB/)7*T"
*%C$\N6-PE4HP9PFA$D8=/S!IYC5%.P)W;6G$LH:,?+U/I(2=O3TF>V4*)1VP9PFA$D8=/S!
AAY(ST[)C**&@VKZFZK[GNJ#!(O#C!^39KD$Q]1_/9(,.8?'^YV=PY_$YFW[U<!+_WOGBCK5
WW+JG$N5J>[?'@Q4UR98/",>4/QM8?NTS5-0A$A" [DREH"$0B;36?\6GQE"M\I7Z^*A,C2W
X^J<S(W>HE?C<-CI#?+(/G9P0B;36?\6GQE"!<&+)W%>$D8%/%K-2RF0-1X\<Y(# R:;Z^IS
,'NW$LGJEP\P<DJWV/9(@8%RQ5W0\_3*@GW%(1$-^4_;UU,A'4PTA+P,NN(=C17, X6+@SZ-
LQ5U'A@84\VSL(>3Z9^HF+6P'4PTA+P,NN(=C17, X6+@SZ-R1K.5Z;?]U+)I=:O@WEIJ+"E
A A(J11E\F2$0.ZO9DA,;0Q '@Q4UR98/",>/YJ:CX#(FV8_]<I#(F"4K_WU 8[ZY'H!M<(!
&"3X*EAYS<P8N5ZS"<_(ZRJY]\[HJIK8>)'WDB5;V:)XHQ:2DXOTIU-WP[F3DXOTIU-WP[F3
DXOTIU-WP[F3DXOTIU-WP[F3DXOTIU-WP[F3DXOTIU-WP[F3\BVT FTX/'WR* RA^;%IR1LH
@==OQB:]BE.!^8?J2\E"Z/WY^QH]^, @QEO[NA)[0@4QA6JZL\A:Q_@O(+^S^&MMY.DBLG+X
VB_P5Z% (3G:8=OBH_>KPQ9AKR5.<Y<U>(NO?(ZNV6I95^E\SW 6SDG!;M;/0FGYA-LIBY!"
Y)))IX*PJ<+DOJ>:"]X#9=&^']HUP]@V9R$?'>^R(0.TH8$=I2&:ZVS \ABE"JP(KL)TKZ8*
7?X5#J24T&==@YS[XM7Q:>"#VB_P5Z% (3G:8=OBH_>KPQ9AKR5.<Y<U>(NO?(ZNV6I95^E\
SW 6SDG!;M;/QWI0I^,949K'#5 $+KB2N9$-$I6G(QH)$&@255(N%+]WNC)5(8 !-SK;T8 A
B ;A]?*2?#6((4O_A9=*8%LAI5]WA-L;&6>EN-PRW+/Y&36XZ;P<]JY$5*CIIQ[LH)14U26G
6AR-_8573]]:M*A('^#WY.^TF*KL *$8#[^8=GL+C@R^^\EVU$0RO9"4^E74<Z]5 4(VHSMS
)VA7>8[*E"LGNE9@(YOE'C*ZV.=*^<X#8*C8O_V^26VI>Q6_$'DW2.3($V$05GU4@,BW'O=6
M0]7QX0BS#NURJ*JY6A$','*@!\-JH(5LY* 3&"GE9F-,5U,&9R4^X^*&!,9OF?X6:P/\X2^
7QG01*10ZKI?K%MO[G&XMZVL;1#E)Z7BG(EMNE@[Z"$E3W^ZR''VN!-4U(/(#5 $+KB2N9$-
JVQ,YN9_$^FK#5 $+KB2N9$-C\3PG,O&I<B/,Y2;2SA^]VXS'X +8?4T3&4?KXMHMZLL%Z6O
CGQA@EH"W[2.0L+BPU,?* E"FU4I47#),0*;KPTDQEM_AQFO-TP"T:I7<@HWQD1^9"QD\DC&
=GL+C@R^^\EVU$0RO9"4^E74<Z]5 4(VHSMS)VA7>8[*E"LG?D>UO4C-</M^-5C1WW5JHA<U
"XNUAB//FN8+4.X;?UE$Y010IPY(:1N*Y*NG,X-P3= E($<S2CY*%<"ZCXQ*]I 0N\;8!+7V
>\Z,+,Y?=>)[^AU<I5VQ=S;ZYW475*Z2:[GG'$+'Z\BQ!9$<,;PMNTTZVW<Q-9RN:+2<H/0U
*W2=R5)O /XK=GL+C@R^^\EVU$0RO9"4^E74<Z]5 4(VHSMS)VA7>8[*E"LG?D>UO4C-</M^
AF%NW]\SO?B&IPY(:1N*Y*NGC4;8^HM)0%J-IPY(:1N*Y*NG,X-P3= E($<S2CY*%<"ZCXQ*
?#4D_-?2M3)\>\Z,+,Y?=>)[^AU<I5VQ=S;ZYW475*Z2:[GG'$+'Z\BQ!9$<,;PMNTTZVW<Q
-9RN:+2<H/0UA+>;V!XPK5:$J2 )6 7"_8JIK>FC1GC$#NZM:@/8D=YE)H9J&<KSNX#;8(<9
'LY;?I=P#98>'3P$PX%Q]SD=?RL/]C>BO\)_;(T,7*T6,KILA3L5L6?Z"%6%'_6+G"$CDCL?
4!>[2\L\#:)0G#/[V6OI1&Z<WP$RB):I 1G?B)-*=3/MI?F(=GL+C@R^^\EVU$0RO9"4^E74
<Z]5 4(VHSMS)VA7>8[*E"LG?D>UO4C-</M^-5C1WW5JHA<U"XNUAB//FN8+6D"+4UDO2I=:
0=Q[_C40=])!H]T4UWXWP?ZC2CY*%<"ZCXQ*^&U"U@VD9=/X>\Z,+,Y?=>)[^AU<I5VQ=S;Z
YW475*Z2:[GG'$+'Z\BQ!9$<,;PMNTTZVW<Q-9RN:+2<H/0UK[S;'Y2;B4FOJ2 )6 7"_8JI
K>FC1GC$#NZM:@/8D=YE)H9J&<KSNX#;8(<9'LY;?I=P#98>C-H,!D2NH 2,OX)J?SXQE*._
KXMHMZLL%Z6OCGQA@EH"W[2.0L+BPU,?* E"FU4I47#),0*;KPTDQEM_AQFO-TP"T:I7<@HW
.@$L&-+W 5TZ=GL+C@R^^\EVU$0RO9"4^E74<Z]5 4(VHSMS)VA7>8[*E"LGNE9@(YOE'C*Z
V.=*^<X#8*C8UZ,!ZD.Z0VG7I5]WA-L;&6>EN-PRW+/Y&36XZ;P<]JY$5*CIIQ[LH)14U26G
6AR-_8573]]:M*A('^#WY.^T5B&QZ59)K"-6.O,?#TMD1F\ZD2F6F1%>)<B16WI3P]RU5 5;
+UB?S_K8%3\OQ?2IH*C5>[/%>=1H(A@G5@1YIPY(:1N*Y*NGJ$>J/U]0(2BH>/#.GKZC:YMX
4"X#K'-B@N50>\Z,+,Y?=>)[^AU<I5VQ=S;ZYW475*Z2:[GG'$+'Z\BQ!9$<,;PMNTTZVW<Q
-9RN:+2<H/0U.4[3>T%RL]HYUALZ!M8D:0S6Z+:]DM[ \6;H-KM&6#BG#-4V(B83=X9M8%(B
T7 Z!'KHUB?1<%%OA@!1J$UP**+4GC7-G'DHI5]WA-L;&6>EN-PRW+/Y&36XZ;P<]JY$5*CI
IQ[LH)14U26G6AR-_8573]]:M*A('^#WY.^T,A_ ]E]*JR(R([%PFL892:$CDS$JYHYP[X:3
K>FC1GC$#NZM:@/8D=YE)H9J&<KSNX#;8(<9'LY;?I=P#98>'3P$PX%Q]SD=Z[P@+O P\HWK
>\Z,+,Y?=>)[^AU<I5VQ=S;ZYW475*Z2:[GG'$+'Z\BQ!9$<,;PMNTTZVW<Q-9RN:+2<H/0U
$[U)65@4Q?T3L4 3M:\+S BQ8=OBH_>KPQ9AKR5.<Y<U>(NO?(ZNV6I95^E\SW 6SDG!;M;/
QWI0I^,949K'#5 $+KB2N9$-97R=5*SYBLIEC-H,!D2NH 2,%3HE,L:@CJ,5KXMHMZLL%Z6O
CGQA@EH"W[2.0L+BPU,?* E"FU4I47#),0*;KPTDQEM_AQFO-TP"T:I7<@HWVB_P5Z% (3G:
_%,P_WSY A3\8=OBH_>KPQ9AKR5.<Y<U>(NO?(ZNV6I95^E\SW 6SDG!;M;/0FGYA-LIBY!"
?4>>?&V<V/A]?FV&BA:="B]^:F"7\(2K2X]J(".%9CJR_ (@@FM9X8 8B&B"#.F[8T-1$\ ,
YE75]B:,$:3F@$DX"K8(*-J J[:: 1WW+J.KQJ?,K B+FJ7&;B@4("LA/RIN'H!2XYM.%AX>
NA)[0@4QA6JZ<1RN74&U0:=Q+$EMF,F)T34LP$TF8WY_75C O?P?IJ!PPP>]_MY&&C"3 4;^
YG#U5NA%2_;F,>.G5]@IX$PQ=3 [2#<U9+YUIX153F.Y[_^G JT0SNO3>ID"HLR(>+SQ]0RB
+30NYQ6=?6<M:92!!\T@O$1I-"W!  2J U(T8,X&'A].:'I@8YP/9DD0VL%C>\Z,+,Y?=>)[
<4 Z@$D/+UQQ_!U3XJ@I&\7\M8%)<0 CCR.UQT3>O.(3@R/'D)NA]<@P"=.05UI<^:XV1V=7
,>.G5]@IX$PQ=3 [2#<U9+YU@==OQB:]BE.!$Z7NG93;TSP31# WF$$UKRY$!0#P"UB6P*P%
C4Q8>3 SY+R-DR5T2TAD:-.3Z4VYEYZ\ ,_I@?G6!#EV6:2!J@#[(%1?QEBJK1K629A9:7RM
MLB4,P'-9(VV6M1,! BGQ3-:GHU[*0=V+Q*>ID,.034=DI>FUF6;-%?XPUG6X9'2RE=.E";A
HQA:2#DKI4^CZ],S!-21>"+KU?EYMN+R?N7554$)GMWUO*M5=TH- J7]*P-W4=R@B7IR$:!1
=<#:.\;9&$=UJ01XF_9Q= *I=<N$ARLJRDYU3LCPY$^?[]E.F.<5=#IU>-B8M72#I[A%+)6U
&R1@%&_*.Q8;(A@IZA/MQU(BR&>[*K+A<)3(^9*K?41W&P/Y9K9Z<012<G=F'A*:Y5?X;F >
;)QP4IGG";EL]I*#0:.)*AKV ?+*1AQ6Z^4!0Y[3K<@;C]]#;@&"O2P%5X9N\-9";V=IXBKP
&R1@%&_*.Q8;TH2%KT^]&R;241'+BA6EAV91:':;3)^-D55HV8\"(,A7*3'9SD7N'G_2)H3.
$N:.UMLU*E\2!40.D,V9XJP%PSP=BC(*@FK#N!&#TTFFU4NXWF3K?3+$$N7>7W;0K!!^L!9?
QT3>O.(3@R/'* 5>T#Q>H]@H_(14@ A0^N+\4IM5TU;!I*E2XPJN*V,@,;WC,>.G5]@IX$PQ
 ;U?.@OUY/ !2OP?/KV'()=*DUO+T]G5VF63DMB6")W47YB2/+(2 R9-S\4\!0*491FC[#4%
*D#0EOI5NJ\J2<Z.Q1G<S09)Z94IN#W]I7SIM1)T+N/>:@JUM58F&&AV!]FU/C)H:/Z =SP^
>]Y$W(@FF=A[\6T89_>O:>#Q9IPTDVR$RCYF[(4/2ML6G:SL$U2/QW8Y0*\3PBF6L"_=7@#"
TF1JRGD-P"+2R'%O[O1N6$O(;J*XG'HO AIN U?8<"B$B\$#]"\)?K<1VX?TTZ/D2K;"M"#3
=QQ9IF?')<YW^ F.2@CG8.3X7J'"NO$K(R9>E(]T\D2KWU^432L#RL^".$I-_!]"6:M[= _\
7_66:*4&!(M?AL.^]6/_W.V&2E&6D!Z_@ ]*4_\2\ T7.--3?3#GX,.24.U]0BINQXO:K$5"
ZB\Q"+M9?07JJ,"9MLW<!H.H+I:U@?TU4LPNNF.1_5.JGM>Z3!9X.L'I8ZI,E=S<OKC\7 N5
)E@@AJ!32" FZ-KQ82A>!J/H391%J:+S["I->IDJR7U+G_]ZOM%<!<V44Q&^LZ.#6P8(O/2S
L6P\\W4W#[BQ0T(M1) 5@PU#F!$J&O->WMJ8=[TZM8ZK7@QW
#pragma PXL encrypted end




//******************************************************************************
//      OUTPUT
//******************************************************************************
#ifndef COMBINE
output_layers : list of write_layer_map_s = {};

COMPRESS_TYPE : compress_fill_mode_e = AUTO;
//COMPRESS_TYPE : compress_fill_mode_e = NONE;
#endif

//******************************************************************************
//      OUTPUT
//******************************************************************************
#ifdef OUTPUT_GDS
#else
#endif
#ifdef FILL_M0_VIA0_M1_BTCD
output_layers.push_back({ BTCD_M0_V0_M1_TCDDMY_M0_C, { 165, 30 }, compress_fill = { cell = "BTCD_M0_V0_M1_TCDDMY_M0", mode = COMPRESS_TYPE}} );
output_layers.push_back({ BTCD_M0_V0_M1_TCDDMY_V0_C, { 165, 50 }, compress_fill = { cell = "BTCD_M0_V0_M1_TCDDMY_V0", mode = COMPRESS_TYPE}} );
output_layers.push_back({ BTCD_M0_V0_M1_TCDDMY_M1_C, { 165, 31 }, compress_fill = { cell = "BTCD_M0_V0_M1_TCDDMY_M1", mode = COMPRESS_TYPE}} );
#endif

#ifdef FILL_M1_VIA1_M2_BTCD
output_layers.push_back({ BTCD_M1_V1_M2_TCDDMY_M1_C, { 165, 31 }, compress_fill = { cell = "BTCD_M1_V1_M2_TCDDMY_M1", mode = COMPRESS_TYPE}} );
output_layers.push_back({ BTCD_M1_V1_M2_TCDDMY_V1_C, { 165, 51 }, compress_fill = { cell = "BTCD_M1_V1_M2_TCDDMY_V1", mode = COMPRESS_TYPE}} );
output_layers.push_back({ BTCD_M1_V1_M2_TCDDMY_M2_C, { 165, 32 }, compress_fill = { cell = "BTCD_M1_V1_M2_TCDDMY_M2", mode = COMPRESS_TYPE}} );
#endif

#ifdef FILL_M2_VIA2_M3_BTCD
output_layers.push_back({ BTCD_M2_V2_M3_TCDDMY_M2_C, { 165, 32 }, compress_fill = { cell = "BTCD_M2_V2_M3_TCDDMY_M2", mode = COMPRESS_TYPE}} );
output_layers.push_back({ BTCD_M2_V2_M3_TCDDMY_V2_C, { 165, 52 }, compress_fill = { cell = "BTCD_M2_V2_M3_TCDDMY_V2", mode = COMPRESS_TYPE}} );
output_layers.push_back({ BTCD_M2_V2_M3_TCDDMY_M3_C, { 165, 33 }, compress_fill = { cell = "BTCD_M2_V2_M3_TCDDMY_M3", mode = COMPRESS_TYPE}} );
#endif

#ifdef FILL_M3_VIA3_M4_BTCD
output_layers.push_back({ BTCD_M3_V3_M4_TCDDMY_M3_C, { 165, 33 }, compress_fill = { cell = "BTCD_M3_V3_M4_TCDDMY_M3", mode = COMPRESS_TYPE}} );
output_layers.push_back({ BTCD_M3_V3_M4_TCDDMY_V3_C, { 165, 53 }, compress_fill = { cell = "BTCD_M3_V3_M4_TCDDMY_V3", mode = COMPRESS_TYPE}} );
output_layers.push_back({ BTCD_M3_V3_M4_TCDDMY_M4_C, { 165, 34 }, compress_fill = { cell = "BTCD_M3_V3_M4_TCDDMY_M4", mode = COMPRESS_TYPE}} );
#endif

#ifdef FILL_M4_VIA4_M5_BTCD
output_layers.push_back({ BTCD_M4_V4_M5_TCDDMY_M4_C, { 165, 34 }, compress_fill = { cell = "BTCD_M4_V4_M5_TCDDMY_M4", mode = COMPRESS_TYPE}} );
output_layers.push_back({ BTCD_M4_V4_M5_TCDDMY_V4_C, { 165, 54 }, compress_fill = { cell = "BTCD_M4_V4_M5_TCDDMY_V4", mode = COMPRESS_TYPE}} );
output_layers.push_back({ BTCD_M4_V4_M5_TCDDMY_M5_C, { 165, 35 }, compress_fill = { cell = "BTCD_M4_V4_M5_TCDDMY_M5", mode = COMPRESS_TYPE}} );
#endif

#ifdef FILL_M5_VIA5_M6_BTCD
output_layers.push_back({ BTCD_M5_V5_M6_TCDDMY_M5_C, { 165, 35 }, compress_fill = { cell = "BTCD_M5_V5_M6_TCDDMY_M5", mode = COMPRESS_TYPE}} );
output_layers.push_back({ BTCD_M5_V5_M6_TCDDMY_V5_C, { 165, 55 }, compress_fill = { cell = "BTCD_M5_V5_M6_TCDDMY_V5", mode = COMPRESS_TYPE}} );
output_layers.push_back({ BTCD_M5_V5_M6_TCDDMY_M6_C, { 165, 36 }, compress_fill = { cell = "BTCD_M5_V5_M6_TCDDMY_M6", mode = COMPRESS_TYPE}} );
#endif

#ifdef FILL_M6_VIA6_M7_BTCD
output_layers.push_back({ BTCD_M6_V6_M7_TCDDMY_M6_C, { 165, 36 }, compress_fill = { cell = "BTCD_M6_V6_M7_TCDDMY_M6", mode = COMPRESS_TYPE}} );
output_layers.push_back({ BTCD_M6_V6_M7_TCDDMY_V6_C, { 165, 56 }, compress_fill = { cell = "BTCD_M6_V6_M7_TCDDMY_V6", mode = COMPRESS_TYPE}} );
output_layers.push_back({ BTCD_M6_V6_M7_TCDDMY_M7_C, { 165, 37 }, compress_fill = { cell = "BTCD_M6_V6_M7_TCDDMY_M7", mode = COMPRESS_TYPE}} );
#endif

#ifdef FILL_M7_VIA7_M8_BTCD
output_layers.push_back({ BTCD_M7_V7_M8_TCDDMY_M7_C, { 165, 37 }, compress_fill = { cell = "BTCD_M7_V7_M8_TCDDMY_M7", mode = COMPRESS_TYPE}} );
output_layers.push_back({ BTCD_M7_V7_M8_TCDDMY_V7_C, { 165, 57 }, compress_fill = { cell = "BTCD_M7_V7_M8_TCDDMY_V7", mode = COMPRESS_TYPE}} );
output_layers.push_back({ BTCD_M7_V7_M8_TCDDMY_M8_C, { 165, 38 }, compress_fill = { cell = "BTCD_M7_V7_M8_TCDDMY_M8", mode = COMPRESS_TYPE}} );
#endif

#ifdef FILL_M8_VIA8_M9_BTCD
output_layers.push_back({ BTCD_M8_V8_M9_TCDDMY_M8_C, { 165, 38 }, compress_fill = { cell = "BTCD_M8_V8_M9_TCDDMY_M8", mode = COMPRESS_TYPE}} );
output_layers.push_back({ BTCD_M8_V8_M9_TCDDMY_V8_C, { 165, 58 }, compress_fill = { cell = "BTCD_M8_V8_M9_TCDDMY_V8", mode = COMPRESS_TYPE}} );
output_layers.push_back({ BTCD_M8_V8_M9_TCDDMY_M9_C, { 165, 39 }, compress_fill = { cell = "BTCD_M8_V8_M9_TCDDMY_M9", mode = COMPRESS_TYPE}} );
#endif

#ifdef FILL_M9_VIA9_M10_BTCD
output_layers.push_back({ BTCD_M9_V9_M10_TCDDMY_M9_C, { 165, 39 }, compress_fill = { cell = "BTCD_M9_V9_M10_TCDDMY_M9", mode = COMPRESS_TYPE}} );
output_layers.push_back({ BTCD_M9_V9_M10_TCDDMY_V9_C, { 165, 59 }, compress_fill = { cell = "BTCD_M9_V9_M10_TCDDMY_V9", mode = COMPRESS_TYPE}} );
output_layers.push_back({ BTCD_M9_V9_M10_TCDDMY_M10_C, { 165, 40 }, compress_fill = { cell = "BTCD_M9_V9_M10_TCDDMY_M10", mode = COMPRESS_TYPE}} );
#endif

#ifdef FILL_M10_VIA10_M11_BTCD
output_layers.push_back({ BTCD_M10_V10_M11_TCDDMY_M10_C, { 165, 40 }, compress_fill = { cell = "BTCD_M10_V10_M11_TCDDMY_M10", mode = COMPRESS_TYPE}} );
output_layers.push_back({ BTCD_M10_V10_M11_TCDDMY_V10_C, { 165, 60 }, compress_fill = { cell = "BTCD_M10_V10_M11_TCDDMY_V10", mode = COMPRESS_TYPE}} );
output_layers.push_back({ BTCD_M10_V10_M11_TCDDMY_M11_C, { 165, 41 }, compress_fill = { cell = "BTCD_M10_V10_M11_TCDDMY_M11", mode = COMPRESS_TYPE}} );
#endif

#ifdef FILL_M11_VIA11_M12_BTCD
output_layers.push_back({ BTCD_M11_V11_M12_TCDDMY_M11_C, { 165, 41 }, compress_fill = { cell = "BTCD_M11_V11_M12_TCDDMY_M11", mode = COMPRESS_TYPE}} );
output_layers.push_back({ BTCD_M11_V11_M12_TCDDMY_V11_C, { 165, 61 }, compress_fill = { cell = "BTCD_M11_V11_M12_TCDDMY_V11", mode = COMPRESS_TYPE}} );
output_layers.push_back({ BTCD_M11_V11_M12_TCDDMY_M12_C, { 165, 42 }, compress_fill = { cell = "BTCD_M11_V11_M12_TCDDMY_M12", mode = COMPRESS_TYPE}} );
#endif

#ifdef FILL_M12_VIA12_M13_BTCD
output_layers.push_back({ BTCD_M12_V12_M13_TCDDMY_M12_C, { 165, 42 }, compress_fill = { cell = "BTCD_M12_V12_M13_TCDDMY_M12", mode = COMPRESS_TYPE}} );
output_layers.push_back({ BTCD_M12_V12_M13_TCDDMY_V12_C, { 165, 62 }, compress_fill = { cell = "BTCD_M12_V12_M13_TCDDMY_V12", mode = COMPRESS_TYPE}} );
output_layers.push_back({ BTCD_M12_V12_M13_TCDDMY_M13_C, { 165, 43 }, compress_fill = { cell = "BTCD_M12_V12_M13_TCDDMY_M13", mode = COMPRESS_TYPE}} );
#endif







#ifdef FILL_M0_BTCD2
output_layers.push_back({ BTCD_M0_TCDDMY_M0_C, { 165, 30 }, compress_fill = { cell = "BTCD_M0_TCDDMY_M0", mode = COMPRESS_TYPE}} );
#endif

#ifdef FILL_M1_BTCD2
output_layers.push_back({ BTCD_M1_TCDDMY_M1_C, { 165, 31 }, compress_fill = { cell = "BTCD_M1_TCDDMY_M1", mode = COMPRESS_TYPE}} );
#endif

#ifdef FILL_M2_BTCD2
output_layers.push_back({ BTCD_M2_TCDDMY_M2_C, { 165, 32 }, compress_fill = { cell = "BTCD_M2_TCDDMY_M2", mode = COMPRESS_TYPE}} );
#endif

#ifdef FILL_M3_BTCD2
output_layers.push_back({ BTCD_M3_TCDDMY_M3_C, { 165, 33 }, compress_fill = { cell = "BTCD_M3_TCDDMY_M3", mode = COMPRESS_TYPE}} );
#endif

#ifdef FILL_M4_BTCD2
output_layers.push_back({ BTCD_M4_TCDDMY_M4_C, { 165, 34 }, compress_fill = { cell = "BTCD_M4_TCDDMY_M4", mode = COMPRESS_TYPE}} );
#endif

#ifdef FILL_M5_BTCD2
output_layers.push_back({ BTCD_M5_TCDDMY_M5_C, { 165, 35 }, compress_fill = { cell = "BTCD_M5_TCDDMY_M5", mode = COMPRESS_TYPE}} );
#endif

#ifdef FILL_M6_BTCD2
output_layers.push_back({ BTCD_M6_TCDDMY_M6_C, { 165, 36 }, compress_fill = { cell = "BTCD_M6_TCDDMY_M6", mode = COMPRESS_TYPE}} );
#endif

#ifdef FILL_M7_BTCD2
output_layers.push_back({ BTCD_M7_TCDDMY_M7_C, { 165, 37 }, compress_fill = { cell = "BTCD_M7_TCDDMY_M7", mode = COMPRESS_TYPE}} );
#endif

#ifdef FILL_M8_BTCD2
output_layers.push_back({ BTCD_M8_TCDDMY_M8_C, { 165, 38 }, compress_fill = { cell = "BTCD_M8_TCDDMY_M8", mode = COMPRESS_TYPE}} );
#endif

#ifdef FILL_M9_BTCD2
output_layers.push_back({ BTCD_M9_TCDDMY_M9_C, { 165, 39 }, compress_fill = { cell = "BTCD_M9_TCDDMY_M9", mode = COMPRESS_TYPE}} );
#endif

#ifdef FILL_M10_BTCD2
output_layers.push_back({ BTCD_M10_TCDDMY_M10_C, { 165, 40 }, compress_fill = { cell = "BTCD_M10_TCDDMY_M10", mode = COMPRESS_TYPE}} );
#endif

#ifdef FILL_M11_BTCD2
output_layers.push_back({ BTCD_M11_TCDDMY_M11_C, { 165, 41 }, compress_fill = { cell = "BTCD_M11_TCDDMY_M11", mode = COMPRESS_TYPE}} );
#endif

#ifdef FILL_M12_BTCD2
output_layers.push_back({ BTCD_M12_TCDDMY_M12_C, { 165, 42 }, compress_fill = { cell = "BTCD_M12_TCDDMY_M12", mode = COMPRESS_TYPE}} );
#endif

#ifdef FILL_M13_BTCD2
output_layers.push_back({ BTCD_M13_TCDDMY_M13_C, { 165, 43 }, compress_fill = { cell = "BTCD_M13_TCDDMY_M13", mode = COMPRESS_TYPE}} );
#endif







#ifdef FILL_DM0
output_layers.push_back({ WRAPPER_DM0_O_A_C, { 330, 151 }, compress_fill = { cell = "WRAPPER_DM0_O_A", mode = COMPRESS_TYPE}} );
output_layers.push_back({ WRAPPER_DM0_O_B_C, { 330, 152 }, compress_fill = { cell = "WRAPPER_DM0_O_B", mode = COMPRESS_TYPE}} );
#endif
#ifdef FILL_DM1
output_layers.push_back({ WRAPPER_DM1_O_C, { 331, 420 }, compress_fill = { cell = "WRAPPER_DM1_O", mode = COMPRESS_TYPE}} );
#endif
#ifdef FILL_DM2
#ifdef VERTICAL_M2
output_layers.push_back({ WRAPPER_DM2_O_A_C, { 332, 201 }, compress_fill = { cell = "WRAPPER_DM2_O_A", mode = COMPRESS_TYPE}} );
output_layers.push_back({ WRAPPER_DM2_O_B_C, { 332, 202 }, compress_fill = { cell = "WRAPPER_DM2_O_B", mode = COMPRESS_TYPE}} );
#else
output_layers.push_back({ WRAPPER_DM2_O_A_C, { 332, 201 }, compress_fill = { cell = "WRAPPER_DM2_O_A", mode = COMPRESS_TYPE}} );
output_layers.push_back({ WRAPPER_DM2_O_B_C, { 332, 202 }, compress_fill = { cell = "WRAPPER_DM2_O_B", mode = COMPRESS_TYPE}} );
#endif
#endif
#ifdef FILL_DM3
#ifdef VERTICAL_M3
output_layers.push_back({ WRAPPER_DM3_O_C, { 333, 270 }, compress_fill = { cell = "WRAPPER_DM3_O", mode = COMPRESS_TYPE}} );
#else
output_layers.push_back({ WRAPPER_DM3_O_C, { 333, 250 }, compress_fill = { cell = "WRAPPER_DM3_O", mode = COMPRESS_TYPE}} );
#endif
#endif
#ifdef FILL_DM4
#ifdef VERTICAL_M4
output_layers.push_back({ WRAPPER_DM4_O_C, { 334, 320 }, compress_fill = { cell = "WRAPPER_DM4_O", mode = COMPRESS_TYPE}} );
#else
output_layers.push_back({ WRAPPER_DM4_O_C, { 334, 300 }, compress_fill = { cell = "WRAPPER_DM4_O", mode = COMPRESS_TYPE}} );
#endif
#endif
#ifdef FILL_DM5
#ifdef VERTICAL_M5
output_layers.push_back({ WRAPPER_DM5_O_A_C, { 335, 371 }, compress_fill = { cell = "WRAPPER_DM5_O_A", mode = COMPRESS_TYPE}} );
output_layers.push_back({ WRAPPER_DM5_O_B_C, { 335, 372 }, compress_fill = { cell = "WRAPPER_DM5_O_B", mode = COMPRESS_TYPE}} );
#else
output_layers.push_back({ WRAPPER_DM5_O_A_C, { 335, 351 }, compress_fill = { cell = "WRAPPER_DM5_O_A", mode = COMPRESS_TYPE}} );
output_layers.push_back({ WRAPPER_DM5_O_B_C, { 335, 352 }, compress_fill = { cell = "WRAPPER_DM5_O_B", mode = COMPRESS_TYPE}} );
#endif
#endif
#ifdef FILL_DM6
#ifdef VERTICAL_M6
output_layers.push_back({ WRAPPER_DM6_O_C, { 336, 960 }, compress_fill = { cell = "WRAPPER_DM6_O", mode = COMPRESS_TYPE}} );
#else
output_layers.push_back({ WRAPPER_DM6_O_C, { 336, 950 }, compress_fill = { cell = "WRAPPER_DM6_O", mode = COMPRESS_TYPE}} );
#endif
#pragma PXL encrypted begin
,R:!1FR@43TS$$1K<PF'&=00*5P>GU=).L,I&5B5JBC6*E095IRFP>7?U.!6-/E)AK!;=XLT
"U6D33B4@;4+A1@$N3U<:!J%.PT$P[B5'J\[LM)VK<$N@4^R
#pragma PXL encrypted end
#ifdef VERTICAL_M6
output_layers.push_back({ WRAPPER_DM6NEW_O_C, { 336, 960 }, compress_fill = { cell = "WRAPPER_DM6NEW_O", mode = COMPRESS_TYPE}} );
#else
output_layers.push_back({ WRAPPER_DM6NEW_O_C, { 336, 950 }, compress_fill = { cell = "WRAPPER_DM6NEW_O", mode = COMPRESS_TYPE}} );
#endif
#pragma PXL encrypted begin
%QL>4$E*Y&,76=7FG#^L,FY9.@JA37V$,C<Z:NC#. Y\ZU%JV"Q=H?40Q^C84I!6CZA!BW=2
2O/D"[<0S4=*RWIOM,X>?J++
#pragma PXL encrypted end

#endif
#ifdef FILL_DM7
#ifdef VERTICAL_M7
output_layers.push_back({ WRAPPER_DM7_O_C, { 337, 810 }, compress_fill = { cell = "WRAPPER_DM7_O", mode = COMPRESS_TYPE}} );
#else
output_layers.push_back({ WRAPPER_DM7_O_C, { 337, 800 }, compress_fill = { cell = "WRAPPER_DM7_O", mode = COMPRESS_TYPE}} );
#endif
#pragma PXL encrypted begin
LUST/.S45FVSE#\D<G> 'EN4%;H+MPRR/BL5%Z!J\'0K(E87#>6$-IJ>C-,-\I@AB-]VN93R
3]):XY,..8Q/'AK#*2V#V2D>_*;7T:Q5T4;\\,++OX^$0$/P
#pragma PXL encrypted end
#ifdef VERTICAL_M7
output_layers.push_back({ WRAPPER_DM7NEW_O_C, { 337, 810 }, compress_fill = { cell = "WRAPPER_DM7NEW_O", mode = COMPRESS_TYPE}} );
#else
output_layers.push_back({ WRAPPER_DM7NEW_O_C, { 337, 800 }, compress_fill = { cell = "WRAPPER_DM7NEW_O", mode = COMPRESS_TYPE}} );
#endif
#pragma PXL encrypted begin
X[?=2B55:4+C@BCMNJ(I)%>"K2_@V\<I*G:M0>V1AV=&2YI!:ZZ/_Z"X'FUK)"RMZH7+[U<D
K0G!@T*KBXVM;O^JQ,^JE\IN
#pragma PXL encrypted end

#endif
#ifdef FILL_DM8
#ifdef VERTICAL_M8
output_layers.push_back({ WRAPPER_DM8_O_C, { 338, 980 }, compress_fill = { cell = "WRAPPER_DM8_O", mode = COMPRESS_TYPE}} );
#else
output_layers.push_back({ WRAPPER_DM8_O_C, { 338, 970 }, compress_fill = { cell = "WRAPPER_DM8_O", mode = COMPRESS_TYPE}} );
#endif
#pragma PXL encrypted begin
[-^@%C'J.X#LE'VHH91$Y964>KE"F@=U25EZ#BND%5,IRH<.)T)Y?4"T=&DG/>\)F'698&L]
Y5PI>(L J-OEC@,C#CRHF(J.IHCO5)P#>A>FPTDA[LC9KV[#
#pragma PXL encrypted end
#ifdef VERTICAL_M8
output_layers.push_back({ WRAPPER_DM8NEW_O_C, { 338, 980 }, compress_fill = { cell = "WRAPPER_DM8NEW_O", mode = COMPRESS_TYPE}} );
#else
output_layers.push_back({ WRAPPER_DM8NEW_O_C, { 338, 970 }, compress_fill = { cell = "WRAPPER_DM8NEW_O", mode = COMPRESS_TYPE}} );
#endif
#pragma PXL encrypted begin
KU2=10%@[B"O>E83Y%ASQ89ZW+[NC=#T0?+<]640  ,J0RCU;2APUMY<PP!M1J"2JJ[5=F1&
-#9P^"?FB" T;.Y[8*A'))YL
#pragma PXL encrypted end

#endif
#ifdef FILL_DM9
#ifdef VERTICAL_M9
output_layers.push_back({ WRAPPER_DM9_O_C, { 339, 980 }, compress_fill = { cell = "WRAPPER_DM9_O", mode = COMPRESS_TYPE}} );
#else
output_layers.push_back({ WRAPPER_DM9_O_C, { 339, 970 }, compress_fill = { cell = "WRAPPER_DM9_O", mode = COMPRESS_TYPE}} );
#endif
#pragma PXL encrypted begin
J#P09 ;;T!NHNSH;+3XH8^V[VN&CUD73-C#:Q66O#I/A;NW%2N++[! H#+-*\^@.L 1/\N_S
#X 2D8_EU:8/4<$MZPQA^T!15#]9/[F!Z)E4(I9W]:V4A?\B
#pragma PXL encrypted end
#ifdef VERTICAL_M9
output_layers.push_back({ WRAPPER_DM9NEW_O_C, { 339, 980 }, compress_fill = { cell = "WRAPPER_DM9NEW_O", mode = COMPRESS_TYPE}} );
#else
output_layers.push_back({ WRAPPER_DM9NEW_O_C, { 339, 970 }, compress_fill = { cell = "WRAPPER_DM9NEW_O", mode = COMPRESS_TYPE}} );
#endif
#pragma PXL encrypted begin
-#Z6(Z)+4V(TJRSSO ><-<NKXJ.[1QU UPCBDVX @*.4GZN3@(9-6'F\$AV $H3$./UTUWP2
MH]!#8/.9(BV.(YP4L(2N<8X
#pragma PXL encrypted end

#endif
#ifdef FILL_DM10
#ifdef VERTICAL_M10
output_layers.push_back({ WRAPPER_DM10_O_C, { 340, 980 }, compress_fill = { cell = "WRAPPER_DM10_O", mode = COMPRESS_TYPE}} );
#else
output_layers.push_back({ WRAPPER_DM10_O_C, { 340, 970 }, compress_fill = { cell = "WRAPPER_DM10_O", mode = COMPRESS_TYPE}} );
#endif
#pragma PXL encrypted begin
]K*24G/!!0/V#7G$7?'R4D4-800H5H+2KV=A_MM@0#="$<7^U^W*XP[G*]77ZJB]GWT444WJ
I7V2CRKQL>.E>U"]4?,7(U-[K.7!S=J<ARRLZ8=B:$\=IR?I
#pragma PXL encrypted end
#ifdef VERTICAL_M10
output_layers.push_back({ WRAPPER_DM10NEW_O_C, { 340, 980 }, compress_fill = { cell = "WRAPPER_DM10NEW_O", mode = COMPRESS_TYPE}} );
#else
output_layers.push_back({ WRAPPER_DM10NEW_O_C, { 340, 970 }, compress_fill = { cell = "WRAPPER_DM10NEW_O", mode = COMPRESS_TYPE}} );
#endif
#pragma PXL encrypted begin
@K08$@\RB$F";Y\FA%>L+)IO4]*6<\,1/G!3 ;8-KP7S^$H!T_!ZDY7;R@;3WXGY@19MZN3?
V+ +X7#ET$?8UAK'OBP.ONC6
#pragma PXL encrypted end

#endif
#ifdef FILL_DM11
#ifdef VERTICAL_M11
output_layers.push_back({ WRAPPER_DM11_O_C, { 341, 980 }, compress_fill = { cell = "WRAPPER_DM11_O", mode = COMPRESS_TYPE}} );
#else
output_layers.push_back({ WRAPPER_DM11_O_C, { 341, 970 }, compress_fill = { cell = "WRAPPER_DM11_O", mode = COMPRESS_TYPE}} );
#endif
#pragma PXL encrypted begin
#K:>4:NB"A .9+ESC1':?R!D&H(8.0KSR\<:+< E1O?-8J$M* L,'B<G8/XHXZ-Q4@D+B]7C
/LG"CK=)5P@^'5AY=;1=1T(=[P]UUVZ<\MCO";!]P!M@??T)
#pragma PXL encrypted end
#ifdef VERTICAL_M11
output_layers.push_back({ WRAPPER_DM11NEW_O_C, { 341, 980 }, compress_fill = { cell = "WRAPPER_DM11NEW_O", mode = COMPRESS_TYPE}} );
#else
output_layers.push_back({ WRAPPER_DM11NEW_O_C, { 341, 970 }, compress_fill = { cell = "WRAPPER_DM11NEW_O", mode = COMPRESS_TYPE}} );
#endif
#pragma PXL encrypted begin
FK<D$4<3C5::7DGGA4[CC+)>,SYLVJ6A.& S#?XO14Z]H+@-UU>Y7_UX6A[7,WJ:*G)7XV0S
":WQQO5TY8L)-R0@WI>9WRHW
#pragma PXL encrypted end

#endif
#ifdef FILL_DM12
#ifdef VERTICAL_M12
output_layers.push_back({ WRAPPER_DM12_O_C, { 342, 980 }, compress_fill = { cell = "WRAPPER_DM12_O", mode = COMPRESS_TYPE}} );
#else
output_layers.push_back({ WRAPPER_DM12_O_C, { 342, 970 }, compress_fill = { cell = "WRAPPER_DM12_O", mode = COMPRESS_TYPE}} );
#endif
#pragma PXL encrypted begin
 (6$#K68SP4 S'A/$Y H!??,D!\Z'WT,#)N0^G'M6^# V\#ZU.5HG;?K8PW4K75QCV?\SJVM
F+'>*Q"<H7"8D GYZ<V*A/B001(0,#Y<K!!!>+K4)0OL9/IX
#pragma PXL encrypted end
#ifdef VERTICAL_M12
output_layers.push_back({ WRAPPER_DM12NEW_O_C, { 342, 980 }, compress_fill = { cell = "WRAPPER_DM12NEW_O", mode = COMPRESS_TYPE}} );
#else
output_layers.push_back({ WRAPPER_DM12NEW_O_C, { 342, 970 }, compress_fill = { cell = "WRAPPER_DM12NEW_O", mode = COMPRESS_TYPE}} );
#endif
#pragma PXL encrypted begin
K0>K*%X],E*M#Z<.Q$:;)V0/%#O?Z4R<O$T4&"VN$L3Q@3\8;@!=P++-X75NYV']W\T2(F_G
49T">/YC)7%1:;>/M [YJ59I
#pragma PXL encrypted end

#endif
#ifdef FILL_DM13
#ifdef VERTICAL_M13
output_layers.push_back({ WRAPPER_DM13_O_C, { 343, 980 }, compress_fill = { cell = "WRAPPER_DM13_O", mode = COMPRESS_TYPE}} );
#else
output_layers.push_back({ WRAPPER_DM13_O_C, { 343, 970 }, compress_fill = { cell = "WRAPPER_DM13_O", mode = COMPRESS_TYPE}} );
#endif
#pragma PXL encrypted begin
<'RG5RZSY')P[PC'5C:M;RWO][?K(=NMWQ7W?%TA-9M6ZU=\ T\6H93.8!,#VX![ZVB;6__;
JB^!TJ*7E#VJE]K44"-H*J>7X6:.A<#,-[;AJ'*4&]133@:H
#pragma PXL encrypted end
#ifdef VERTICAL_M13
output_layers.push_back({ WRAPPER_DM13NEW_O_C, { 343, 980 }, compress_fill = { cell = "WRAPPER_DM13NEW_O", mode = COMPRESS_TYPE}} );
#else
output_layers.push_back({ WRAPPER_DM13NEW_O_C, { 343, 970 }, compress_fill = { cell = "WRAPPER_DM13NEW_O", mode = COMPRESS_TYPE}} );
#endif
#pragma PXL encrypted begin
6"3*2"T4URI8%*/%]BP42I(4>[G!,/,D5DE[;?I# S/7F;YM4SJRQ[7AW^%3-.ZVNE[\KGPT
% J^J,4% 3 4$^P 7E2CR543
#pragma PXL encrypted end

#endif
#ifdef FILL_DM14
output_layers.push_back({ WRAPPER_DM14_O_C, { 344, 90 }, compress_fill = { cell = "WRAPPER_DM14_O", mode = COMPRESS_TYPE}} );
#endif
#ifdef FILL_DM15
output_layers.push_back({ WRAPPER_DM15_O_C, { 345, 90 }, compress_fill = { cell = "WRAPPER_DM15_O", mode = COMPRESS_TYPE}} );
#endif
#ifdef FILL_DM16
#endif
#ifdef FILL_DM17
#endif
#ifdef FILL_DM18
#endif
#ifdef FILL_DM19
#endif
#ifdef FILL_DM0
output_layers.push_back({ DM0_A_C, { 330, 161 }, compress_fill = { cell = "DM0_A", mode = COMPRESS_TYPE}} );
output_layers.push_back({ DM0_B_C, { 330, 162 }, compress_fill = { cell = "DM0_B", mode = COMPRESS_TYPE}} );
output_layers.push_back({ DM0_O_A_C, { 330, 151 }, compress_fill = { cell = "DM0_O_A", mode = COMPRESS_TYPE}} );
output_layers.push_back({ DM0_O_B_C, { 330, 152 }, compress_fill = { cell = "DM0_O_B", mode = COMPRESS_TYPE}} );
output_layers.push_back({ DM0_OW_A_C, { 330, 151 }, compress_fill = { cell = "DM0_OW_A", mode = COMPRESS_TYPE}} );
output_layers.push_back({ DM0_OW_B_C, { 330, 152 }, compress_fill = { cell = "DM0_OW_B", mode = COMPRESS_TYPE}} );
output_layers.push_back({ DM0_OW2_A_C, { 330, 151 }, compress_fill = { cell = "DM0_OW2_A", mode = COMPRESS_TYPE}} );
output_layers.push_back({ DM0_OW2_B_C, { 330, 152 }, compress_fill = { cell = "DM0_OW2_B", mode = COMPRESS_TYPE}} );
output_layers.push_back({ CM0CELL_C_330_151, { 330, 151 }, compress_fill = { cell = "CM0CELL_330_151", mode = COMPRESS_TYPE}} );
output_layers.push_back({ CM0CELL_C_330_152, { 330, 152 }, compress_fill = { cell = "CM0CELL_330_152", mode = COMPRESS_TYPE}} );
output_layers.push_back({ CM0CELL_C_530_150, { 530, 150 }, compress_fill = { cell = "CM0CELL_530_150", mode = COMPRESS_TYPE}} );
output_layers.push_back({ CM0CELL_C_530_155, { 530, 155 }, compress_fill = { cell = "CM0CELL_530_155", mode = COMPRESS_TYPE}} );
#endif
#ifdef FILL_DM1
output_layers.push_back({ DM1_A_C, { 331, 430 }, compress_fill = { cell = "DM1_A", mode = COMPRESS_TYPE}} );
output_layers.push_back({ DM1_O_A_C, { 331, 420 }, compress_fill = { cell = "DM1_O_A", mode = COMPRESS_TYPE}} );
output_layers.push_back({ DM1_OW_A_C, { 331, 420 }, compress_fill = { cell = "DM1_OW_A", mode = COMPRESS_TYPE}} );
output_layers.push_back({ DM1_OW2_C, { 331, 420 }, compress_fill = { cell = "DM1_OW2", mode = COMPRESS_TYPE}} );
#endif
#ifdef FILL_DM2
#ifdef VERTICAL_M2
output_layers.push_back({ DM2_A_C, { 332, 231 }, compress_fill = { cell = "DM2_A", mode = COMPRESS_TYPE}} );
output_layers.push_back({ DM2_B_C, { 332, 232 }, compress_fill = { cell = "DM2_B", mode = COMPRESS_TYPE}} );
output_layers.push_back({ DM2_O_A_C, { 332, 221 }, compress_fill = { cell = "DM2_O_A", mode = COMPRESS_TYPE}} );
output_layers.push_back({ DM2_O_B_C, { 332, 222 }, compress_fill = { cell = "DM2_O_B", mode = COMPRESS_TYPE}} );
output_layers.push_back({ DM2_OW_A_C, { 332, 221 }, compress_fill = { cell = "DM2_OW_A", mode = COMPRESS_TYPE}} );
output_layers.push_back({ DM2_OW_B_C, { 332, 222 }, compress_fill = { cell = "DM2_OW_B", mode = COMPRESS_TYPE}} );
output_layers.push_back({ DM2_OW2_A_C, { 332, 221 }, compress_fill = { cell = "DM2_OW2_A", mode = COMPRESS_TYPE}} );
output_layers.push_back({ DM2_OW2_B_C, { 332, 222 }, compress_fill = { cell = "DM2_OW2_B", mode = COMPRESS_TYPE}} );
#else
output_layers.push_back({ DM2_A_C, { 332, 211 }, compress_fill = { cell = "DM2_A", mode = COMPRESS_TYPE}} );
output_layers.push_back({ DM2_B_C, { 332, 212 }, compress_fill = { cell = "DM2_B", mode = COMPRESS_TYPE}} );
output_layers.push_back({ DM2_O_A_C, { 332, 201 }, compress_fill = { cell = "DM2_O_A", mode = COMPRESS_TYPE}} );
output_layers.push_back({ DM2_O_B_C, { 332, 202 }, compress_fill = { cell = "DM2_O_B", mode = COMPRESS_TYPE}} );
output_layers.push_back({ DM2_OW_A_C, { 332, 201 }, compress_fill = { cell = "DM2_OW_A", mode = COMPRESS_TYPE}} );
output_layers.push_back({ DM2_OW_B_C, { 332, 202 }, compress_fill = { cell = "DM2_OW_B", mode = COMPRESS_TYPE}} );
output_layers.push_back({ DM2_OW2_A_C, { 332, 201 }, compress_fill = { cell = "DM2_OW2_A", mode = COMPRESS_TYPE}} );
output_layers.push_back({ DM2_OW2_B_C, { 332, 202 }, compress_fill = { cell = "DM2_OW2_B", mode = COMPRESS_TYPE}} );
#endif
#endif
#ifdef FILL_DM3
#ifdef VERTICAL_M3
output_layers.push_back({ DM3_C, { 333, 280 }, compress_fill = { cell = "DM3", mode = COMPRESS_TYPE}} );
output_layers.push_back({ DM3_O_C, { 333, 270 }, compress_fill = { cell = "DM3_O", mode = COMPRESS_TYPE}} );
output_layers.push_back({ DM3_OW_F, { 333, 270 }, compress_fill = { cell = "DM3_OW_F", mode = COMPRESS_TYPE}} );
#else
output_layers.push_back({ DM3_C, { 333, 260 }, compress_fill = { cell = "DM3", mode = COMPRESS_TYPE}} );
output_layers.push_back({ DM3_O_C, { 333, 250 }, compress_fill = { cell = "DM3_O", mode = COMPRESS_TYPE}} );
output_layers.push_back({ DM3_OW_F, { 333, 250 }, compress_fill = { cell = "DM3_OW_F", mode = COMPRESS_TYPE}} );
#endif
#endif
#ifdef FILL_DM4
#ifdef VERTICAL_M4
output_layers.push_back({ DM4_C, { 334, 330 }, compress_fill = { cell = "DM4", mode = COMPRESS_TYPE}} );
output_layers.push_back({ DM4_O_C, { 334, 320 }, compress_fill = { cell = "DM4_O", mode = COMPRESS_TYPE}} );
output_layers.push_back({ DM4_OW_F, { 334, 320 }, compress_fill = { cell = "DM4_OW_F", mode = COMPRESS_TYPE}} );
#else
output_layers.push_back({ DM4_C, { 334, 310 }, compress_fill = { cell = "DM4", mode = COMPRESS_TYPE}} );
output_layers.push_back({ DM4_O_C, { 334, 300 }, compress_fill = { cell = "DM4_O", mode = COMPRESS_TYPE}} );
output_layers.push_back({ DM4_OW_F, { 334, 300 }, compress_fill = { cell = "DM4_OW_F", mode = COMPRESS_TYPE}} );
#endif
#endif
#ifdef FILL_DM5
#ifdef VERTICAL_M5
output_layers.push_back({ DM5_A_C, { 335, 381 }, compress_fill = { cell = "DM5_A", mode = COMPRESS_TYPE}} );
output_layers.push_back({ DM5_B_C, { 335, 382 }, compress_fill = { cell = "DM5_B", mode = COMPRESS_TYPE}} );
output_layers.push_back({ DM5_O_A_C, { 335, 371 }, compress_fill = { cell = "DM5_O_A", mode = COMPRESS_TYPE}} );
output_layers.push_back({ DM5_O_B_C, { 335, 372 }, compress_fill = { cell = "DM5_O_B", mode = COMPRESS_TYPE}} );
output_layers.push_back({ DM5_OW_A_C, { 335, 371 }, compress_fill = { cell = "DM5_OW_A", mode = COMPRESS_TYPE}} );
output_layers.push_back({ DM5_OW_B_C, { 335, 372 }, compress_fill = { cell = "DM5_OW_B", mode = COMPRESS_TYPE}} );
#else
output_layers.push_back({ DM5_A_C, { 335, 361 }, compress_fill = { cell = "DM5_A", mode = COMPRESS_TYPE}} );
output_layers.push_back({ DM5_B_C, { 335, 362 }, compress_fill = { cell = "DM5_B", mode = COMPRESS_TYPE}} );
output_layers.push_back({ DM5_O_A_C, { 335, 351 }, compress_fill = { cell = "DM5_O_A", mode = COMPRESS_TYPE}} );
output_layers.push_back({ DM5_O_B_C, { 335, 352 }, compress_fill = { cell = "DM5_O_B", mode = COMPRESS_TYPE}} );
output_layers.push_back({ DM5_OW_A_C, { 335, 351 }, compress_fill = { cell = "DM5_OW_A", mode = COMPRESS_TYPE}} );
output_layers.push_back({ DM5_OW_B_C, { 335, 352 }, compress_fill = { cell = "DM5_OW_B", mode = COMPRESS_TYPE}} );
#endif
#endif
#ifdef FILL_DM6
#ifdef VERTICAL_M6
output_layers.push_back({ DM6_C, { 336, 965 }, compress_fill = { cell = "DM6", mode = COMPRESS_TYPE}} );
output_layers.push_back({ DM6_O_C, { 336, 960 }, compress_fill = { cell = "DM6_O", mode = COMPRESS_TYPE}} );
#else
output_layers.push_back({ DM6_C, { 336, 955 }, compress_fill = { cell = "DM6", mode = COMPRESS_TYPE}} );
output_layers.push_back({ DM6_O_C, { 336, 950 }, compress_fill = { cell = "DM6_O", mode = COMPRESS_TYPE}} );
#endif
#pragma PXL encrypted begin
Q<QN)%]%2GK%\)*.,MH&-//P5-H;&FZC\T14K OJ^B\U_6NL(DEUD$JR"K@B@Q2)&X1)?Z2#
9?I;^=<6Y)QEZ5/!\2$U<Q;IN,&LY(.L:8NX;ZN*X/5$IBIO
#pragma PXL encrypted end


#ifdef VERTICAL_M6
output_layers.push_back({ DM6NEW_C, { 336, 965 }, compress_fill = { cell = "DM6NEW", mode = COMPRESS_TYPE}} );
#else
output_layers.push_back({ DM6NEW_C, { 336, 955 }, compress_fill = { cell = "DM6NEW", mode = COMPRESS_TYPE}} );
#endif
#pragma PXL encrypted begin
Y.<'!9*K; SDR4]8NE8)D:/)X_I<^3@GVO3C(/#,W#K>XPL@J<#9P9TCGTZI-@ R'GSUV[<V
GBWC>=AHWV*>3K!86OC%/*A.
#pragma PXL encrypted end


#pragma PXL encrypted begin
EART!EP'+VJ6?,G')+'(+9M\'@_,:-! 6%8>FU#A\:FK+H*;)W58_)N6T#@GBT-)RR^3A_2+
"?R/<S&N>G@),P ^3U/R6PDSX/9$]2$?'[3@)&.]%MT?I0\D
#pragma PXL encrypted end
#pragma PXL encrypted begin
$=[I&/)=P6T1KM.;'P#6[>ZN.J*,V\J!65\ZN"HI_>QE3T&X/G+H^<11G4T^:J%\1#@FF+QJ
DK,%R$HMX@22($7MA[SE)RP@4B-;*_EK<3M2.7ECD_;<#(LY:-^:"-LULZ-H7Z,M,>"1IF]?
B"D96:<0=%V(,]@#;E.3O30S0N!483X.2\]"OA-R,8K]K12^-L0<SJ.](S@V#+9&R::'I P,
CKS>T9H.#(B.[CVQ.LG>=C_NUEE_8XH FC'6R6VNTJUYDX[)@DWM.)(5<SN"D< -*F4K@9>1
'7YRP Y1C.T=7S>8>F5C?VY?7I;P0IT%,"!>+>[_Z=_"X@8M,]@#;E.3O30S0N!483X.2\]"
OA-R,8K]K12^-L0<SJ.](S@V#+9&R::'I P,CKS>T9H.#(B.A7/XOFMY2G&%?*S:4R'[V^%\
TP4?_'X#4133\YNBY2?]WA#S D6,^#YP@RT"1;L:N1_"):Q%M);.TFLR>8ZTLA:],.3O]4VR
+\,K()_E&(DO@V+N=S*IZ@&##@V!\;.Z\M0.$81=<Q0,I<@1GBI.=UPTLR:>3;YBU"2/S2U-
O,TC^*\YMJB\;546-;3+D3QMA>4*DOQRC0F%*;<B;PVJ7  IR<^J;@^P(';)U\+C Y9#N.;7
(2K[%\S\H'@A@)AD6M2)#3^ 5! HK2PUP<%4-0H=$<]\=$<U(Y AT3&BM7 C#@V!\;.Z\M0.
$81=<Q0,I<@1GBI.=UPTLR:>3;YBU"2/S2U-O,TC^*\YMJB\;546-;3+D3QM=/W@9V8,V_IT
I1,REWKB30"E"9\SGLU)>O8)KE^9I+2RP(2NN!^[LE)_7RVX ,O%0.9T#2\ 1AN#)"531X9&
U3_A.$FUD7#5%8"O>C%A^J85UN7/LJ$A!9/6
#pragma PXL encrypted end
#pragma PXL encrypted begin
3,:=;!%!9'1,CZ$DG/.IU+6/'LB(I%13RI0>A5<Z9G.Q%D>%KWYP5)\M&]&O,Y;B+>(5[IXS
Z#'RJDO'S\KH=_URGP9UT<-W
#pragma PXL encrypted end

#endif
#ifdef FILL_DM7
#ifdef VERTICAL_M7
output_layers.push_back({ DM7_C, { 337, 815 }, compress_fill = { cell = "DM7", mode = COMPRESS_TYPE}} );
output_layers.push_back({ DM7_O_C, { 337, 810 }, compress_fill = { cell = "DM7_O", mode = COMPRESS_TYPE}} );
#else
output_layers.push_back({ DM7_C, { 337, 805 }, compress_fill = { cell = "DM7", mode = COMPRESS_TYPE}} );
output_layers.push_back({ DM7_O_C, { 337, 800 }, compress_fill = { cell = "DM7_O", mode = COMPRESS_TYPE}} );
#endif

#pragma PXL encrypted begin
K>%W EX/1Q*M0T#'%1T544%#6 .NWN)&K=I8_Y9)?]0!K:O_KBA[#R\3*#&NQVY_ (SYKRS'
<N^+MD;[M<URJ[MP0'D&W?VK1^P5>2AC(RM'(U\D+$D?GRXC
#pragma PXL encrypted end


#ifdef VERTICAL_M7
output_layers.push_back({ DM7NEW_C, { 337, 815 }, compress_fill = { cell = "DM7NEW", mode = COMPRESS_TYPE}} );
#else
output_layers.push_back({ DM7NEW_C, { 337, 805 }, compress_fill = { cell = "DM7NEW", mode = COMPRESS_TYPE}} );
#endif

#pragma PXL encrypted begin
.>/]0?I_R5@YK!7WO9[UWC:L,2H%:NL,?Y,QN#^?0P>"FFNXN[L(VQ3HE%"[*_'2;FESC/HK
H:=IC;\$AKNA[1V'%Q.YUUGM
#pragma PXL encrypted end


#pragma PXL encrypted begin
6/Z6(BWFZVI8=9J$#]5+&JQUQC?G=0:.ILW&+9-:<_+('L0M?ZU+FU'/(IQ_#,ZO#;+O%8\,
S)MR^]%IT[S,(K*T=53C:Z\B^@Y4.2?/W3#Z9=L'+Q)QW1]E
#pragma PXL encrypted end
#pragma PXL encrypted begin
=QDP V!,#GUW9Q!/4E]UF?!G P/N;=%OK\<#<MA+,.;O^RQRD1TM-W)M@>617.77D/W%F0M<
W\FQ,O8#UXG??U!YW]J3KP-_UN^'CU3E5Q[6M#,S.9C O>.TPC+"!HU>1$'"*=;-RN3[[_HI
ZZ HYUE^F/_K07Y'>R+)L]1!K F8#JN>9TBL_'"6]U Q_DW\HV.$Q)P_4TFCDH(3K3]5*>F2
OV3O3047OCV_-5P1 ^7_4_0U6,G&H[;5%M-8<S@U3?Y= >)SP)*/4"'199+ 5;0\C*\X"YY5
#[(B"Y "J18/ZUEO^>ZYLJ?K1:2V*;M$+BA%XUBS Y']%NSC07Y'>R+)L]1!K F8#JN>9TBL
_'"6]U Q_DW\HV.$Q)P_4TFCDH(3K3]5*>F2OV3O3047OCV_[R2<IX;'UW[OVGE<RJ^WG[7:
1RX4AU^.0C!'!DDC=<3VP&$&''S21.#P&/D<J;F#)7(780RI:4*!/#]$E-1IO:F1S/C .S.]
Q&>'LED7L%3$&,1NPXF7H0P85H^9[Z3GKPY6"[0_"[*L%6\+4JUI;,@\T[%2"#S2\&$");@(
2K@7O"#SU2]*+MO&1I]Y[&$N"0-[V^+I"1\);SUO(?$2R#-O-31/.82UWT(U%:,>8WX3,V$5
36S[Q%'C@1=-HV8.2#U>\;&CL\B-P?Y243NSY Q5O"6UGT#D!JIL @)ZD* &5H^9[Z3GKPY6
"[0_"[*L%6\+4JUI;,@\T[%2"#S2\&$");@(2K@7O"#SU2]*+MO&1I]Y[&$NE<X^F>EI'G65
G+S64L%P(4.<[!7ZI]]EU4WLCIHY3*@(Z'R.&;2-#B?=[CL9R8S6JOC>FV#)4@WJ=]'''(]2
16&H+CZ2(/E%S:\O:?Y?1J+-D%!55R1;KFN0
#pragma PXL encrypted end
#pragma PXL encrypted begin
HL&3*7@5P4"B=C@Y8%AI!5MVU&DC3SL]&@+4+?TVI&/FUO\M""L,TG&/6KX('9%;+NA*7"0=
F2L:+MU[NYF9U0%>X+A1TW;5
#pragma PXL encrypted end

#endif
#ifdef FILL_DM8
#ifdef VERTICAL_M8
output_layers.push_back({ DM8_C, { 338, 985 }, compress_fill = { cell = "DM8", mode = COMPRESS_TYPE}} );
output_layers.push_back({ DM8_O_C, { 338, 980 }, compress_fill = { cell = "DM8_O", mode = COMPRESS_TYPE}} );
#else
output_layers.push_back({ DM8_C, { 338, 975 }, compress_fill = { cell = "DM8", mode = COMPRESS_TYPE}} );
output_layers.push_back({ DM8_O_C, { 338, 970 }, compress_fill = { cell = "DM8_O", mode = COMPRESS_TYPE}} );
#endif
#pragma PXL encrypted begin
9#:06$F+<V%D!<R80L'VS'D%?R5O@;$6W>U_;7C+41 BTT!M[5Q]1OBU6AGMPAP$VHIC_:K"
9$"3=ITO+'AD\W!=HM?/8A3S'Y2P)8UUFH<?1B*@3&*^<+5&
#pragma PXL encrypted end


#ifdef VERTICAL_M8
output_layers.push_back({ DM8NEW_C, { 338, 985 }, compress_fill = { cell = "DM8NEW", mode = COMPRESS_TYPE}} );
#else
output_layers.push_back({ DM8NEW_C, { 338, 975 }, compress_fill = { cell = "DM8NEW", mode = COMPRESS_TYPE}} );
#endif

#pragma PXL encrypted begin
71X#=TX&5EQ=Z+K6'$]-51OH+;YE5TXIDC\M$K-&2=$5PLP2+V?0Z,[_1Q0OY-[?.V/*H6WD
-L Z#5-T?W@VO8/,#ZT'<[Z]
#pragma PXL encrypted end


#pragma PXL encrypted begin
Z1^)-NIVV"+I4=:Y2'8KT#)1/#U*"-/Y&QX\V,?7,A)IQDG84M!AK-?UU[E25V@4G=?362-7
NB%BLLV/1KZZA64=*:$N CB%_65+\ZE]\G/]K@T[/+)5BDNN
#pragma PXL encrypted end
#pragma PXL encrypted begin
EJ&O4),;.V^6]*N,J0K53#[TE*3AF>J-#4:4)= O\I0RNX,EFR4*29W*1BV;NJAN$<=O^4VZ
+%RJV+,-WTDLM!(+@PLB_82T@NZZ<SFG*&6"&0WB1\]0@C<9)R.N7OUFZN<G+VA@QG*V?)0O
8M<K)QUVG^5B)9-6&BH/2\@EGEZA<)M.M[^>1'<<NIDS> U$+M^G>Z@G]RXN3!5#+3^]YQY,
Q$G['3@CG7K$B6:J^.UL$2>)J,-AA6>PIBRHQY97QT>( 8_'418?U5KC"[11IMU^ M3Q556F
H=110^1O-VBA@!V!P*=96DN A7[+=4N748F%9.K@J+(* _5D)9-6&BH/2\@EGEZA<)M.M[^>
1'<<NIDS> U$+M^G>Z@G]RXN3!5#+3^]YQY,Q$G['3@CG7K$!^C&APNMT\\'#899_\'#.EH-
UQF%Z^__-P[75/@.+V*^VKU481;%N#'%&)IAL[+6)6LL67BS6<N@UF)V%[Y9%Q>IUWBHBRL7
C4Z&M+X_$B"-^.T0F>=!$"#XKCY ACN;XY&N$VC1EJHABH,378/"FI+P6A5=;+6DI3R@3K)L
[5$\*20N]$KM,FYU#33R1V8R.*J7TCCSJ'$XUNM++C0S#JC6B+?^G<-!O:B(15A>Q//R>Q=%
YC#G<56DTBOF_=ZL7M&H L#]@CBIF]4VC5Z":_)^/5.#!7=K9#I2V#(EWS]DKCY ACN;XY&N
$VC1EJHABH,378/"FI+P6A5=;+6DI3R@3K)L[5$\*20N]$KM,FYU#33R1V8R6>#H38:6P3]9
8FNH(;C7BOIB*X.].G%"-50K+3+9!?;=8+,M>N8YSH4P+FEZG8]YJ*IYE4*=XJ/\\D,FE2KB
D,@UFOS87'"09Z/< X@SVN%G=U51EVP$O:=W
#pragma PXL encrypted end
#pragma PXL encrypted begin
'?"O* [5720=F[ 6JI.],2J;Q-269R<*V]C$Y7::!]EIYWSE7."JO+[5S]5<J;:SVKD(+_ZI
$8<CZ?G=?SX15J&%!*L5XSY6
#pragma PXL encrypted end


#endif
#ifdef FILL_DM9
#ifdef VERTICAL_M9
output_layers.push_back({ DM9_C, { 339, 985 }, compress_fill = { cell = "DM9", mode = COMPRESS_TYPE}} );
output_layers.push_back({ DM9_O_C, { 339, 980 }, compress_fill = { cell = "DM9_O", mode = COMPRESS_TYPE}} );
#else
output_layers.push_back({ DM9_C, { 339, 975 }, compress_fill = { cell = "DM9", mode = COMPRESS_TYPE}} );
output_layers.push_back({ DM9_O_C, { 339, 970 }, compress_fill = { cell = "DM9_O", mode = COMPRESS_TYPE}} );
#endif
#pragma PXL encrypted begin
/ M)"4$[@#8\'")YO=9U>W0<S0VOJ<B71HC-^LY7&YVC!83Z"XPRO/H"!9X+A=B\F1C2)2.%
F%C_=@+LCX&8%F?JJ"+ZO+L6AKMQ+,W$1VR&\&&BJ6(0+%OP
#pragma PXL encrypted end


#ifdef VERTICAL_M9
output_layers.push_back({ DM9NEW_C, { 339, 985 }, compress_fill = { cell = "DM9NEW", mode = COMPRESS_TYPE}} );
#else
output_layers.push_back({ DM9NEW_C, { 339, 975 }, compress_fill = { cell = "DM9NEW", mode = COMPRESS_TYPE}} );
#endif

#pragma PXL encrypted begin
);-K>C^<<FXE-7%U=TG2SK$U\EW"EW68(@7R$$4?<S%*,B00D<YLV*<WKK214?D&%0D>T"E1
V:56R&,A[M#9&+GH=K]6(VL8
#pragma PXL encrypted end


#pragma PXL encrypted begin
TC22%.A U3K2FTWK7&'7?R6;;E!=TA&\#[EN P.OY&SSJ]<#=8* 2]*@PA5U$H,@/>G.R#(2
M&Q0L)6]0<6T!UT=W;"D;M<'>TK18YJ9N %[@0RSE1@,\*R!
#pragma PXL encrypted end
#pragma PXL encrypted begin
\4\K=1NG]TSQNJP2), OB@:Z>^,&QS:BZE9[3_>3?H-E^2-/?\,M3O1;1(!_)1I_N*'*,6,E
;OPP4<L[]F]NY51[;H/E')+E$2C8012=9?41O[5$ONZY X>_#?GGFSS5#FD-8;"U?OKQU\YA
&D!<E'R^,#0:")1W J1+AN@(N5 OCO2>#.&Y"C:/M(8&B!D*YI'"Q1Y8S=KF(J\K/&8\">(B
2P/G6TG]^DU+ >E.XI@>#C<!VP+D[9.]40_;H>]G/X:5"V6AGYDS$6T*G5&?T/!N  S;L0#0
ZDH+F-HL*$SJYSZ[:#^NCYKG6%9.'GJ"L_U8Z<YP>7E7-?[I")1W J1+AN@(N5 OCO2>#.&Y
"C:/M(8&B!D*YI'"Q1Y8S=KF(J\K/&8\">(B2P/G6TG]^DU+;@XB4IY.T%ANVM'<7AR[ .C:
9$#]9*C)==9D4#'M H!;E!)0/!)?E/;-RDT\+4!<_1W4/A8MN2P1B&N@?^NY#[UTM [X.&(/
WP 4*%U0>@#?^B07B@R!!-;Z[1KL;V9$:S'M[<73'H'L!CKM'48ZD^!I#4L=0S>^H\S?1S%#
E6K&\]X%D0J5OO8I%>N$5XV^,#P?5P\H_GHPS'/M!=4K\>?,W:]=7Y;:C(#=FM[%D8/H*%6:
UH>F?SSY9J#67+(R_5#-$@%<4-I:> U O@A0\X]!()(T6!OS\>6,,CG=40;Q[1KL;V9$:S'M
[<73'H'L!CKM'48ZD^!I#4L=0S>^H\S?1S%#E6K&\]X%D0J5OO8I%>N$5XV^V/8?"'\YCM?8
*J@PM>H63W<J%DU/KO7N^/06,BF(H#&KG^(RKF42Q[5@43&N=68$4>5XR=!U[J;&/^PGV9?N
;@335Z)2TN5N/A Y7;46XJ8^H+AB;R]BZM>@
#pragma PXL encrypted end
#pragma PXL encrypted begin
!@6Y!@R?6CP&Y44Z"6)!#1WES:=AB,=<@*7-XMXF8P$5TG;B(O7; Z=NX!HB0XN^9E"2Q,I#
8; '8=EV#Y-A ?0#>R3Z398!
#pragma PXL encrypted end


#endif
#ifdef FILL_DM10
#ifdef VERTICAL_M10
output_layers.push_back({ DM10_C, { 340, 985 }, compress_fill = { cell = "DM10", mode = COMPRESS_TYPE}} );
output_layers.push_back({ DM10_O_C, { 340, 980 }, compress_fill = { cell = "DM10_O", mode = COMPRESS_TYPE}} );
#else
output_layers.push_back({ DM10_C, { 340, 975 }, compress_fill = { cell = "DM10", mode = COMPRESS_TYPE}} );
output_layers.push_back({ DM10_O_C, { 340, 970 }, compress_fill = { cell = "DM10_O", mode = COMPRESS_TYPE}} );
#endif
#pragma PXL encrypted begin
HD:/<Z\IS46B*E@FAZYF7_,J4IOB27R"X$Y20K*@5$)+FH9"3A4\$+]P=RM.?JE)$+PLB(A^
M-]FN<ZN*.&T*8^#.'HFMEXIHBU67C#RM\RBJ-OQ\,60$+JH
#pragma PXL encrypted end


#ifdef VERTICAL_M10
output_layers.push_back({ DM10NEW_C, { 340, 985 }, compress_fill = { cell = "DM10NEW", mode = COMPRESS_TYPE}} );
#else
output_layers.push_back({ DM10NEW_C, { 340, 975 }, compress_fill = { cell = "DM10NEW", mode = COMPRESS_TYPE}} );
#endif

#pragma PXL encrypted begin
^-2>0Q:5'S+X0BR N'I4+LY"5 G46**C=9U433CY3^P-USM-,GBDR_GM&,PRT#@@F#8? L30
V?"&2V85>M/9=C!4@.8G9*EV
#pragma PXL encrypted end


#pragma PXL encrypted begin
X'S!-!7V$6K@[G'FJSC-SD'N_79Q42_(L"_]O7. P]E]"N6]?$\I-:&A-!I\S5&A+=+LN97-
!FE0)D;^_3H&S%C-R]@!$I',C*+72XYEAE6,#K*@B1-AV44.
#pragma PXL encrypted end
#pragma PXL encrypted begin
_Y=:%4A<-'S_/_.VMJOXTL(_0&4*EDHUV:= [(4)?W[V%#;L_I%#]SHY847^PX(4<G9'Z8+#
_;G$.VVT^CW]061%-.:5'/Y!0GF<%4W.!XE""GZ^N.>6?XP*FK+3K2'R&_*:VS&0I0'K@_;;
[.S+:GE\@:CL+^G0S:7!@+POOLP#SF\<MHV^E0%%H!(G+O"5[F/.%XN)WSONRCZH[!N;5BS*
E9JGHY+95825_T78C&WIZAG_/C8!\\FM[&(^S\9EF0-(U4O/U%GU%JV>;RO4?J0J=R%()X)^
V6N8G_Z.KB'9W6KQ<07JRF[=2\GV)97$R0M+-8YP;<#/BS U:5I?L#+:F69ID4U)*.D2PT.1
7_E>LZ")A0M?9GYW/1N;?[5F$Y&_\=LB3U433[TV\V&MC[I/$?P3&,<#YJ@1:5I?L#+:F69I
B;J*H0&'HQR)8!?PCE_L%"U@BQ"5<.*2B9&+[]NU\0M)*+7OR!MGQ*I\<R3(2S5ASTI_@[)+
\5;@7\'EX*/Q4S1LA\"&!LU3VXDN1")*7*;;D4U)*.D2PT.17@AE$XN'I>Q>9GYW/1N;?[5F
$Y&_\=LB3U433[TV\V&MC[I/$?P3&,<#YJ@1)!2?CTMW'<8D\1-M;I%M=XKQ<25[85DAER=Q
AFO_LN]8"6*&5<Y',D+)+KY53^E0*-R:5JQ/&JJN\W"HHND:;!,HN'Q_D*MLX51R#R[98[OA
^,)-93SSX+;XTRR?!1.X,2K3/&+,#R-%6AT\E) YEJC1/;V4*U,%2.@EZ!0KGD_;S*%4.!R>
X51R#R[98[OAS3W5LZ0>UKC->Z&7/E\6.P-[1<PBH51:3P9%6;<:[VZG+TA9G%)<W_1GY>J<
R)%!,JZC-.S(\G[0*MS2"Z?R.<K?EZCE#U0YBAJT84,#\>R*
#pragma PXL encrypted end
#pragma PXL encrypted begin
8+,T*Y4J%QI@,Q_5P7G\JSXSH?(7M&5\2!ZA+W_LP]<HYJ4O#X(67J95M48/X5LV?6&"8Q[A
LIA(9SR9*G2R].NLPU'V&"/T
#pragma PXL encrypted end


#endif
#ifdef FILL_DM11
#ifdef VERTICAL_M11
output_layers.push_back({ DM11_C, { 341, 985 }, compress_fill = { cell = "DM11", mode = COMPRESS_TYPE}} );
output_layers.push_back({ DM11_O_C, { 341, 980 }, compress_fill = { cell = "DM11_O", mode = COMPRESS_TYPE}} );
#else
output_layers.push_back({ DM11_C, { 341, 975 }, compress_fill = { cell = "DM11", mode = COMPRESS_TYPE}} );
output_layers.push_back({ DM11_O_C, { 341, 970 }, compress_fill = { cell = "DM11_O", mode = COMPRESS_TYPE}} );
#endif
#pragma PXL encrypted begin
(R@Q6F6@R3HCAY<,\='!9!F'Q^E8.J>H"Y''+N0:*5F(O/\NNP819Y*G/*F[FUVMC(;<%I";
$R+7@[KISDL3[#QV?F3:A^GLBE)=$6TCXJ2*G66AGW48O66=
#pragma PXL encrypted end


#ifdef VERTICAL_M11
output_layers.push_back({ DM11NEW_C, { 341, 985 }, compress_fill = { cell = "DM11NEW", mode = COMPRESS_TYPE}} );
#else
output_layers.push_back({ DM11NEW_C, { 341, 975 }, compress_fill = { cell = "DM11NEW", mode = COMPRESS_TYPE}} );
#endif

#pragma PXL encrypted begin
Y9PM"386?%OES&P.X5A9J5G,M<F:[70=D(:UEUKD6)S!+\J7Y^-0-.2'3ESG,GQ^?]G')9TR
RZ'Y,4O698K+Z[3=@&1 A/OK
#pragma PXL encrypted end


#pragma PXL encrypted begin
E]'9"@!Q/CF7#Q8;2FO--H4/PKQ*L&I[3N[".O-KG^OOWLPZD#Y>*:X=#/>0&Q3C(&'[>IX;
8A:=VHO[,C5BJ9P74AG_M;VIP!I?.YWD+^[ =.YBDO6X4@UT
#pragma PXL encrypted end
#pragma PXL encrypted begin
(]-?2ISBP'\CBFO+D%L4MJ>*@ >YUIX\^I& KNI 3\9TY=BN^/Y70KD'.%?XVQ[\B\"P)'S;
K6%>:[YH"/JM%>T.=D [9_P51L)6R %E15!&6FOP.U03!FI:QS')!&#-\EC'INR"9^:TT=>F
76]^M(U==HM=KB4HY>$!QDZN:,G/(TM5I<YHV.X^G\JLC['8?0PK 0;[$61]7_'R#>QF_N%?
GF2D9,H.5EF>F[6Z'):Q?E2;H),S\,CMK]2@XOVAAM^UZ)3B%]/*X)Z/#B078P*JS(]^IJQC
.*]I)T59N+DXB"L8%@')\.F([Z'M_#Y*4@+O\5 17%[ICZ;QG:A6ROZ>/!"=GOK1F:)G"B*>
AF.2D"O9E_F&0'MR#4*SC[=  Y-6$ SK<R8#AF-C,_IMRTR&%*]UB>'.3^44G:A6ROZ>/!"=
42(?8HPB6?Y1F)V:J_)<P*B8^0(Z&))J?JGYK9=9-C_?HV2M:8^"655&L1=I)*\,BM(0W, D
0?KOB8-ASR!!L@GL=MV?X5*R//>-+^->T_L\GOK1F:)G"B*>K<-BN74!TN^M0'MR#4*SC[= 
 Y-6$ SK<R8#AF-C,_IMRTR&%*]UB>'.3^44V'B<1E"QCW?8&2Z4N[!41MP9+K=M48?=PM8N
-!IM'*S^EU4T\)XP"==M>G?P1)K2'I(EYK9$Y351SE$$?R_E2%1\!PEL#41(GP7[O\#S&":?
3+W?5?"(\*U,E&91M]]I@@J4,-U&&3^0NF4P$5X^Q:CTIB415L(X]7R-C2%6F3!N.@\A_U^9
GP7[O\#S&":?LO'+B7(."GVR:@Q*9C$4?))J$J5> =D(%>423]<;5W5-?8M/'J17XO_ZQU >
\"9 L849AT/PCE318,'9N3Z./;R?D>'FF/,] I]2_(3P;C0"
#pragma PXL encrypted end
#pragma PXL encrypted begin
*$B=+H; ,RPHG1B8]&\1Z!B=IMD(: \''^VFG2I=)CD$^LV=?M@5GWK8",5^MW3UU$ANK-VW
KN4VUYG!@L.N&JOI% ?'N"0:
#pragma PXL encrypted end


#endif
#ifdef FILL_DM12
#ifdef VERTICAL_M12
output_layers.push_back({ DM12_C, { 342, 985 }, compress_fill = { cell = "DM12", mode = COMPRESS_TYPE}} );
output_layers.push_back({ DM12_O_C, { 342, 980 }, compress_fill = { cell = "DM12_O", mode = COMPRESS_TYPE}} );
#else
output_layers.push_back({ DM12_C, { 342, 975 }, compress_fill = { cell = "DM12", mode = COMPRESS_TYPE}} );
output_layers.push_back({ DM12_O_C, { 342, 970 }, compress_fill = { cell = "DM12_O", mode = COMPRESS_TYPE}} );
#endif
#pragma PXL encrypted begin
ZKR975<VYDSJ4MUJ]$\,9UE2FA!+YD&.@I&:;9:1$$XF2[9M=B58^GZ3>FEVD&RS2I*GT\J0
S8:*",$Q5$S-'G.$Y1.*<Q8>;$8*SJ\KQH5L[^S'18AL(,#O
#pragma PXL encrypted end


#ifdef VERTICAL_M12
output_layers.push_back({ DM12NEW_C, { 342, 985 }, compress_fill = { cell = "DM12NEW", mode = COMPRESS_TYPE}} );
#else
output_layers.push_back({ DM12NEW_C, { 342, 975 }, compress_fill = { cell = "DM12NEW", mode = COMPRESS_TYPE}} );
#endif

#pragma PXL encrypted begin
K3&6#">LF&VMY'&=GK!C8M'D*L3#>!X2O[TJ(J+>W!=9Y^<BH>[8/;H]1;.AJ&Q5E*'Z(NBH
.@PZRBG*@2TZ=K>,E9!IM?5V
#pragma PXL encrypted end


#pragma PXL encrypted begin
7V9"#O$'6TM?WFV?U=5A?/O>1#66["G63^%$F'AG;,OP;UF8#K ;G(;"";P.AYOB<IWPY@V'
H1:<6<Q@KN:AL=E6M'6'-OZQA .&\\ LB7>$YW-P:(*%HHGG
#pragma PXL encrypted end
#pragma PXL encrypted begin
?H';;B1N?5U^6+)DQ/&R:618FY$F'DD&)$6;Q5N!I<9_]V#%H E_)+HF]$V@49 +]^:J?;51
*9M"3&!"9A\IO1K2@8JUBY^]0(A\(/JO.1Y YEOTQM,=$/SFSO;KXV__H#7.JQ4VC]8O":6K
WI<_T0-"@0W>%/M@YN<E_$04+TO$C<J93!POR6UQ=*@IS;3))*\LC-MZW.$D_U4/!VTC3J3_
C4(LW(,2'XJ-0H$HG36P?OU"Q41@$XAH2_/%7#2&Z?.<X@A<YQ7)AT47%GWG93K4KH:K7LME
HB/+'AYTID^B+/IL$H1W1LDLG<?W'#4"1OV=/@#/)T!W7",^,9^VXL 9"2HQ+BSTMNO"->8N
5Y,5>A]N'!M7Q*X9@2U.=B?$;5UEU$.N4$AM!O8):4DG^T$&$G622ZZ>"OP2,9^VXL 9"2HQ
!3 3(I7X6C$%;I!Q]L42JKYN?\JFUTIB!6%_&)$221_5J!@8(%_S#-Z$MXX@8TS]3]H>V/QC
Y$036-&\>&/DZ#+T)!7"]D3H\T6.SFW%=@3S+BSTMNO"->8N;YH\T[S+BMUOQ*X9@2U.=B?$
;5UEU$.N4$AM!O8):4DG^T$&$G622ZZ>"OP2R+O[[E<B";W(WR(4)A["!YG?YYKRM^!)CR3G
H,!+COW4_':@8JTVG!]17*1B(<FO9YP"210AAO,7L-IAOO.&>GXRL5#U,JEZ4(HAZTDLN/E0
%'9E6K([7SH4'*4;B T^T3,<H7Z?,^@TB 6AQ"3#@@WS,TK$0*"_4Z$]7D] KM\EH, [L*2N
4(HAZTDLN/E0HIP,,S(/,>VB+4^U)>L'^(8MP972J+O N&C!S POP3(0@PS,6M<PX025QP]:
5:ZXY33+U/55%HVD=GY.!^46Q$+@._SB>S#$4 4;[# ;FLU0
#pragma PXL encrypted end
#pragma PXL encrypted begin
J"D_%3TW,"&HL4^AD0FPLD2QYS"M;".5]'3G/@9]R#,T5Y0^<H:,)\?#-\URQ54GM9[@/-'%
!3[BZ'6W+%@%J_..WYINS+:K
#pragma PXL encrypted end


#endif
#ifdef FILL_DM13
#ifdef VERTICAL_M13
output_layers.push_back({ DM13_C, { 343, 985 }, compress_fill = { cell = "DM13", mode = COMPRESS_TYPE}} );
output_layers.push_back({ DM13_O_C, { 343, 980 }, compress_fill = { cell = "DM13_O", mode = COMPRESS_TYPE}} );
#else
output_layers.push_back({ DM13_C, { 343, 975 }, compress_fill = { cell = "DM13", mode = COMPRESS_TYPE}} );
output_layers.push_back({ DM13_O_C, { 343, 970 }, compress_fill = { cell = "DM13_O", mode = COMPRESS_TYPE}} );
#endif
#pragma PXL encrypted begin
LE$"84C, E^RY?7W>:/XCBKED@_-\]OE0Z62]BM#R>8)89_V '#*F"6Y?&0 %)-Y4,,@1^H4
;X2EN98X QMO5M^QC1C%6.]6M^Z4G5-&' 2W).7H=(UKIB D
#pragma PXL encrypted end


#ifdef VERTICAL_M13
output_layers.push_back({ DM13NEW_C, { 343, 985 }, compress_fill = { cell = "DM13NEW", mode = COMPRESS_TYPE}} );
#else
output_layers.push_back({ DM13NEW_C, { 343, 975 }, compress_fill = { cell = "DM13NEW", mode = COMPRESS_TYPE}} );
#endif

#pragma PXL encrypted begin
X:SK;H),%33AD=&_9;CJSM.1S&Y5Y:"M5<C,K= /.+@25XBM-8#C]&V8?<DUQN4$NK?)[ 3&
F2[QMH[5"AR9."AO1EBO>J8X
#pragma PXL encrypted end


#pragma PXL encrypted begin
D^&7<$RHUQ&3TI%9="[%.Y[2'-/S#M^AYR <:36:Q9]*_8EIX&A%#IHUKMS@*)#A;)I,WG8H
L!?WUQ]P2/FP:@0 "VNY %MJT=,NP/\18[711,!D8CZ0)\%$
#pragma PXL encrypted end
#pragma PXL encrypted begin
LOPP47\.^B.R^I.S5 TMJKKZ7(8(C\P!6')<XHOS 56C+?KB.!^5JW%J0$DX?"+V0RQ0X/)\
8G!=I)N:D$9B&:CH0Y#Z@&09J?"J;]NV!XFIG8L:6XA=+-B=F!YY)/^]:S"8DIX7@QMNR9F2
9F YSL7+UL-FH<RZL+] H!^AYXT:##;<(3KGZ(0KDFEZ!J;H#5 X#J[46$\->QCGH++;=>=[
F.\U=:P"P<B8DXX+ U9-YV"3A%G_#G[O;BZ$QB0FKBK5K<K&$4^9^9<(6ZP1"C#>W:Y:6R4*
R68574>QSA?)EM%(F5N.(.N6VFHNIH-_Q<+:@0YP XC=^ZJ!+B64M\I[IB0NR@RGA_7[1"O*
J,Z@1^_CR;VH\GR]BJ1-R<#R.Y%R]9Z!2^X[!.KLQOK_V78$=%JAS 2?$;!T+B64M\I[IB0N
A9:TPS[TV?:%9>GKO#/:^3=E0:?!1I" 6XY!?C:7<MP%6(Q^UBT&(KNX24W61&@2^VS"T#=$
/R/*D>M/?@X_<>$KAA 7.9EQ[G]A34S\5#CNR@RGA_7[1"O*W[7"X7>DK&K?\GR]BJ1-R<#R
.Y%R]9Z!2^X[!.KLQOK_V78$=%JAS 2?$;!T<5-1([SA#79Q11\CB!S?Y\I%.HS@AV2>EA<Z
TZ:$TONM_ S3P9C4FA*3OBG!7]NMXYJ63G5?L R]A=L7-LBP 0(!NY=H:A8!/_*GZ_'^G3X_
&PF,L<.$5!P;"<\-7JD]@58)%B)?M%4EQN(6X*'@0'EQ%W?@QUK3_[*V#!;'Y**70QORO>/D
/_*GZ_'^G3X_RHAB]DN?6B[*4Q3;)ZV0?)%3.5?E!AI$6OTYA8 :\/9MCA.%],2JL,46E=_T
ZVC6CE\'P5'K2#%Q:74SY=1(C_6%S0!L_WN/>W\)U%MQ+2Y[
#pragma PXL encrypted end
#pragma PXL encrypted begin
W:24=Y?7K&?=3UDCBT52HK5/%RI;)E=Z]K07]JP@LK56W1+V(FA"%3@,*/(BJJK3'>KI];FJ
8V7(1\GZIV9CZ86GN&)H(>GI
#pragma PXL encrypted end


#endif
#ifdef FILL_DM14
output_layers.push_back({ DM14_C, { 344, 95 }, compress_fill = { cell = "DM14", mode = COMPRESS_TYPE}} );
output_layers.push_back({ DM14_O_C, { 344, 90 }, compress_fill = { cell = "DM14_O", mode = COMPRESS_TYPE}} );
#pragma PXL encrypted begin
,C.D1_]"_U,R^6)[_F$EV\'Y@5XCQBBSZ2F!-HA,!_/:_F\VZ@K2!4SSD9SJ;RC$1MU!R)IO
JSZ12B'C39*K7UD;3W M"9M?VO,<&S+@0@?:&<$#!)E*!%H9
#pragma PXL encrypted end
output_layers.push_back({ DM14W62_O_L, { 344, 90 }, compress_fill = { cell = "DM14W62_O_L", mode = COMPRESS_TYPE}} );
output_layers.push_back({ DM14W62_DN_O_L, { 344, 90 }, compress_fill = { cell = "DM14W62_DN_O_L", mode = COMPRESS_TYPE}} );
#pragma PXL encrypted begin
B,&S%V:N44"(&;/O(\\1H7P9W[UKTNLG: /?3%4<ZR ?BV],M\NWU$$>0@FW*4<HCW.B[@<I
!"S(8GE,+(<$<2^V[V%*L!)Q
#pragma PXL encrypted end

#endif
#ifdef FILL_DM15
output_layers.push_back({ DM15_C, { 345, 95 }, compress_fill = { cell = "DM15", mode = COMPRESS_TYPE}} );
output_layers.push_back({ DM15_O_C, { 345, 90 }, compress_fill = { cell = "DM15_O", mode = COMPRESS_TYPE}} );
#pragma PXL encrypted begin
%,,Y5P(?U 84C3%SSGB3Z?2-@J[KJ3@.(BN"?QTIIQ/]K?A_6$.VUP!#GRY8S9])L\0PB^G-
']>X<5K-/<P?AD@/,X&)[J"&@T[<JR?I.J"#>5V:8$24HX%Y
#pragma PXL encrypted end
output_layers.push_back({ DM15W62_O_L, { 345, 90 }, compress_fill = { cell = "DM15W62_O_L", mode = COMPRESS_TYPE}} );
output_layers.push_back({ DM15W62_DN_O_L, { 345, 90 }, compress_fill = { cell = "DM15W62_DN_O_L", mode = COMPRESS_TYPE}} );
#pragma PXL encrypted begin
:5%))VJ*)G-IJ$R"@6DABC2HGFTDGD'Q][">/*Y4V-/,WD,\/DT_FW<3,1<^*KF@O:^BX]@J
?&&S7/D<I[E\-OX!]_5 (RPV
#pragma PXL encrypted end

#endif
#ifdef FILL_DM16
output_layers.push_back({ DM16_C, { 346, 75 }, compress_fill = { cell = "DM16", mode = COMPRESS_TYPE}} );
#endif
#ifdef FILL_DM17
output_layers.push_back({ DM17_C, { 347, 75 }, compress_fill = { cell = "DM17", mode = COMPRESS_TYPE}} );
#endif
#ifdef FILL_DM18
output_layers.push_back({ DM18_C, { 348, 85 }, compress_fill = { cell = "DM18", mode = COMPRESS_TYPE}} );
#endif
#ifdef FILL_DM19
output_layers.push_back({ DM19_C, { 349, 85 }, compress_fill = { cell = "DM19", mode = COMPRESS_TYPE}} );
#endif
#ifdef FILL_DmyVIA0
output_layers.push_back({ DV0_C, { 350, 200 }, compress_fill = { cell = "DV0", mode = COMPRESS_TYPE}} );
#endif

#ifdef FILL_DmyVIA1
output_layers.push_back({ DV1_C, { 351, 200 }, compress_fill = { cell = "DV1", mode = COMPRESS_TYPE}} );
#endif

#ifdef FILL_DmyVIA2
output_layers.push_back({ DV2_C, { 352, 250 }, compress_fill = { cell = "DV2", mode = COMPRESS_TYPE}} );
#endif

#ifdef FILL_DmyVIA3
output_layers.push_back({ DV3_A_C, { 353, 301 }, compress_fill = { cell = "DV3_A", mode = COMPRESS_TYPE}} );
output_layers.push_back({ DV3_B_C, { 353, 302 }, compress_fill = { cell = "DV3_B", mode = COMPRESS_TYPE}} );
#endif

#ifdef FILL_DmyVIA4
output_layers.push_back({ DV4_A_C, { 354, 351 }, compress_fill = { cell = "DV4_A", mode = COMPRESS_TYPE}} );
output_layers.push_back({ DV4_B_C, { 354, 352 }, compress_fill = { cell = "DV4_B", mode = COMPRESS_TYPE}} );
#endif

#ifdef FILL_DmyVIA5
output_layers.push_back({ DV5_C, { 355, 955 }, compress_fill = { cell = "DV5", mode = COMPRESS_TYPE}} );
#endif

#ifdef FILL_DmyVIA6
output_layers.push_back({ DV6_C, { 356, 805 }, compress_fill = { cell = "DV6", mode = COMPRESS_TYPE}} );
#endif

#ifdef FILL_DmyVIA7
output_layers.push_back({ DV7_C, { 357, 975 }, compress_fill = { cell = "DV7", mode = COMPRESS_TYPE}} );
#endif

#ifdef FILL_DmyVIA8
output_layers.push_back({ DV8_C, { 358, 975 }, compress_fill = { cell = "DV8", mode = COMPRESS_TYPE}} );
#endif

#ifdef FILL_DmyVIA9
output_layers.push_back({ DV9_C, { 359, 975 }, compress_fill = { cell = "DV9", mode = COMPRESS_TYPE}} );
#endif

#ifdef FILL_DmyVIA10
output_layers.push_back({ DV10_C, { 360, 975 }, compress_fill = { cell = "DV10", mode = COMPRESS_TYPE}} );
#endif

#ifdef FILL_DmyVIA11
output_layers.push_back({ DV11_C, { 361, 975 }, compress_fill = { cell = "DV11", mode = COMPRESS_TYPE}} );
#endif

#ifdef FILL_DmyVIA12
output_layers.push_back({ DV12_C, { 362, 975 }, compress_fill = { cell = "DV12", mode = COMPRESS_TYPE}} );
#endif

#ifdef FILL_DmyVIA13
output_layers.push_back({ DV13_C, { 363, 95 }, compress_fill = { cell = "DV13", mode = COMPRESS_TYPE}} );
#endif

#ifdef FILL_DmyVIA14
output_layers.push_back({ DV14_C, { 364, 95 }, compress_fill = { cell = "DV14", mode = COMPRESS_TYPE}} );
#endif

#ifdef FILL_DmyVIA15
#endif

#ifdef FILL_DmyVIA16
#endif

#ifdef FILL_DmyVIA17
#endif

#ifdef FILL_DmyVIA18
#endif


#pragma PXL encrypted begin
I#G]>HEMR7FD1(8K-9U6Z\E$(=.?&2VN/5XAYL(6?FQ3N'7F/_HQ9=;>DG8_K=KZ3\D:*#VM
=9C!:%?K$CUU(A<KV$7*R9LB&@P).E.0C\T:O@1%-]["MP"^
#pragma PXL encrypted end







#ifdef FILL_DmyVIA6
output_layers.push_back({ OPC_VIA6, { 356, 800 }, compress_fill = { cell = "OPC_VIA6", mode = COMPRESS_TYPE}} );
#endif

#ifdef FILL_DmyVIA7
output_layers.push_back({ OPC_VIA7, { 357, 970 }, compress_fill = { cell = "OPC_VIA7", mode = COMPRESS_TYPE}} );
#endif

#ifdef FILL_DmyVIA8
output_layers.push_back({ OPC_VIA8, { 358, 970 }, compress_fill = { cell = "OPC_VIA8", mode = COMPRESS_TYPE}} );
#endif

#ifdef FILL_DmyVIA9
output_layers.push_back({ OPC_VIA9, { 359, 970 }, compress_fill = { cell = "OPC_VIA9", mode = COMPRESS_TYPE}} );
#endif

#ifdef FILL_DmyVIA10
output_layers.push_back({ OPC_VIA10, { 360, 970 }, compress_fill = { cell = "OPC_VIA10", mode = COMPRESS_TYPE}} );
#endif

#ifdef FILL_DmyVIA11
output_layers.push_back({ OPC_VIA11, { 361, 970 }, compress_fill = { cell = "OPC_VIA11", mode = COMPRESS_TYPE}} );
#endif

#ifdef FILL_DmyVIA12
output_layers.push_back({ OPC_VIA12, { 362, 970 }, compress_fill = { cell = "OPC_VIA12", mode = COMPRESS_TYPE}} );
#endif

#ifdef FILL_DmyVIA13
output_layers.push_back({ OPC_VIA13, { 363, 90 }, compress_fill = { cell = "OPC_VIA13", mode = COMPRESS_TYPE}} );
#endif

#ifdef FILL_DmyVIA14
output_layers.push_back({ OPC_VIA14, { 364, 90 }, compress_fill = { cell = "OPC_VIA14", mode = COMPRESS_TYPE}} );
#endif





#pragma PXL encrypted begin
<CO$;S]&#$QR&H>="D%:MAP:_,][F)XJN(C\(B_';%#EBX(B8!WK8.F$#4M@\CD*K;J[Y.GR
)O_N1N: CD\F:U,#_RO2K4EK
#pragma PXL encrypted end

#ifdef SHDMIM
output_layers.push_back({ TPMIM_S_260_4_C, { 260, 4 }, compress_fill = { cell = "TPMIM_S_260_4", mode = COMPRESS_TYPE}} );
output_layers.push_back({ TPMIM_S_261_4_C, { 261, 4 }, compress_fill = { cell = "TPMIM_S_261_4", mode = COMPRESS_TYPE}} );
output_layers.push_back({ TPMIM_S_262_4_C, { 262, 4 }, compress_fill = { cell = "TPMIM_S_262_4", mode = COMPRESS_TYPE}} );
output_layers.push_back({ KOZ, { 150, 260 }, compress_fill = { cell = "KOZ", mode = COMPRESS_TYPE}} );
#endif
#ifdef FHDMIM
output_layers.push_back({ TPMIM_S_261_4_C, { 261, 4 }, compress_fill = { cell = "TPMIM_S_261_4", mode = COMPRESS_TYPE}} );
output_layers.push_back({ TPMIM_S_262_4_C, { 262, 4 }, compress_fill = { cell = "TPMIM_S_262_4", mode = COMPRESS_TYPE}} );
output_layers.push_back({ KOZ, { 150, 260 }, compress_fill = { cell = "KOZ", mode = COMPRESS_TYPE}} );
#endif
#pragma PXL encrypted begin
HI:M?7C&'B&B#Y\!=5(6:M(/;; &..XB\:YM!=)2ZK0,,%\%%_T_Z]=O 2$7_JJ$1:B]F^_^
="W3,-1#715T>URY(8.VWWM[5NN@U;9.C;=6/\'ZL&;@_1<_Z1V'<WX6FMCIN0=.TT_;+#*Y
#1SD;N^>PHL-$H^,.8V9J*<20NPH'M)1\4E"$=,(?K,B&9<1/AK0H5MK-Y\^$A41#25I?6@2
/1B/Y5Y:0?8]4-5C76,@69Y0UI<G_PL/7MO6#U?'6[M=H[T/APC##^O=KDF'3O/F!!N$YA5.
IH^@1?RU5R.F8:H3!EDZ 7MA&5I7F*_IO $95^+D/,6?FXQ7>RNZ:Y?>[T1[0 *H!  A[4Q 
B(J/!W)-]Z:(,2%9@I TZ]XQOBN9PEW>>HZ^WR9&"RR+@E#?PO^!K.''O9K"0;L\:H2*D'-!
I\,4CO_$Q!.G>&3/AE!.H'!XLNQ8AB=:U4BR=6.[&WSH#G1UR^5,U+768-3+W&)8E=EW-?+<
%9W*56)EL=P51%?)4VEQ399$2#WP7UY !C-(FQJO#3*ZH+*;4'2ZE"NLYM10TR6@3L_Z]M'3
 *:0O/V8)K@ +%<S38R(P*DLNV]NMQ!I#2V[Q@P1TDQWH,[&<;SHDP(*[_)Q^CA$N>)6A^#Z
NG.\0^C_?#&ZW$2H\)$&AC+<(\U/Y$DVQ+TC=?E,LPTEW^EURQ/^HX[XS:[+Q>@)C':+@&;%
D$%&))PAJV^0;QD%J*\+X>EOTT1]/;Y5'3/3W"(D_0EN$TC<*37IZ+V(>DPI_+C/VJT[VWO\
PWZD@\ E5PO#
#pragma PXL encrypted end

#pragma PXL encrypted begin
\G$W9K]Z$7SRVC\0CU)D./7:7CWS\-%E@D)>&I\!I#8PWPP:NW!EAM^GJ7Z[!_S8ZB&4M2,'
XYM8@.3YMX#CE(\GS0M0>?N48NARGZ]*Y2IBP<!Y8/Q[@.S!3JDCT$=*,FI.<4[6G0J$,+YQ
,[T8YNFNG\ SLZC*E,)<S6RS)<@R\X14AT4E.%Z+\Y>J8@\X.B, PFH2B&8Z@]"H[6!0"W&#
HD S[]_!#D"B8S]@_6!L2^5C7*O%MXX'.%I<K)]2,]4/D!BL4G@/D:7YA %20@&4FL0). M"
5 0ETT!2@]-4'G?M(CLB+* >*]8H'/-4X@\K6C3:L(JB9W1:Q8S@LXO/ ;_%SI2.%BB8%Q+.
.O#"#,-%UY\ZSCM)T$).Y*K..U,DW3-PI[P[G_-U*P$C98Z?SCEE'.A0/Z[.?1)LAQ3M!@U]
7"&R3A(R.4Q<Y-%%&,;,D!?D=-C?\:4;E\-TN;,[\PV!C!ZY0M?M3Y'%9 Q"TI=ZA^@IR>+2
P@8%2R<JFO["?-0A]W^,#PQ\\_)_4:I[,)GS29[1W+A[4+I)![K/=7#,T!0'%P1DHW'\]5H7
B?FR+-$V=_J)
#pragma PXL encrypted end


#ifdef OUTPUT_GDS
write_gds(
    holding_cell = output_cell_prefix + get_top_cell(),
    output_library = out_file,
#ifdef MERGE_ORIGINAL_DESIGN
    merge_input_layout = true,
#endif
    cell_prefix = output_cell_prefix,
    layers = output_layers
);
#else
write_oasis(
    holding_cell = output_cell_prefix + get_top_cell(),
    output_library = out_file,
#ifdef MERGE_ORIGINAL_DESIGN
    merge_input_layout = true,
#endif
    cell_prefix = output_cell_prefix,
    layers = output_layers
);
#endif  // end of #ifdef OUTPUT_GDS


